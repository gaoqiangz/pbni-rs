#ifndef _RTCCODE_H_
#define _RTCCODE_H_

#pragma pack(push,1)
/*
#if defined(UNICODE) || defined(_UNICODE)
#define PS_UNICODE
#endif
*/
//#define TEXT(quote) L##quote
//#define STRICT
#define GENERATED_CODE_BUILD
#define PBUSE_SMRTHEAP
//#define PSTYPE_DLL
//#define PSVER_R
//#define WIN32
#define PBWIN32
#define PBOS_NT
#define PBOS_MAC

#define PBVM_IGNORE 1

#undef _WIN32_WINNT
#undef WINVER
#define  WINVER 0x0501
#define  _WIN32_WINNT 0x0501




// disable warnings we don't care about
#ifdef __WATCOMC__
#pragma off (unreferenced)
#pragma warning 13 9
#pragma warning 367 9
#pragma warning 368 9
#pragma warning 583 9
#pragma warning 442 9
#else
#pragma warning( disable: 4244 4101 4102 4146 4049)
#endif

#include <setjmp.h>

// the following defines are used in the generated code to encapsulate
// access through the run-time data structures

#define RT_ERROR \
	{	\
	if ( !(_obThis->thrown_exception)  )	\
		rt_error(_obThis, IDS_FRT_R0012);	\
	_funcOK	= FAILURE; \
	goto _handleRuntimeError;	\
	}

#define SET_CURR_LINE( lineNo ) \
	_RoutineInfo.line_no = (lineNo)

#define TRACE_LINE( lineNo ) \
	SH_DBG_OUT( _obThis->dbgthis, (DBG_PCODE_TRACE, 			\
		PBTEXT("Executing instruction at line %d\n"), (lineNo) ) );		\
	ob_trace_line( _obThis, lineNo )

// NOTE: the category MUST be a string constant or this will not compile!!
#define TRACE_INTO( category, routine_name, vtabid, rtinst) 	\
	ob_trace_routine_entry(_obThis, ob_get_group_id (obThis, _pGroup), \
			ob_get_class_entry_id (_obThis, _pClass), 			\
			vtabid, rtinst);									\
	if( SH_DBG_QUERY( _obThis->dbgthis, DBG_CALLS_TRACE ) )		\
		{														\
		ot_dbg_funccall( _obThis, PBTEXT("Executing ") category, 		\
			_pGroup, _pClass->perm_entry->class_id, (routine_name) );					\
		SH_DBG_START_INDENT( _obThis->dbgthis );				\
		}

// NOTE: the category MUST be a string constant or this will not compile!!
#define TRACE_OUT_OF( category, routine_name, vtabid, rtinst ) \
	if( SH_DBG_QUERY( _obThis->dbgthis, DBG_CALLS_TRACE ) )		\
		{														\
		SH_DBG_END_INDENT( _obThis->dbgthis );					\
		ot_dbg_funccall( _obThis, PBTEXT("End ") category,		 		\
			_pGroup, _pClass->perm_entry->class_id, (routine_name) );					\
		}														\
	ob_trace_routine_exit(_obThis, ob_get_group_id (obThis, _pGroup), \
			ob_get_class_entry_id (_obThis, _pClass), 			\
			vtabid, rtinst)

#define FELL_OFF_END_ERROR \
	if( rt_error( _obThis, IDS_RT_R0018 ) == FAILURE ) \
		{ \
		RT_ERROR; \
		} \

#define INVALID_OBJECT_ERROR \
	if( rt_error( _obThis, IDS_RT_R0002 ) == FAILURE ) \
		{ \
		RT_ERROR; \
		}

// this assumes that it is above a block for the else case
// so we don't try to reference through an NULL object pointer
#define CHECK_VALID_OBJECT( instance, object_null ) \
	if( (object_null) || !ob_rtinst_defined( instance ) ) \
		{ \
		INVALID_OBJECT_ERROR; \
		} \
	else

// this assumes that it is above a block for the else case
// so we don't try to do the divide
#define CHECK_DEC_ZERO( the_dec ) \
	if( shCompareDec( (the_dec), &_DEC_ZERO ) == 0 ) \
		{ \
		DIVIDE_BY_ZERO_ERROR;\
		} \
	else

#define DIVIDE_BY_ZERO_ERROR \
	if( rt_error( _obThis, IDS_RT_R0001 ) == FAILURE ) \
		{ \
		RT_ERROR; \
		} \

#define ARRAY_NULL_SUBSCRIPT_ERROR \
	if( rt_error( _obThis, IDS_RT_R0008 ) == FAILURE ) \
		{ \
		RT_ERROR; \
		} \

#define ARRAY_BOUNDS_ERROR \
	if( rt_error( _obThis, IDS_RT_R0003 ) == FAILURE ) \
		{ \
		RT_ERROR; \
		} \

#define MATH_ERROR \
	if( rt_error( _obThis, IDS_RT_R0005 ) == FAILURE ) \
		{ \
		RT_ERROR; \
		} \

#define NO_PARENT_ERROR \
	if( rt_error( _obThis, IDS_RT_R0043 ) == FAILURE ) \
		{ \
		RT_ERROR; \
		}

#define STRING_LENGTH_ERROR \
	if( rt_error( _obThis, IDS_RT_R0016 ) == FAILURE ) \
		{ \
		RT_ERROR; \
		}

// we only generate an overflow error if the result is not null
#define	CHECK_FLOAT_OVERFLOW( value, value_null ) \
	if( ! (value_null) && ( (value) == FLT_MAX ) ) \
		{ \
		if( rt_error( _obThis, IDS_RT_R0025 ) == FAILURE ) \
			{ \
			RT_ERROR; \
			} \
		}

// we only generate an overflow error if the result is not null
#define	CHECK_DOUBLE_OVERFLOW( value, value_null ) \
	if( ! (value_null) && ( (value) == DBL_MAX ) ) \
		{ \
		if( rt_error( _obThis, IDS_RT_R0025 ) == FAILURE ) \
			{ \
			RT_ERROR; \
			} \
		}

// this assumes that it is above a block for the else case
// so we don't try to do the pow call
#define CHECK_DOUBLES_FOR_POW( val1, val2 ) \
		if( (val1) < 0.0 && (val2) != (DOUBLE) ((INT) (val2) ) ) \
			{ \
			if(rt_error ( _obThis, IDS_RT_R0027 ) == FAILURE ) \
				{ \
				RT_ERROR; \
				} \
			} \
		else

#define CHECK_ANY_EXACT_TYPE( obthis, any_var, expected_type ) \
	if( ot_check_any_exact_type( obthis, any_var, expected_type ) == FAILURE ) \
		{ \
		RT_ERROR; \
		} \
	else

#define CHECK_ANY_STRING_TYPE( obthis, any_var, expected_type ) \
	if( ot_check_any_string_type( obthis, any_var, expected_type ) == FAILURE ) \
		{ \
		RT_ERROR; \
		} \
	else

#define CHECK_ANY_BINARY_TYPE( obthis, any_var, expected_type ) \
	if( ot_check_any_binary_type( obthis, any_var, expected_type ) == FAILURE ) \
		{ \
		RT_ERROR; \
		} \
	else

#define CHECK_ANY_MATH_TYPE( obthis, any_var, expected_type ) \
	if( ot_check_any_math_type( obthis, any_var, expected_type ) == FAILURE ) \
		{ \
		RT_ERROR; \
		} \
	else

#define CHECK_ANY_ENUM_TYPE( obthis, any_var, group, expected_type ) \
	if( ot_check_any_enum_type( obthis, any_var, group, expected_type ) == FAILURE ) \
		{ \
		RT_ERROR; \
		} \
	else

#define CHECK_ANY_OBJECT_TYPE( obthis, any_var, group, expected_type ) \
	if( ot_check_any_object_type( obthis, any_var, group, expected_type ) == FAILURE ) \
		{ \
		RT_ERROR; \
		} \
	else

#define CHECK_DOT_CALL( instance, vtab_offset ) \
	PB_ASSERT( DOT_CALL( instance, vtab_offset ) != NULL )

#define CHECK_CLASS_CALL( instance, vtab_offset ) \
	PB_ASSERT( CLASS_CALL( instance, vtab_offset ) != NULL )

#define DOT_CALL( instance, vtab_offset ) \
	( ob_get_func_vtable_entry( (instance), (vtab_offset) ) )

#define QUALIFIED_DOT_CALL( class_id, vtab_offset ) \
	( ob_get_class_func_vtable_entry( ob_get_runtime_class( _obThis, _pGroup, (class_id) ), (vtab_offset) ) )

#define CLASS_CALL( class, vtab_offset ) \
	( ob_get_class_func_vtable_entry( (class), (vtab_offset) ) )

#define	LEN_BINARY( bin_value ) \
	shGetBinaryLength( _obThis -> stgthis, (bin_value ) )

#define FUNC_ARGS( start ) \
	&( _obdataArray[ (start) ] )

// this is so the code looks better!
#define _This ((POB_RUNTIME_INST) _obThis->curr_obinst)

#define _RETURN_VALUE					\
	(&_obThis->return_value->data)

#define _CALLED_RETURN_VALUE					\
	(&_obThis->called_return_value->data)

// in most cases, the funcArrayStart and numArgs should be constant.
// return value is after all args on top of stack
#define SETUP_FUNC_CALL( obthis, funcArrayStart, numArgs ) \
	(obthis) -> num_variables = ((funcArrayStart) + (numArgs));			\
	(obthis) -> curr_arg_pos = 0; \
	(obthis) -> lvalue_info = NULL; \
	(obthis) -> evaled_arglist = FUNC_ARGS( (funcArrayStart) ); // JGD - THIS SHOULD BE ABLE TO BE REMOVED ONCE CLASS AND EVENT CALLS ARE CONVERTED

// the following macro's are used to maintain group currency in functions
#define	_GROUP_INDEX_VAR( fixed_id ) \
	_GroupIndex_## fixed_id

#define DECLARE_GROUP_CURRENCY( fixed_id ) \
	static ULONG		_GROUP_INDEX_VAR( fixed_id ) = (ULONG)-1

#define GET_GROUP_CURRENCY( obthis, fixed_id, result ) \
	{ \
	POB_THIS	pObThis = obthis; \
	while (pObThis->parentObThis != NULL) \
		pObThis = pObThis->parentObThis; \
	(result) =  ob_group_data( (obthis), ob_get_indexed_groupid( (pObThis), _GROUP_INDEX_VAR( fixed_id ) ) ); \
	}

// to be thread safe, access to SET_GROUP_CURRENCY needs to be serialized
#define SET_GROUP_CURRENCY( obthis, fixed_id, pgroup_id ) \
	{ \
	if( _GROUP_INDEX_VAR( fixed_id ) == -1 ) \
		_GROUP_INDEX_VAR( fixed_id ) = ob_group_get_next_index( obthis ); \
	POB_THIS	pObThis = obthis; \
	while (pObThis->parentObThis != NULL) \
		pObThis = pObThis->parentObThis; \
	ob_set_indexed_groupid( pObThis, _GROUP_INDEX_VAR( fixed_id ), (pgroup_id) ); \
	}

#define CHECK_EXCEPTION_0(obthis) \
	if ((obthis)->thrown_exception)	\
			goto _handleExceptionReturn

#define CHECK_EXCEPTION_1(obthis) \
	if ((obthis)->thrown_exception)	\
		if ( (_exception_depth > 0) && (_exception_node[_exception_depth - 1].state == IN_EXCEPTION_FINALLY) ) \
		{	\
			(obthis)->curr_exception = (obthis)->thrown_exception;	\
			(obthis)->thrown_exception = 0;	\
		}	\
		else	\
			goto _handleException

#define HANDLE_EXCEPTION(obthis) \
	switch((EXCEPTION_STATE)ot_handle_exception((obthis), _exception_node, _exception_depth))	\
	{	\
	 case IN_EXCEPTION_CATCH:	\
	 	longjmp(_exception_dest_stack[_exception_depth - 1].catchLoc, IN_EXCEPTION_TRY);	\
	 	break;	\
	 case IN_EXCEPTION_FINALLY:	\
	 	longjmp(_exception_dest_stack[_exception_depth - 1].finallyLoc, IN_EXCEPTION_TRY);	\
	 	break;	\
	 default:	\
		goto _handleExceptionReturn;	\
	}
#define HANDLE_EXCEPTION_RETURN()	\
	{	\
	goto _handleExceptionReturn;	\
_handleExceptionReturn:	\
	ob_set_data_type( _RETURN_VALUE, ANY_TYPE );	\
	ob_set_data_nullval( _RETURN_VALUE, 1 );	\
	goto _Cleanup;	\
	}



typedef enum {
	IN_EXCEPTION_NONE = 0,
	IN_EXCEPTION_TRY = 1,
	IN_EXCEPTION_CATCH = 2,
	IN_EXCEPTION_FINALLY = 3
} EXCEPTION_STATE;
typedef struct {
	EXCEPTION_STATE	state;
	unsigned short		routine_level;
} EXCEPTION_STATE_NODE;
typedef struct {
	short 		catchFlag, finallyFlag;
	jmp_buf		catchLoc;
	jmp_buf		finallyLoc;
	jmp_buf		gosubLoc;
} EXCEPTION_DEST_NODE;

#ifdef	__cplusplus
extern "C" {
#endif

#include <limits.h>
#include <float.h>
#include <stdarg.h>

	// Include math.h only if we are in code gen and we are not building typdef.
	// We can use the _MSC_VER preprocessor macro to check for that.
#ifndef _MSC_VER
#if defined(_AIX)
#include </usr/include/math.h>
#else
#include <math.h>
#endif
#endif

// #include <mathX.h>
// ***** DOINC including oswindow.h *****
/*                                                                         */
/* *********************************************************************** */
/*                                                                         */
/*                 Copyright Powersoft Corporation 1991-1994               */
/*                                                                         */
/*       Powersoft Corporation ("Powersoft") claims copyright in this      */
/*     program and documentation as an unpublished work, versions of       */
/*     which were first licensed on the date indicated in the foregoing    */
/*     notice. Claim of copyright does not imply waiver of Powersoft's     */
/*     other rights. See Notice of Proprietary Rights.                     */
/*                                                                         */
/*                 NOTICE OF PROPRIETARY RIGHTS                            */
/*                                                                         */
/*       This program and documentation are confidential trade             */
/*     secrets and the property of Powersoft.  Use, examination,           */
/*     reproduction, copying, disassembly, decompilation, transfer         */
/*     and/or disclosure to others are strictly prohibited except by       */
/*     express written agreement with Powersoft.                           */
/*                                                                         */
/* ----------------------------------------------------------------------- */
/*                                                                         */
/*    Filename :    oswindow.h                                             */
/*                                                                         */
/*    Author   :    Jim Kosko                                              */
/*                                                                         */
/*    Purpose  :    Wrapper for windows.h                                  */
/*                                                                         */
/* *********************************************************************** */

/* *********************************************************************** */
/*  Insure file is not included in twice                                   */
/* *********************************************************************** */

#ifndef OSWINDOW_H
#define OSWINDOW_H

/* *********************************************************************** */
/*  Include in MAC OS header.                                              */
/* *********************************************************************** */
// ***** DOINC including pbos.h *****
/* *********************************************************************** */
/*                                                                         */
/*             COPYRIGHT POWERSOFT CORPORATION 1990-1994                   */
/*                                                                         */
/*        POWERSOFT CORPORATION ("POWERSOFT") CLAIMS COPYRIGHT IN THIS     */
/*   PROGRAM AND DOCUMENTATION AS AN UNPUBLISHED WORK, VERSIONS OF         */
/*   WHICH WERE FIRST LICENSED ON THE DATE INDICATED IN THE FOREGOING      */
/*   NOTICE.   CLAIM OF COPYRIGHT DOES NOT IMPLY WAIVER OF POWERSOFT'S     */
/*   OTHER RIGHTS.                                                         */
/*                                                                         */
/* ----------------------------------------------------------------------- */
/*                                                                         */
/*   Filename : pbos.h                                                     */
/*                                                                         */
/*   Author   : Shih-Lin N. Liu                                            */
/*                                                                         */
/*   Purpose  : platform-specific include file.                            */
/*              should be the first thing included in all c and c++ files. */
/*                                                                         */
/* *********************************************************************** */

#ifndef PBOS_H
#define PBOS_H

#if defined PBOS_MAC && !defined WIN32_LAYER
// ***** DOINC including platform.h *****
	// DOINC skipping missing include
#endif



// define generic bitfield manipulation macros

// SET_BIT where:
//  stb_data_type = integral type of bit set being manipulated
//  stb_value    = bit set to manipulate
//  stb_mask = bit mask
//  stb_bSet = clear or set bits (0 or 1 respectively)

#define SET_BIT(stb_datatype,stb_value,stb_mask,stb_bSet)\
    (stb_value) = (stb_bSet) ? \
              (stb_datatype)((stb_mask) | (stb_value))\
             :\
              (stb_datatype)(~(stb_mask) & (stb_value));

// GET_BIT where:
//  gtb_data_type = integral type of bit set being tested
//  gtb_value    = bit set to check
//  gtb_mask = bit mask
#define GET_BIT(gtb_data_type,gtb_value,gtb_mask) \
    ( (gtb_data_type) ((gtb_value) & (gtb_mask)))


#ifdef _MIPS_
#ifndef _DOUBLE_LPCATCHBUF
#define _DOUBLE_LPCATCHBUF
#endif
#endif

#ifdef _ALPHA_
#ifndef _DOUBLE_LPCATCHBUF
#define _DOUBLE_LPCATCHBUF
#endif
#endif

// define byte  order and structure alignment macros, based on predefined
// compiler symbols

#if defined __sparc || ( defined _POWER && defined _AIX ) || \
 	defined __MC68K__ || defined powerc || \
    defined __hp9000s300 || defined __hp9000s700 || defined __hp9000s800

#ifndef _BIG_ENDIAN
#define _BIG_ENDIAN 
#endif

#endif 


// structure alignment

#if defined __sparc || ( defined _POWER && defined _AIX ) || \
    defined __hp9000s300 || defined __hp9000s700 || defined __hp9000s800

#ifndef _RISC_NATURAL_ALIGN
#define  _RISC_NATURAL_ALIGN
#endif

#endif 

#ifdef PBOS_LINUX
#ifndef _NEED_BRACKETS_FOR_NEW
#define _NEED_BRACKETS_FOR_NEW
#endif
#endif

#if defined __hp9000s300 || defined __hp9000s700 || defined __hp9000s800

// We need a separate version of new that includes [] for allocation of arrays.
#ifndef _NEED_BRACKETS_FOR_NEW
#define _NEED_BRACKETS_FOR_NEW
#endif

// HP compiler provides headers containing definition for bool (BOOL).
#ifndef _BOOL_DEFINED
#define _BOOL_DEFINED
#endif

// Using C++ compiler, we have to be sure pbstg_alloc uses 8 byte headers
// to force alignment of doubles on 8 byte boundary.
#ifndef _DOUBLE_ALIGNMENT
#define _DOUBLE_ALIGNMENT
#endif

#ifndef _DOUBLE_LPCATCHBUF
#define _DOUBLE_LPCATCHBUF
#endif

// HP Function names do have preceeding underscore
#ifdef WITHOUT_UNDERSCORE
#undef WITHOUT_UNDERSCORE
#endif

#endif // hp9000...

#endif /* PBOS_H */
// DOINC popped back into header 'oswindow.h'

/* *********************************************************************** */
/* Unicode defines                                                         */
/* *********************************************************************** */
#if defined(PS_UNICODE) && !defined(UNICODE)
#define UNICODE
#endif
#if defined(PS_UNICODE) && !defined(_UNICODE)
#define _UNICODE
#endif

/* *********************************************************************** */
/*  If min or max already defined (in stdlib.h), turn off                  */
/*    min/max in windows.h                                                 */
/* *********************************************************************** */

#ifdef min
#define NOMINMAX
#endif

/* *********************************************************************** */
/* Undefine NOWH to avoid conflict in PBMAIN.H.                            */
/* *********************************************************************** */
#ifdef NOWH
#undef NOWH
#endif

/* *********************************************************************** */
/* Undefine NULL definition. (Conflict from stdio.h)                       */
/* *********************************************************************** */
#ifndef _INC_WINDOWS
#undef NULL
#endif

/* *********************************************************************** */
/* Define for Win16 variable argument functions.                           */
/* *********************************************************************** */
#ifdef PBWIN16
#ifndef WINAPIV
#define WINAPIV _cdecl
#endif
#endif


/* *********************************************************************** */
/* This assumes OLE is ALWAYS 8bit characters for Unix!!!                  */
/* *********************************************************************** */
#if defined(PBOS_UNIX)
#ifndef OLE2ANSI
#define OLE2ANSI
#endif
#endif



/* *********************************************************************** */
/*  Include Windows                                                        */
/* *********************************************************************** */

// for codegen, we want to skip including windows stuff
// DOINC told to skip 23 lines...

/* *********************************************************************** */
/* Wrappers for Non-Standard keywords in MS-DOS C compiler.                */
/* *********************************************************************** */

#ifndef FAR
#ifdef PBWIN32
#define FAR
#else
#define FAR                 _far
#endif
#endif

#ifdef PBWIN16
	typedef char OLECHAR;
	typedef char FAR* LPOLESTR;
	typedef const char FAR* LPCOLESTR;
#endif

#ifndef NEAR
#ifdef PBWIN32
#define NEAR
#else
#define NEAR                _near
#endif
#endif

#ifndef HUGEPTR
#ifdef PBWIN32
#define HUGEPTR
#else
#define HUGEPTR         _huge
#endif
#endif

#ifndef PASCAL
#ifdef PBWIN32
#if (defined(PBOS_UNIX) && defined(GENERATED_CODE_BUILD))
	// gmoison CODEGEN
#define PASCAL
#else
#define PASCAL          __stdcall
#endif
#else
#define PASCAL          _pascal
#endif
#endif

#ifndef CDECL
#ifdef PBWIN32
#define CDECL
#else
#define CDECL               _cdecl
#endif
#endif

#ifndef START_ASSEMBLER
#define START_ASSEMBLER _asm {
#endif

#ifndef END_ASSEMBLER
#define END_ASSEMBLER   }
#endif

	/* *********************************************************************** */
	/* Standard system typedefs for MS_DOS                                     */
	/* *********************************************************************** */

#ifndef VOID
#define VOID                void
#endif

#ifndef PVOID
//#if defined(PBOS_MAC) && defined(applec)
#if defined(PBOS_MAC)
	typedef VOID FAR* PVOID;
#else
#define PVOID               VOID FAR *
#endif
#endif

// Ansi character
#ifndef CHAR
#define CHAR                char
#endif

// Obsolete--use LPCHAR
#ifndef PCHAR
#define PCHAR               char FAR *
#endif

#if defined(PBWIN16) || defined(GENERATED_CODE_BUILD)
	typedef short SHORT;
	typedef int INT;
#endif

#ifndef PSHORT
#define PSHORT              SHORT FAR *
#endif

#ifndef LONG
#define LONG                long
#endif

#ifndef LPWORD
#define LPWORD              WORD FAR *
#endif

#ifndef PLONG
#define PLONG               LONG FAR *
#endif

#ifndef PINT
#define PINT                INT FAR *
#endif

#ifdef PBOS_UNIX
#if defined(__sun) || defined(PBOS_LINUX)
#define LONGLONG_MAX    LLONG_MAX
#define ULONGLONG_MAX   ULLONG_MAX
#define LONGLONG_MIN    LLONG_MIN
#endif
#if defined(__hpux)
#define LONGLONG_MAX    LONG_LONG_MAX
#define ULONGLONG_MAX   ULONG_LONG_MAX
#define LONGLONG_MIN    LONG_LONG_MIN
#endif
#if defined(__sun) || defined(__hpux) || defined(_AIX)
	typedef int INT_PTR, * PINT_PTR;
	typedef long LONG_PTR, * PLONG_PTR;
	typedef unsigned int UINT_PTR, * PUINT_PTR;
	typedef unsigned long ULONG_PTR, * PULONG_PTR;
	typedef ULONG_PTR DWORD_PTR, * PDWORD_PTR;
#define __int64		long long
#endif
#define _I64_MAX   LONGLONG_MAX  /* maximum value of a signed 64 bit type   */
#define _UI64_MAX  ULONGLONG_MAX /* maximum value of an unsigned 64 bit type*/
#define _I64_MIN   LONGLONG_MIN
#define pbstg_charnext(s)               CharNext(s)
#define pbstg_charprev(s1, s2)          CharPrev(s1, s2)
#endif

#ifdef PBOS_UNIX
#ifndef LONGLONG
#define LONGLONG            long long
#endif

#ifndef PLONGLONG
#define PLONGLONG           long long *
#endif

#ifndef ULONGLONG
#define ULONGLONG           unsigned long long
#endif

#ifndef PULONGLONG
#define PULONGLONG          unsigned long long *
#endif

#else

#ifndef LONGLONG
#define LONGLONG            __int64
#endif

#ifndef PLONGLONG
#define PLONGLONG           __int64 *
#endif

#ifndef ULONGLONG
#define ULONGLONG           unsigned __int64
#endif

#ifndef PULONGLONG
#define PULONGLONG          unsigned __int64 *
#endif

	//**********************************************************
	// Begin of the new type BYTE
	//**********************************************************
#ifndef BYTE
#define BYTE				unsigned char
#endif

#ifndef PBYTE
#define PBYTE				unsigned char *
#endif
//**********************************************************
// End of the new type BYTE
//**********************************************************

#endif
//Note: This macro "_ULONGLONG_" is defined to bypass the redefinition of longlong, ulonglong
//      plonglong pulonglong happened in db\oledb\intel32\include\oledb.h
#define _ULONGLONG_

#ifndef FLOAT
#define FLOAT               float
#endif

#ifndef PFLOAT
#define PFLOAT              FLOAT FAR *
#endif

#ifndef DOUBLE
#define DOUBLE              double
#endif

#ifndef PDOUBLE
#define PDOUBLE             DOUBLE FAR *
#endif
/*
#ifndef REAL
#define REAL                FLOAT
#endif
*/
#ifndef PREAL
#define PREAL               REAL FAR *
#endif

#if !(defined(__WATCOMC__) && defined (_WINDOWS_)) && !defined(PBOS_LINUX)
#if (!defined(PBOS_UNIX) ||(defined(PBOS_UNIX) && defined(GENERATED_CODE_BUILD)))
	typedef unsigned char   UCHAR;
	typedef unsigned short  USHORT;
	typedef unsigned long   ULONG;
#define OTHER_WINDOWS_H_STUFF
#endif // Not UNIX
#endif

	// this catches typedef's that are defined in windows.h, if we don't include
	// window.h.  We always include windows.h on mac and unix.
#if (!defined(PBOS_MAC) ||(defined(PBOS_MAC) && defined(GENERATED_CODE_BUILD))) && !defined(PBOS_LINUX)
#if (!defined(PBOS_UNIX) ||(defined(PBOS_UNIX) && defined(GENERATED_CODE_BUILD)))
#ifndef _INC_WINDOWS

#define BYTE            unsigned char
	typedef int             BOOL;
	typedef unsigned int    UINT;
	typedef unsigned short  WORD;
	typedef unsigned long   DWORD;
	typedef DWORD FAR* LPDWORD;
#ifndef OTHER_WINDOWS_H_STUFF
	typedef unsigned char   UCHAR;
	typedef unsigned short  USHORT;
	typedef unsigned long   ULONG;
#endif
	typedef UINT            WPARAM;
	typedef LONG            LPARAM;
	typedef VOID FAR* LPVOID;
	typedef LONG FAR* LPLONG;

#if defined(PBOS_MAC)
	typedef BYTE     Boolean;
#endif

	// declare handle stuff
#ifdef STRICT

#ifdef PBWIN32
#ifndef _WINNT_
	typedef void* HANDLE;
#endif // _WINNT_
#else // !PBWIN32
	typedef const void NEAR* HANDLE;
#endif //PBWIN32

#ifndef DECLARE_HANDLE
#define DECLARE_HANDLE(name)     struct name##__ { int unused; }; \
            typedef const struct name##__ NEAR* name
#endif

#ifndef DECLARE_HANDLE32
#define DECLARE_HANDLE32(name)  struct name##__ { int unused; }; \
            typedef const struct name##__ FAR* name
#endif

#else   /* STRICT */

#ifdef PBWIN32

#ifndef _WINNT_
	typedef void* HANDLE;
#endif // _WINNT_

#else // !PBWIN32
	typedef UINT                    HANDLE;
#endif //PBWIN32

#ifndef DECLARE_HANDLE
#define DECLARE_HANDLE(name)    typedef UINT name
#endif

#ifndef DECLARE_HANDLE32
#define DECLARE_HANDLE32(name)  typedef DWORD name
#endif

#endif  /* !STRICT */

	DECLARE_HANDLE(HBITMAP);
	DECLARE_HANDLE(HICON);
	DECLARE_HANDLE(COLORREF);
	DECLARE_HANDLE(HDC);
	DECLARE_HANDLE(HINSTANCE);
	DECLARE_HANDLE(GLOBALHANDLE);
	DECLARE_HANDLE(LOCALHANDLE);
	DECLARE_HANDLE(HWND);
	DECLARE_HANDLE(HPALETTE);
	DECLARE_HANDLE(HBRUSH);
	DECLARE_HANDLE(HMENU);
	DECLARE_HANDLE(HFONT);
	DECLARE_HANDLE(HCURSOR);
	DECLARE_HANDLE(HACCEL);
	DECLARE_HANDLE(HPEN);
	DECLARE_HANDLE(HHOOK);

#endif // _INC_WINDOWS
#endif // PBOS_MAC
#endif // PBOS_UNIX

#ifndef PUCHAR
#define PUCHAR          BYTE FAR *
#endif

#ifndef PUSHORT
#define PUSHORT         USHORT FAR *
#endif

#ifndef PULONG
#define PULONG          ULONG FAR *
#endif

#ifndef LPULONG
#define LPULONG         ULONG FAR *
#endif

#ifndef PUINT
#define PUINT               UINT FAR *
#endif

	//johnf will be removed after Unicode conversion...
#ifndef PBYTE
#define PBYTE               BYTE FAR *
#endif

#ifndef PBOOL
#define PBOOL               BOOL FAR *
#endif

#ifndef EXPORT
#if (defined(PBOS_NT) || defined(PBOS_MAC) || defined(PBOS_WIN40) || defined(PBOS_UNIX))
#define EXPORT
#else
#define EXPORT              __export
#endif
#endif



	/* *********************************************************************** */
	/* String literal macros                                                   */
	/* *********************************************************************** */
#ifdef RC_INVOKED
#define PBTEXT(quote)                   quote
#define PBANSI(quote)                   quote
#define PBUNICODE(quote)                quote
#else
#ifdef PBWIN32
#define PBTEXT(quote)                   TEXT(quote)
#define PBTEXTC(quote)                  TEXT(quote)
#define PBANSI(quote)                   quote
#define PBUNICODE(quote)                L##quote
#else
#define PBTEXT(quote)                   quote
#define PBANSI(quote)                   quote
#define PBUNICODE(quote)                quote
#endif
#endif

#define QUOTED(x)                       #x
/* *********************************************************************** */
/* Windows 5.0 definitions                                                 */
/* *********************************************************************** */
#if(WINVER >= 0x0400) //CR161322, Should version 0x0500
#define WS_EX_NOINHERITLAYOUT   0x00100000L // Disable inheritence of mirroring by children
#define WS_EX_LAYOUTRTL         0x00400000L // Right to left mirroring
#endif

/* *********************************************************************** */
/* Windows 4.0 definitions                                                 */
/* *********************************************************************** */
#if WINVER < 0x0400

// New Styles
#define DS_3DLOOK               0x00000004L
#define SS_SUNKEN               0x00001000L

// New Extended Window Styles
#define WS_EX_TOOLWINDOW        0x00000080L
#define WS_EX_WINDOWEDGE        0x00000100L
#define WS_EX_CLIENTEDGE        0x00000200L
#define WS_EX_PALETTEWINDOW     (WS_EX_WINDOWEDGE|WS_EX_TOOLWINDOW|WS_EX_TOPMOST)

// Explorer common dialogs
#define OFN_EXPLORER            0x00080000L

// New 3D colors
#define COLOR_3DFACE            15
#define COLOR_3DSHADOW          16
#define COLOR_3DHILIGHT         20
#define COLOR_3DDKSHADOW        21
#define COLOR_3DLIGHT           22

// DOINC told to skip 23 lines...

// Defined in 32-bits but not in 16-bits
#define IDI_WINLOGO     MAKEINTRESOURCE(32517)
#define IDI_WARNING     MAKEINTRESOURCE(32515)

#endif

/* *********************************************************************** */
/*  PowerBuilder COLOR constants                                           */
/* *********************************************************************** */
#define COLOR_ANCHOR             128
#define COLOR_ANCHORHOVER        129
#define COLOR_ANCHORACTIVE       130
#define COLOR_ANCHORVISITED      131

/* *********************************************************************** */
/*  Pascal definitions.                                                    */
/* *********************************************************************** */
// ***** DOINC including ospascal.h *****
/*                                                                         */
/* *********************************************************************** */
/*                                                                         */
/*                 Copyright Powersoft Corporation 1991-1994               */
/*                                                                         */
/*       Powersoft Corporation ("Powersoft") claims copyright in this      */
/*     program and documentation as an unpublished work, versions of       */
/*     which were first licensed on the date indicated in the foregoing    */
/*     notice. Claim of copyright does not imply waiver of Powersoft's     */
/*     other rights. See Notice of Proprietary Rights.                     */
/*                                                                         */
/*                 NOTICE OF PROPRIETARY RIGHTS                            */
/*                                                                         */
/*       This program and documentation are confidential trade             */
/*     secrets and the property of Powersoft.  Use, examination,           */
/*     reproduction, copying, disassembly, decompilation, transfer         */
/*     and/or disclosure to others are strictly prohibited except by       */
/*     express written agreement with Powersoft.                           */
/*                                                                         */
/* ----------------------------------------------------------------------- */
/*                                                                         */
/*    Filename :    ospascal.h                                             */
/*                                                                         */
/*    Author   :    Jim Kosko                                              */
/*                                                                         */
/*    Purpose  :    Wrapper for PASCAL definitions.                        */
/*                                                                         */
/* *********************************************************************** */

// This header is included by oswindow.h--include oswindow.h instead.
#ifndef OSWINDOW_H
// ***** DOINC including oswindow.h *****
	// DOINC skipping duplicate include
#endif

/* *********************************************************************** */
/*  Insure file is not included in twice                                   */
/* *********************************************************************** */

#ifndef OSPASCAL_H
#define OSPASCAL_H

/* *********************************************************************** */
/*  Include in MAC OS header.                                              */
/* *********************************************************************** */
// ***** DOINC including pbos.h *****
	// DOINC skipping duplicate include

#ifndef WINAPI
#ifdef PBOS_NT
#define WINAPI              __stdcall
#else
#define WINAPI              FAR PASCAL
#endif
#endif

#ifndef CALLBACK
#ifdef PBOS_NT
#define CALLBACK            __stdcall
#else
#define CALLBACK            FAR PASCAL
#endif
#endif

/* *********************************************************************** */
/* NOTE:    I added underbar versions of the following macros which don't   */
/*      include the name, since I didn't see any need for it. Dean.     */
/* *********************************************************************** */

/* *********************************************************************** */
/* External definitions for Mac                                            */
/* *********************************************************************** */

#ifdef  PBOS_MAC

#ifdef PBWIN32
// Windows 32 API on Mac
#define PBWINAPI(r,n)   r (_PB_##n)
#define PBWINAPI_(r)    r
#define PBDLGPROC(r,n)  r (n)
#define PBDLGPROC_(r)   r
#define PBCALLBACK(r,n) r (n)
#define PBCDECLAPI(r,n) r (_PB_##n)
#define PBCDECLCALLBACK(r,n) r (n)

#define PBCALLBACK_(r)  r
#define PBCDECLAPI_(r)  r

#else
// Windows 16 API on Mac
#define PBWINAPI(r,n)   PASCAL r (n)
#define PBWINAPI_(r)    PASCAL r
#define PBDLGPROC(r,n)  PASCAL r (n)
#define PBDLGPROC_(r)   PASCAL r

#define PBCALLBACK(r,n) PASCAL r (n)
#define PBCDECLAPI(r,n) CDECL  r (n)
#define PBCDECLCALLBACK(r,n) CDECL  r (n)
#define PBCALLBACK_(r)  PASCAL r
#define PBCDECLAPI_(r)  CDECL  r
#endif


/* *********************************************************************** */
/* External definitions for OS/2                                           */
/* *********************************************************************** */

#elif   defined(PBOS_OS2)

#define PBCALLBACK(r,n) FAR PASCAL __loadds r n
#define PBDLGPROC(r,n)  FAR PASCAL __loadds r n
#define PBWINAPI(r,n)   FAR PASCAL __loadds r n
#define PBCDECLAPI(r,n) FAR CDECL  __loadds r n
#define PBCDECLCALLBACK(r,n) FAR CDECL  __loadds r n

#define PBCALLBACK_(r)  FAR PASCAL __loadds r
#define PBDLGPROC_(r)   FAR PASCAL __loadds r
#define PBWINAPI_(r)    FAR PASCAL __loadds r
#define PBCDECLAPI_(r)  FAR CDECL  __loadds r

/* *********************************************************************** */
/* External definitions for WATCOM C                                       */
/* *********************************************************************** */

#elif defined(__WATCOMC__) && defined(__cplusplus)


#define PBCALLBACK(r,n) __declspec(dllexport) r ( CALLBACK    n )
#define PBDLGPROC(r,n)  __declspec(dllexport) r ( WINAPI      n )
#define PBWINAPI(r,n)   __declspec(dllexport) r ( WINAPI      n )
#define PBCDECLAPI(r,n) __declspec(dllexport) r ( FAR __cdecl   n )
#define PBCDECLCALLBACK(r,n) __declspec(dllexport) r ( FAR __cdecl   n )
#define PBCALLBACK_(r)  __declspec(dllexport) r CALLBACK
#define PBDLGPROC_(r)   __declspec(dllexport) r WINAPI
#define PBWINAPI_(r)    __declspec(dllexport) r WINAPI
#define PBCDECLAPI_(r)  __declspec(dllexport) r FAR __cdecl


/* *********************************************************************** */
/* External definitions for everyone else                                  */
/* *********************************************************************** */

#else

#define PBCALLBACK(r,n) r ( CALLBACK    n )
#define PBDLGPROC(r,n)  r  WINAPI      n
#define PBWINAPI(r,n)   r  WINAPI      n
#if defined(__WATCOMC__)
#define PBCDECLAPI(r,n) r ( __export FAR CDECL   n )
#define PBCDECLCALLBACK(r,n) r ( __export FAR CDECL   n )
#else
#define PBCDECLAPI(r,n) r  FAR CDECL   n
#define PBCDECLCALLBACK(r,n) r ( FAR CDECL   n )
#endif
#define PBCALLBACK_(r)  r CALLBACK
#define PBDLGPROC_(r)   r WINAPI
#define PBWINAPI_(r)    r WINAPI
#if defined(__WATCOMC__)
#define PBCDECLAPI_(r)  r __export FAR CDECL
#else
#define PBCDECLAPI_(r)  r FAR CDECL
#endif
#endif

#endif /* OSPASCAL_H */
// DOINC popped back into header 'oswindow.h'

// DOINC told to skip 77 lines...


/* *********************************************************************** */
/* These are windows.h definitions that are not used in generated code, but*/
/* must be defined to compile included header files                        */
/* THEY DO NOT MATCH THE WINDOWS.H DEFINITIONS FOR COPYWRITE REASONS       */
/* *********************************************************************** */

/* *********************************************************************** */
/* Typedef for pointers to functions.                                      */
/* *********************************************************************** */

	typedef VOID(*PFV) ();
	typedef INT(*PFI) ();
	typedef TCHAR(*PFC) ();
	typedef TCHAR* (*PFS) ();
	typedef FLOAT(*PFF) ();

	/* *********************************************************************** */
	/*  Define the slash character                                             */
	/* *********************************************************************** */
#ifdef PBOS_UNIX
#define PBSLASH       PBTEXTC('/')
#define PBSLASHSTRING PBTEXT("/")
#elif  defined(PBOS_MAC)
#define PBSLASH       PBTEXT(':')
#define PBSLASHSTRING PBTEXT(":")
#else
#define PBSLASH       PBTEXTC('\\')
#define PBSLASHSTRING PBTEXT("\\")
#endif

/* *********************************************************************** */
/*  Define the new line string                                             */
/* *********************************************************************** */
#if defined(PBOS_MAC) && defined(__SC__)
#define PBNEWLINE_CHAR 0x0A
#define PBRETURN_CHAR  0x0D
#else
#define PBNEWLINE_CHAR PBTEXTC('\n')
#define PBRETURN_CHAR  PBTEXTC('\r')
#endif

#ifdef PBOS_MAC
#define PBNEWLINESTRING PBTEXT("\r")
#else
#define PBNEWLINESTRING PBTEXT("\r\n")
#endif

/* *********************************************************************** */
/* Define file extension requirements                                      */
/* *********************************************************************** */
#if !defined(PBOS_MAC) && !defined(PBOS_UNIX)
#define PBFILEEXTREQUIRED
#endif

// DOINC told to skip 195 lines...

/* *********************************************************************** */
/*  The remainder of this file is what was in stdcsi.h                     */
/* *********************************************************************** */

/* *********************************************************************** */
/*  Macro for embedding version info into strings                          */
/* *********************************************************************** */

/*
	# is the "stringize" precompiler directive.

This macro would yield results as follows:

	psAddVersionID ( "head", "tail" )
	==> "head" "031" "tail"
	==> "head031tail"

	psAddVersionID ( "head", "" )
	==> "head" "031" ""
	==> "head031"

	psAddVersionID ( "", "tail" )
	==> "" "031" "tail"
	==> "031tail"
*/

// ***** DOINC including builddef.h *****
/*  Include File generated from current build*/
/*  This header file is called by stdcsi.h for up-to-date environment variables!*/
#ifndef PBTEXT
#ifdef PBWIN32
#define PBTEXT(quote)                   TEXT(quote)
#else
#define PBTEXT(quote)                   quote
#endif
#endif
#define BUILDDEF               12.5.2.5629
#define BuildMajorVersionID    12
#define BuildMinorVersionID    5
#define BuildFixesVersionID    2
#define BuildInternalID        5629
#define BuildVersionID         PBTEXT("125")
#define BuildVersionIDAnsi	   "125"
#define BuildShortVersionID    PBTEXT("125")
#define BuildVersionString     PBTEXT("12.5.2.5629")
#define BuildVersionStringFixed     PBTEXT("12.5.2.0")
#define BuildVersionAnsiString     "12.5.2.5629"
#define ProductVersionString   PBTEXT("12.5.2.5629")
#define BuildMajorVersionString		"12"
#define BuildMinorVersionString		"5"
#define BuildAssemblyVersionString   PBTEXT("12.5.0.0")
#define BuildVersionIDString         PBTEXT("5629")

#define DWBuildMajorVersionID    3
#define DWBuildMinorVersionID    0
#define DWBuildFixesVersionID    0
#define DWBuildVersionString     PBTEXT("3.0.0.5629")
#define DWProductVersionString   PBTEXT("3.0.0.5629")
#define DWAssemblyVersionAttribute   "3.0.0.0"
#define DWBuildVersionID		PBTEXT("25")
#define DWBuildShortVersionString     PBTEXT("3.0") 
#define DWMaintBuildVersionString     PBTEXT("3.0")
#define DWBuildMajorVersionString		"3"
#define DWBuildMinorVersionString		"0" 
#define DWBuildAssemblyVersionString   PBTEXT("3.0.0.0")

#define BuildGUIDVersionID   0xc5c5L

#define BuildGUIDVersionID_STR   PBTEXT("C5C5")

/* BuildShortVersionString is used for register key and installation destionation */
/* do NOT change the .0 to .x, unless major version upgrade, say 10.0 -> 10.5 */
#define BuildShortVersionString     PBTEXT("12.5") 

/* MaintBuildVersionString: MajorVersion.MinorVersion*/
#define MaintBuildVersionString     PBTEXT("12.5.2") 

#define CopyrightYearString     PBTEXT("2013")
#define CopyrightFullString     PBTEXT("Copyright (C) Sybase Inc. 2013")
#define PBPublicKeyToken	PBTEXT("PublicKeyToken=598c7456a83d557a")
#define DWPublicKeyToken	PBTEXT("PublicKeyToken=cc0f66dd9541b3da")
// DOINC popped back into header 'oswindow.h'

#ifdef BUILDDEF
#define psMajorVersionID BuildMajorVersionID
#define psMinorVersionID BuildMinorVersionID
#define psFixesVersionID BuildFixesVersionID
#define psInternalID     BuildInternalID
#define psVersionID      BuildVersionID
#define psShortVersionID BuildShortVersionID
#define psVersionGUID    BuildGUIDVersionID
#define psVersionGUID_HI  (psVersionGUID << 16)
#define psVersionGUID_STR  BuildGUIDVersionID_STR
#define psDWVersionID      DWBuildVersionID
#endif

#define psAddVersionID( head, tail ) head psVersionID tail
#define psDWAddVersionID( head, tail ) head psDWVersionID tail
#define psAddBuildShortVersionString( head, tail ) head BuildMajorVersionID . BuildMinorVersionID tail
#define psAddShortVersionID( head, tail ) head psShortVersionID tail

/* *********************************************************************** */
/*  Macro used to handle the different naming standards for referencing    */
/*      dlls on the platforms. Example: psDLLName( "bgr" )                 */
/* *********************************************************************** */

#if defined(PBOS_MAC)
#define psDLLPrefixName()   PBTEXT("Powersoft")
#define psDLLVersionLong()  PBTEXT("")
#define psDLLVersionShort() PBTEXT("")
#define psDLLSuffixName()   PBTEXT("Lib")
#define psDLLName( module ) psDLLPrefixName() module psDLLSuffixName()
#define psDLLNameShort( module ) psDLLPrefixName() module psDLLSuffixName()
#define psDLLNameQuoted( module ) QUOTED(psDLLName(module))

#elif defined(DW_OCX)
#define psDLLPrefixName()   PBTEXT("pb")
#ifdef PBWIN16
#if defined(PS_HEBREW)
#define psDLLSuffixName()   PBTEXT("i.dll")
#elif defined(PS_ARAB)
#define psDLLSuffixName()   PBTEXT("b.dll")
#elif defined(PS_JPN)
#define psDLLSuffixName()   PBTEXT("k.dll")
#else
#define psDLLSuffixName()   PBTEXT("w.dll")
#endif
#elif defined(_AIX)
#define psDLLSuffixName()   PBTEXT(".so.a")
#elif defined(HPUX_IT32)
#define psDLLSuffixName()   PBTEXT(".so")
#elif defined (HPUX_IT64)
#define psDLLSuffixName()   PBTEXT(".so")
#elif defined(__hpux)
#define psDLLSuffixName()   PBTEXT(".sl")
#elif defined(__sun)
#define psDLLSuffixName()   PBTEXT(".so")
#elif defined(PBOS_LINUX)
#define psDLLSuffixName()   PBTEXT(".so")
#elif defined(PS_UNICODE)
#define psDLLSuffixName()   PBTEXT(".dll")
#elif defined(PS_HEBREW)
#define psDLLSuffixName()   PBTEXT("h.dll")
#elif defined(PS_ARAB)
#define psDLLSuffixName()   PBTEXT("a.dll")
#elif defined(PS_JPN)
#define psDLLSuffixName()   PBTEXT("j.dll")
// ADC_DBCS_START_MODIFY cchong Jun 30 1999
//#elif defined(PS_DBCS)
//#define psDLLSuffixName()   PBTEXT("m.dll")
// ADC_DBCS_END_MODIFY cchong Jun 30 1999
#else
#define psDLLSuffixName()   PBTEXT(".dll")
#endif
#define psDLLVersionLong()  psVersionID
#define psDLLVersionShort() psShortVersionID
#define psDLLName( module ) psAddVersionID( psDLLPrefixName() module, psDLLSuffixName())
#define psDLLNameShort( module ) psAddShortVersionID(psDLLPrefixName() module, psDLLSuffixName())
#define psDLLNameQuoted( module ) QUOTED(psDLLName(module))

#else
#if defined(PBOS_UNIX)
#define BUILD_VERSION	"Version12.5.0.2511"
#define psDLLPrefixName()   PBTEXT("libpb")
#if !defined(_AIX)
#define PBVMLIBRARY   PBTEXT("libpbvm125x.so")
#define PBSHRLIBRARY  PBTEXT("libpbshr125x.so")
#define PBJAGLIBRARY  PBTEXT("libpbjag125x.so")
#define PBDWLIBRARY  	 PBTEXT("libpbdwe125x.so")
#define PBJVMLIBRARY  	 PBTEXT("libpbjvm125x.so")
#define PBXERCESLIBRARY  PBTEXT("libpbxerces125x.so")
#else
#define PBVMLIBRARY   PBTEXT("libpbvm125x.so.a")
#define PBSHRLIBRARY  PBTEXT("libpbshr125x.so.a")
#define PBJAGLIBRARY  PBTEXT("libpbjag125x.so.a")
#define PBDWLIBRARY  	 PBTEXT("libpbdwe125x.so.a")
#define PBJVMLIBRARY  	 PBTEXT("libpbjvm125x.so.a")
#define PBXERCESLIBRARY  PBTEXT("libpbxerces125x.so.a")
#endif
#else
#define psDLLPrefixName()   PBTEXT("pb")
#endif
#ifdef PBWIN16
#if defined(PS_HEBREW)
#define psDLLSuffixName()   PBTEXT("i.dll")
#elif defined(PS_ARAB)
#define psDLLSuffixName()   PBTEXT("b.dll")
#elif defined(PS_JPN)
#define psDLLSuffixName()   PBTEXT("k.dll")
#else
#define psDLLSuffixName()   PBTEXT("w.dll")
#endif
#elif defined(_AIX)
#if defined(PS_WINFREE)
#define psDLLSuffixName()   "x.so.a"
#else
#define psDLLSuffixName()   PBTEXT(".so.a")
#endif //_AIX, Winfree
#elif defined (HPUX_IT32)
#if defined(PS_WINFREE)
#define psDLLSuffixName()   "x.so"
#else
#define psDLLSuffixName()   PBTEXT(".so")
#endif
#elif defined  (HPUX_IT64)
#if defined(PS_WINFREE)
#define psDLLSuffixName()   "x.so"
#else
#define psDLLSuffixName()   PBTEXT(".so")
#endif
#elif defined(__hpux)
#if defined(PS_WINFREE)
#define psDLLSuffixName()   "x.sl"
#else
#define psDLLSuffixName()   PBTEXT(".sl")
#endif
#elif defined(__sun)
#if defined(PS_WINFREE)
#define psDLLSuffixName()   PBTEXT("x.so")
#else
#define psDLLSuffixName()   PBTEXT(".so")
#endif
#elif defined(PBOS_LINUX)
#if defined(PS_WINFREE)
#define psDLLSuffixName()   PBTEXT("x.so")
#else
#define psDLLSuffixName()   PBTEXT(".so")
#endif
#elif defined(PS_WINFREE)
#define psDLLSuffixName()   PBTEXT("x.dll")
#elif defined(PS_UNICODE)
#define psDLLSuffixName()   PBTEXT(".dll")
#elif defined(PS_HEBREW)
#define psDLLSuffixName()   PBTEXT("h.dll")
#elif defined(PS_ARAB)
#define psDLLSuffixName()   PBTEXT("a.dll")
#elif defined(PS_JPN)
#define psDLLSuffixName()   PBTEXT("j.dll")
// ADC_DBCS_START_MODIFY cchong Jul 6 1999
//#elif defined(PS_DBCS)
//#define psDLLSuffixName()   PBTEXT("m.dll")
// ADC_DBCS_END_MODIFY cchong Jul 6 1999
#else
#define psDLLSuffixName()   PBTEXT(".dll")
#endif
#define psDLLVersionLong()  psVersionID
#define psDLLVersionShort() psShortVersionID
#define psDLLName( module ) psAddVersionID( psDLLPrefixName() module, psDLLSuffixName())
#define psDLLNameShort( module ) psAddShortVersionID(psDLLPrefixName() module, psDLLSuffixName())
#define psDLLNameQuoted( module ) QUOTED(psDLLName(module))
#endif

#if defined (__sun)
#define jagDLLSuffixName()  PBTEXT(".so")
#elif defined (HPUX_IT32)
#define jagDLLSuffixName()  PBTEXT(".so")
#elif defined (HPUX_IT64)
#define jagDLLSuffixName()  PBTEXT(".so")
#elif defined (PBOS_LINUX)
#define jagDLLSuffixName()  PBTEXT(".so")
#elif defined (__hpux)
#define jagDLLSuffixName()  PBTEXT(".sl")
#elif defined (_AIX)
#define jagDLLSuffixName()  PBTEXT(".so.a")
#else
#define jagDLLSuffixName()  PBTEXT(".dll")
#endif

/* *********************************************************************** */
/*  Macro used to handle the different ways dlls are check for their       */
/*  existance. Macro only works on Mac with shared librarys right now.     */
/* *********************************************************************** */
#if defined(PBOS_MAC)
#define psLibraryExists(libName)        ( SharedLibraryExists(libName) )
#else
#define psLibraryExists(libName)        (1)
#endif

/* *********************************************************************** */
/*  Define PowerBuilder library extensions.                                */
/* *********************************************************************** */

#define psLibExtAnsi        PBTEXT(".pbl")
#define psLibExtUnicode     PBTEXT(".pbl")
#define psLibExtNoDot       PBTEXT("pbl")
#ifdef PS_UNICODE
#define psLibExt            psLibExtUnicode
#else
#define psLibExt            psLibExtAnsi
#endif

#define psRTLibExtAnsi      PBTEXT(".pbd")
#define psRTLibExtUnicode   PBTEXT(".pbd")
#define psRTLibExtNoDot     PBTEXT("pbd")
#ifdef PS_UNICODE
#define psRTLibExt          psRTLibExtUnicode
#else
#define psRTLibExt          psRTLibExtAnsi
#endif
#define psPBDName( module ) psAddVersionID( psDLLPrefixName() module, psRTLibExt)

#define psWorkspaceExt      PBTEXT(".pbw")
#define psTargetExt         PBTEXT(".pbt")
#define psDWProjectExt      PBTEXT(".dwp")  // Add for DW Builder

/* *********************************************************************** */
/*  Define the newline and return chars                                    */
/* *********************************************************************** */
#if defined(PBOS_MAC) && defined(__SC__)
#define PBNEWLINE_CHAR   0x0A
#define PBRETURN_CHAR    0x0D

#define PBNL_STR    PBTEXT("\x0A")
#define PBCR_STR    PBTEXT("\x0D")
#define PBCRNL_STR  PBTEXT("\x0D\x0A")
#else
#define PBNEWLINE_CHAR   PBTEXTC('\n')
#define PBRETURN_CHAR    PBTEXTC('\r')

#define PBNL_STR    PBTEXT("\n")
#define PBCR_STR    PBTEXT("\r")
#define PBCRNL_STR  PBTEXT("\r\n")
#endif

/* *********************************************************************** */
/*  Define the end-of-line macros                                          */
/* *********************************************************************** */

#if defined(PBOS_UNIX)
#define PB_EOL_STR      PBNL_STR
#define PB_EOL_LENGTH   1 * sizeof(TCHAR)
#elif defined(PBOS_MAC)
#define PB_EOL_STR      PBCR_STR
#define PB_EOL_LENGTH   1 * sizeof(TCHAR)
#else
#define PB_EOL_STR      PBCRNL_STR
#define PB_EOL_LENGTH   2 * sizeof(TCHAR)
#endif

/* *********************************************************************** */
/*  Define enumerated type values to force type to INT on Mac.             */
/* *********************************************************************** */
#if defined(PBOS_MAC) && defined(__SC__)
#include <Limits.h>     /* for INT_MAX */
#define PB_ENUM_TRAILER( token ) ,token = INT_MAX
#else
#define PB_ENUM_TRAILER( token )
#endif

/* *********************************************************************** */
/*  Operating system constants                                             */
/* *********************************************************************** */

#define OS_MSDOS3_3     0
#define OS_MSDOS        OS_MSDOS3_3

#define OS_OS2_1_1      10
#define OS_OS2          OS_OS2_1_1

#define OS_MPEXL        20

#define OS_UNIXSYS_5    30
#define OS_UNIX         OS_UNIXSYS_5

#define OS_SYSTEM       OS_MSDOS

/* *********************************************************************** */
/* Processor / Model Constants                                             */
/* *********************************************************************** */

#define OS_I86L         0       /* Intel Large Model */
#define OS_I86S         1       /* Intel Small Model */

#define OS_MODEL        OS_I86S

/* *********************************************************************** */
/*  Environment related constants                                          */
/* *********************************************************************** */

#define PBMAXRES        260     /* Maximum resource buffer size */
#define PBMAXFILE       260     /* Maximum file buffer size */
#define PBMAXCAPTION    PBMAXFILE   /* Maximum caption size */

#if defined(PBOS_MAC)

#define PBMAXFILENAME       31  /* Max file name size */
#define PBMAXEXTNAME        3   /* Max ext. size  */

#elif defined(PBOS_UNIX)

#define PBMAXFILENAME       31  /* Max file name size */
#define PBMAXEXTNAME        3   /* Max ext. size  */

#elif defined(PBOS_NT)

#define PBMAXFILENAME       255 /* Max file name size */
#define PBMAXEXTNAME        3   /* Max ext. size  */

#else

#define PBMAXFILENAME       8   /* Max file name size */
#define PBMAXEXTNAME        3   /* Max ext. size  */

#endif

/* *********************************************************************** */
/* External definitions for Mac                                            */
/* *********************************************************************** */

#ifdef  PBOS_MAC

#ifdef PBWIN32
#define PSCALLBACK(r,n)     r (n)
#define PSPASCALAPI(r,n)    r (n)
#define PSCDECLAPI(r,n)     r (n)
#else
#define PSCALLBACK(r,n)     PASCAL r (n)
#define PSPASCALAPI(r,n)    PASCAL r (n)
#define PSCDECLAPI(r,n)     CDECL  r (n)
#endif

/* *********************************************************************** */
/* External definitions for OS/2                                           */
/* *********************************************************************** */

#elif   defined (PBOS_OS2)

#define PSCALLBACK(r,n)     FAR PASCAL __loadds r n
#define PSPASCALAPI(r,n)    FAR PASCAL __loadds r n
#define PSCDECLAPI(r,n)     FAR CDECL  __loadds r n

/* *********************************************************************** */
/* External definitions for everyone else                                  */
/* *********************************************************************** */

#else

#define PSCALLBACK(r,n)     r (FAR PASCAL n)
#define PSPASCALAPI(r,n)    r (FAR PASCAL n)
#define PSCDECLAPI(r,n)     r (FAR CDECL  n)

#endif

/* *********************************************************************** */
/*  Typedefs for far procedure pointers.                                   */
/* *********************************************************************** */

#ifndef FAR_DECL
#define FAR_DECL            FAR
#endif

	typedef PSPASCALAPI(void, *FAR_VOID_PROC)       (VOID);
	typedef PSPASCALAPI(int, *FAR_INT_PROC)        (VOID);
	typedef PSPASCALAPI(int, *PASCALFAR_INT_PROC)  (VOID);
	typedef PSPASCALAPI(TCHAR, *PASCALFAR_CHAR_PROC) (VOID);

	/* Note: These still need to be converted for the Mac! JPL 12/23/93 */
#ifndef PBOS_MAC
	typedef void   FAR* (FAR_DECL* FAR_PVOID_PROC) (VOID);
	typedef int    FAR* (FAR_DECL* FAR_PINT_PROC) (VOID);
	typedef long  (FAR_DECL* FAR_LONG_PROC) (VOID);
	typedef long   FAR* (FAR_DECL* FAR_PLONG_PROC) (VOID);
	typedef TCHAR(FAR_DECL* FAR_CHAR_PROC) (VOID);
	typedef TCHAR   FAR* (FAR_DECL* FAR_PCHAR_PROC) (VOID);
	typedef float (FAR_DECL* FAR_FLOAT_PROC) (VOID);
	typedef float  FAR* (FAR_DECL* FAR_PFLOAT_PROC) (VOID);

	typedef void            (FAR_DECL PASCAL* PASCALFAR_VOID_PROC) (VOID);
	typedef void FAR* (FAR_DECL PASCAL* PASCALFAR_PVOID_PROC) (VOID);
	typedef int FAR* (FAR_DECL PASCAL* PASCALFAR_PINT_PROC) (VOID);
	typedef long            (FAR_DECL PASCAL* PASCALFAR_LONG_PROC) (VOID);
	typedef long FAR* (FAR_DECL PASCAL* PASCALFAR_PLONG_PROC) (VOID);
	typedef TCHAR FAR* (FAR_DECL PASCAL* PASCALFAR_PCHAR_PROC) (VOID);
	typedef float       (FAR_DECL PASCAL* PASCALFAR_FLOAT_PROC) (VOID);
	typedef float FAR* (FAR_DECL PASCAL* PASCALFAR_PFLOAT_PROC) (VOID);
#endif

	/* *********************************************************************** */
	/* Declaration of NULL                                                     */
	/* *********************************************************************** */

#undef NULL
#if (defined(M_I86SM) || defined(M_I86MM))
#define  NULL    0
#elif (defined(M_I86CM) || defined(M_I86LM) || defined(M_I86HM))
#define  NULL    0L
#else
#define  NULL    0
#endif


/* *********************************************************************** */
/* Standard on/off declarations                                            */
/* *********************************************************************** */

#ifndef FALSE
#define FALSE               0
#endif

#ifndef TRUE
#define TRUE                1
#endif


#ifndef OFF
#define OFF                 0
#endif

#ifndef ON
#define ON                  1
#endif


#ifndef NOTFOUND
#define NOTFOUND            0
#endif

#ifndef FOUND
#define FOUND               1
#endif


#ifndef FAILURE
#define FAILURE         0
#endif

#ifndef SUCCESS
#define SUCCESS         1
#endif


/* *********************************************************************** */
/* Popular Macros                                                          */
/* *********************************************************************** */

#ifndef OSWINDOW_H
#define LOWORD(l)           ((WORD)(DWORD)(l))
#define HIWORD(l)           ((WORD)((((DWORD)(l)) >> 16) & 0xFFFF))
#define MAKELONG(low, high) ((LONG)(((WORD)(low)) | (((DWORD)((WORD)(high))) << 16)))
#endif

//****************************************************************************
// Name of PB System Library and default application
//****************************************************************************

#if defined(PBOS_MAC)
#define OB_PBSYSTEM_LIBNAME         psAddBuildShortVersionString ( PBTEXT("PowerBuilder "), PBTEXT(" VM Library"))
#define OB_PBSYSTEM_FRAGMENTNAME    psAddVersionID ( PBTEXT("PBType"), PBTEXT("Lib"))
#define DWLIBRARY                   PBTEXT("PBDataWindowLib")
#define PB_GENAPP_LIBRARY           PBTEXT("PBGenLib")
#define PBD_CCODE_LIBRARY_EXTENSION PBTEXT("Lib")
#define OB_DEFAULT_STYLE_LIBRARY_NAME PBTEXT("IMStyleLib")
#else

#define OB_DEFAULT_STYLE_LIBRARY_NAME psAddVersionID( PBTEXT("imstyletradition"), PBTEXT(".pbl") )
#define OB_NEW_STYLE_LIBRARY_NAME psAddVersionID( PBTEXT("imstylecontemp"), PBTEXT(".pbl") )
// This should be version independent!

#if defined(PBWIN16)
#define OB_PBSYSTEM_LIBNAME     psDLLName(PBTEXT("typ"))
#else
#ifndef PBOS_UNIX
#define OB_PBSYSTEM_LIBNAME     psDLLName(PBTEXT("vm"))
#else
#if !defined(_AIX)
#define OB_PBSYSTEM_LIBNAME     PBTEXT("libpbvm125x.so")
#else
#define OB_PBSYSTEM_LIBNAME     PBTEXT("libpbvm125x.so.a")
#endif
#endif
#endif

#if defined(NISQL) && !defined(NISQL_DEBUG)

#ifdef PBWIN16
#define DWLIBRARY     psAddVersionID (PBTEXT("nisql"), PBTEXT("w.dll"))
#elif PS_UNICODE
#define DWLIBRARY     psAddVersionID (PBTEXT("nisql"), PBTEXT(".dll"))
#else
#define DWLIBRARY     psAddVersionID (PBTEXT("nisql"), PBTEXT(".dll"))
#endif

#else

#define DWLIBRARY     psDLLName(PBTEXT("dwo"))
#define PB_GENAPP_LIBRARY     psDLLName(PBTEXT("gen"))
#define PBD_CCODE_LIBRARY_EXTENSION    PBTEXT(".dll")
#endif
#endif

#define PB_DEFAULT_APPLICATION      PBTEXT("__pb_default_application")
#define PBD_PCODE_LIBRARY_EXTENSION psRTLibExt

//****************************************************************************
// Class name for dialog windows (prop sheets use this)
//****************************************************************************

#if defined(PBOS_MAC)
#define PB_DIALOG_CLASS_NAME PBTEXT("dialog")
#elif defined(PBOS_UNIX) // wlg PT317884 Fix dialog name for UNIX
#define PB_DIALOG_CLASS_NAME PBTEXT("WC_DIALOG")
#else
#define PB_DIALOG_CLASS_NAME PBTEXT("#32770")
#endif

#if defined(PS_UNICODE)
#define PBCF_TEXT CF_UNICODETEXT
#else
#define PBCF_TEXT CF_TEXT
#endif


#if defined(PS_JPN)
#define PB_IM_REGISTRY_SUBKEY PBTEXT("Software\\Sybase\\InfoMaker\\12.5j")
#define PB_DW_REGISTRY_SUBKEY PBTEXT("Software\\Sybase\\DataWindowBuilder\\12.5j")
#define PB_PB_REGISTRY_SUBKEY PBTEXT("Software\\Sybase\\PowerBuilder\\12.5j")
#define DWNET_REGISTRY_SUBKEY PBTEXT("Software\\Sybase\\DataWindow .NET\\3.0j")
#elif defined(PS_UNICODE)
#define PB_IM_REGISTRY_SUBKEY PBTEXT("Software\\Sybase\\InfoMaker\\12.5")
#define PB_DW_REGISTRY_SUBKEY PBTEXT("Software\\Sybase\\DataWindowDesigner\\3.0")
#define PB_DWVSPLUGIN_REGISTRY_SUBKEY PBTEXT("Software\\Sybase\\DataWindowDesignerPlugin\\3.0")
#define PB_PB_REGISTRY_SUBKEY PBTEXT("Software\\Sybase\\PowerBuilder\\12.5")
#define DWNET_REGISTRY_SUBKEY PBTEXT("Software\\Sybase\\DataWindow .NET\\3.0")
#else
#define PB_IM_REGISTRY_SUBKEY PBTEXT("Software\\Sybase\\InfoMaker\\12.5")
#define PB_DW_REGISTRY_SUBKEY PBTEXT("Software\\Sybase\\DataWindowDesigner\\3.0")
#define PB_DWVSPLUGIN_REGISTRY_SUBKEY PBTEXT("Software\\Sybase\\DataWindowDesignerPlugin\\3.0")
#define PB_PB_REGISTRY_SUBKEY PBTEXT("Software\\Sybase\\PowerBuilder\\12.5")
#define DWNET_REGISTRY_SUBKEY PBTEXT("Software\\Sybase\\DataWindow .NET\\3.0")
#endif

#define ECLIPSE_PB_REGISTRY_SUBKEY PBTEXT("Software\\Sybase\\Workspace\\2.0\\DBComponents")

#ifdef PS_WINFREE

//
//   Let PB call winfree's implementation of Critical Sections

#define InitializeCriticalSection(critref)  WFR_InitializeCriticalSection(critref)
#define DeleteCriticalSection(critref)  WFR_DeleteCriticalSection(critref)
#define EnterCriticalSection(critref) WFR_EnterCriticalSection(critref)
#define LeaveCriticalSection(critref) WFR_LeaveCriticalSection(critref)

#ifdef __cplusplus
	extern "C" {
#endif

		VOID APIENTRY WFR_InitializeCriticalSection(LPCRITICAL_SECTION lpcs);
		VOID APIENTRY WFR_EnterCriticalSection(LPCRITICAL_SECTION lpcs);
		VOID APIENTRY WFR_LeaveCriticalSection(LPCRITICAL_SECTION lpcs);
		VOID APIENTRY WFR_DeleteCriticalSection(LPCRITICAL_SECTION lpcs);
		void _splitpath(LPCTSTR path, LPTSTR drive, LPTSTR dir, LPTSTR fname, LPTSTR ext);
		int    wfr_wcsicmp(LPCTSTR ws1, LPCTSTR ws2);
		int    wfr_wcsnicmp(LPCTSTR ws1, LPCTSTR ws2, size_t n);
#ifdef __cplusplus
	}; // extern "C"
#endif

#endif  // PS_WINFREE

#ifdef PS_WINFREE_DEBUG

// ****************************************************************************
//  Macros for CriticalSection debugging
// ****************************************************************************
#ifndef _fake_w32_
#define InitializeCriticalSection(a) InitializeCriticalSectionA(a, __FILE__, __LINE__)
#define EnterCriticalSection(a) EnterCriticalSectionA(a, __FILE__, __LINE__)
#define LeaveCriticalSection(a) LeaveCriticalSectionA(a, __FILE__, __LINE__)
#define DeleteCriticalSection(a) DeleteCriticalSectionA(a, __FILE__, __LINE__)
#endif

#ifdef __cplusplus
	extern "C" {
#endif

		VOID APIENTRY InitializeCriticalSectionA(LPCRITICAL_SECTION lpcs, char* file,
			int lineno);
		VOID APIENTRY EnterCriticalSectionA(LPCRITICAL_SECTION lpcs, char* file,
			int lineno);
		VOID APIENTRY LeaveCriticalSectionA(LPCRITICAL_SECTION lpcs, char* file,
			int lineno);
		VOID APIENTRY DeleteCriticalSectionA(LPCRITICAL_SECTION lpcs, char* file,
			int lineno);
#ifdef __cplusplus
	}; // extern "C"
#endif

#endif


//*****************************************************************************
// Includes for internalization
//*****************************************************************************
#ifdef PS_JPN   //For KANJI support
// ***** DOINC including pbxltjp.h *****
/*                                                                         */
/* *********************************************************************** */
/*                                                                         */
/*                 Copyright Powersoft Corporation 1991-1994               */
/*                                                                         */
/*       Powersoft Corporation ("Powersoft") claims copyright in this      */
/*     program and documentation as an unpublished work, versions of       */
/*     which were first licensed on the date indicated in the foregoing    */
/*     notice. Claim of copyright does not imply waiver of Powersoft's     */
/*     other rights. See Notice of Proprietary Rights.                     */
/*                                                                         */
/*                 NOTICE OF PROPRIETARY RIGHTS                            */
/*                                                                         */
/*       This program and documentation are confidential trade             */
/*     secrets and the property of Powersoft.  Use, examination,           */
/*     reproduction, copying, disassembly, decompilation, transfer         */
/*     and/or disclosure to others are strictly prohibited except by       */
/*     express written agreement with Powersoft.                           */
/*                                                                         */
/* ----------------------------------------------------------------------- */
/*                                                                         */
/*    Filename :    pbxltjp.h                                              */
/*                                                                         */
/*    Author   :    Tsuyoshi Fukuyama                                      */
/*                                                                         */
/*    Purpose  :    Japanese(KANJI) macros translation for PowerBuilder.   */
/*                                                                         */
/* *********************************************************************** */

#ifndef PBXLTJP_H
#define PBXLTJP_H

/* TEXT */
/*
 *	PBXLT_XXX is same as PBXLT_E_XXX in pbxlten.h(E mean english)
 *
 *	But PBXLT_ XXX is NOT same as PBXLT_E_XXX in localization header file.
 *	#define PBXLT_ASC	"xxxxxx"	translated
 *	#define PBXLT_E_ASC	"asc"		english
 *
 *	Localization needs original(english) text and Localized test.
 *
 *	if you want to compare strings and localized text, use the following
 *		strcmp(str,PBXLT_ASC)
 *
 *	if you want to compre localized text and english, use the following
 * 		if(!strcmpr(str,PBXLT_ASC) || !strcmpr(str,PBXLT_E_ASC))
 *
 */
#define PBXLT_APPLICATION		PBTEXT("AvP[V")
#define PBXLT_E_APPLICATION		PBTEXT("Application")
#define PBXLT_ASC			PBTEXT("")
#define PBXLT_E_ASC			PBTEXT("asc")
#define PBXLT_ASCENDING			PBTEXT("")
#define PBXLT_E_ASCENDING		PBTEXT("Ascending")
#define PBXLT_ASCENDING_L		PBTEXT("")
#define PBXLT_E_ASCENDING_L		PBTEXT("ascending")	// lowercase
#define PBXLT_ASCENDING_W_A		PBTEXT("(&A)")
#define PBXLT_E_ASCENDING_W_A		PBTEXT("&Ascending")
#define PBXLT_BOX			PBTEXT("")
#define PBXLT_E_BOX			PBTEXT("Box")
#define PBXLT_CHECKED_OUT		PBTEXT("`FbNAEg ID:")
#define PBXLT_CLUSTERED			PBTEXT("NX^")
#define PBXLT_COLUMN_FONT		PBTEXT("J tHg")
#define PBXLT_COMMENTS			PBTEXT(":")
#define PBXLT_CONTINUE			PBTEXT("\n ?")
#define PBXLT_CROSSTAB			PBTEXT("NX ^u")
#define PBXLT_E_CROSSTAB		PBTEXT("crosstab")
#define PBXLT_DATABASE_ERROR		PBTEXT("%s%s \n\n f[^x[X G[: \n\n%s")
#define PBXLT_DEBUG			PBTEXT("fobO - %s")
#define PBXLT_DEBUG_FOR			PBTEXT("fobO - %s  %s")
#define PBXLT_DEBUG_FOR_OF		PBTEXT("fobO - %s  %s  %s")
#define PBXLT_DELETE_QUESTION		PBTEXT("?")
#define PBXLT_DESC			PBTEXT("~")
#define PBXLT_E_DESC			PBTEXT("desc")
#define PBXLT_DESCENDING		PBTEXT("~")
#define PBXLT_E_DESCENDING		PBTEXT("Descending")
#define PBXLT_DESCENDING_L		PBTEXT("~")	
#define PBXLT_E_DESCENDING_L		PBTEXT("descending")	// lower case
#define PBXLT_DESCENDING_W_A		PBTEXT("~(&D)")
#define PBXLT_E_DESCENDING_W_A		PBTEXT("&Descending")
#define PBXLT_EMPTY			PBTEXT("")
#define PBXLT_FILE_SAVE			PBTEXT("t@C")
#define PBXLT_FILL_SPACES		PBTEXT("Xy[X")
#define PBXLT_E_FILL_SPACES		PBTEXT("spaces")
#define PBXLT_FORM			PBTEXT("tH[")
#define PBXLT_E_FORM			PBTEXT("Form")	
#define PBXLT_FOR_SS			PBTEXT("%s  %s")
#define PBXLT_FREE_FORM			PBTEXT("t[ tH[")
#define PBXLT_E_FREE_FORM		PBTEXT("form")
#define PBXLT_FUNCTION			PBTEXT("")
#define PBXLT_E_FUNCTION		PBTEXT("Function")
#define PBXLT_GLOBAL_VAR		PBTEXT("O[o")
#define PBXLT_GRID			PBTEXT("Obh")
#define PBXLT_E_GRID			PBTEXT("grid")
#define PBXLT_GROUP			PBTEXT("O[v")
#define PBXLT_E_GROUP			PBTEXT("group")
#define PBXLT_GROUP_D			PBTEXT("O[v %d")
#define PBXLT_GROUP_SELECT		PBTEXT("O[vw\0")
#define PBXLT_HEADER_FONT		PBTEXT("wb_ tHg")
#define PBXLT_INHERITED_FROM		PBTEXT("%s p ")
#define PBXLT_LABEL_FONT		PBTEXT("x tHg")
#define PBXLT_LABEL			PBTEXT("x")
#define PBXLT_E_LABEL			PBTEXT("label")
#define PBXLT_LAST_MODIFIED		PBTEXT("IC:")
#define PBXLT_LIBRARY_NAME		PBTEXT("Cu:")
#define PBXLT_LOCAL_VAR			PBTEXT("[J")
#define PBXLT_LOWERED			PBTEXT("3D \x95\x5c")
#define PBXLT_E_LOWERED			PBTEXT("3D Lowered")
#define PBXLT_MENU			PBTEXT("j[")
#define PBXLT_MENU2			PBTEXT("j[ - ")
#define PBXLT_E_MENU			PBTEXT("Menu")
#define PBXLT_MENU_INHERITED		PBTEXT("j[ - %s p ()")
#define PBXLT_MENU_UNTITLED		PBTEXT("j[ - (^Cg)")
#define PBXLT_NOMESSAGE			PBTEXT("bZ[W %d e[uB")
#define PBXLT_NONCLUSTERED		PBTEXT("NX^")
#define PBXLT_NONE			PBTEXT("g")
#define PBXLT_E_NONE			PBTEXT("None")
#define PBXLT_NUP			PBTEXT("ig")
#define PBXLT_E_NUP			PBTEXT("nup")
#define PBXLT_OBJECT_NAME		PBTEXT("IuWFNg:")
#define PBXLT_OF			PBTEXT("")
#define PBXLT_ORACLE1			PBTEXT("e[us")
#define PBXLT_ORACLE2			PBTEXT("s (RESTRICT)\0")
#define PBXLT_ORACLE3			PBTEXT("s (CASCADE)\0")
#define PBXLT_RAISED			PBTEXT("3D \x95\x5c")
#define PBXLT_E_RAISED			PBTEXT("3D Raised")
#define PBXLT_SCRIPT			PBTEXT("XNvg(&S)\tCtrl+K")
#define PBXLT_SELECT			PBTEXT("Select ...")
#define PBXLT_SETEMPTY			PBTEXT("")
#define PBXLT_E_SETEMPTY		PBTEXT("empty")
#define PBXLT_SETNULL			PBTEXT("Null ")
#define PBXLT_E_SETNULL			PBTEXT("null")
#define PBXLT_SETTODAY			PBTEXT("Today() ")
#define PBXLT_E_SETTODAY		PBTEXT("today")
#define PBXLT_SETZERO			PBTEXT("(0) ")
#define PBXLT_E_SETZERO			PBTEXT("0")
#define PBXLT_SHADOWBOX			PBTEXT("et")
#define PBXLT_E_SHADOWBOX		PBTEXT("Shadow Box")
#define PBXLT_SHARED_VAR		PBTEXT("L")
#define PBXLT_SIZE_IN			PBTEXT("TCY(oCg):")
#define PBXLT_S_FOR_S			PBTEXT("%s  %s XNvg")
#define PBXLT_TABULAR			PBTEXT("^u")
#define PBXLT_E_TABULAR			PBTEXT("tabular")
#define PBXLT_TEXT_FONT			PBTEXT("eLXg tHg")
#define PBXLT_UNDERLINE			PBTEXT("")
#define PBXLT_E_UNDERLINE		PBTEXT("Underline")
#define PBXLT_UNTITLED			PBTEXT("^Cg")
#define PBXLT_UNTITLED_W_B		PBTEXT("(^Cg)")
#define PBXLT_USER_OBJECT		PBTEXT("[U IuWFNg")
#define PBXLT_E_USER_OBJECT		PBTEXT("User Object")
#define PBXLT_VARIABLES			PBTEXT(" :")
#define PBXLT_WATCH_VAR			PBTEXT(" @:")
#define PBXLT_WINDOW			PBTEXT("EBhE")
#define PBXLT_E_WINDOW			PBTEXT("Window")

#define PBXLT_COLORBLACK		PBTEXT("")
#define PBXLT_E_COLORBLACK		PBTEXT("BLACK")
#define PBXLT_COLORBLUE			PBTEXT("")
#define PBXLT_E_COLORBLUE		PBTEXT("BLUE")
#define PBXLT_COLORCYAN			PBTEXT("VA")
#define PBXLT_E_COLORCYAN		PBTEXT("CYAN")
#define PBXLT_COLORGREEN		PBTEXT("")
#define PBXLT_E_COLORGREEN		PBTEXT("GREEN")
#define PBXLT_COLORMAGENTA		PBTEXT("}[^")
#define PBXLT_E_COLORMAGENTA		PBTEXT("MAGENTA")
#define PBXLT_COLORRED			PBTEXT("")
#define PBXLT_E_COLORRED		PBTEXT("RED")
#define PBXLT_COLORWHITE		PBTEXT("")
#define PBXLT_E_COLORWHITE		PBTEXT("WHITE")
#define PBXLT_COLORYELLOW		PBTEXT("")
#define PBXLT_E_COLORYELLOW		PBTEXT("YELLOW")

#define PBXLT_DTTMCURRENTTIME		PBTEXT("")
#define PBXLT_DTTMWINDOWSGENERAL	PBTEXT("")
#define PBXLT_DTTMWINDOWSLONG		PBTEXT("`")
#define PBXLT_DTTMWINDOWSSHORT		PBTEXT("Z`")
#define PBXLT_DTTMWINDOWSTIME		PBTEXT("")
#define PBXLT_E_DTTMCURRENTTIME		PBTEXT("CURRENT")
#define PBXLT_E_DTTMWINDOWSGENERAL	PBTEXT("GENERAL")
#define PBXLT_E_DTTMWINDOWSLONG		PBTEXT("LONGDATE")
#define PBXLT_E_DTTMWINDOWSSHORT	PBTEXT("SHORTDATE")
#define PBXLT_E_DTTMWINDOWSTIME		PBTEXT("TIME")

#define PBXLT_CLRBG			255,255,210	// use in shared\pbshr\ccttip.cpp			

 /* Only in JPN version */
#define PBXLT_JPN_CREATE		PBTEXT("")
#define PBXLT_SELECT_GROUP		PBTEXT("O[vw\0")	
#define PBXLT_JPN_MEIJI			PBTEXT("")
#define PBXLT_JPN_TAISYOU		PBTEXT("")
#define PBXLT_JPN_SYOUWA		PBTEXT("a") 
#define PBXLT_JPN_HEISEI		PBTEXT("")
#define PBXLT_JPN_UNKOWN_GENGO	PBTEXT("HH")

#define PBXLT_JPN_NAMESUN		PBTEXT("j")
#define PBXLT_JPN_NAMEMON		PBTEXT("j")
#define PBXLT_JPN_NAMETUE		PBTEXT("j")
#define PBXLT_JPN_NAMEWED		PBTEXT("j")
#define PBXLT_JPN_NAMETHU		PBTEXT("j")
#define PBXLT_JPN_NAMEFRI		PBTEXT("j")
#define PBXLT_JPN_NAMESAT		PBTEXT("yj")
#define PBXLT_JPN_ABBREVSUN		PBTEXT("")
#define PBXLT_JPN_ABBREVMON		PBTEXT("")
#define PBXLT_JPN_ABBREVTUE		PBTEXT("")
#define PBXLT_JPN_ABBREVWED		PBTEXT("")
#define PBXLT_JPN_ABBREVTHU		PBTEXT("")
#define PBXLT_JPN_ABBREVFRI		PBTEXT("")
#define PBXLT_JPN_ABBREVSAT		PBTEXT("y")

#define PBXLT_JPN_GG_GENGO		PBTEXT("gg - ")
#define PBXLT_JPN_NN_NENGO		PBTEXT("nn - N")
#define PBXLT_JPN_DATE			PBTEXT("ggnnNmmdd")
#define PBXLT_JPN_TIME			PBTEXT("hhmmssb")
#define PBXLT_JPN_DATETIME		PBTEXT("ggnnNmmdd hhmmssb")

#define PBXLT_IME_NONE			PBTEXT("")
#define PBXLT_IME_ON			PBTEXT("I")
#define PBXLT_IME_OFF			PBTEXT("It")
#define PBXLT_IME_FIXED_OFF		PBTEXT("It")
#define PBXLT_JPN_IME_HIRAGANA		PBTEXT("Sp")
#define PBXLT_JPN_IME_KATAKANA		PBTEXT("SpJ^Ji")
#define PBXLT_JPN_IME_HANKAKU_KATAKANA	PBTEXT("pJ^Ji")
#define PBXLT_JPN_IME_EISUU		PBTEXT("Spp")
#define PBXLT_JPN_IME_HANKAKU_EISUU	PBTEXT("pp")

//Font Localization:
#ifndef SHIFTJIS_CHARSET
#define SHIFTJIS_CHARSET						128
#endif
#define PBXLT_CHARSET							((BYTE )SHIFTJIS_CHARSET)
#define PBXLT_DEFAULT_FONT_HEIGHT				9
#define	PBXLT_DW_DLGINIT_FONT					PBTEXT("lr SVbN")
#define PBXLT_DW_GEN_FONT						PBTEXT("lr SVbN")
#define PBXLT_DW_GEN_GRAPH_FONT					PBTEXT("lr SVbN")
#define PBXLT_DW_GEN_STYLE_FONT					PBTEXT("lr SVbN")
#define	PBXLT_DW_GEN_STYLE_FONT_HEIGHT			12
#define PBXLT_DW_GEN_STYLE_FONT_PITCHFAMILY		FF_ROMAN | FIXED_PITCH
#define PBXLT_DW_SRTDLG_FONT					PBTEXT("lr SVbN")
#define	PBXLT_DW_PPPAINT_FONT					PBTEXT("lr SVbN")
#define PBXLT_DW_SETFONT_FONT					PBTEXT("lr SVbN")
#define PBXLT_DW_CHECKBOX_RECT_FONT				PBTEXT("Wingdings")
#define PBXLT_PDT_FONT_HEIGHT					-9
#define PBXLT_PDT_FONT 							PBTEXT("lr SVbN")
#define PBXLT_PDT_CREATE_TABLE_FONT				PBTEXT("lr SVbN")
#define PBXLT_PDT_CREATE_TABLE_FONT_HEIGHT		11
#define PBXLT_PDT_INSTALLED_INTERFACES			PBTEXT("gp\x94\x5c Powersoft f[^x[X C^[tF[X")
// <begin> T.Asano 1999.07.20 ******************************
#define PBXLT_PDT_TITLE							PBTEXT("Database Painter")
#define PBXLT_PDT_EDIT_STYLES					PBTEXT("Wl")
#define PBXLT_PDT_DISPLAY_FORMAT				PBTEXT("\")
#define PBXLT_PDT_VALIDATION_RULES				PBTEXT("")
#define PBXLT_DBCONNECTIONS						PBTEXT("Connections")
#define PBXLT_PDT_UTILITIES						PBTEXT("Utilities")
#define PBXLT_PDT_ODBCADMIN						PBTEXT("ODBC Administrator")
#define PBXLT_PDT_OPENCLIENT10					PBTEXT("Open Client 10")
#define PBXLT_PDT_SQLEDIT						PBTEXT("SQLEdit")
#define PBXLT_PDT_SYBPING						PBTEXT("Sybase Ping")
#define PBXLT_PDT_OPENCLIENT11					PBTEXT("Open Client 11")
#define PBXLT_PDT_OPENCLIENT					PBTEXT("Open Client")
#define PBXLT_PDT_DSEDIT						PBTEXT("Directory Services Editor")
#define PBXLT_PDT_SQLADVANTAGE					PBTEXT("SQL Advantage")
#define PBXLT_PDT_OCFCFG						PBTEXT("Server Config")
#define PBXLT_PDT_SETNET						PBTEXT("Informix SetNet32")
#define PBXLT_PDT_NET8							PBTEXT("Net8 Easy Config")
#define PBXLT_PDT_SQLNET						PBTEXT("SQL*Net Easy Config")
#define PBXLT_PDT_SQLCENTRAL					PBTEXT("Sybase Central")
#define PBXLT_PDT_MSSISQL						PBTEXT("Query Anaylzer")
#define PBXLT_PDT_MSQUERY						PBTEXT("MS Query")
#define PBXLT_PDT_MSSWINDBVER					PBTEXT("Client Configuration Utility")
#define PBXLT_PDT_MSSENTERPRISE					PBTEXT("Enterprise Manager")
#define PBXLT_PDT_MSSDTSWIZARD					PBTEXT("Import and Export Data")
#define PBXLT_PDT_MSSSERVICEMANAGER				PBTEXT("Service Manager")
#define PBXLT_PDT_MSSINDEXWIZARD				PBTEXT("Index Tuning Wizard")
#define PBXLT_PDT_CREATEASADB					PBTEXT("Create ASA Database")
#define PBXLT_PDT_DELETEASADB					PBTEXT("Delete ASA Database")
#define PBXLT_PDT_DATALINKS						PBTEXT("Manage Data Links")
#define PBXLT_PDT_OLEDB_PBADMIN					PBTEXT("PowerBuilder DataDirect OLE DB Administrator")

#define PBXLT_NO_CONNECTION						PBTEXT("No Connection")
#define PBXLT_CONNECTIONS						PBTEXT("Connections")
#define PBXLT_CONNECTION						PBTEXT("Connection")
// <end  > T.Asano 1999.07.20 ******************************
#define PBXLT_SCR_DLGINIT_FONT		   PBTEXT("lr SVbN")
#define PBXLT_SCR_DLGINIT_FONT_HEIGHT	   11
#define PBXLT_SCR_INITCOMBOS_FONT	   PBTEXT("lr SVbN")
#define PBXLT_SCR_INITCOMBOS_FONT_HEIGHT  12
#if !defined(PBOS_MAC)
#define PBXLT_PDW_PSXFMTDLGPROC_FONT		 PBTEXT("lr SVbN")
#define PBXLT_PDW_PSXFMTDLGPROC_FONT_HEIGHT   9
#else
#define PBXLT_PDW_PSXFMTDLGPROC_FONT		 PBTEXT("lr SVbN")
#define PBXLT_PDW_PSXFMTDLGPROC_FONT_HEIGHT   9
#endif
#define PBXLT_PDW_PSXFMTDLGPROC_PITCHFAMILY	  FIXED_PITCH | FF_ROMAN
#define	PBXLT_PDW_DLGINIT_FONT		PBTEXT("lr SVbN")
#define PBXLT_PDW_DLGINIT_FONT_HEIGHT	   -9
#if !defined(PBOS_MAC)
#define PBXLT_PDW_MSGPAINTRULER_FONT	PBTEXT("lr SVbN")
#else
#define PBXLT_PDW_MSGPAINTRULER_FONT	PBTEXT("lr SVbN")
#endif
#define PBXLT_PDW_EVENTLEFTBUTTON_FONT	  PBTEXT("lr SVbN")
#define PBXLT_PDW_PDWGRAPH_FONT_WEIGHT	  400
#define PBXLT_PDW_LOADDRAWBLOB_FONT		 PBTEXT("lr SVbN")
#define PBXLT_PDW_LOADDRAWREPORT_FONT		 PBTEXT("lr SVbN")
#if !defined(PBOS_MAC)
#define PBXLT_PDW_INITDATAWIN_FONT	   PBTEXT("lr SVbN")
#define PBXLT_PDW_INITDATAWIN_FONT_HEIGHT	   13
#define PBXLT_PDW_INITDATAWIN_FONT_WEIGHT	   400
#else
#define PBXLT_PDW_INITDATAWIN_FONT	   PBTEXT("lr SVbN")
#define PBXLT_PDW_INITDATAWIN_FONT_HEIGHT	   16
#define PBXLT_PDW_INITDATAWIN_FONT_WEIGHT	   400
#endif
#define PBXLT_PDW_SELECTREPORTSDLGPROC_FONT		PBTEXT("lr SVbN")
#define PBXLT_PDW_UNDODELETE_FONT	   PBTEXT("lr SVbN")

// Add tsuyoshi
//#define PBXLT_PDW_DRAW_FONT_WEIGHT					400
#if defined(PBOS_MAC)
#define PBXLT_PDW_DRAW_FACE_FONT	PBTEXT("lr SVbN")
#else
#define PBXLT_PDW_DRAW_FACE_FONT	PBTEXT("lr SVbN")
#endif
#define PBXLT_PDW_DRAW_PRINT_FONT			PBTEXT("lr SVbN")

//#define PBXLT_PDW_DRAW_PROC_FONT			PBTEXT("lr SVbN")
#if !defined(PBOS_MAC)
#define PBXLT_PDW_DRAW_FONT_HEIGHT		-9
#define PBXLT_PDW_DRAW_FONT_WEIGHT		400
#define PBXLT_PDW_DRAW_PROC_FONT		PBTEXT("lr SVbN")
#else
#define PBXLT_PDW_DRAW_FONT_HEIGHT		-9
#define PBXLT_PDW_DRAW_FONT_WEIGHT		400
#define PBXLT_PDW_DRAW_PROC_FONT		PBTEXT("lr SVbN")
#endif
#define PBXLT_PDW_NONETEXT				PBTEXT("")

#define PBXLT_SCRIPT_FONT_SIZE	11
#define PBXLT_SCRIPT_FONT_HEIGHT		11
#define PBXLT_SCRIPT_FONT_FACENAME		PBTEXT("lr SVbN")
#define PBXLT_VIEW_FONT_SIZE			12
#define PBXLT_VIEW_FONT_FACENAME		PBTEXT("lr SVbN")		
#define PBXLT_WINDOW_FONT				PBTEXT("lr SVbN")

// begin RichText defines

#define PBXLT_RTC_HEICON_PITCH			DEFAULT_PITCH
#define PBXLT_RTC_HEICON_FF				FF_MODERN
#define PBXLT_RTC_HETBTN_PITCH			FIXED_PITCH
#define PBXLT_RTC_HETBTN_FF				FF_MODERN
#define PBXLT_RTC_HETBTN_FONT			PBTEXT("lr SVbN")
#define PBXLT_RTC_HETSTAT_FONT_PITCH	FIXED_PITCH	
#define PBXLT_RTC_HETSTAT_FONT_FF		FF_MODERN
#define PBXLT_RTC_HETSTAT_FONT			PBTEXT("lr SVbN")

#if defined(PBOS_MAC)
#define PBXLT_RTC_DEFAULT_FONTNAME		((LPTSTR) PBTEXT("lr SVbN"))
#define PBXLT_RTC_HEICON_FONT			PBTEXT("lr SVbN")
#else
#define PBXLT_RTC_DEFAULT_FONTNAME		((LPTSTR) PBTEXT("lr SVbN"))
#define PBXLT_RTC_HEICON_FONT			PBTEXT("lr SVbN")
#endif

#define PBXLT_RTC_DEFAULT_PITCHFAMILY	(FF_MODERN | FIXED_PITCH)
// end RichText defines


#define PBXLT_RT_FUNCTION_FONT			PBTEXT("lr SVbN")
#define PBXLT_RTFUNC_FACE_HEIGHT		9
#define PBXLT_RTFUNC_FACE_FONT			PBTEXT("lr SVbN")
#define PBXLT_RTFUNC_TOOL1_FONT_HEIGHT	8
#define PBXLT_RTFUNC_TOOL1_FONT			PBTEXT("lr SVbN")
#define PBXLT_RTFUNC_T2_FACE_FONT		PBTEXT("lr SVbN")

#define PBXLT_RTFUNC_T2_FONT_HEIGHT		13
#define PBXLT_RTFUNC_T2_FONT_WEIGHT		FW_NORMAL
#define PBXLT_RTFUNC_T2_LOG_FONT		PBTEXT("lr SVbN")
#define PBXLT_SETUP_FACE_FONT			PBTEXT("lr SVbN")
#define PBXLT_PBSHR_STOCK_FONT		SYSTEM_FONT	
#define PBXLT_PBSHR_TEXT_FONT		PBTEXT("lr SVbN")
#define PBXLT_PBSHR_TEXT_SIZE		9
#define PBXLT_PBSHR_SHFONT			PBTEXT("lr SVbN")
#define PBXLT_SPLASH_TEXT_SIZE		14
#define PBXLT_SYS_PBSYS_FONT_HEIGHT		11
#define PBXLT_SYS_PBSYS_FONT_WEIGHT		400
#define PBXLT_SYS_PBSYS_FONT			PBTEXT("lr SVbN")
#define PBXLT_SYS_T2_FONT				PBTEXT("lr SVbN")
#define PBXLT_SYS_T4_FONT				PBTEXT("lr SVbN")
#define PBXLT_SYS_PBUTIL_LOG_FONT		PBTEXT("lr SVbN")
#define PBXLT_SYS_PBUTIL_FONT_WEIGHT	FW_NORMAL
#define PBXLT_SYS_PBUTIL_SYS_FONT		SYSTEM_FONT
#define PBXLT_SYS_PBUTIL_SYS_FACENAME	PBTEXT("lr SVbN")
#define PBXLT_VBX_FONT					PBTEXT("lr SVbN")
#define PBXLT_PBSHR_DPERR_DWSTR1		PBTEXT("datawindow(color= %ld units=2 processing=1 row.resize=0) ")	
#define PBXLT_PBSHR_DPERR_DWSTR2		PBTEXT("text(band=header alignment=2 border=6 font.height=-9 font.weight=400 ")	
#define PBXLT_PBSHR_DPERR_DWSTR3		PBTEXT("font.charset=SHIFTJIS_CHARSET font.pitch=2 font.family=2 ")	
#define PBXLT_PBSHR_DPERR_DWSTR4		PBTEXT("font.face=\"lr SVbN\" color=%ld) ")	
#define PBXLT_PBSHR_DPERR_DWSTR5		PBTEXT("column(band=detail alignment=0 border=0 ")	
#define PBXLT_PBSHR_DPERR_DWSTR6		PBTEXT("font.height=-9 font.weight=400 ")	
#define PBXLT_PBSHR_DPERR_DWSTR7		PBTEXT("font.charset=SHIFTJIS_CHARSET font.pitch=2 font.family=2 ")	
#define PBXLT_PBSHR_DPERR_DWSTR8		PBTEXT("font.face=\"lr SVbN\" color=%ld Background.Mode=2 Background.Color=%ld )  style(type=grid)"),   
#define PBXLT_PBTAB_TEXTPOINTSIZE   	9
#define PBXLT_PBTAB_TEXT_FONT		PBTEXT("lr SVbN")


/* OTHERS */
#define PBXLT_DWP_SZSTYLE_SIZE	20
#define PBXLT_PM_WIDTH1		5	// use PAINTERS\MENU
#define PBXLT_PM_WIDTH2 	2	// use PAINTERS\MENU
#define PBXLT_PM_WIDTH3		1	// use PAINTERS\MENU
#define PBXLT_PM_WIDTH4		8	// use PAINTERS\MENU
#define PBXLT_PM_WIDTH_REGULATE	(pMainStg->charwd * 3)	// US=0, JPN=pMainStg->charwd * 3

#define PBXLT_CMP_ARRAY				PBTEXT("z")
#define PBXLT_CMP_AUTOINST_STRUCT	PBTEXT("CX^XIuWFNg\x8d\x5c")

#define PBXLT_COM_GUIDSOURCE		PBTEXT("GUID \[X t@C")
#define PBXLT_COM_OBJECTSOURCE		PBTEXT("PB COM IuWFNg \[X t@C")
#define PBXLT_COM_SERVERSOURCE		PBTEXT("PB COM T[o \[X t@C")

#endif // PBXLTJP_H
// DOINC popped back into header 'oswindow.h'
// ADC_DBCS_START_MODIFY cchong Apr 22 1999
#elif defined PS_DBCS   //For CK support
// ***** DOINC including pbxlten.h *****
/*                                                                         */
/* *********************************************************************** */
/*                                                                         */
/*                 Copyright Powersoft Corporation 1991-1994               */
/*                                                                         */
/*       Powersoft Corporation ("Powersoft") claims copyright in this      */
/*     program and documentation as an unpublished work, versions of       */
/*     which were first licensed on the date indicated in the foregoing    */
/*     notice. Claim of copyright does not imply waiver of Powersoft's     */
/*     other rights. See Notice of Proprietary Rights.                     */
/*                                          */
/*                 NOTICE OF PROPRIETARY RIGHTS                            */
/*                                                                         */
/*       This program and documentation are confidential trade             */
/*     secrets and the property of Powersoft.  Use, examination,           */
/*     reproduction, copying, disassembly, decompilation, transfer         */
/*     and/or disclosure to others are strictly prohibited except by       */
/*     express written agreement with Powersoft.                           */
/*                                                                         */
/* ----------------------------------------------------------------------- */
/*                                                                         */
/*    Filename :    pbxlten.h                                              */
/*                                                                         */
/*    Author   :    Tsuyoshi Fukuyama                                      */
/*                                                                         */
/*    Purpose  :    English macros translation for PowerBuilder.           */
/*                                                                         */
/* *********************************************************************** */

#ifndef PBXLTEN_H
#define PBXLTEN_H

/* TEXT */
/*
 *	PBXLT_XXX is same as PBXLT_E_XXX in pbxlten.h(E mean english)
 *
 *	But PBXLT_ XXX is NOT same as PBXLT_E_XXX in localization header file.
 *	#define PBXLT_ASC	"xxxxxx"	translated
 *	#define PBXLT_E_ASC	"asc"		english
 *
 *	Localization needs original(english) text and Localized test.
 *
 *	if you want to compare strings and localized text, use the following
 *		strcmp(str,PBXLT_ASC)
 *
 *	if you want to compre localized text and english, use the following
 * 		if(!strcmpr(str,PBXLT_ASC) || !strcmpr(str,PBXLT_E_ASC))
 *
 */
#define PBXLT_APPLICATION		PBTEXT("Application")
#define PBXLT_E_APPLICATION		PBTEXT("Application")
#define PBXLT_ASC			PBTEXT("asc")
#define PBXLT_E_ASC			PBTEXT("asc")
#define PBXLT_ASCENDING			PBTEXT("Ascending")
#define PBXLT_E_ASCENDING		PBTEXT("Ascending")
#define PBXLT_ASCENDING_L		PBTEXT("ascending")	// lower case
#define PBXLT_E_ASCENDING_L		PBTEXT("ascending")	// lower case
#define PBXLT_ASCENDING_W_A		PBTEXT("&Ascending")
#define PBXLT_E_ASCENDING_W_A		PBTEXT("&Ascending")
#define PBXLT_BOX			PBTEXT("Box")
#define PBXLT_E_BOX			PBTEXT("Box")
#define PBXLT_CHECKED_OUT		PBTEXT("Checked out by:")
#define PBXLT_CLUSTERED			PBTEXT("Clustered")
#define PBXLT_COLUMN_FONT		PBTEXT("Column Font")
#define PBXLT_COMMENTS			PBTEXT("Comments:")
#define PBXLT_CONTINUE			PBTEXT("\nDo you want to continue?")
#define PBXLT_CROSSTAB			PBTEXT("crosstab")
#define PBXLT_E_CROSSTAB		PBTEXT("crosstab")
#define PBXLT_DATABASE_ERROR		PBTEXT("%s%s \n\n Database error text follows: \n\n%s")
#define PBXLT_DEBUG			PBTEXT("Debug - %s")
#define PBXLT_DEBUG_FOR			PBTEXT("Debug - %s for %s")
#define PBXLT_DEBUG_FOR_OF		PBTEXT("Debug - %s for %s of %s")
#define PBXLT_DELETE_QUESTION		PBTEXT("?")
#define PBXLT_DESC			PBTEXT("desc")
#define PBXLT_E_DESC			PBTEXT("desc")
#define PBXLT_DESCENDING		PBTEXT("Descending")
#define PBXLT_E_DESCENDING		PBTEXT("Descending")
#define PBXLT_DESCENDING_L		PBTEXT("descending")	// lower case
#define PBXLT_E_DESCENDING_L		PBTEXT("descending")	// lower case
#define PBXLT_DESCENDING_W_A		PBTEXT("&Descending")
#define PBXLT_E_DESCENDING_W_A		PBTEXT("&Descending")
#define PBXLT_EMPTY			PBTEXT("empty")
#define PBXLT_FILE_SAVE			PBTEXT("File Save")
#define PBXLT_FILL_SPACES		PBTEXT("spaces")
#define PBXLT_E_FILL_SPACES		PBTEXT("Fill With Spaces")//slahiri for cr221373
#define PBXLT_FORM			PBTEXT("Form")	
#define PBXLT_E_FORM			PBTEXT("Form")	
#define PBXLT_FOR_SS			PBTEXT("For %s %s")
#define PBXLT_FREE_FORM			PBTEXT("form")
#define PBXLT_E_FREE_FORM		PBTEXT("form")
#define PBXLT_FUNCTION			PBTEXT("Function")
#define PBXLT_E_FUNCTION		PBTEXT("Function")
#define PBXLT_GLOBAL_VAR		PBTEXT("Global")
#define PBXLT_GRID			PBTEXT("grid")
#define PBXLT_E_GRID			PBTEXT("grid")
#define PBXLT_GROUP			PBTEXT("group")
#define PBXLT_E_GROUP			PBTEXT("group")
#define PBXLT_GROUP_D			PBTEXT("Group %d")
#define PBXLT_GROUP_SELECT		PBTEXT("group")
#define PBXLT_HEADER_FONT		PBTEXT("Header Font")
#define PBXLT_INHERITED_FROM		PBTEXT("%s")
#define PBXLT_LABEL_FONT		PBTEXT("Label Font")
#define PBXLT_LABEL			PBTEXT("label")
#define PBXLT_E_LABEL			PBTEXT("label")
#define PBXLT_LAST_MODIFIED		PBTEXT("Last modified:")
#define PBXLT_LIBRARY_NAME		PBTEXT("Library name:")
#define PBXLT_LOCAL_VAR			PBTEXT("Local")
#define PBXLT_LOWERED			PBTEXT("3D Lowered")
#define PBXLT_E_LOWERED			PBTEXT("3D Lowered")
#define PBXLT_MENU			PBTEXT("Menu")
#define PBXLT_E_MENU			PBTEXT("Menu")
#define PBXLT_MENU_INHERITED		PBTEXT(" inherited from %s")
#define PBXLT_MENU_UNTITLED		PBTEXT("Menu - (Untitled)")
#define PBXLT_NOMESSAGE			PBTEXT("Message %d not in string table!")
#define PBXLT_NONCLUSTERED		PBTEXT("Nonclustered")
#define PBXLT_NONE			PBTEXT("None")
#define PBXLT_E_NONE			PBTEXT("None")
#define PBXLT_NUP			PBTEXT("nup")
#define PBXLT_E_NUP			PBTEXT("nup")
#define PBXLT_OBJECT_NAME		PBTEXT("Object name:")
#define PBXLT_ORACLE1			PBTEXT("On Delete of Primary Table Row")
#define PBXLT_ORACLE2			PBTEXT("Disallow if Dependent Rows Exist (RESTRICT)\0")	
#define PBXLT_ORACLE3			PBTEXT("Delete any Dependent Rows (CASCADE)\0")
#define PBXLT_RAISED			PBTEXT("3D Raised")
#define PBXLT_E_RAISED			PBTEXT("3D Raised")
#define PBXLT_SCRIPT			PBTEXT("&Script\tCtrl+K")
#define PBXLT_SELECT			PBTEXT("Select...")
#define PBXLT_SETEMPTY			PBTEXT("empty")
#define PBXLT_E_SETEMPTY		PBTEXT("Set To Empty String") //slahiri for cr221373
#define PBXLT_SETNULL			PBTEXT("null")
#define PBXLT_E_SETNULL			PBTEXT("Set To Null")//slahiri for cr221373
#define PBXLT_SETTODAY			PBTEXT("today")
#define PBXLT_E_SETTODAY		PBTEXT("Set To Today")//slahiri for cr221373
#define PBXLT_SETZERO			PBTEXT("0")
#define PBXLT_E_SETZERO			PBTEXT("Set To Zero")//slahiri for cr221373
#define PBXLT_SHADOWBOX			PBTEXT("Shadow Box")
#define PBXLT_E_SHADOWBOX		PBTEXT("Shadow Box")
#define PBXLT_SHARED_VAR		PBTEXT("Shared")
#define PBXLT_SIZE_IN			PBTEXT("Size in bytes:")
#define PBXLT_S_FOR_S			PBTEXT("%s for %s")
#define PBXLT_TABULAR			PBTEXT("tabular")
#define PBXLT_E_TABULAR			PBTEXT("tabular")
#define PBXLT_TREE				PBTEXT("treeview")
#define PBXLT_TEXT_FONT			PBTEXT("Text Font")
#define PBXLT_PRN_FONT			PBTEXT("Printer Font")		// tanb: Added Printer font tab
#define PBXLT_EDIT_FONT			PBTEXT("Editor Font")		// tanb: Added Editor font caption
#define PBXLT_SYSTEM_FONT		PBTEXT("System Font")		// tanb: Added System Font caption
#define PBXLT_UNDERLINE			PBTEXT("Underline")
#define PBXLT_E_UNDERLINE		PBTEXT("Underline")
#define PBXLT_UNTITLED			PBTEXT("Untitled")
#define PBXLT_USER_OBJECT		PBTEXT("User Object")
#define PBXLT_E_USER_OBJECT		PBTEXT("User Object")
#define PBXLT_VARIABLES			PBTEXT(" Variables: ")
#define PBXLT_WATCH_VAR			PBTEXT(" Watch Variables:")
#define PBXLT_WINDOW			PBTEXT("Window")
#define PBXLT_E_WINDOW			PBTEXT("Window")

#define PBXLT_COLORBLACK		PBTEXT("BLACK")
#define PBXLT_E_COLORBLACK		PBTEXT("BLACK")
#define PBXLT_COLORBLUE			PBTEXT("BLUE")
#define PBXLT_E_COLORBLUE		PBTEXT("BLUE")
#define PBXLT_COLORCYAN			PBTEXT("CYAN")
#define PBXLT_E_COLORCYAN		PBTEXT("CYAN")
#define PBXLT_COLORGREEN		PBTEXT("GREEN")
#define PBXLT_E_COLORGREEN		PBTEXT("GREEN")
#define PBXLT_COLORMAGENTA		PBTEXT("MAGENTA")
#define PBXLT_E_COLORMAGENTA		PBTEXT("MAGENTA")
#define PBXLT_COLORRED			PBTEXT("RED")
#define PBXLT_E_COLORRED		PBTEXT("RED")
#define PBXLT_COLORWHITE		PBTEXT("WHITE")
#define PBXLT_E_COLORWHITE		PBTEXT("WHITE")
#define PBXLT_COLORYELLOW		PBTEXT("YELLOW")
#define PBXLT_E_COLORYELLOW		PBTEXT("YELLOW")

#define PBXLT_DTTMCURRENTTIME		PBTEXT("CURRENT")
#define PBXLT_DTTMWINDOWSGENERAL	PBTEXT("GENERAL")
#define PBXLT_DTTMWINDOWSLONG		PBTEXT("LONGDATE")
#define PBXLT_DTTMWINDOWSSHORT		PBTEXT("SHORTDATE")
#define PBXLT_DTTMWINDOWSTIME		PBTEXT("TIME")
#define PBXLT_E_DTTMCURRENTTIME		PBTEXT("CURRENT")
#define PBXLT_E_DTTMWINDOWSGENERAL	PBTEXT("GENERAL")
#define PBXLT_E_DTTMWINDOWSLONG		PBTEXT("LONGDATE")
#define PBXLT_E_DTTMWINDOWSSHORT	PBTEXT("SHORTDATE")
#define PBXLT_E_DTTMWINDOWSTIME		PBTEXT("TIME")

#define PBXLT_CLRBG			255,255,128	// use in shared\pbshr\ccttip.cpp			

 // ADC_DBCS_START_MODIFY cchong Apr 22 1999
 // IME related strings used in PDW
#define PBXLT_IME_NONE			PBTEXT("None")
#define PBXLT_IME_ON			PBTEXT("On")
#define PBXLT_IME_OFF			PBTEXT("Off")
#define PBXLT_IME_FIXED_OFF		PBTEXT("Fixed")
// ADC_DBCS_END_MODIFY cchong Apr 22 1999

//Font Localization:
#define PBXLT_CHARSET							ANSI_CHARSET
#define PBXLT_DEFAULT_FONT_HEIGHT				8
#define	PBXLT_DW_DLGINIT_FONT					PBTEXT("Tahoma")
#define PBXLT_DW_GEN_FONT						PBTEXT("Tahoma")
#define PBXLT_DW_GEN_GRAPH_FONT					PBTEXT("Tahoma")
#define PBXLT_DW_GEN_STYLE_FONT					PBTEXT("Tahoma")
#define	PBXLT_DW_GEN_STYLE_FONT_HEIGHT			13
#define PBXLT_DW_GEN_STYLE_FONT_PITCHFAMILY		FF_SWISS | VARIABLE_PITCH
#define PBXLT_DW_SRTDLG_FONT					PBTEXT("Tahoma")
#define	PBXLT_DW_PPPAINT_FONT					PBTEXT("Tahoma")
#define PBXLT_DW_SETFONT_FONT					PBTEXT("Tahoma")
#define PBXLT_DW_CHECKBOX_RECT_FONT             PBTEXT("Wingdings")
#define PBXLT_DW_CHECKBOX_RECT_FONT2             PBTEXT("Arial Unicode MS")
#define PBXLT_PDT_FONT_HEIGHT					13
#define PBXLT_PDT_FONT							PBTEXT("Small Fonts")
#define PBXLT_PDT_CREATE_TABLE_FONT				PBTEXT("Tahoma")
#define PBXLT_PDT_CREATE_TABLE_FONT_HEIGHT		13
#define PBXLT_PDT_TITLE							PBTEXT("Database Painter")
#define PBXLT_PDT_EDIT_STYLES					PBTEXT("Edit Styles")
#define PBXLT_PDT_DISPLAY_FORMAT				PBTEXT("Display Formats")
#define PBXLT_PDT_VALIDATION_RULES				PBTEXT("Validation Rules")
#define PBXLT_DBCONNECTIONS						PBTEXT("Connections")
#define PBXLT_PDT_UTILITIES						PBTEXT("Utilities")
#define PBXLT_PDT_ODBCADMIN						PBTEXT("ODBC Administrator")
#define PBXLT_PDT_CREATEODBCDSN					PBTEXT("Create ODBC Data Source")
#define PBXLT_PDT_OPENCLIENT10					PBTEXT("Open Client 10")
#define PBXLT_PDT_SQLEDIT						PBTEXT("SQLEdit")
#define PBXLT_PDT_SYBPING						PBTEXT("Sybase Ping")
#define PBXLT_PDT_OPENCLIENT11					PBTEXT("Open Client 11")
#define PBXLT_PDT_OPENCLIENT					PBTEXT("Open Client")
#define PBXLT_PDT_DSEDIT						PBTEXT("Directory Services Editor")
#define PBXLT_PDT_SQLADVANTAGE					PBTEXT("SQL Advantage")
#define PBXLT_PDT_OCFCFG						PBTEXT("Server Config")
#define PBXLT_PDT_SETNET						PBTEXT("Informix SetNet32")
#define PBXLT_PDT_NET8							PBTEXT("Net8 Easy Config")
#define PBXLT_PDT_SQLNET						PBTEXT("SQL*Net Easy Config")
#define PBXLT_PDT_SQLCENTRAL					PBTEXT("Sybase Central")
#define PBXLT_PDT_MSSISQL						PBTEXT("Query Anaylzer")
#define PBXLT_PDT_MSQUERY						PBTEXT("MS Query")
#define PBXLT_PDT_MSSWINDBVER					PBTEXT("Client Configuration Utility")
#define PBXLT_PDT_MSSENTERPRISE					PBTEXT("Enterprise Manager")
#define PBXLT_PDT_MSSDTSWIZARD					PBTEXT("Import and Export Data")
#define PBXLT_PDT_MSSSERVICEMANAGER				PBTEXT("Service Manager")
#define PBXLT_PDT_MSSINDEXWIZARD				PBTEXT("Index Tuning Wizard")
#define PBXLT_PDT_CREATEASADB					PBTEXT("Create ASA Database")
#define PBXLT_PDT_DELETEASADB					PBTEXT("Delete ASA Database")
#define PBXLT_PDT_LAUNCHMLSRV					PBTEXT("MobiLink Synchronization Server")
#define PBXLT_PDT_ULVIEW						PBTEXT("UltraLite Schema Painter")
#define PBXLT_PDT_CREATEULDB                    PBTEXT("Create UltraLite Database")
#define PBXLT_PDT_DATALINKS						PBTEXT("Manage Data Links")
#define PBXLT_PDT_OLEDB_PBADMIN					PBTEXT("PowerBuilder DataDirect OLE DB Administrator")
#define PBXLT_PDT_DATADIRECTHELP                PBTEXT("DataDirect ODBC Help")

#define PBXLT_NO_CONNECTION						PBTEXT("No Connection")
#define PBXLT_CONNECTIONS						PBTEXT("Connections")
#define PBXLT_CONNECTION						PBTEXT("Connection")

#define PBXLT_SCR_DLGINIT_FONT		   PBTEXT("Tahoma")
#define PBXLT_SCR_DLGINIT_FONT_HEIGHT	   13
#define PBXLT_SCR_INITCOMBOS_FONT	   PBTEXT("Tahoma")
#define PBXLT_SCR_INITCOMBOS_FONT_HEIGHT  13
#if !defined(PBOS_MAC)
#define PBXLT_PDW_PSXFMTDLGPROC_FONT		 PBTEXT("Courier New")
#define PBXLT_PDW_PSXFMTDLGPROC_FONT_HEIGHT   8
#else
#define PBXLT_PDW_PSXFMTDLGPROC_FONT		 PBTEXT("Monaco")
#define PBXLT_PDW_PSXFMTDLGPROC_FONT_HEIGHT   9
#endif
#define PBXLT_PDW_PSXFMTDLGPROC_PITCHFAMILY	  FIXED_PITCH | FF_DONTCARE
#define	PBXLT_PDW_DLGINIT_FONT 		PBTEXT("Tahoma")
#define PBXLT_PDW_DLGINIT_FONT_HEIGHT	   -8	
#if !defined(PBOS_MAC)
#define PBXLT_PDW_MSGPAINTRULER_FONT	PBTEXT("Tahoma")
#else
#define PBXLT_PDW_MSGPAINTRULER_FONT	PBTEXT("Geneva")
#endif
#define PBXLT_PDW_EVENTLEFTBUTTON_FONT	  PBTEXT("Tahoma")
#define PBXLT_PDW_PDWGRAPH_FONT_WEIGHT	  1000
#define PBXLT_PDW_LOADDRAWBLOB_FONT		 PBTEXT("Tahoma")
#define PBXLT_PDW_LOADDRAWREPORT_FONT		 PBTEXT("Tahoma")
#if !defined(PBOS_MAC)
#define PBXLT_PDW_INITDATAWIN_FONT	   PBTEXT("Tahoma")
#define PBXLT_PDW_INITDATAWIN_FONT_HEIGHT	   13
#define PBXLT_PDW_INITDATAWIN_FONT_WEIGHT	   1000
#else
#define PBXLT_PDW_INITDATAWIN_FONT	   PBTEXT("Chicago")
#define PBXLT_PDW_INITDATAWIN_FONT_HEIGHT	   16
#define PBXLT_PDW_INITDATAWIN_FONT_WEIGHT	   400
#endif
#define PBXLT_PDW_SELECTREPORTSDLGPROC_FONT		PBTEXT("Tahoma")
#define PBXLT_PDW_UNDODELETE_FONT	   PBTEXT("Tahoma")

// Add tsuyoshi
//#define PBXLT_PDW_DRAW_FONT_WEIGHT					1000
#if defined(PBOS_MAC)
#define PBXLT_PDW_DRAW_FACE_FONT	PBTEXT("Geneva")
#else
#define PBXLT_PDW_DRAW_FACE_FONT	PBTEXT("Tahoma")
#endif
#define PBXLT_PDW_DRAW_PRINT_FONT			PBTEXT("Courier")

//#define PBXLT_PDW_DRAW_PROC_FONT			"Tahoma"
#if !defined(PBOS_MAC)
#define PBXLT_PDW_DRAW_FONT_HEIGHT		-7	
#define PBXLT_PDW_DRAW_FONT_WEIGHT		1000
#define PBXLT_PDW_DRAW_PROC_FONT		PBTEXT("Tahoma")
#else
#define PBXLT_PDW_DRAW_FONT_HEIGHT		-9
#define PBXLT_PDW_DRAW_FONT_WEIGHT		400
#define PBXLT_PDW_DRAW_PROC_FONT		PBTEXT("Geneva")
#endif
#define PBXLT_PDW_NONETEXT				PBTEXT("none")

#define PBXLT_SCRIPT_FONT_SIZE	8
#define PBXLT_SCRIPT_FONT_HEIGHT		13
#define PBXLT_SCRIPT_FONT_FACENAME		PBTEXT("Tahoma")
#define PBXLT_VIEW_FONT_SIZE			13
#define PBXLT_VIEW_FONT_FACENAME		PBTEXT("Tahoma")		
#define PBXLT_WINDOW_FONT				PBTEXT("Courier 17cpi")

// begin RichText defines

#define PBXLT_RTC_HEICON_PITCH			DEFAULT_PITCH 		
#define PBXLT_RTC_HEICON_FF		 		FF_SWISS
#define PBXLT_RTC_HETBTN_PITCH			VARIABLE_PITCH
#define PBXLT_RTC_HETBTN_FF				FF_SWISS
#define PBXLT_RTC_HETBTN_FONT			PBTEXT("Tahoma")
#define PBXLT_RTC_HETSTAT_FONT_PITCH	VARIABLE_PITCH	
#define PBXLT_RTC_HETSTAT_FONT_FF		FF_DONTCARE
#define PBXLT_RTC_HETSTAT_FONT			PBTEXT("Tahoma")

#if defined(PBOS_MAC)
#define PBXLT_RTC_DEFAULT_FONTNAME		((LPTSTR) PBTEXT("Geneva"))
#define PBXLT_RTC_HEICON_FONT			PBTEXT("Chicago")
#else
#define PBXLT_RTC_DEFAULT_FONTNAME		((LPTSTR) PBTEXT("Tahoma"))
#define PBXLT_RTC_HEICON_FONT			PBTEXT("Tahoma")
#endif

#define PBXLT_RTC_DEFAULT_PITCHFAMILY	(FF_ROMAN | VARIABLE_PITCH)
// end RichText defines


#define PBXLT_RT_FUNCTION_FONT			PBTEXT("Tahoma")
#define PBXLT_RTFUNC_FACE_HEIGHT		8
#define PBXLT_RTFUNC_FACE_FONT			PBTEXT("Tahoma")
#define PBXLT_RTFUNC_TOOL1_FONT_HEIGHT	6
#define PBXLT_RTFUNC_TOOL1_FONT			PBTEXT("Small Fonts")
#define PBXLT_RTFUNC_T2_FACE_FONT		PBTEXT("Small Fonts")

#define PBXLT_RTFUNC_T2_FONT_HEIGHT		13
#define PBXLT_RTFUNC_T2_FONT_WEIGHT		FW_BOLD
#define PBXLT_RTFUNC_T2_LOG_FONT		PBTEXT("Tahoma")
#define PBXLT_SETUP_FACE_FONT			PBTEXT("Tahoma")
#define PBXLT_PBSHR_STOCK_FONT		ANSI_VAR_FONT	
#define PBXLT_PBSHR_TEXT_FONT		PBTEXT("Tahoma")
#define PBXLT_PBSHR_TEXT_SIZE		8
#define PBXLT_PBSHR_SHFONT			PBTEXT("Tahoma")
#define PBXLT_SPLASH_TEXT_SIZE		13
#define PBXLT_SYS_PBSYS_FONT_HEIGHT		8
#define PBXLT_SYS_PBSYS_FONT_WEIGHT		700
#define PBXLT_SYS_PBSYS_FONT			PBTEXT("Tahoma")
#define PBXLT_SYS_T2_FONT				PBTEXT("Tahoma")
#define PBXLT_SYS_T4_FONT				PBTEXT("Tahoma")
#define PBXLT_SYS_PBUTIL_LOG_FONT		PBTEXT("Tahoma")
#define PBXLT_SYS_PBUTIL_FONT_WEIGHT	FW_NORMAL
#define PBXLT_SYS_PBUTIL_SYS_FONT		ANSI_VAR_FONT
#define PBXLT_SYS_PBUTIL_SYS_FACENAME	PBTEXT("Tahoma")
#define PBXLT_VBX_FONT					PBTEXT("Tahoma")
#define PBXLT_PBSHR_DPERR_DWSTR1		PBTEXT("datawindow(color= %ld units=2 processing=1 row.resize=0) ")
#define PBXLT_PBSHR_DPERR_DWSTR2		PBTEXT("text(band=header alignment=2 border=6 font.height=-8 font.weight=400 ")
#define PBXLT_PBSHR_DPERR_DWSTR3		PBTEXT("font.charset=0 font.pitch=2 font.family=2 ")
#define PBXLT_PBSHR_DPERR_DWSTR4		PBTEXT("font.face=\"Tahoma\" color=%ld) ")
#define PBXLT_PBSHR_DPERR_DWSTR5		PBTEXT("column(band=detail alignment=0 border=0 ")
#define PBXLT_PBSHR_DPERR_DWSTR6		PBTEXT("font.height=-8 font.weight=400 ")
#define PBXLT_PBSHR_DPERR_DWSTR7		PBTEXT("font.charset=PBXLT_CHARSET font.pitch=2 font.family=2 ")
#define PBXLT_PBSHR_DPERR_DWSTR8	    PBTEXT("font.face=\"Tahoma\" color=%ld Background.Mode=2 Background.Color=%ld )  style(type=grid)"),
#define PBXLT_PBTAB_TEXTPOINTSIZE   	8
#define PBXLT_PBTAB_TEXT_FONT		PBTEXT("Tahoma")


/* OTHERS */
#define PBXLT_DWP_SZSTYLE_SIZE	10
#define PBXLT_PM_WIDTH1		7	// use PAINTERS\MENU
#define PBXLT_PM_WIDTH2 	3	// use PAINTERS\MENU
#define PBXLT_PM_WIDTH3		2	// use PAINTERS\MENU
#define PBXLT_PM_WIDTH4		4	// use PAINTERS\MENU
#define PBXLT_PM_WIDTH_REGULATE	0	// US=0, JPN=pMainStg->charwd * 3

#define PBXLT_CMP_ARRAY				PBTEXT("array")
#define PBXLT_CMP_AUTOINST_STRUCT	PBTEXT("autoinstantiate or structure")

#define PBXLT_COM_GUIDSOURCE		PBTEXT("GUID Source File")
#define PBXLT_COM_OBJECTSOURCE		PBTEXT("PB COM Object Source File")
#define PBXLT_COM_SERVERSOURCE		PBTEXT("PB COM Server Source File")

#endif // PBXLTEN_H
// DOINC popped back into header 'oswindow.h'
// ADC_DBCS_END_MODIFY cchong Apr 22 1999
#else      //add here for new translations
// ***** DOINC including pbxlten.h *****
	// DOINC skipping duplicate include
#endif

#ifdef PBWIN32

#ifdef __cplusplus
	extern "C" {
#endif
#ifdef PBOS_LINUX
#define _try
#define __try
#define _except(e)      if (0)
#define __except(e)     if (0)
#define __finally       if (1)
#define BUFSIZ      	4096 
#endif
#ifdef __cplusplus
	}; // extern "C"
#endif

#endif
#endif /* OSWINDOW_H */
// DOINC popped back into header 'rtccode.h'
// ***** DOINC including osstdlib.h *****
/*                                                                         */
/* *********************************************************************** */
/*                                                                         */
/*                 Copyright Powersoft Corporation 1991-1994               */
/*                                                                         */
/*       Powersoft Corporation ("Powersoft") claims copyright in this      */
/*     program and documentation as an unpublished work, versions of       */
/*     which were first licensed on the date indicated in the foregoing    */
/*     notice. Claim of copyright does not imply waiver of Powersoft's     */
/*     other rights. See Notice of Proprietary Rights.                     */
/*                                                                         */
/*                 NOTICE OF PROPRIETARY RIGHTS                            */
/*                                                                         */
/*       This program and documentation are confidential trade             */
/*     secrets and the property of Powersoft.  Use, examination,           */
/*     reproduction, copying, disassembly, decompilation, transfer         */
/*     and/or disclosure to others are strictly prohibited except by       */
/*     express written agreement with Powersoft.                           */
/*                                                                         */
/* ----------------------------------------------------------------------- */
/*                                                                         */
/*    Filename :    osstdlib.h                                             */
/*                                                                         */
/*    Author   :    Jim Kosko                                              */
/*                                                                         */
/*    Purpose  :    Wrapper for stdlib.h                                   */
/*                                                                         */
/* *********************************************************************** */

/* *********************************************************************** */
/*  Insure file is not include twice                                       */
/* *********************************************************************** */
#ifndef OSSTDLIB_H
#define OSSTDLIB_H

/* *********************************************************************** */
/*  Undefine min and max definitions (Conflict from windows.h)             */
/* *********************************************************************** */
#ifndef  PBOS_MAC
//#undef  min
//#undef  max
#endif 

/* *********************************************************************** */
/*  Clear anything necessary for cross-platform compilers                  */
/* *********************************************************************** */
#if defined(PBOS_MAC) && ( defined(THINK_C) || defined(THINK_CPLUS) )
#undef  NULL
#endif 

/* *********************************************************************** */
/*  #include stdlib.h                                                      */
/* *********************************************************************** */

#ifndef _WINDU_SOURCE
#include <stdlib.h>
#else
// ***** DOINC including windu_stdlib.h *****
	// DOINC skipping missing include
#endif


//****************************************************************************
// Redefine min and max functions for C++
//****************************************************************************

#define osmax(a,b)  (((a) > (b)) ? (a) : (b))
#define osmin(a,b)  (((a) < (b)) ? (a) : (b))

#endif /* OSSTDLIB_H */
// DOINC popped back into header 'rtccode.h'
// ***** DOINC including ospascal.h *****
	// DOINC skipping duplicate include
// ***** DOINC including pbstg.h *****
/*                                                                         */
/* *********************************************************************** */
/*                                                                         */
/*                 Copyright Powersoft Corporation 1991-1994               */
/*                                                                         */
/*       Powersoft Corporation ("Powersoft") claims copyright in this      */
/*     program and documentation as an unpublished work, versions of       */
/*     which were first licensed on the date indicated in the foregoing    */
/*     notice. Claim of copyright does not imply waiver of Powersoft's     */
/*     other rights. See Notice of Proprietary Rights.                     */
/*                                                                         */
/*                 NOTICE OF PROPRIETARY RIGHTS                            */
/*                                                                         */
/*       This program and documentation are confidential trade             */
/*     secrets and the property of Powersoft.  Use, examination,           */
/*     reproduction, copying, disassembly, decompilation, transfer         */
/*     and/or disclosure to others are strictly prohibited except by       */
/*     express written agreement with Powersoft.                           */
/*                                                                         */
/* ----------------------------------------------------------------------- */
/*                                                                         */
/*    Filename :    pbstg.h                                                */
/*                                                                         */
/*    Author   :    Julie Kessler                                          */
/*                                                                         */
/*    Purpose  :    Memory function prototypes                             */
/*                                                                         */
/* *********************************************************************** */

/* *********************************************************************** */
/*  Insure file is not included twice                                      */
/* *********************************************************************** */

#ifndef PBSTG_H
#define PBSTG_H

#ifdef PBOS_NT
// this is a HACK to work around a HeapAgent bug on NT that is replacing
// our allocations based on their name
#define pbstg_alloc pbstg_alc
#define pbstg_free pbstg_fee
#define pbstg_realloc pbstg_realc
#define pbstg_size pbstg_sz
#endif

#ifdef PB_ENABLE_ALLOCATION_TRACKING
#ifndef PBDEBUG
#define PBDEBUG
#endif
#endif

#ifndef OSWINDOW_H
// ***** DOINC including oswindow.h *****
	// DOINC skipping duplicate include
#endif

#ifdef PS_DBCS					// KANJI
// ***** DOINC including kanji.h *****
// **************************************************************************
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// --------------------------------------------------------------------------
//
//    Filename :    kanji.h
//    Author   :    
//
// **************************************************************************

#ifndef   KANJI_H
#define   KANJI_H

// ***** DOINC including kanjic.h *****
// **************************************************************************
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// --------------------------------------------------------------------------
//
//    Filename :    kanjic.h
//    Author   :    yoshiyuki yamashita
//
// **************************************************************************
// 
// Keyword :
// PS_DBCS  KANJI
//
#ifndef	KANJIC_H
#define	KANJIC_H

// ADC_DBCS_START_MODIFY cchong Jul 14 1999
// Add !defined(PBOS_UNIX) because include mbstring.h here breaks UNIX build
#if defined(PBWIN32) && !defined (PBOS_UNIX)
#include <mbstring.h>
#endif
// ADC_DBCS_END_MODIFY cchong Jul 14 1999

#ifdef	__cplusplus
	extern "C" {
#endif

#include	<ctype.h>
#ifdef	PBWIN16
#define	INT	int
#endif

		//#ifdef	isdigit
		//#undef	isdigit
		//#endif


		INT FAR PASCAL issbdigit(INT c);

		//#ifdef	isalpha
		//#undef	isalpha
		//#endif
		//#define	pbstg_isalpha		iskalpha

		//#ifdef	isalnum
		//#undef	isalnum
		//#endif
		//#define	pbstg_isalnum		iskalnum


		//#define	pbstg_isdigit		issbdigit	 /* kanjic.c */
#define	iskanji1	iskanji
#define	ishankaku 	iskana


#if defined(PBWIN32) && !defined (PBOS_UNIX)
// ADC_DBCS_START_ORIG tlim July 7 1999
// Genric macros to check if it is 1st or 2nd byte of DBCS.
// In CK, there is no Kana.
#define iskanji(c) IsDBCSLeadByte ((unsigned char) c)
#define iskanji2(c)	_ismbbtrail((unsigned char) (c))
#define iskana(c) (0)
// ADC_DBCS_END_MODIFY
#else
#define iskanji(c)\
 	(((0x81 <= (BYTE )(c)) && ((BYTE )(c) <= 0x9f))\
	|| ((0xe0 <= (BYTE )(c))&& ((BYTE )(c) <= 0xfc)))
#define iskanji2(c)\
	(((0x40 <= (BYTE )(c)) && ((BYTE )(c) <= 0x7e))\
	|| ((0x80 <= (BYTE )(c))&& ((BYTE )(c) <= 0xfc)))
#define iskana(c)\
	((0xA1 <= (BYTE )(c)) && ((BYTE )(c) <= 0xDF))
#endif


#define	iskalpha(c) (iskanji((BYTE) c) || iskana((BYTE)c) || pbstg_isupper((BYTE)c) || pbstg_islower((BYTE)c))
#define	iskalnum(c) (iskanji((BYTE)c)  || iskana((BYTE)c) || pbstg_isupper((BYTE)c) || pbstg_islower((BYTE)c) || pbstg_isdigit((BYTE)c))

//added by Wangjj 30/01/2001 CR230954 for simplify the DBCS str pointer operation.DBCS Support
#define DBCS_MOVE_POINTER_AHEAD(Pointer) \
	if( iskanji(*Pointer) && *(Pointer + 1) && iskanji2(*(Pointer + 1))) { Pointer+=2;} \
    else { Pointer++;}

#define DBCS_MOVE_POINTER_BEHIND(Pointer) \
	if( iskanji2(*Pointer) && *(Pointer - 1) && iskanji(*(Pointer - 1))) { Pointer-=2;} \
    else { Pointer--;}

#define DBCS_COPY_CHARACTER_N_MOVE_POINTER(ScrPointer, DesPointer) \
    if( iskanji(*ScrPointer) && *(ScrPointer + 1) && iskanji2(*(ScrPointer + 1))) \
{ *DesPointer++ = *ScrPointer++; *DesPointer++ = *ScrPointer++ ;} \
    else { *DesPointer++ = *ScrPointer++; }

//end of add Winner-0006

//ADC_DBCS_START_ORIG ylu cchong Apr 22 1999
//#define	_MBC_SINGLE 	0x0	// 
//#define	_MBC_LEAD 	0x1	// 0x81-0x9f or 0xe0-0xfc
//#define	_MBC_TRAIL 	0x2	// 0x40-0x7e or 0x80-0xfc
//#define	_MBC_ILLEGAL 	-1	// nouse
//ADC_DBCS_END_ORIG
//ADC_DBCS_START_MODIFY ylu cchong Apr 22 1999
//Make the definition the same as it is in other header files
//Otherwise will cause macro redefinition compliling error
#define	_MBC_SINGLE 	0	// 
#define	_MBC_LEAD 		1	// 0x81-0x9f or 0xe0-0xfc
#define	_MBC_TRAIL 		2	// 0x40-0x7e or 0x80-0xfc
#define	_MBC_ILLEGAL 	(-1)	// nouse
//ADC_DBCS_END_MODIFY

#define	KANJI_1ST	_MBC_LEAD
#define	KANJI_2ND	_MBC_TRAIL
#define	KANA		0x4


//
// MBT_(Multi Byte Character Type)
//
#define	MBT_SINGLE		0x0000	// single byte ascii code and KANA
#define	MBT_KANJI 		0x0100	// double byte KANJI code
#define	MBT_KANA		0x0200	// double byte KANA code
#define	MBT_HIRAGANA		0x0400	// double byte HIRAGANA code
#define	MBT_ALPHA		0x0800	// double byte alphabetic 
#define	MBT_DIGIT		0x1000	// double byte digit
//
// SBT_(Single Byte Character Type)
//
#define	SBT_SINGLE_KANA		(KANA)
#define	SBT_KANJI_1ST		(MBT_KANJI | _MBC_LEAD)
#define	SBT_KANJI_2ND		(MBT_KANJI | _MBC_TRAIL)
#define	SBT_KANA_1ST		(MBT_KANA | _MBC_LEAD)
#define	SBT_KANA_2ND		(MBT_KANA | _MBC_TRAIL)
#define	SBT_HIRAGANA_1ST	(MBT_HIRAGANA | _MBC_LEAD)
#define	SBT_HIRAGANA_2ND	(MBT_HIRAGANA | _MBC_TRAIL)
#define	SBT_ALPHA_1ST		(MBT_ALPHA | _MBC_LEAD)
#define	SBT_ALPHA_2ND		(MBT_ALPHA | _MBC_TRAIL)
#define	SBT_DIGIT_1ST		(MBT_DIGIT | _MBC_LEAD)
#define	SBT_DIGIT_2ND		(MBT_DIGIT | _MBC_TRAIL)
#define	SBT_ALPHANUM_1ST	(MBT_ALPHANUM | _MBC_LEAD)
#define	SBT_ALPHANUM_2ND	(MBT_ALPHANUM | _MBC_TRAIL)

#define	IsMBT_DBCS(X)		(X & (_MBC_LEAD | _MBC_TRAIL))
#define	IsMBT_LEAD(X)		(X & _MBC_LEAD)
#define	IsMBT_TRAIL(X)		(X & _MBC_TRAIL)

#define	IsSBT_KANJI(X)		(X & MBT_KANJI)
#define	IsSBT_KANA(X)		(X & MBT_KANA)
#define	IsSBT_HIRAGANA(X)	(X & MBT_HIRAGANA)
#define	IsSBT_ALPHA(X)		(X & MBT_ALPHA)
#define	IsSBT_DIGIT(X)		(X & MBT_DIGIT)
#define	IsSBT_SINGLE_KANA(X)	(X & KANA)

// ADC_DBCS_START_ORIG tlim Jan 20 1999
// #define	IsMBKana(W)	( (0x8340 <= W) && (W <= 0x8396) )
// #define	IsMBDigit(W)	( (0x824F <= W) && (W <= 0x8258) )
// #define	IsMBAlpha(W)	( (0x8260 <= W) && (W <= 0x829A) )
// #define	IsMBHiraGana(W)	( (0x829F <= W) && (W <= 0x82F1) )
// ADC_DBCS_END_ORIG

// ADC_DBCS_START_MODIFY tlim Jan 20 1999 cchong Jan 26 1999
// cchong: CP936(GB) and CP949(KSC) have identical MBDigit and MBAlpha range.
// These macros are used only in rtc/ for optimization 
// purposes
#define IsMBKana(W)		(0)
#define IsMBDigit(W)	( (0xa3b0 <= W) && (W <= 0xa3b9) )
#define IsMBAlpha(W)	( (0xa3c1 <= W) && (W <= 0xa3fa) )
#define IsMBHiraGana(W)	(0)
// ADC_DBCS_END_MODIFY

#define ATTRIB_START 0x0000
#define SBC_ALPHANUM 0x0001
#define SBC_KATAKANA 0x0002
#define MBC_KANJI    0x0004
#define MBC_HIRAGANA 0x0008
#define MBC_KATAKANA 0x0010
#define MBC_ALPHA    0x0020
#define MBC_DIGIT    0x0040

#ifndef MB_MAX_LEN
#define MB_MAX_LEN 2
#endif

#ifdef	__cplusplus
	}
#endif	// __cplusplus

#endif	// KANJIC_H
	// DOINC popped back into header 'kanji.h'
	// ***** DOINC including kanjis.h *****
	// **************************************************************************
	//
	//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
	//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
	//    INCORPORATED.
	//
	// --------------------------------------------------------------------------
	//
	//    Filename :    kanjis.h
	//    Author   :    yoshiyuki yamashita
	//
	// **************************************************************************
#ifndef	KANJIS_H
#define	KANJIS_H

#ifdef	__cplusplus
	extern	"C" {
#endif

#ifndef OSWINDOW_H
		// ***** DOINC including oswindow.h *****
			// DOINC skipping duplicate include
#endif
// ***** DOINC including kanjic.h *****
	// DOINC skipping duplicate include

		PBWINAPI(BOOL, IsDBCS) ();

		PBWINAPI(LPSTR, fjstrupr) (LPSTR string);
		PBWINAPI(LPSTR, fjstrlwr) (LPSTR string);
		PBWINAPI(INT, fjstrnupr) (LPSTR string, INT i);
		PBWINAPI(INT, fjstrnlwr) (LPSTR string, INT i);

		PBWINAPI(LPSTR, fjstrstr) (LPCSTR string1, LPCSTR string2);
		PBWINAPI(LPSTR, fjstrchr) (LPCSTR string1, INT c);
		PBWINAPI(LPSTR, fjstrrchr) (LPCSTR string1, INT c);
		PBWINAPI(LPSTR, fjstrmatch) (LPCSTR string1, LPCSTR string2);

		/* #define	fmbsbtype	x_fmbsbtype */
		PBWINAPI(INT, fmbsbtype) (LPCSTR string, INT nbyte);
		PBWINAPI(UINT, fmbslen) (LPCSTR string);
		PBWINAPI(UINT, fmbsnbcnt) (LPCSTR string, UINT nChar);
		PBWINAPI(UINT, fmbsnccnt) (LPCSTR string, UINT nByte);
		//PBWINAPI (size_t, fmbslen) (LPSTR string);
		//PBWINAPI (size_t, fmbsnbcnt) (LPSTR string, size_t nChar);
		//PBWINAPI (size_t, fmbsnccnt) (LPSTR string, size_t nByte);

#ifdef	__cplusplus
	}
#endif

#endif	// KANJIS_H
	// DOINC popped back into header 'kanji.h'
#endif	// KANJI_H

// DOINC popped back into header 'pbstg.h'
#ifdef	PBWIN32
#include <mbstring.h>
#else
#include <jstring.h>
#endif
#endif							// KANJI

#ifdef PBWIN16
#include <ctype.h>
#endif

#if defined(PBOS_LINUX)
#include <wchar.h>
#include <wctype.h>
#endif

#ifdef __cplusplus
	extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/* *********************************************************************** */
/*  Make sure all string function prototypes are here for the Mac          */
/* *********************************************************************** */
#ifdef  PBOS_MAC
// ***** DOINC including dosstubs.h *****
	// DOINC skipping missing include
#ifndef OSWINDOW_H
// ***** DOINC including oswindow.h *****
	// DOINC skipping duplicate include
#endif
#include <stdlib.h>         
#endif

#ifdef  PBOS_UNIX
#ifndef OSWINDOW_H
// ***** DOINC including oswindow.h *****
	// DOINC skipping duplicate include
#endif
#endif

// ***** DOINC including kanjis.h *****
	// DOINC skipping duplicate include
#ifdef PBOS_LINUX
// ***** DOINC including new.h *****
/***
*new.h - declarations and definitions for C++ memory allocation functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the declarations for C++ memory allocation functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_NEW
#define _INC_NEW

#ifdef  __cplusplus

#ifndef _MSC_EXTENSIONS
#include <new>
#endif

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


/* Protect against #define of new */
#pragma push_macro("new")
#undef  new


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTIMP2 */
#ifndef _CRTIMP2
#if defined(_DLL) && !defined(_STATIC_CPPLIB)
#define _CRTIMP2 __declspec(dllimport)
#else   /* ndef _DLL && !STATIC_CPPLIB */
#define _CRTIMP2
#endif  /* _DLL && !STATIC_CPPLIB */
#endif  /* _CRTIMP2 */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* types and structures */

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
		typedef unsigned __int64    size_t;
#else
		typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifdef  _MSC_EXTENSIONS
		namespace std {
			typedef void(__cdecl* new_handler) ();
			_CRTIMP2 new_handler __cdecl set_new_handler(new_handler) throw();
		};
		using std::new_handler;
		using std::set_new_handler;
#endif

#ifndef __NOTHROW_T_DEFINED
#define __NOTHROW_T_DEFINED
		namespace std {
			/* placement new tag type to suppress exceptions */
			struct nothrow_t {};

			/* constant for placement new tag */
			extern const nothrow_t nothrow;
		};

		void* __cdecl operator new(size_t, const std::nothrow_t&) throw();
		void* __cdecl operator new[](size_t, const std::nothrow_t&) throw();
		void __cdecl operator delete(void*, const std::nothrow_t&) throw();
		void __cdecl operator delete[](void*, const std::nothrow_t&) throw();
#endif

#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
		inline void* __cdecl operator new(size_t, void* _P)
		{
			return (_P);
		}
#if     _MSC_VER >= 1200
		inline void __cdecl operator delete(void*, void*)
		{
			return;
		}
#endif
#endif


		/*
		 * new mode flag -- when set, makes malloc() behave like new()
		 */

		_CRTIMP int __cdecl _query_new_mode(void);
		_CRTIMP int __cdecl _set_new_mode(int);

#ifndef _PNH_DEFINED
		typedef int(__cdecl* _PNH)(size_t);
#define _PNH_DEFINED
#endif

		_CRTIMP _PNH __cdecl _query_new_handler(void);
		_CRTIMP _PNH __cdecl _set_new_handler(_PNH);

		/*
		 * Microsoft extension:
		 *
		 * _NO_ANSI_NEW_HANDLER de-activates the ANSI new_handler. Use this special value
		 * to support old style (_set_new_handler) behavior.
		 */

#ifndef _NO_ANSI_NH_DEFINED
#define _NO_ANSI_NEW_HANDLER  ((new_handler)-1)
#define _NO_ANSI_NH_DEFINED
#endif

#pragma pop_macro("new")

#endif  /* __cplusplus */

#endif  /* _INC_NEW */
		 // DOINC popped back into header 'pbstg.h'
#endif

#ifndef PBOS_UNIX
#define PBSTG_SAFE_WSPRINTF
#define PBSTG_SAFE_STRCAT
#define PBSTG_SAFE_STRCPY
#define PBSTG_INLINED_SAFE_FORTIFY_SCA
#define PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
#endif

#if defined(PBSTG_SAFE_STRCAT) || defined(PBSTG_SAFE_WSPRINTF) || defined(PBSTG_SAFE_STRCPY)
#ifndef _INC_TCHAR
#include <tchar.h>
#endif
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>
#endif

#undef PVOID                                /* occurs also in stdcsi.h */
#if defined(PBOS_MAC) && defined(applec)
		typedef VOID FAR* PVOID;
#else
#define PVOID void FAR *
#endif

//Unicode conversion - will be removed!
#undef PCHAR                                /* occurs also in stdcsi.h */
#define PCHAR char FAR *

/* *********************************************************************** */
/*  Get documented window things that we provide shell over                */
/* *********************************************************************** */
#ifndef CDECL
#ifdef PBWIN32
#define CDECL
#else
#define CDECL _cdecl
#endif
#endif
#ifndef HUGEPTR
#ifdef PBWIN32
#define HUGEPTR
#else
#define HUGEPTR huge
#endif
#endif

#ifndef  PBOS_MAC
#ifndef  PBOS_UNIX
#ifndef    STDCSI_H
#ifndef OSFARPRC_H
		typedef unsigned short WORD;
#endif
#endif
#endif
#endif

#ifdef STRICT

#ifdef PBWIN32

#ifndef _WINNT_
#ifndef PBOS_UNIX
		typedef void* HANDLE;
#endif // UNIX
#endif // _WINNT_

#else // !PBWIN32

#ifndef  PBOS_MAC
#ifndef  PBOS_UNIX
#ifndef  STDCSI_H
#ifndef  OSFARPRC_H
#ifndef _INC_WINDOWS
		typedef const void NEAR* HANDLE;
#endif //_INC_WINDOWS
#endif //_OSFARPC_H
#endif //STDCSI_H
#endif //PBOS_UNIX
#endif //PBOS_MAC

#endif //PBWIN32

#ifndef PBOS_UNIX
#ifndef DECLARE_HANDLE
#define DECLARE_HANDLE(name)     struct name##__ { int unused; }; \
            typedef const struct name##__ NEAR* name
#endif
#endif  /* PBOS_UNIX */

#ifndef DECLARE_HANDLE32
#define DECLARE_HANDLE32(name)  struct name##__ { int unused; }; \
            typedef const struct name##__ FAR* name
#endif

#else   /* STRICT */

#ifdef PBWIN32

#ifndef _WINNT_
		typedef void* HANDLE;
#endif // _WINNT_

#else // !PBWIN32

#ifndef  PBOS_MAC
#ifndef  PBOS_UNIX
#ifndef  STDCSI_H
#ifndef _INC_WINDOWS
		typedef UINT                    HANDLE;
#endif //_INC_WINDOWS
#endif
#endif
#endif

#endif //PBWIN32

#ifndef DECLARE_HANDLE
#define DECLARE_HANDLE(name)    typedef UINT name
#endif /* DECLARE_HANDLE */

#ifndef DECLARE_HANDLE32
#define DECLARE_HANDLE32(name)  typedef DWORD name
#endif

#endif  /* !STRICT */

#if (!defined(PBOS_MAC) || (defined (PBOS_MAC) && defined(GENERATED_CODE_BUILD)) )
#if (!defined(PBOS_UNIX) || (defined (PBOS_UNIX) && defined(GENERATED_CODE_BUILD)) )
		// gmoison CODEGEN
#ifndef OSWINDOW_H
#ifndef _INC_WINDOWS
		typedef HANDLE GLOBALHANDLE;
		typedef HANDLE LOCALHANDLE;
		typedef TCHAR FAR* LPTSTR;
		typedef const TCHAR  FAR* LPCTSTR;
#endif
#endif
#endif
#endif

#ifndef PASCAL
#define PASCAL          pascal
#endif

#if !defined(PBOS_UNIX) && !defined(PBOS_MAC)
#if defined(__WATCOMC__) 
#ifndef _SIZE_T_DEFINED_
		typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#define _SIZE_T_DEFINED_
#endif
#else
#ifndef _SIZE_T_DEFINED
		typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif
#endif
#endif

#include <string.h>


		/*
		   Provide option of only including the
		   macro's defined in PBSTG.H, not the
		   storage management functions
		*/
#ifndef PBSTG_MACROS_ONLY

		/* Storage statistics */
		typedef struct {
			LONG         lStgCount;     /* Items currently allocated */
			LONG         lStgHigh;      /* Storage high water mark */
			LONG         lStgCurrent;   /* Current storage allocated */
			LONG         lStgAlloc;     /* # of blocks allocated  * sizeof(block) */
			LONG         lStgMemAlloc;  /* # of user allocated bytes */
			LONG         lStgMemFree;   /* # of free bytes */
		} pbstg_statistics;

#ifdef PBUSE_SMRTHEAP
		// ***** DOINC including pbsmrthp.h *****
		/* *********************************************************************** */
		/*  Smart Heap Definitions                                                 */
		/* *********************************************************************** */
		/* dont include for generated code build */
#ifndef  GENERATED_CODE_BUILD
//#include <smrtheap.h>
#endif // GENERATED_CODE_BUILD

		typedef struct stg_subpool_entryS
		{
			struct stg_subpool_entryS FAR* pNext;		/* next subpool in list */
			struct stg_subpool_entryS FAR* pPrev;		/* prev subpool in list */
#ifndef  GENERATED_CODE_BUILD
			MEM_POOL 						heap;		/* the heap for this subpool */
#endif // GENERATED_CODE_BUILD
			LPTSTR							lpstrPoolName;
		} pbstg_subpool_entry, FAR* pbstg_subpool;

#define POOL_NAME_LIMIT		64

#define PBSTG_DEFAULT ((pbstg_subpool) NULL)
#define pbstg_subpool_eq( sp1, sp2 ) ((sp1) == (sp2))

		typedef struct stg_anchorS {
#ifndef  GENERATED_CODE_BUILD
			MEM_POOL 	defaultHeap; 	/* heap when PBSTG_DEFAULT specified */
#endif // GENERASTED_CODE_BUILD
			UINT		uiBlockSize;	/* the storage block size */
			UINT		iAllocFlags;
			LPTSTR		lpszOwner;		/* owner of stg_this */

			pbstg_subpool pSubpoolList;  /* list of all subpools created off of this anchor */
			struct stg_anchorS FAR* pNext; 		/* link to next storage anchor in list */

#ifdef PBDEBUG
			TCHAR  debugString[8];       /* if debug on, stick a "stgthis " literal in here*/
#endif   
		} pbstg_anchor;

#ifndef PPBSTG_ANCHOR_DEFINED
#define PPBSTG_ANCHOR_DEFINED
		typedef struct stg_anchorS FAR* ppbstg_anchor;
#endif

#define PBSTG_HUGE_OFFSET 16

		//myfunc		
		//PB_API_DEF(ppbstg_anchor, pbstg_begin , USHORT buffer)
		typedef void (WINAPI* _Syspbstg_fee)(ppbstg_anchor , void*);
		typedef ppbstg_anchor(WINAPI* _Syspbstg_begin)(short );
		typedef void (WINAPI* _Syspbstg_end)(ppbstg_anchor );
		typedef void* (WINAPI* _Syspbstg_alc)(ppbstg_anchor , int, pbstg_subpool);
		typedef int (WINAPI* _Syspbstg_sz)(ppbstg_anchor , void*);
		typedef void *(WINAPI* _Syspbstg_realc)(ppbstg_anchor , void*, int, pbstg_subpool);
		typedef VOID(WINAPI* _Sysrt_hit_level_0)(void * obthis);		
		
		extern _Syspbstg_fee      pbstg_fee;
		extern _Syspbstg_alc      pbstg_alc;
		extern _Syspbstg_realc    pbstg_realc;
		extern _Sysrt_hit_level_0 rt_hit_level_0;
		extern _Syspbstg_sz       pbstg_sz;
		/* *********************************************************************** */
		/*  Prototype functions                                                    */
		/* *********************************************************************** */

		/* Storage management functions */
		//bluo
		PBWINAPI(ppbstg_anchor, pbstg_begin)(USHORT buffer);
		PBWINAPI(ppbstg_anchor, pbstg_begin_allocflags)(USHORT buffer, UINT lAllocFlags);
		PBWINAPI(ppbstg_anchor, pbstg_begin_nofast)(USHORT buffer);
		PBWINAPI(void, pbstg_end)(ppbstg_anchor pthis);
		PBWINAPI(void, pbstg_free_pool)(ppbstg_anchor pthis, pbstg_subpool subPool);
		PBWINAPI(pbstg_subpool, pbstg_new_pool)(ppbstg_anchor pthis);
		PBWINAPI(pbstg_subpool, pbstg_new_pool_nofast)(ppbstg_anchor pthis);
		//bluo
		PBWINAPI(pbstg_subpool, pbstg_new_pool_with_size)(ppbstg_anchor pthis, USHORT page_size);
		PBWINAPI(pbstg_subpool, pbstg_new_pool_with_size_nofast)(ppbstg_anchor pthis, USHORT page_size);
		PBWINAPI(void, pbstg_set_pool_name)(ppbstg_anchor pthis, pbstg_subpool subPool, LPTSTR lpstrName);
		PBWINAPI(BOOL, pbstg_set_poolpagesize)(ppbstg_anchor pthis, ULONG pagesize);

		PBWINAPI(short, pbstg_write_debug)(ppbstg_anchor pthis, pbstg_subpool subpool, LPTSTR lpFile);
		PBWINAPI(VOID, pbstg_stat)(ppbstg_anchor pthis, pbstg_statistics FAR* stat);
		PBWINAPI(VOID, pbstg_shrink)(ppbstg_anchor pThis);
		PBWINAPI(LONG, pbstg_nextGeneration)();
		PBWINAPI(VOID, pbstg_dumpLeaks)(long generation);
		PBWINAPI(VOID, pbstg_dumpHeap)();

		PBWINAPI(PVOID, pbstg_alloc)(ppbstg_anchor pthis, ULONG iNumberOfBytes, pbstg_subpool subPool);
		PBWINAPI(void, pbstg_free)(ppbstg_anchor pthis, PVOID stg);
		PBWINAPI(PVOID, pbstg_realloc)(ppbstg_anchor pthis, PVOID pOldStorage, ULONG iLength, pbstg_subpool subPool);
		PBWINAPI(ULONG, pbstg_size)(ppbstg_anchor pthis, PVOID pStg);
		PBWINAPI(ULONG, pbstg_fast_strlen)(LPTSTR s);

		/*
		#define pbstg_alloc(pthis, iNumberOfBytes, subPool) \
			( ((subPool) == PBSTG_DEFAULT ) ? \
					MemAllocPtr( ((ppbstg_anchor)(pthis))->defaultHeap, iNumberOfBytes, 0 ) : \
					MemAllocPtr( (subPool)->heap, iNumberOfBytes, 0 ) )
		*/

		// this needs to worry about people doing function calls for stg!!
		// we therefore can't repeat stg in the macro!!
		// because people also pass NULL alot, we need to use a function :-(
		/*
		#define pbstg_free(pthis, stg) \
				MemFreePtr( stg )
		*/

		/*
		#define pbstg_realloc(pthis, pOldStorage, iNumberOfBytes, subPool) \
			((pOldStorage != NULL) ? \
				MemReAllocPtr( pOldStorage, iNumberOfBytes, 0 ) : \
				pbstg_alloc(pthis, iNumberOfBytes, subPool))
		*/

		/*
		#define pbstg_size( pthis, pStg ) MemSizePtr( pStg )
		*/

#define pbstg_alloc_align(a,b,c,d)     pbstg_alloc(a,b,c)
#define pbstg_realloc_align(a,b,c,d,e) pbstg_realloc(a,b,c,d)

#define pbstg_setOwner(pthis, name) \
	(((pthis) != NULL) ? \
		((ppbstg_anchor)(pthis))->lpszOwner = name : NULL)

		// this lets us make sure we don't stomp on subpools
		// SmartHeap does not need to worry about this.
#define pbstg_synchronize_subpool( pthis, subpool )

// DOINC popped back into header 'pbstg.h'
#else
		// use homegrown heap manager
		// ***** DOINC including pbheap.h *****
		/* *********************************************************************** */
		/*  Storage manager blocks                                                 */
		/* *********************************************************************** */
#define PBSTG_LOCAL  0x0001
#define PBSTG_GLOBAL 0x0002

#ifndef COREPTR
#define COREPTR PVOID
#endif

#ifdef STRICT_SUBPOOL
// this allows us to do strict type checking of subpool usage
		typedef struct
		{
			ULONG v;
		} pbstg_subpool;

		static pbstg_subpool PBSTG_DEFAULT = { 0 };

#define pbstg_subpool_eq( sp1, sp2 ) ((sp1).v == (sp2).v)
#define pbstg_subpool_value( sp ) ((sp).v)
#else
// this is the normal case for our heap implementation
		typedef ULONG pbstg_subpool;
#define PBSTG_DEFAULT 0L

#define pbstg_subpool_eq( sp1, sp2 ) ((sp1) == (sp2))
#define pbstg_subpool_value( sp ) ((sp))
#endif

		typedef struct stg_anchorS {
			PVOID spAnchor;    /* Ptr to anchor block (a block of subpool ids) */
			PVOID sosCatch;             /* Short on storage catcher */
			pbstg_subpool defaultSubPool; /* subpool when PBSTG_DEFAULT specified */
			pbstg_subpool generateSubPool;/* When user asks for another sp */
			LONG  lStgCount;            /* Items currently allocated */
			LONG  lStgHigh;             /* Storage high water mark */
			LONG  lStgBlks;             /* # of blocks allocated */
			unsigned short   blocksize; /* Block size requested (4096) - sizeof(COREHEADER) */
			GLOBALHANDLE handle;        /* handle of this block */
			UINT iAllocFlags;           /* Allocation flags  */
			PVOID pLastAlloc;           /* Last allocated block */
			GLOBALHANDLE hLastAlloc;    /* Keep last allocated block's handle, too */
#ifdef	PB_ENABLE_ALLOCATION_TRACKING
			LPTSTR lpszOwner;            /* owner of the storage anchor */
			LPTSTR lpszContext;          /* context of person calling begin */
			LONG  lLineNo;
			struct stg_anchorS FAR* pNext; /* link to next storage anchor in list */
#endif
#ifdef PBDEBUG
			TCHAR  debugString[8];       /* if debug on, stick a "stgthis " literal in here*/
#endif   
		} pbstg_anchor;

#ifndef PPBSTG_ANCHOR_DEFINED
#define PPBSTG_ANCHOR_DEFINED
		typedef struct stg_anchorS FAR* ppbstg_anchor;
#endif

#define PBSTG_HUGE_OFFSET 16

		/* *********************************************************************** */
		/*  Prototype functions                                                    */
		/* *********************************************************************** */

		/* Storage management functions */
		PBWINAPI(ppbstg_anchor, pbstg_begin)(short buffer);
		PBWINAPI(ppbstg_anchor, pbstg_begin_allocflags)(short buffer, UINT lAllocFlags);
		PBWINAPI(ppbstg_anchor, pbstg_begin_nofast)(short buffer);
		PBWINAPI(PVOID, pbstg_alloc)(ppbstg_anchor pthis, ULONG iNumberOfBytes, pbstg_subpool subPool);
		PBWINAPI(void, pbstg_set_pool_name)(ppbstg_anchor pthis, pbstg_subpool subPool, LPTSTR lpstrName);

		PBWINAPI(ppbstg_anchor, pbstg_dbbegin)(short buffer, LPTSTR lpszFileName, ULONG lLineNumber);
		PBWINAPI(ppbstg_anchor, pbstg_dbbegin_allocflags)(short buffer, UINT lAllocFlags, LPTSTR lpszFileName, ULONG lLineNumber);
		PBWINAPI(PVOID, pbstg_dballoc)(ppbstg_anchor pthis, ULONG iNumberOfBytes, pbstg_subpool subPool, LPTSTR lpszFileName, ULONG lLineNumber);
		PBWINAPI(PVOID, pbstg_dbrealloc)(ppbstg_anchor pthis, PVOID pOldStorage, ULONG iNumberOfBytes, pbstg_subpool subPool, LPTSTR lpszFileName, ULONG lLineNumber);
		PBWINAPI(LPTSTR, pbstg_dbstrdup)(ppbstg_anchor pthis, LPCTSTR pszString, pbstg_subpool subpool, LPTSTR lpszFileName, ULONG lLineNumber);

		PBWINAPI(LPTSTR, pbstg_allo_tstring)(ppbstg_anchor pthis, ULONG iNumberOfBytes, pbstg_subpool subPool);
		PBWINAPI(unsigned int, pbstg_allo_tstringlen)(LPTSTR s);
		PBWINAPI(pbstg_subpool, pbstg_default_pool)(ppbstg_anchor pthis, pbstg_subpool subPool);
		PBWINAPI(void, pbstg_end)(ppbstg_anchor pthis);
		PBWINAPI(void, pbstg_free)(ppbstg_anchor pthis, PVOID stg);
		PBWINAPI(void, pbstg_free_pool)(ppbstg_anchor pthis, pbstg_subpool subPool);
		PBWINAPI(pbstg_subpool, pbstg_get_pointer_subpool)(ppbstg_anchor pthis, PVOID stg);
		PBWINAPI(pbstg_subpool, pbstg_new_pool)(ppbstg_anchor pthis);
		PBWINAPI(pbstg_subpool, pbstg_new_pool_nofast)(ppbstg_anchor pthis);
		PBWINAPI(PVOID, pbstg_realloc)(ppbstg_anchor pthis, PVOID pOldStorage, ULONG iLength, pbstg_subpool subPool);
		PBWINAPI(void, pbstg_set_next_pool)(ppbstg_anchor pthis, pbstg_subpool subPool);
		PBWINAPI(ULONG, pbstg_size)(ppbstg_anchor pthis, PVOID pStg);
		PBWINAPI(PVOID, pbstg_sos)(ppbstg_anchor pthis, PVOID ca);  /* returns prior SOS catch buffer */
		PBWINAPI(short, pbstg_validate)(ppbstg_anchor pthis);
		PBWINAPI(short, pbstg_write_debug)(ppbstg_anchor pthis, pbstg_subpool subpool, LPTSTR lpFile);
		PBWINAPI(VOID, pbstg_stat)(ppbstg_anchor pthis, pbstg_statistics FAR* stat);
		PBWINAPI(VOID, pbstg_shrink)(ppbstg_anchor pThis);
		PBWINAPI(LONG, pbstg_nextGeneration)();
		PBWINAPI(VOID, pbstg_dumpLeaks)(long generation);
		PBWINAPI(VOID, pbstg_dumpHeap)();
		PBWINAPI(BOOL, pbstg_set_poolpagesize)(ppbstg_anchor pthis, ULONG pagesize);

		PBWINAPI(ULONG, pbstg_fast_strlen)(LPTSTR s);

		// this lets us make sure we don't stomp on subpools in distributed
#define pbstg_synchronize_subpool( pthis, subpool ) \
	(pbstg_subpool_value( ((ppbstg_anchor)(pthis))->generateSubPool ) = \
		pbstg_subpool_value((subpool)) + 1)


#ifdef PBOS_WIN
		PBWINAPI(PVOID, pbstg_alloc_align)(ppbstg_anchor pthis, ULONG iNumberOfBytes, pbstg_subpool subPool, UINT iStructSize);
		PBWINAPI(PVOID, pbstg_realloc_align)(ppbstg_anchor pthis, PVOID pOldStorage, ULONG lSize, pbstg_subpool sp, UINT iStructSize);
#else
#define pbstg_alloc_align(a,b,c,d)     pbstg_alloc(a,b,c)
#define pbstg_realloc_align(a,b,c,d,e) pbstg_realloc(a,b,c,d)
#endif

#ifdef PB_ENABLE_ALLOCATION_TRACKING
#pragma message("debug,reroute pbstg_alloc to pbstg_dballoc")
#define pbstg_alloc(pthis,iNumberOfBytes,subPool) pbstg_dballoc(pthis,iNumberOfBytes,subPool,__FILE__,__LINE__)
#define pbstg_realloc(pthis,lpOldStore,iNumberOfBytes,subPool) pbstg_dbrealloc(pthis,lpOldStore,iNumberOfBytes,subPool,__FILE__,__LINE__)
#define pbstg_strdup(pthis,string,subPool) pbstg_dbstrdup(pthis,string,subPool,__FILE__,__LINE__)
#define pbstg_begin(buffer) pbstg_dbbegin(buffer,__FILE__,__LINE__)
#define pbstg_begin_allocflags(buffer,flags) pbstg_dbbegin_allocflags(buffer,flags,__FILE__,__LINE__)

#define pbstg_setOwner(pthis, name) (((pthis) != NULL) ? ((ppbstg_anchor)(pthis))->lpszOwner = name : NULL)
#else
#define pbstg_setOwner(pthis, name)
#endif // PB_ENABLE_ALLOCATION_TRACKING



// DOINC popped back into header 'pbstg.h'
#endif

#if defined (USE_SYBHEAP) && !defined(_AIX)
/* /#pragma message ("Using Sybheap") */
// temporary ?? defines and include to use the EAServer memory manager symbols
// ***** DOINC including spbheap.h *****
/*
 * spbheap.h
 * Confidential property of Sybase, Inc.
 * (c) Copyright Sybase, Inc. 2003
 * All rights reserved.
 */

#ifndef __PBHEAP_H__
#define __PBHEAP_H__

#include <csconfig.h>
 /*#define CS_PUBLIC
 #define CS_CDECL
 typedef unsigned long CS_UINT;*/

#include <stdio.h>

#ifdef __cplusplus
		extern "C"
		{
#endif

			extern volatile int spinMax;

			typedef struct _PbHeapTypeInfo
			{
				char* type;
				char* alloc;
				char* free;
				char* file;
				CS_UINT line;
			} *PbHeapTypeInfo;

#define PB_HEAP_SHOW_BLOCK_DATA			 1
#define PB_HEAP_SHOW_SUMMARY_ONLY		 2

			typedef void (CS_PUBLIC* PbHeapLogFunc)(char*);

			void CS_PUBLIC PbHeap_init();

			void CS_PUBLIC PbHeap_setCheckInterval(int value);

			void CS_PUBLIC PbHeap_showFullPath(int value);

			void CS_PUBLIC PbHeap_showBufferMaximumBytes(size_t bytes);

			void CS_PUBLIC PbHeap_log(FILE* file, PbHeapLogFunc func);

			void CS_PUBLIC PbHeap_error(char* format, ...);

			void CS_PUBLIC PbHeap_exception(char* format, ...);

			void* CS_PUBLIC PbHeap_allocPerm(size_t size);

			void* CS_PUBLIC PbHeap_allocPool(void* userData);

			void CS_PUBLIC PbHeap_freePool(void* pool);

			size_t CS_PUBLIC PbHeap_poolSize(void* pool);

			void* CS_PUBLIC PbHeap_userData(void* pool);

			void* CS_PUBLIC PbHeap_allocFromPool(size_t size, PbHeapTypeInfo typeInfo, void* pool);

			void* CS_PUBLIC PbHeap_alloc(size_t size, PbHeapTypeInfo typeInfo, void* parent);

			void* CS_PUBLIC PbHeap__alloc(size_t size, const char* type, const char* alloc, const char* free, const char* file, CS_UINT line, void* parent);

#ifdef PBOS_UNIX
			void* CS_CDECL PbHeap_malloc(size_t size);

			void* CS_CDECL PbHeap_calloc(size_t nobj, size_t size);

			void* CS_CDECL PbHeap_realloc(void* ptr, size_t size);

			void CS_CDECL PbHeap_free(void* block);
#else
			void* _cdecl PbHeap_malloc(size_t size);

			void* _cdecl PbHeap_calloc(size_t nobj, size_t size);

			void* _cdecl PbHeap_realloc(void* ptr, size_t size);

			void _cdecl PbHeap_free(void* block);
#endif

			void CS_PUBLIC PbHeap_freeIfParent(void* block);

			void CS_PUBLIC PbHeap_adopt(void* child, void* parent);

			void* CS_PUBLIC PbHeap_parent(void* block);

			size_t CS_PUBLIC PbHeap_size(void* block);

			void CS_PUBLIC PbHeap_sizeEx(void* block, size_t* oldSize, size_t* minSize, size_t* maxSize);

			void* CS_PUBLIC PbHeap_resize(void* block, size_t oldSize, size_t newSize, size_t minSize, size_t maxSize);

			size_t CS_PUBLIC PbHeap_totalSizeVM();

			void CS_PUBLIC PbHeap_debugOn();

			void CS_PUBLIC PbHeap_debugOff();

			void CS_PUBLIC PbHeap_checkOn();

			void CS_PUBLIC PbHeap_checkOff();

			void CS_PUBLIC PbHeap_check(void* block);

			void CS_PUBLIC PbHeap_checkAll();

			void CS_PUBLIC PbHeap_traceOn();

			void CS_PUBLIC PbHeap_traceOff();

			void CS_PUBLIC PbHeap_dump(int flags);

#ifdef __cplusplus
		}
#endif

#endif
		// DOINC popped back into header 'pbstg.h'
#if defined malloc
#undef malloc
#endif
#define malloc PbHeap_malloc
#if defined _alloca
#undef _alloca
#endif
#define _alloca PbHeap_malloc
#if defined alloca
#undef alloca
#endif
#define alloca PbHeap_malloc
#if defined realloc
#undef realloc
#endif
#define realloc PbHeap_realloc
#if defined calloc
#undef calloc
#endif
#define calloc PbHeap_calloc
#if defined free
#undef free
#endif
#define free PbHeap_free
#define _INC_MALLOC             // prevents the MS malloc.h from being included
#endif



/* WARNING: OBSOLETE FUNCTIONS  */
		PBWINAPI(int, pbstg_ansitoupper)(int c);
		PBWINAPI(int, pbstg_ansitolower)(int c);

		/* STG String management functions */
		PBWINAPI(LPTSTR, pbstg_strdup)(ppbstg_anchor pthis, LPCTSTR string, pbstg_subpool subpool);
		PBWINAPI(LPTSTR, pbstg_strdup_malloc)(LPTSTR  lpstrString);
		PBWINAPI(void, pbstg_str_build)(ppbstg_anchor sa, pbstg_subpool subpool,
			LPTSTR FAR* syn, LONG FAR* synLen,
			LONG FAR* synOff, LPTSTR string);
		PBWINAPI(void, pbstg_str_build_char)(ppbstg_anchor sa, pbstg_subpool subpool,
			LPTSTR FAR* syn, LONG FAR* synLen,
			LONG FAR* synOff, TCHAR c);
		PBWINAPI(void, pbstg_str_build_huge)(ppbstg_anchor sa, pbstg_subpool subpool,
			LPTSTR FAR* syn, LONG FAR* synLen,
			LONG FAR* synOff, TCHAR HUGEPTR* string);
		PBWINAPI(LPTSTR, pbstg_str_remove_char)(LPTSTR  string, TCHAR c);

		// A .C file does not support default parameters
#ifdef __cplusplus
		PBWINAPI(LPTSTR, pbstg_str_trim_left)(LPTSTR  string, BOOL IncludeAllSpaceTypes = TRUE);
		PBWINAPI(LPTSTR, pbstg_str_trim_right)(LPTSTR  string, BOOL IncludeAllSpaceTypes = TRUE);
		PBWINAPI(LPTSTR, pbstg_str_trim)(LPTSTR  string, BOOL IncludeAllSpaceTypes = TRUE);
#endif

		PBWINAPI(LPTSTR, pbstg_str_wordcap)(LPTSTR s);

		/* Integer conversion functions. */
		PBWINAPI(INT, pbstg_atoi_imp)(LPTSTR);
		PBWINAPI(double, pbstg_atof_imp)(LPTSTR);
		PBWINAPI(double, pbstg_strtod_imp)(LPTSTR pText, LPTSTR FAR* endptr);
		PBWINAPI(LONG, pbstg_atol_imp)(LPTSTR);
		PBWINAPI(LONG, pbstg_strtol_imp)(LPTSTR, LPTSTR FAR*, int);
		PBWINAPI(UINT, pbstg_atou_imp)(LPTSTR);
		PBWINAPI(ULONG, pbstg_atoul_imp)(LPTSTR);
		PBWINAPI(ULONG, pbstg_strtoul_imp)(LPTSTR, LPTSTR FAR*, int);
		PBWINAPI(INT, pbstg_remove_imp)(LPTSTR);

#ifdef PBWIN32
		/* COMMON TO PBWIN32 */
#define pbstg_atou(s) 			pbstg_atou_imp(s)
#define pbstg_atoul(s) 			pbstg_atoul_imp(s)
#define pbstg_remove(s) 		pbstg_remove_imp(s)
#if defined(PS_UNICODE)
#ifndef PBOS_UNIX
#define pbstg_atof(s) 			((float)(wcstod(s,NULL)))
#define pbstg_atoi(s) 			_wtoi(s)
#define pbstg_atol(s) 			_wtol(s)
#define pbstg_strtod(s,p)		wcstod(s,p)
#define pbstg_strtol(s, ps, i)	wcstol(s, ps, i)
#define pbstg_strtoul(s, ps, i)	wcstoul(s, ps, i)
#define pbstg_atoi64(s)			_wtoi64(s)
#else
#define pbstg_atof(s) 			((float)(wcstod(s,NULL)))
#define pbstg_atoi(s) 			((int)wcstol((s), (wchar_t **)0, 10))
#define pbstg_atol(s) 			wcstol((s), (wchar_t **)0, 10)
#define pbstg_strtoul(s, ps, i)	wcstoul(s, ps, i)
#define pbstg_strtol(s, ps, i)	wcstol(s, ps, i)
#define pbstg_strtod(s,p)		wcstod(s,p)
#ifdef PBOS_LINUX
#define pbstg_atoi64(s)			((long long)(wcstold(s,NULL)))
#elif defined(__hpux)
		long long __wcstoll(const wchar_t* nptr, wchar_t** endptr, int base);
#define pbstg_atoi64(s)			((long long)(__wcstoll(s,NULL,10)))
#else
#define pbstg_atoi64(s)			((long long)(wcstod(s,NULL)))
#endif
#endif  /*unicode*/
#else
#define pbstg_atof(s) 			atof(s)
#define pbstg_atoi(s) 			atoi(s)
#define pbstg_atol(s) 			atol(s)
#define pbstg_strtod(s,p)		strtod(s,p)
#define pbstg_strtol(s, ps, i)	strtol(s, ps, i)
#define pbstg_strtoul(s, ps, i)	strtoul(s, ps, i)
#if defined(__sun)
#define pbstg_atoi64(s)			atoll(s)
#elif defined(_AIX)
#define pbstg_atoi64(s)			atof(s)
#elif defined(__hpux)
#define pbstg_atoi64(s)                 atof(s)
#elif defined(PBOS_LINUX)
#define pbstg_atoi64(s)                 atof(s)
#else
#define pbstg_atoi64(s)			_atoi64(s)
#endif
#endif
#else /* not PBWIN32 */							
#define pbstg_atof(s) 			pbstg_atof_imp(s)
#define pbstg_strtod(s,p)		pbstg_strtod_imp(s,p)
#define pbstg_atoi(s) 			pbstg_atoi_imp(s)
#define pbstg_atol(s) 			pbstg_atol_imp(s)
#define pbstg_atou(s) 			pbstg_atou_imp(s)
#define pbstg_atoul(s) 			pbstg_atoul_imp(s)
#define pbstg_strtol(s, ps, i)	pbstg_strtol_imp(s, ps, i)
#define pbstg_strtoul(s, ps, i)	pbstg_strtoul_imp(s, ps, i)
#define pbstg_remove(s) 		pbstg_remove_imp(s)
#endif 

		/* johnf: Save these until after the Unicode conversion... */
#define PBSTG_ATOF(s) 				pbstg_atof_imp(s)
#define PBSTG_STRTOD(s,p)			pbstg_strtod_imp(s,p)
#define PBSTG_ATOI(s)	 			pbstg_atoi_imp(s)
#define PBSTG_ATOL(s)	 			pbstg_atol_imp(s)
#define PBSTG_ATOU(s)	 			pbstg_atou_imp(s)
#define PBSTG_ATOUL(s) 				pbstg_atoul_imp(s)
#define PBSTG_STRTOL(s, ps, i)		pbstg_strtol_imp(s, ps, i)
#define PBSTG_STRTOUL(s, ps, i)		pbstg_strtoul_imp(s, ps, i)
#define PBSTG_REMOVE(s)	 			pbstg_remove_imp(s)
/* end of save */

/* STG dde storage management.  When you have to share data via dde. */
		PBWINAPI(PVOID, pbstg_dde_alloc)(unsigned short iNumberOfBytes);
		PBWINAPI(void, pbstg_dde_free)(PVOID);
		PBWINAPI(GLOBALHANDLE, pbstg_dde_get_handle)(PVOID);
		PBWINAPI(PVOID, pbstg_dde_lock)(GLOBALHANDLE);
		PBWINAPI(void, pbstg_dde_unlock)(GLOBALHANDLE);
		PBWINAPI(LPTSTR, pbstg_dde_strdup)(LPTSTR  string);

		/* STG HUGE storage management. */
		PBWINAPI(short, pbstg_huge_memcmp) (void HUGEPTR* v1, void HUGEPTR* v2, ULONG count);
		PBWINAPI(void HUGEPTR*, pbstg_huge_memcpy) (void HUGEPTR* v1, void HUGEPTR* v2, ULONG count);
		PBWINAPI(void HUGEPTR*, pbstg_huge_memmove)(void HUGEPTR* v1, void HUGEPTR* v2, ULONG count);
		PBWINAPI(void HUGEPTR*, pbstg_huge_memset)(void HUGEPTR* v1, short c, ULONG count);
		PBWINAPI(TCHAR HUGEPTR*, pbstg_huge_strchr) (TCHAR HUGEPTR* s, TCHAR c);
		PBWINAPI(TCHAR HUGEPTR*, pbstg_huge_strcpy) (TCHAR HUGEPTR* s, TCHAR HUGEPTR* s2);
		PBWINAPI(ULONG, pbstg_huge_strlen) (TCHAR HUGEPTR* s);
		PBWINAPI(TCHAR HUGEPTR*, pbstg_huge_strncpy) (TCHAR HUGEPTR* s, TCHAR HUGEPTR* s2, ULONG count);
		PBWINAPI(TCHAR HUGEPTR*, pbstg_huge_strstr) (TCHAR HUGEPTR* s, TCHAR HUGEPTR* s2);
#ifdef PBWIN32
#define PBSTG_HUGE_MEMCPY(v1, v2, count) pbstg_memcpy((v1), (v2), (count))
#define PBSTG_HUGE_MEMMOVE(v1, v2, count) pbstg_memmove((v1), (v2), (count))
#define PBSTG_HUGE_MEMSET(v1, c, count) pbstg_memset((v1), (c), (count))
#define PBSTG_HUGE_STRCHR(s, c) pbstg_strchr(s,  c)
#define PBSTG_HUGE_STRCPY(x, y) pbstg_strcpy(x, y)
#define PBSTG_HUGE_STRLEN(s) pbstg_strlen(s)
#define PBSTG_HUGE_STRNCPY(x, y, c) pbstg_strncpy(x, y, c)
#else /* NOT PBWIN32 */
#define PBSTG_HUGE_MEMCPY(v1, v2, count) hmemcpy((v1), (v2), (count))
#define PBSTG_HUGE_MEMMOVE(v1, v2, count) pbstg_huge_memmove((v1), (v2), (count))
#define PBSTG_HUGE_MEMSET(v1, c, count) pbstg_huge_memset((v1), (c), (count))
#define PBSTG_HUGE_STRCHR(s, c) pbstg_huge_strchr(s, c)
#define PBSTG_HUGE_STRCPY(x, y) pbstg_huge_strcpy(x, y)
#define PBSTG_HUGE_STRLEN(s) pbstg_huge_strlen(s)
#define PBSTG_HUGE_STRNCPY(x, y, c) pbstg_huge_strncpy(x, y, c)
#endif /* PBWIN32 */

		/* Profile (.INI file) management functions */
		PBWINAPI(INT, OS_UtilGetProfInt)(LPCTSTR lpSection, LPCTSTR lpKey, INT   nDefault);
		PBWINAPI(INT, OS_UtilGetProfStr)(LPCTSTR lpSection, LPCTSTR lpKey, LPCTSTR lpDefault, LPTSTR lpReturnedStr, INT nSize);
		PBWINAPI(INT, OS_UtilPutProfStr)(LPCTSTR pSection, LPCTSTR pKey, LPCTSTR pValue);
		PBWINAPI(INT, OS_NetworkGetProfInt)(LPTSTR lpSection, LPTSTR lpKey, INT   nDefault);
		PBWINAPI(INT, OS_NetworkGetProfStr)(LPTSTR lpSection, LPTSTR lpKey, LPTSTR lpDefault, LPTSTR lpReturnedStr, INT nSize);
		PBWINAPI(INT, OS_NetworkPutProfStr)(LPTSTR pSection, LPTSTR pKey, LPTSTR pValue);
		PBWINAPI(INT, OS_NetworkSharedProfileAccessible)(VOID);
		PBWINAPI(LPTSTR, OS_UtilGetInitPath)(LPTSTR    pBuff, INT nBuffLen, LPTSTR pName);
		PBWINAPI(BOOL, OS_UtilPutInitPath)(LPTSTR pBuff);
		PBWINAPI(LPTSTR, UtilIniFile)(LPTSTR lpszFileNameBuf, WORD cbFileNameBufSize, BOOL bCheck);
		PBWINAPI(DWORD, FDCC_Get_Registry_Entry)(LPTSTR pEntryname, LPTSTR pValue, INT nBuffLen, LPTSTR pToolName);
		PBWINAPI(DWORD, FDCC_Get_CSIDL_Path)(INT CSIDL_Value, LPTSTR pPath, INT nBuffLen, BOOL bWithSuffix, BOOL bCreate);
		PBWINAPI(BOOL, FDCC_Create_Registry_Entry)(LPTSTR pEntryName, LPTSTR pValue);
		PBWINAPI(DWORD, FDCC_Get_Install_Location)(LPTSTR pValue, INT nBuffLen, INT iSuffix);
		PBWINAPI(BOOL, FDCC_New_INI_Installed)(LPTSTR pNewIniFileName);


#endif /* PBSTG_MACROS_ONLY */

		/*
		   PBSTG.H MACRO SECTION
		*/

		// UNICODE macros that always operate on UNICODE strings 
		PBWINAPI(LPWSTR, pbstg_unicodestrdup)(ppbstg_anchor sa, LPCWSTR pwsz, pbstg_subpool subpool);
		PBWINAPI(void, pbstg_unicodestr_build)(ppbstg_anchor sa, pbstg_subpool subpool, LPWSTR* syn, LONG* synLen, LONG* synOff, LPCWSTR string);
#define pbstg_unicodestrcmp(s1,s2)		wcscmp(s1,s2)
#define pbstg_unicodestrncmp(s1,s2,n)	wcsncmp(s1,s2,n)
		// pbstg_unicodestrlen returns number of characters excluding NULL terminator
#define pbstg_unicodestrcmpi(s1,s2)		wcsicmp(s1,s2)
#define pbstg_unicodestrlen(s)			wcslen(s)
#define pbstg_unicodestrcpy(s1,s2)		wcscpy(s1,s2)
// END UNICODE

// String conversion macros:
		PBWINAPI(LPWSTR, pbstg_strtounicodedup)(ppbstg_anchor pthis, LPCTSTR psz, pbstg_subpool subpool);
		PBWINAPI(LPTSTR, pbstg_unicodetostrdup)(ppbstg_anchor pthis, LPCWSTR pwsz, pbstg_subpool subpool);
		PBWINAPI(LPSTR, pbstg_strtoansidup)(ppbstg_anchor pthis, LPCTSTR psz, pbstg_subpool subpool);
		PBWINAPI(LPTSTR, pbstg_ansitostrdup)(ppbstg_anchor pthis, LPCSTR pasz, pbstg_subpool subpool);
		PBWINAPI(LPSTR, pbstg_strtoprintable)(LPSTR dest, LPCTSTR source);
		PBWINAPI(LPSTR, pbstg_strtoprintabledup)(ppbstg_anchor pthis, LPCTSTR psz, pbstg_subpool subpool);
		PBWINAPI(LPTSTR, pbstg_printabletostr)(LPTSTR dest, LPCSTR source);
		PBWINAPI(LPTSTR, pbstg_printabletostrdup)(ppbstg_anchor pthis, LPCSTR pasz, pbstg_subpool subpool);
		PBWINAPI(LPTSTR, PBUNI_memchr)(LPTSTR lpszString, TCHAR cToFind, ULONG ulLength);

#ifdef PS_UNICODE
#define pbstg_strtounicode(d,s,n)	(pbstg_strncpy(d,s,n),1)
#define pbstg_unicodetostr(d,s,n)	(pbstg_strncpy(d,s,n),1)
#if !defined(__sun)
#define pbstg_strtoansi(d,s,n)		wcstombs(d,s,n)
#define pbstg_ansitostr(d,s,n)		mbstowcs(d,s,n)
#else
		size_t pbstg_ansitostr(wchar_t* pwcs, const char* s, size_t n);
		size_t pbstg_strtoansi(char* s, const wchar_t* pwcs, size_t n);
#endif
#else // ANSI
#define pbstg_strtounicode(d,s,n)	mbstowcs(d,s,n)
#define pbstg_unicodetostr(d,s,n)	wcstombs(d,s,n)
#define pbstg_strtoansi(d,s,n)		(pbstg_strncpy(d,s,n),1)
#define pbstg_ansitostr(d,s,n)		(pbstg_strncpy(d,s,n),1)
#endif

#ifdef PS_UNICODE
#define pbstg_strtounicodelen(s) pbstg_strlen(s)
#define pbstg_unicodetostrlen(s) pbstg_strlen(s)
#if !defined(__sun)
#define pbstg_strtoansilen(s)    wcstombs(NULL, s, 0)
#else
#define pbstg_strtoansilen(s)    pbstg_strtoansi(NULL, s, 0)
#endif
#define pbstg_ansitostrlen(s)    mbstowcs(NULL, s, 0)
#else // ANSI
#define pbstg_strtounicodelen(s) mbstowcs(NULL, s, 0)
#define pbstg_unicodetostrlen(s) wcstombs(NULL, s, 0)
#define pbstg_strtoansilen(s)    pbstg_strlen(s)
#define pbstg_ansitostrlen(s)    pbstg_strlen(s)
#endif

#ifdef PS_UNICODE
		PBWINAPI(size_t, pbstg_UCS2toUTF8)(char* utf8, const TCHAR* ucs2, size_t count);
		PBWINAPI(size_t, pbstg_UTF8toUCS2)(TCHAR* ucs2, const char* utf8, size_t  count);

#define pbstg_UCS2toUTF8len(s) pbstg_UCS2toUTF8(NULL, s, 0)
#define pbstg_UTF8toUCS2len(s) pbstg_UTF8toUCS2(NULL, s, 0)

		// The prototype is actually the same as mbstowcs() except it 
		// will forcefully convert unrecognized character to '?'
		//
		// If hasUnrecognizedChar == NULL, the status will not be reported
		PBWINAPI(size_t, mbstowcs_force)(wchar_t* wcstr, const char* mbstr, size_t count, BOOL* hasUnrecognizedChar);
#endif

		// Convert and duplicate strings using pbstg storage manager.
		// Caller must free the string using pbstg_free.



		// OLE (LPOLESTR) to native string (LPTSTR) conversions.
		// These are preferred over the W2A() and A2W() macros.
#ifdef  PBOS_NT
  // **** Win32 ****
#if defined(PS_UNICODE)
  // OLE and native text are the same size (Ansi or Unicode)
  // This includes Win32-Unicode builds
#define pbstg_olestrtostr(d,s,n)	pbstg_strncpy(d,s,n)
#define pbstg_strtoolestr(d,s,n)	pbstg_strncpy(d,s,n)
#define pbstg_olestrtostrdup(a,s,p)	pbstg_strdup(a,s,p)
#define pbstg_strtoolestrdup(a,s,p)	pbstg_strdup(a,s,p)
// strlen - to me, only the 'pbstg_olestrlen()' makes sense...
#define pbstg_olestrtostrlen(s)		pbstg_strlen(s)
#define pbstg_strtoolestrlen(s)		pbstg_strlen(s)
#define pbstg_olestrlen(s)    		pbstg_strlen(s)
#define pbstg_olestrcmp(s1,s2)		pbstg_strcmp(s1,s2)
#define pbstg_olestrcmpi(s1,s2)		pbstg_strcmpi(s1,s2)
#else
  // OLE is Unicode, native text is Ansi
  // This includes Win32-Ansi builds
#define pbstg_olestrtostr(d,s,n)	pbstg_unicodetostr(d,s,n)
#define pbstg_strtoolestr(d,s,n)	pbstg_strtounicode(d,s,n)
#define pbstg_olestrtostrdup(a,s,p)	pbstg_unicodetostrdup(a,s,p)
#define pbstg_strtoolestrdup(a,s,p)	pbstg_strtounicodedup(a,s,p)
// strlen - to me, only the 'pbstg_olestrlen()' makes sense...
#define pbstg_olestrtostrlen(s)		pbstg_unicodetostrlen(s)
#define pbstg_strtoolestrlen(s)		pbstg_strtounicodelen(s)
#define pbstg_olestrlen(s)    		pbstg_unicodetostrlen(s)
#define pbstg_olestrcmp(s1,s2)		wcscmp(s1,s2)
#define pbstg_olestrcmpi(s1,s2)		_wcsicmp(s1,s2)
#endif
#else
	// **** UNIX ****
	// OLE and native text are the same size (all 8bit chars)
	// This includes Unix (Bristol)
#define pbstg_olestrtostr(d,s,n)	pbstg_strncpy(d,s,n)
#define pbstg_strtoolestr(d,s,n)	pbstg_strncpy(d,s,n)
#define pbstg_olestrtostrdup(a,s,p)	pbstg_strdup(a,s,p)
#define pbstg_strtoolestrdup(a,s,p)	pbstg_strdup(a,s,p)
// strlen - to me, only the 'pbstg_olestrlen()' makes sense...
#define pbstg_olestrtostrlen(s)		pbstg_strlen(s)
#define pbstg_strtoolestrlen(s)		pbstg_strlen(s)
#define pbstg_olestrlen(s)    		pbstg_strlen(s)
#define pbstg_olestrcmp(s1,s2)		pbstg_strcmp(s1,s2)
#define pbstg_olestrcmpi(s1,s2)		pbstg_strcmpi(s1,s2)
#endif

// BSTR conversion functions
// for codegen, we want to skip including this logging stuff
// DOINC told to skip 5 lines...

/* end String conversion macros */

/* COMMON MACROS FOR ALL  */
#ifndef pbstg_sprintf
#define pbstg_sprintf		wsprintf
#endif

#ifndef pbstg_vsprintf
#define pbstg_vsprintf		wvsprintf
#endif

#ifndef pbstg_wsprintf
#define pbstg_wsprintf		wsprintf
#endif

#ifndef pbstg_wvsprintf
#define pbstg_wvsprintf		wvsprintf
#endif

#ifndef pbstg_wsprintf_s
#ifdef PBSTG_SAFE_WSPRINTF
#define pbstg_wsprintf_s	StringCchPrintf
#else
#define pbstg_wsprintf_s(s,n,...)	pbstg_wsprintf(s, __VA_ARGS__)
#endif
#endif

#ifndef pbstg_sprintf_s
#define pbstg_sprintf_s	pbstg_wsprintf_s
#endif

#ifndef pbstg_wsprintf_safe
#ifdef PBSTG_INLINED_SAFE_FORTIFY_SCA
		_inline HRESULT pbstg_wsprintf_safe(LPTSTR pszDest, size_t cchDest, LPCTSTR pszFormat, ...)
		{
			va_list args;
			va_start(args, pszFormat);
			return StringCchVPrintf(pszDest, cchDest, pszFormat, args);
		}
#else
#define pbstg_wsprintf_safe	pbstg_wsprintf_s
#endif
#define pbstg_sprintf_safe pbstg_wsprintf_safe
#endif

#define pbstg_stralloc(pa, n, ps)		((LPTSTR)pbstg_alloc(pa, ( (n) * sizeof(TCHAR)), ps))
#define pbstg_strrealloc(pa, p,n, ps)	((LPTSTR)pbstg_realloc(pa,p, ( (n) * sizeof(TCHAR)), ps))
#define PBSIZE(x)						(sizeof(x)/sizeof((x)[0]))

#define pbstg_strlenA(s)				strlen(s)
#define pbstg_strlenW(s)				wcslen(s)

#if  defined(PBOS_UNIX) && !defined(PBOS_LINUX)
		wchar_t* _itow(int value, wchar_t* string, int radix);
		wchar_t* _ltow(long value, wchar_t* string, int radix);
		wchar_t* _ultow(unsigned long value, wchar_t* string, int radix);
#endif


		/* END COMMON MACROS FOR ALL */

#ifdef PBWIN32                                                  

#if defined(PBOS_UNIX) && !defined(PBOS_LINUX)/* unsupported stdlib functions mapped by Wind/U */
// ***** DOINC including wuStdlib.h *****
	// DOINC skipping missing include
// ***** DOINC including wudosmemory.h *****
	// DOINC skipping missing include
#endif

/* COMMON MACROS FOR PBWIN32  */
#define pbstg_charnext(s)				CharNext(s)
#define pbstg_charprev(s1, s2)			CharPrev(s1, s2)

/* Memory utility functions */
#define pbstg_memchr(m1, c, count)      memchr(m1, c, count)
#define pbstg_memcmp(m1, m2, c)         memcmp(m1, m2, c)
#define pbstg_memcpy(m1, m2, c)         memcpy(m1, m2, c)
#define pbstg_memicmp(m1, m2, c)        memicmp(m1, m2, c)
#define pbstg_memmove(m1, m2, c)        memmove(m1, m2, c)
#define pbstg_memset(m1, c, count)      memset(m1, (INT) c, count)
#define pbstg_memcpy_s(m1, s, m2, c)    memcpy_s(m1, s, m2, c)

/* Conversion functions */
#define pbstg_fcvt(a, b, c, d)          _fcvt(a, b, c, d)
#ifdef PS_UNICODE
#define pbstg_itoa(x, y, z)             _itow(x, y, z)
#define pbstg_ltoa(x, y, z)             _ltow(x, y, z)
#define pbstg_ultoa(x, y, z)			_ultow(x, y, z)
#else
#define pbstg_itoa(x, y, z)             _itoa(x, y, z)
#define pbstg_ltoa(x, y, z)             _ltoa(x, y, z)
#define pbstg_ultoa(x, y, z)			_ultoa(x, y, z)
#endif

		PBWINAPI(INT, pbstg_lchrcmp)(TCHAR c1, TCHAR c2);
		PBWINAPI(INT, pbstg_lchrcmpi)(TCHAR c1, TCHAR c2);
		/* END COMMON MACROS FOR PBWIN32  */

#ifdef  PS_DBCS						// KANJI

/*	WARNING: OBSOLETE FUNCTIONS - DO NOT USE.	*/
/* 8 bit ASCII string functions */
#define pbstg_ansilower(s)              (IsDBCS() ? fjstrlwr(s) : AnsiLower(s))
#define pbstg_ansiupper(s)              (IsDBCS() ? fjstrupr(s) : AnsiUpper(s))
#define pbstg_ansilowerbuff(s, i)       (IsDBCS() ? fjstrnlwr(s, i) : AnsiLowerBuff(s, i))
#define pbstg_ansiupperbuff(s, i)       (IsDBCS() ? fjstrnupr(s, i) : AnsiUpperBuff(s, i))
/* END OF OBSOLETE FUNCTIONS - See following for new functions  */
/* 8 bit ASCII string functions */
#define pbstg_charlower(s)              (IsDBCS() ? fjstrlwr(s) : CharLower(s))
#define pbstg_charupper(s)              (IsDBCS() ? fjstrupr(s) : CharUpper(s))
#define pbstg_charlowerbuff(s, i)       (IsDBCS() ? fjstrnlwr(s, i) : CharLowerBuff(s, i))
#define pbstg_charupperbuff(s, i)       (IsDBCS() ? fjstrnupr(s, i) : CharUpperBuff(s, i))

// ADC_DBCS_START_MODIFY cchong Mar 9 2000
// CR#206111: To enable trimming of DBCS white spaces
// Initial macros cast to "unsigned char" which was incorrect. For exmaple, when casted
// to unsigned char, _ismbcspace will not return true for DBCS white spaces.
#define pbstg_isspace(c)		(IsDBCS() ? _ismbcspace((unsigned int)(c)) : isspace(c))
#define pbstg_isdigit(c)		(IsDBCS() ? _ismbcdigit((unsigned int)(c)) : isdigit(c))
#define pbstg_isalnum(c)		(IsDBCS() ? _ismbcalnum((unsigned int)(c)) : isalnum(c))
#define pbstg_isalpha(c)		(IsDBCS() ? _ismbcalpha((unsigned int)(c)) : isalpha(c))
#define pbstg_iscntrl(c)		(IsDBCS() ? iscntrl((c)) : iscntrl(c))
#define pbstg_isgraph(c)		(IsDBCS() ? _ismbcgraph((unsigned int)(c)) : isgraph(c))
#define pbstg_islower(c)		(IsDBCS() ? _ismbclower((unsigned int)(c)) : islower(c))
#define pbstg_isprint(c)		(IsDBCS() ? _ismbcprint((unsigned int)(c)) : isprint(c))
#define pbstg_ispunct(c)		(IsDBCS() ? _ismbcpunct((unsigned int)(c)) : ispunct(c))
#define pbstg_isupper(c)		(IsDBCS() ? _ismbcupper((unsigned int)(c)) : isupper(c))
#define pbstg_isxdigit(c)		(IsDBCS() ? isxdigit(c) : isxdigit(c))
#define pbstg_isascii(c)        isascii(c)
// ADC_DBCS_END_MODIFY cchong Mar 9 2000

/* String functions */
#define pbstg_lstrcmp(x, y)             (IsDBCS() ? _mbscmp((const unsigned char *)(x), (const unsigned char *)(y)) : lstrcmp(x, y))
#define pbstg_lstrcmpi(x, y)            (IsDBCS() ? _mbsicmp((const unsigned char *)(x), (const unsigned char *)(y)) : lstrcmpi(x, y))
#define pbstg_mbsbtype(s, c)		_mbsbtype((const unsigned char *)(s), c)
#define pbstg_strcat(x, y)              (IsDBCS() ? ((LPTSTR)_mbscat((unsigned char *)(x), (const unsigned char *)(y))) : strcat(x, y))
#define pbstg_strchr(s, c)		(IsDBCS() ? ((TCHAR *)_mbschr((const unsigned char *)(s), (unsigned int)(c))) : ((char *)strchr(s, (int)(c))))
#define pbstg_strcmp(x, y)              (IsDBCS() ? _mbscmp((const unsigned char *)(x), (const unsigned char *)(y)) : strcmp(x, y))
#define pbstg_strcmpi(x, y)             (IsDBCS() ? _mbsicmp((const unsigned char *)(x), (const unsigned char *)(y)) : stricmp(x, y))
#define pbstg_strcpy(x, y)              (IsDBCS() ? ((LPTSTR)_mbscpy((unsigned char *)(x), (const unsigned char *)(y))) : strcpy((char *)(x), (const char *)(y)))
#define pbstg_strlen(s)                 strlen(s)
#define pbstg_strlwr(s)			(IsDBCS() ? ((TCHAR *)_mbslwr((unsigned char *)(s))) : strlwr((char *)(s)))
#define pbstg_strncat(x, y, i)          strncat(x, y, i)
#define pbstg_strncmp(x, y, i)          strncmp(x, y, i)
#define pbstg_strncpy(x, y, n)          strncpy(x, y, n)
#define pbstg_strnicmp(x, y, i)         strnicmp(x, y, i)
#define pbstg_strrchr(s, c) 		(IsDBCS() ? ((LPTSTR)_mbsrchr((const unsigned char *)(s), (unsigned int)(unsigned char)(c))) : strrchr(s, (INT)c))
#define pbstg_strpbrk(s1, s2) 		(IsDBCS() ? ((LPTSTR)_mbspbrk((const unsigned char *)(s1), (const unsigned char *)(s2))) : strpbrk(s1, s2))
#define pbstg_strstr(s1, s2)		(IsDBCS() ? ((LPTSTR)_mbsstr((const unsigned char *)(s1), (const unsigned char *)(s2))) : strstr(s1, s2))
#define pbstg_strtok(s1, s2)            (IsDBCS() ? ((LPTSTR)_mbstok((unsigned char *)(s1), (const unsigned char *)(s2))) : strtok(s1, s2))
#define pbstg_strupr(s)                 (IsDBCS() ? ((TCHAR *)_mbsupr((unsigned char *)(s))) : strupr((char *)(s)))
#define pbstg_strspn(s1, s2)		(IsDBCS() ? _mbsspn((const unsigned char *)(s1), (const unsigned char *)(s2)) : strspn(s1, s2))
#define pbstg_strcspn(s1, s2)		(IsDBCS() ? _mbscspn((const unsigned char *)(s1), (const unsigned char *)(s2)) : strcspn(s1, s2))
#define pbstg_strnset(s, c, n)		strnset(s, c, n)
//   Do not use strnset to try to fill an ENTIRE string buffer with a certain character.  Use pbstg_setstring
//   instead.  strnset will stop filling the buffer if it hits a null terminator prior to the Nth character. 
#define pbstg_setstring(buff, c, count)   memset(buff, (INT)c, count)

// Start For DBCS
#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline char* pbstg_strncpy_fp(char* s1, const char* s2, size_t c)
		{
			return pbstg_strncpy(s1, s2, c);
		}
#else
#define pbstg_strncpy_fp pbstg_strncpy     
#endif

#ifdef PBSTG_SAFE_STRCPY
#define pbstg_strcpy_s(x, c, y)         (IsDBCS() ? ((LPTSTR)_mbsnbcpy((unsigned char *)(x), (const unsigned char *)(y), c)) : ((StringCchCopyA((char *)(x), (c), (const char *)(y))),(char *)(x)))
#else
#define pbstg_strcpy_s(x, c, y)         pbstg_strcpy(x, y)
#endif

#ifdef PBSTG_SAFE_STRCPY
		_inline size_t pbstg_strlen_s(const char* s, size_t c)
		{
			size_t result;
			return (StringCchLengthA(s, c, &result) == S_OK ? result : c);
		}
#else
#define pbstg_strlen_s(s, c)            pbstg_strlen(s)
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline unsigned char* _mbscpy_fp(unsigned char* a, const unsigned char* b)
		{
			return _mbscpy(a, b);
		}
		_inline unsigned char* _mbscat_fp(unsigned char* a, const unsigned char* b)
		{
			return _mbscat(a, b);
		}
		_inline char* pbstg_strcpy_fp2(char* a, const char* b)
		{
			return strcpy(a, b);
		}
		_inline char* pbstg_strcat_fp2(char* a, const char* b)
		{
			return strcat(a, b);
		}
		_inline int _mbscmp_fp(const unsigned char* a, const unsigned char* b)
		{
			return _mbscmp(a, b);
		}
		_inline int strcmp_fp(const char* a, const char* b)
		{
			return strcmp(a, b);
		}
		_inline unsigned char* _mbsrchr_fp(const unsigned char* a, unsigned int b)
		{
			return _mbsrchr(a, b);
		}
		_inline char* strrchr_fp(const char* a, int b)
		{
			return strrchr(a, b);
		}
		_inline size_t pbstg_strlen_fp(const char* a)
		{
			return strlen(a);
		}
#else
#define _mbscpy_fp _mbscpy
#define _mbscat_fp _mbscat
#define pbstg_strcpy_fp2 strcpy
#define pbstg_strcat_fp2 strcat
#define _mbscmp_fp _mbscmp
#define strcmp_fp strcmp
#define _mbsrchr_fp _mbsrchr
#define strrchr_fp strrchr
#define pbstg_strlen_fp strlen
#endif

#define pbstg_strcpy_fp(x, y)       (IsDBCS() ? ((LPTSTR)_mbscpy_fp((unsigned char *)(x), (const unsigned char *)(y))) : pbstg_strcpy_fp2((char *)(x), (const char *)(y)))

#define pbstg_strcmp_fp(x, y)       (IsDBCS() ? _mbscmp_fp((const unsigned char *)(x), (const unsigned char *)(y)) : strcmp_fp(x, y))

#define pbstg_strcat_fp(x, y)              (IsDBCS() ? ((LPTSTR)_mbscat_fp((unsigned char *)(x), (const unsigned char *)(y))) : pbstg_strcat_fp2(x, y))

#define pbstg_strrchr_fp(s, c) 		(IsDBCS() ? ((LPTSTR)_mbsrchr_fp((const unsigned char *)(s), (unsigned int)(unsigned char)(c))) : strrchr_fp(s, (INT)c))

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline void* pbstg_memcpy_fp(void* a, const void* b, size_t c)
		{
			return pbstg_memcpy(a, b, c);
		}
#else
#define pbstg_memcpy_fp pbstg_memcpy
#endif


// End for DBCS

#elif defined(PS_UNICODE)			// UNICODE

/* 8 bit ASCII string functions */
#define pbstg_charlower(s)                      CharLower(s)
#define pbstg_charupper(s)                      CharUpper(s)
#define pbstg_charlowerbuff(s, i)               CharLowerBuff(s, i)
#define pbstg_charupperbuff(s, i)               CharUpperBuff(s, i)


/* String functions */
#define pbstg_lstrcmp(x, y)             lstrcmp(x, y)
#define pbstg_lstrcmpi(x, y)            lstrcmpi(x, y)
#define pbstg_isspace(c)				iswspace(c)
#define pbstg_isdigit(c)				iswdigit(c)
#if !defined(__sun)
#define pbstg_isalnum(c)				iswalnum(c)
#define pbstg_isalpha(c)				iswalpha(c)
#else
		int pbstg_isalnum(wint_t wc);
		int pbstg_isalpha(wint_t wc);
#endif
#define pbstg_iscntrl(c)				iswcntrl(c)
#define pbstg_isgraph(c)				iswgraph(c)
#define pbstg_islower(c)				iswlower(c)
#define pbstg_isprint(c)				iswprint(c)
#define pbstg_ispunct(c)				iswpunct(c)
#define pbstg_isupper(c)				iswupper(c)
#define pbstg_isxdigit(c)				iswxdigit(c)
#define pbstg_strcat(x, y)              wcscat(x, y)
#define pbstg_strchr(s, c)              wcschr(s, c)
#define pbstg_strcmp(x, y)              wcscmp(x, y)

#ifdef PBSTG_SAFE_STRCAT
#define pbstg_strcat_s(x, n, y)         StringCchCat(x, n, y)
#else
#define pbstg_strcat_s(x, n, y)         pbstg_strcat(x, y)
#endif

#ifdef PBSTG_SAFE_STRCAT
#define pbstg_strncat_s(x, n, y, c)         StringCchCatN(x, n, y, c)
#else
#define pbstg_stnrcat_s(x, n, y,c )         pbstg_strncat(x, y, c)
#endif

#ifdef PBSTG_INLINED_SAFE_FORTIFY_SCA
		_inline HRESULT pbstg_strcat_safe(LPTSTR pszDest, size_t cchDest, LPCTSTR pszSrc)
		{
			return StringCchCat(pszDest, cchDest, pszSrc);
		}
		_inline HRESULT pbstg_strncat_safe(LPTSTR pszDest, size_t cchDest, LPCTSTR pszSrc, size_t cchSrc)
		{
			return StringCchCatN(pszDest, cchDest, pszSrc, cchSrc);
		}
#else
#define pbstg_strcat_safe(x, n, y)   pbstg_strcat_s(x, n, y)     
#define pbstg_stnrcat_s(x, n, y,c )         pbstg_strncat(x, y, c)
#endif

#ifndef PBOS_UNIX
#define pbstg_strcmpi(x, y)             _wcsicmp(x, y)
#define pbstg_isascii(c)				iswascii(c)
#define pbstg_strlwr(s)					_wcslwr(s)
#define pbstg_strlwr_s(s, n)			_wcslwr_s(s,n)
#define pbstg_strnicmp(x, y, i)         _wcsnicmp(x, y, i)
#define pbstg_strupr(s)                 _wcsupr(s)
#define pbstg_strupr_s(s,n)             _wcsupr_s(s,n)
#define pbstg_strnset(s, c, n)			_wcsnset(s, c, n)
#else
#define pbstg_strcmpi(x, y)             wfr_wcsicmp(x, y)
#define pbstg_isascii(c)				isascii(c)
#define pbstg_strlwr(s)					strlwr(s)
#define pbstg_strlwr_s(s, n)			strlwr(s)
#define pbstg_strnicmp(x, y, i)         wfr_wcsnicmp(x, y, i)
#define pbstg_strupr(s)                 strupr(s)
#define pbstg_strupr_s(s,n)             strupr(s)
#define pbstg_strnset(s, c, n)			wmemset(s, c, n)
#endif
#define pbstg_strcpy(x, y)              wcscpy(x, y)
#define pbstg_strlen(s)                 wcslen(s)
#define pbstg_strncat(x, y, i)          wcsncat(x, y, i)
#define pbstg_strncmp(x, y, i)          wcsncmp(x, y, i)
#define pbstg_strncpy(x, y, n)          wcsncpy(x, y, n)
#define pbstg_strrchr(s, c)             wcsrchr(s, c)
#define pbstg_strstr(s1, s2)            wcsstr(s1, s2)
#define pbstg_strpbrk(s1, s2)           wcspbrk(s1, s2)

#ifdef PBSTG_SAFE_STRCPY
#define pbstg_strcpy_s(x, c, y)         StringCchCopy(x, c, y)
#define pbstg_strncpy_s(x, c, y, n)     StringCchCopyN(x, c, y, n)
#else
#define pbstg_strcpy_s(x, c, y)         wcscpy(x, y)
#define pbstg_strncpy_s(x, c, y, n)     wcsncpy(x, y, n)
#endif

#ifdef PBSTG_INLINED_SAFE_FORTIFY_SCA
		_inline HRESULT pbstg_strcpy_safe(LPTSTR pszDest, size_t cchDest, LPCTSTR pszSrc)
		{
			return StringCchCopy(pszDest, cchDest, pszSrc);
		}
#else
#define pbstg_strcpy_safe(x, n, y)   pbstg_strcpy_s(x, n, y)     
#endif

#ifdef PBSTG_INLINED_SAFE_FORTIFY_SCA
		_inline HRESULT pbstg_strncpy_safe(LPTSTR pszDest, size_t cchDest, LPCTSTR pszSrc, size_t cchSrc)
		{
			return StringCchCopyN(pszDest, cchDest, pszSrc, cchSrc);
		}
#else
#define pbstg_strncpy_safe(x, n, y, c)   pbstg_strncpy_s(x, n, y, c)     
#endif


#ifdef PBSTG_SAFE_STRCPY
		_inline size_t pbstg_strlen_s(LPCTSTR s, size_t c)
		{
			size_t result;
			return (StringCchLength(s, c, &result) == S_OK ? result : c);
		}
#else
#define pbstg_strlen_s(s, c)            pbstg_strlen(s)
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline int pbstg_strcmpi_fp(LPCTSTR s1, LPCTSTR s2)
		{
			return pbstg_strcmpi(s1, s2);
		}
#else
#define pbstg_strcmpi_fp pbstg_strcmpi     
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
#if defined(__WATCOMC__) 
		int WINAPI lstrcmpi(
			LPCTSTR lpString1,
			LPCTSTR lpString2
		);
#endif
		_inline int pbstg_lstrcmpi_fp(LPCTSTR s1, LPCTSTR s2)
		{
			return pbstg_lstrcmpi(s1, s2);
		}
#else
#define pbstg_lstrcmpi_fp pbstg_lstrcmpi     
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline LPTSTR pbstg_strncpy_fp(LPTSTR s1, LPCTSTR s2, size_t c)
		{
			return pbstg_strncpy(s1, s2, c);
		}
#else
#define pbstg_strncpy_fp pbstg_strncpy     
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline LPTSTR pbstg_strtoolestr_fp(LPTSTR s1, LPCTSTR s2, size_t c)
		{
			return pbstg_strtoolestr(s1, s2, c);
		}
#else
#define pbstg_strtoolestr_fp pbstg_strtoolestr     
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline size_t pbstg_strtoolestrlen_fp(LPTSTR s1)
		{
			return pbstg_strtoolestrlen(s1);
		}
#else
#define pbstg_strtoolestrlen_fp pbstg_strtoolestrlen     
#endif


#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline LPTSTR pbstg_olestrtostr_fp(LPTSTR s1, LPCTSTR s2, size_t c)
		{
			return pbstg_olestrtostr(s1, s2, c);
		}
#else
#define pbstg_olestrtostr_fp pbstg_olestrtostr     
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline size_t pbstg_ansitostr_fp(wchar_t* d, const char* s, size_t n)
		{
			return pbstg_ansitostr(d, s, n);
		}
#else
#define pbstg_ansitostr_fp pbstg_ansitostr     
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline size_t pbstg_strtoansi_fp(char* d, const wchar_t* s, size_t n)
		{
			return pbstg_strtoansi(d, s, n);
		}
#else
#define pbstg_strtoansi_fp pbstg_strtoansi     
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline size_t pbstg_strtoansilen_fp(const wchar_t* s)
		{
			return pbstg_strtoansilen(s);
		}
#else
#define pbstg_strtoansilen_fp pbstg_strtoansilen     
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline size_t pbstg_ansitostrlen_fp(const char* s)
		{
			return pbstg_ansitostrlen(s);
		}
#else
#define pbstg_ansitostrlen_fp pbstg_ansitostrlen     
#endif


#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
#if defined __WATCOMC__
		int WINAPI wvsprintf(
			LPTSTR lpOutput,
			LPCTSTR lpFmt,
			va_list arglist
		);
#endif
		_inline int pbstg_wsprintf_fp(LPTSTR pszDest, LPCTSTR pszFormat, ...)
		{
			va_list args;
			va_start(args, pszFormat);
			return wvsprintf(pszDest, pszFormat, args);
		}
#else
#define pbstg_wsprintf_fp pbstg_wsprintf     
#endif

#define pbstg_sprintf_fp pbstg_wsprintf_fp

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline LPTSTR pbstg_strcpy_fp(LPTSTR a, LPCTSTR b)
		{
			return pbstg_strcpy(a, b);
		}
		_inline char* pbstg_strcpy_fp2(char* a, const char* b)
		{
			return strcpy(a, b);
		}
#else
#define pbstg_strcpy_fp pbstg_strcpy
#define pbstg_strcpy_fp2 strcpy
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline int pbstg_strcmp_fp(LPCTSTR a, LPCTSTR b)
		{
			return pbstg_strcmp(a, b);
		}
#else
#define pbstg_strcmp_fp pbstg_strcmp
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline int pbstg_strncmp_fp(LPCTSTR a, LPCTSTR b, size_t c)
		{
			return pbstg_strncmp(a, b, c);
		}
#else
#define pbstg_strncmp_fp pbstg_strncmp
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline int pbstg_unicodestrcmp_fp(const wchar_t* a, const wchar_t* b)
		{
			return pbstg_unicodestrcmp(a, b);
		}
#else
#define pbstg_unicodestrcmp_fp pbstg_unicodestrcmp
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline int pbstg_strnicmp_fp(LPCTSTR a, LPCTSTR b, size_t c)
		{
			return pbstg_strnicmp(a, b, c);
		}
#else
#define pbstg_strnicmp_fp pbstg_strnicmp
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
#if defined __WATCOMC__
		int WINAPI lstrcmp(
			LPCTSTR lpString1,
			LPCTSTR lpString2
		);
#endif
		_inline int pbstg_lstrcmp_fp(LPCTSTR a, LPCTSTR b)
		{
			return pbstg_lstrcmp(a, b);
		}
#else
#define pbstg_lstrcmp_fp pbstg_lstrcmp
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline size_t pbstg_strlen_fp(LPCTSTR a)
		{
			return pbstg_strlen(a);
		}
#else
#define pbstg_strlen_fp pbstg_strlen
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline size_t pbstg_strlenA_fp(const char* a)
		{
			return pbstg_strlenA(a);
		}
#else
#define pbstg_strlenA_fp pbstg_strlenA
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline size_t pbstg_olestrlen_fp(LPCTSTR a)
		{
			return pbstg_olestrlen(a);
		}
#else
#define pbstg_olestrlen_fp pbstg_olestrlen
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline LPTSTR pbstg_strcat_fp(LPTSTR a, LPCTSTR b)
		{
			return pbstg_strcat(a, b);
		}
		_inline char* pbstg_strcat_fp2(char* a, const char* b)
		{
			return strcat(a, b);
		}
#else
#define pbstg_strcat_fp pbstg_strcat
#define pbstg_strcat_fp2 strcat
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline void* pbstg_memcpy_fp(void* a, const void* b, size_t c)
		{
			return pbstg_memcpy(a, b, c);
		}
#else
#define pbstg_memcpy_fp pbstg_memcpy
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline LPTSTR pbstg_strupr_fp(LPTSTR a)
		{
			return pbstg_strupr(a);
		}
#else
#define pbstg_strupr_fp pbstg_strupr
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline LPTSTR pbstg_strlwr_fp(LPTSTR a)
		{
			return pbstg_strlwr(a);
		}
#else
#define pbstg_strlwr_fp pbstg_strlwr
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline LPTSTR pbstg_strstr_fp(LPCTSTR a, LPCTSTR b)
		{
			return (LPTSTR)(pbstg_strstr(a, b));
		}
#else
#define pbstg_strstr_fp pbstg_strstr
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline LPTSTR pbstg_strchr_fp(LPCTSTR a, TCHAR b)
		{
			return (LPTSTR)(pbstg_strchr(a, b));
		}
#else
#define pbstg_strchr_fp pbstg_strchr
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline LPTSTR pbstg_strrchr_fp(LPCTSTR a, TCHAR b)
		{
			return (LPTSTR)(pbstg_strrchr(a, b));
		}
#else
#define pbstg_strrchr_fp pbstg_strrchr
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
#if defined __WATCOMC__
		LPTSTR WINAPI CharLower(
			LPTSTR lpsz
		);
#endif
		_inline LPTSTR pbstg_charlower_fp(LPTSTR a)
		{
			return (LPTSTR)(pbstg_charlower(a));
		}
#else
#define pbstg_charlower_fp pbstg_charlower
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
#if defined __WATCOMC__
		LPTSTR WINAPI CharUpper(
			LPTSTR lpsz
		);
#endif
		_inline LPTSTR pbstg_charupper_fp(LPTSTR a)
		{
			return (LPTSTR)(pbstg_charupper(a));
		}
#else
#define pbstg_charupper_fp pbstg_charupper
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline int pbstg_strcmpi_s(LPCTSTR x, LPCTSTR y, size_t n)
		{
			return pbstg_strnicmp(x, y, n);
		}
#else
#ifdef PBSTG_SAFE_STRCPY
#define pbstg_strcmpi_s(x, y, n)        pbstg_strnicmp(x, y, n)
#else
#define pbstg_strcmpi_s(x, y, n)        pbstg_strcmpi(x, y) 
#endif
#endif

#ifdef PBSTG_SAFE_STRCPY
#if defined __WATCOMC__
		DWORD WINAPI CharLowerBuff(
			LPTSTR lpsz,
			DWORD cchLength
		);

		DWORD WINAPI CharUpperBuff(
			LPTSTR lpsz,
			DWORD cchLength
		);
#endif
		_inline LPTSTR pbstg_charlower_s(LPTSTR s, DWORD i)
		{
			DWORD dwLen = pbstg_strlen_s(s, i);
			pbstg_charlowerbuff(s, dwLen < i ? dwLen : i);
			return s;
		}
		_inline LPTSTR pbstg_charupper_s(LPTSTR s, DWORD i)
		{
			DWORD dwLen = pbstg_strlen_s(s, i);
			pbstg_charupperbuff(s, dwLen < i ? dwLen : i);
			return s;
		}
		//*** removed when update to vs2010 start	***
#ifndef _wcslwr_s
#define _wcslwr_s(s,n)  pbstg_charlower_s(s, n)
#endif
#ifndef _wcsupr_s
#define _wcsupr_s(s,n)  pbstg_charupper_s(s, n)
#endif
//*** removed when update to vs2010 end    ***
#else
#define pbstg_charlower_s(s, i) pbstg_charlower(s)
#define pbstg_charupper_s(s, i) pbstg_charupper(s)
		//*** removed when update to vs2010 start	***
#ifndef _wcslwr_s
#define _wcslwr_s(s,n)  _wcslwr(s)
#endif
#ifndef _wcsupr_s
#define _wcsupr_s(s,n)  _wcsupr(s)
#endif
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
		_inline void* pbstg_memset_fp(void* a, int b, size_t c)
		{
			return pbstg_memset(a, b, c);
		}
#else
#define pbstg_memset_fp pbstg_memset
#endif

#define PBSTG_HUGE_STRCPY_FP(x, y) pbstg_strcpy_fp(x, y)
#define PBSTG_HUGE_MEMSET_FP(a, b, c) pbstg_memset_fp(a, b, c)
#define PBSTG_HUGE_MEMCPY_FP(a, b, c) pbstg_memcpy_fp(a, b, c)

#if defined(__WATCOMC__) || defined(PBOS_UNIX)
#define pbstg_strtok(s1, s2, s3)            wcstok(s1, s2, s3)
#else
#define pbstg_strtok(s1, s2)            wcstok(s1, s2)
#endif

#ifdef PBSTG_INLINED_FALSE_POSITIVE_FORTIFY_SCA
#if defined (__WATCOMC__)
#else
		_inline LPTSTR pbstg_strtok_fp(LPTSTR a, LPCTSTR b)
		{
			return (LPTSTR)(pbstg_strtok(a, b));
		}
#endif
#else
#define pbstg_strtok_fp pbstg_strtok
#endif

#define pbstg_strspn(s1, s2)			wcsspn(s1, s2)
#define pbstg_strcspn(s1, s2)			wcscspn(s1, s2)
//   Do not use strnset to try to fill an ENTIRE string buffer with a certain character.  Use pbstg_setstring
//   instead.  strnset will stop filling the buffer if it hits a null terminator prior to the Nth character. 
#define pbstg_setstring(buff, c, count)   {INT iSetStringBuffIdx; LPTSTR pSetStringBuffPtr; \
	 for (iSetStringBuffIdx = 0, pSetStringBuffPtr = buff;  iSetStringBuffIdx < count; \
          iSetStringBuffIdx++, pSetStringBuffPtr++) *pSetStringBuffPtr = c;  } 

#else								// ANSI

/*	WARNING: OBSOLETE FUNCTIONS - DO NOT USE.	*/
/* 8 bit ASCII string functions */
#define pbstg_ansilower(s)                      AnsiLower(s)
#define pbstg_ansiupper(s)                      AnsiUpper(s)
#define pbstg_ansilowerbuff(s, i)               AnsiLowerBuff(s, i)
#define pbstg_ansiupperbuff(s, i)               AnsiUpperBuff(s, i)
/* END OF OBSOLETE FUNCTIONS - See following for new functions:  */
/* 8 bit ASCII string functions */
#define pbstg_charlower(s)                      CharLower(s)
#define pbstg_charupper(s)                      CharUpper(s)
#define pbstg_charlowerbuff(s, i)               CharLowerBuff(s, i)
#define pbstg_charupperbuff(s, i)               CharUpperBuff(s, i)

#define pbstg_isspace(c)						isspace(c)
#define pbstg_isdigit(c)						isdigit(c)
#define pbstg_isalnum(c)						isalnum(c)
#define pbstg_isalpha(c)						isalpha(c)
#define pbstg_iscntrl(c)						iscntrl(c)
#define pbstg_isgraph(c)						isgraph(c)
#define pbstg_islower(c)						islower(c)
#define pbstg_isprint(c)						isprint(c)
#define pbstg_ispunct(c)						ispunct(c)
#define pbstg_isupper(c)						isupper(c)
#define pbstg_isxdigit(c)						isxdigit(c)
#define pbstg_isascii(c)						isascii(c)

/* String functions */
#define pbstg_lstrcmp(x, y)             lstrcmp(x, y)
#define pbstg_lstrcmpi(x, y)            lstrcmpi(x, y)
#define pbstg_strcat(x, y)              strcat(x, y)
#define pbstg_strchr(s, c)              strchr(s, (INT) c)
#define pbstg_strcmp(x, y)              strcmp(x, y)
#define pbstg_strcmpi(x, y)             stricmp(x, y)
#define pbstg_strcpy(x, y)              strcpy(x, y)
#define pbstg_strlen(s)                 strlen(s)
#define pbstg_strlwr(s)                 strlwr(s)
#define pbstg_strncat(x, y, i)          strncat(x, y, i)
#define pbstg_strncmp(x, y, i)          strncmp(x, y, i)
#define pbstg_strncpy(x, y, n)          strncpy(x, y, n)
#define pbstg_strnicmp(x, y, i)         strnicmp(x, y, i)
#define pbstg_strrchr(s, c)             strrchr(s, (INT) c)
#define pbstg_strpbrk(s1, s2)           strpbrk(s1, s2)
#define pbstg_strstr(s1, s2)            strstr(s1, s2)
#define pbstg_strtok(s1, s2)            strtok(s1, s2)
#define pbstg_strupr(s)                 strupr(s)
#define pbstg_strspn(s1, s2)			strspn(s1, s2)
#define pbstg_strcspn(s1, s2)			strcspn(s1, s2)
#define pbstg_strnset(s, c, n)			strnset(s, c, n)
#define pbstg_setstring(buff, c, count) memset(buff, (INT)c, count)
#endif

#if defined(PBOS_UNIX)
		LPTSTR strlwr(LPTSTR);
		LPTSTR strupr(LPTSTR);
#if defined(PBOS_LINUX)
		int stricmp(const char*, const char*);
#endif
#endif

#else /* NOT PBWIN32 */

/* COMMON MACROS */
#define pbstg_charnext(s)				AnsiNext(s)
#define pbstg_charprev(s, d)			AnsiPrev(s, d)

/* Memory utility functions */
#define pbstg_memchr(m1, c, count)      _fmemchr(m1, c, count)
#define pbstg_memcmp(m1, m2, c)         _fmemcmp(m1, m2, c)
#define pbstg_memcpy(m1, m2, c)         _fmemcpy(m1, m2, c)
#define pbstg_memicmp(m1, m2, c)        _fmemicmp(m1, m2, c)
#define pbstg_memmove(m1, m2, c)        _fmemmove(m1, m2, c)
#define pbstg_memset(m1, c, count)      _fmemset(m1, c, count)


		PBWINAPI(INT, pbstg_lchrcmp)(TCHAR c1, TCHAR c2);
		PBWINAPI(INT, pbstg_lchrcmpi)(TCHAR c1, TCHAR c2);

#define pbstg_isspace(c)						isspace(c)
#define pbstg_isdigit(c)						isdigit(c)
#define pbstg_isalnum(c)						isalnum(c)
#define pbstg_isalpha(c)						isalpha(c)
#define pbstg_iscntrl(c)						iscntrl(c)
#define pbstg_isgraph(c)						isgraph(c)
#define pbstg_islower(c)						islower(c)
#define pbstg_isprint(c)						isprint(c)
#define pbstg_ispunct(c)						ispunct(c)
#define pbstg_isupper(c)						isupper(c)
#define pbstg_isxdigit(c)						isxdigit(c)
#define pbstg_isascii(c)						isascii(c)

		/* END COMMON MACROS */

#ifdef  PS_DBCS						// KANJI

/* OS Independent String functions */
#define pbstg_mbsbtype(s, c)			fmbsbtype(s, c)

/*	WARNING: OBSOLETE FUNCTIONS - DO NOT USE.	*/
/* 8 bit ASCII string functions */
#define pbstg_ansilower(s)                      fjstrlwr(s)
#define pbstg_ansiupper(s)                      fjstrupr(s)
#define pbstg_ansilowerbuff(s, i)               fjstrnlwr(s, i)
#define pbstg_ansiupperbuff(s, i)               fjstrnupr(s, i)
/* END OF OBSOLETE FUNCTIONS - See following for new functions  */
/* 8 bit ASCII string functions */
#define pbstg_charlower(s)                      fjstrlwr(s)
#define pbstg_charupper(s)                      fjstrupr(s)
#define pbstg_charlowerbuff(s, i)               fjstrnlwr(s, i)
#define pbstg_charupperbuff(s, i)               fjstrnupr(s, i)

/* Conversion functions */
#define pbstg_fcvt(a, b, c, d)          _fcvt(a, b, c, d)
#define pbstg_itoa(x, y, z)             _itoa(x, y, z)
#define pbstg_ltoa(x, y, z)             _ltoa(x, y, z)

/* String functions */
#define pbstg_lstrcmp(x, y)             _fstrcmp(x, y)
#define pbstg_lstrcmpi(x, y)            _fstricmp(x, y)
#define pbstg_strcat(x, y)              _fstrcat(x, y)
#define pbstg_strchr(s, c)      		fjstrchr(s, (INT)c)
#define pbstg_strcmp(x, y)              _fstrcmp(x, y)
#define pbstg_strcmpi(x, y)             _fstricmp(x, y)
#define pbstg_strcpy(x, y)              _fstrcpy(x, y)
#define pbstg_strlen(s)                 _fstrlen(s)
#define pbstg_strlwr(s)                 fjstrlwr(s)
#define pbstg_strncat(x, y, i)          _fstrncat(x, y, i)
#define pbstg_strncmp(x, y, i)          _fstrncmp(x, y, i)
#define pbstg_strncpy(x, y, n)          _fstrncpy(x, y, n)
#define pbstg_strnicmp(x, y, i)         _fstrnicmp(x, y, i)
#define pbstg_strpbrk(s1, s2)           fjstrmatch(s1, s2)
#define pbstg_strrchr(s, c)             fjstrrchr(s, (INT)c)
#define pbstg_strstr(s1, s2)            fjstrstr(s1, s2)
#define pbstg_strtok(s1, s2)            _fstrtok(s1, s2)
#define pbstg_strupr(s)                 fjstrupr(s)
#define pbstg_strspn(s1, s2)			_fstrspn(s1, s2)
#define pbstg_strcspn(s1, s2)			_fstrcspn(s1, s2)
#define pbstg_strnset(s, c, n)			_fstrnset(s, c, n)
#define pbstg_setstring(buff, c, count) _fmemset(buff, c, count)

/* If compiling under UNIX or MAC */
#elif defined(PBOS_UNIX) || defined(PBOS_MAC)

/* OS Independent String functions */
/*	WARNING: OBSOLETE FUNCTIONS - DO NOT USE.	*/
/* 8 bit ASCII string functions */
#define pbstg_ansilower(s)                      AnsiLower(s)
#define pbstg_ansiupper(s)                      AnsiUpper(s)
#define pbstg_ansilowerbuff(s, i)               AnsiLowerBuff(s, i)
#define pbstg_ansiupperbuff(s, i)               AnsiUpperBuff(s, i)
/* END OF OBSOLETE FUNCTIONS - See following for new functions  */
/* 8 bit ASCII string functions */
#define pbstg_charlower(s)                      AnsiLower(s)
#define pbstg_charupper(s)                      AnsiUpper(s)
#define pbstg_charlowerbuff(s, i)               AnsiLowerBuff(s, i)
#define pbstg_charupperbuff(s, i)               AnsiUpperBuff(s, i)

/* Conversion functions */
#if defined(PBOS_MAC)
#define pbstg_fcvt(a, b, c, d)          _fcvt(a, b, c, d)
#else
#define pbstg_fcvt(a, b, c, d)          fcvt(a, b, c, d)
#endif
#define pbstg_itoa(x, y, z)             itoa(x, y, z)
#define pbstg_ltoa(x, y, z)             ltoa(x, y, z)

/* String functions */
#define pbstg_lstrcmp(x, y)             lstrcmp(x, y)
#define pbstg_lstrcmpi(x, y)            lstrcmpi(x, y)
#define pbstg_strcat(x, y)              strcat(x, y)
#define pbstg_strchr(s, c)              strchr(s, c)
#define pbstg_strcmp(x, y)              strcmp(x, y)
#define pbstg_strcmpi(x, y)             stricmp(x, y)
#define pbstg_strcpy(x, y)              strcpy(x, y)
#define pbstg_strlen(s)                 strlen(s)
#define pbstg_strlwr(s)                 strlwr(s)
#define pbstg_strncat(x, y, i)          strncat(x, y, i)
#define pbstg_strncmp(x, y, i)          strncmp(x, y, i)
#define pbstg_strncpy(x, y, n)          strncpy(x, y, n)
#define pbstg_strnicmp(x, y, i)         strnicmp(x, y, i)
#define pbstg_strpbrk(s1, s2)           strpbrk(s1, s2)
#define pbstg_strrchr(s, c)             strrchr(s, c)
#define pbstg_strstr(s1, s2)            strstr(s1, s2)
#define pbstg_strtok(s1, s2)            strtok(s1, s2)
#define pbstg_strupr(s)                 strupr(s)
#define pbstg_strspn(s1, s2)			strspn(s1, s2)
#define pbstg_strcspn(s1, s2)			strcspn(s1, s2)
#define pbstg_strnset(s, c, n)			strnset(s, c, n)
#define pbstg_setstring(buff, c, count) memset( buff, c, count)

		LPTSTR strlwr(LPTSTR);
		LPTSTR strupr(LPTSTR);

#else /* NOT PBOS_UNIX or NOT PBOS_MAC or NOT DBCS*/

/* OS Independent String functions */
/*	WARNING: OBSOLETE FUNCTIONS - DO NOT USE.	*/
/* 8 bit ASCII string functions */
#define pbstg_ansilower(s)                      AnsiLower(s)
#define pbstg_ansiupper(s)                      AnsiUpper(s)
#define pbstg_ansilowerbuff(s, i)               AnsiLowerBuff(s, i)
#define pbstg_ansiupperbuff(s, i)               AnsiUpperBuff(s, i)
/* END OF OBSOLETE FUNCTIONS - See following for new functions  */
/* 8 bit ASCII string functions */
#define pbstg_charlower(s)                      AnsiLower(s)
#define pbstg_charupper(s)                      AnsiUpper(s)
#define pbstg_charlowerbuff(s, i)               AnsiLowerBuff(s, i)
#define pbstg_charupperbuff(s, i)               AnsiUpperBuff(s, i)

/* Conversion functions */
#define pbstg_fcvt(a, b, c, d)          _fcvt(a, b, c, d)
#define pbstg_itoa(x, y, z)             _itoa(x, y, z)
#define pbstg_ltoa(x, y, z)             _ltoa(x, y, z)

/* String functions */
#define pbstg_lstrcmp(x, y)             lstrcmp(x, y)
#define pbstg_lstrcmpi(x, y)            lstrcmpi(x, y)
#define pbstg_strcat(x, y)              _fstrcat(x, y)
#define pbstg_strchr(s, c)              _fstrchr(s, c)
#define pbstg_strcmp(x, y)              _fstrcmp(x, y)
#define pbstg_strcmpi(x, y)             _fstricmp(x, y)
#define pbstg_strcpy(x, y)              _fstrcpy(x, y)
#define pbstg_strlen(s)                 _fstrlen(s)
#define pbstg_strlwr(s)                 _fstrlwr(s)
#define pbstg_strncat(x, y, i)          _fstrncat(x, y, i)
#define pbstg_strncmp(x, y, i)          _fstrncmp(x, y, i)
#define pbstg_strncpy(x, y, n)          _fstrncpy(x, y, n)
#define pbstg_strnicmp(x, y, i)         _fstrnicmp(x, y, i)
#define pbstg_strpbrk(s1, s2)           _fstrpbrk(s1, s2)
#define pbstg_strrchr(s, c)             _fstrrchr(s, c)
#define pbstg_strstr(s1, s2)            _fstrstr(s1, s2)
#define pbstg_strtok(s1, s2)            _fstrtok(s1, s2)
#define pbstg_strupr(s)                 _fstrupr(s)
#define pbstg_strspn(s1, s2)			_fstrspn(s1, s2)
#define pbstg_strcspn(s1, s2)			_fstrcspn(s1, s2)
#define pbstg_strnset(s, c, n)			_fstrnset(s, c, n)
#define pbstg_setstring(buff, c, count) _fmemset(buff, c, count)

#endif /* PBOS_UNIX */

#endif /* PBWIN32 */

#if defined(PBOS_UNIX) && defined(PS_UNICODE)
		LPTSTR APIENTRY memcpy_UShortString_Len(LPTSTR lpDes, USHORT* lpuSrc, size_t count);
		LPTSTR APIENTRY memcpy_UShortString(LPTSTR lpDes, USHORT* lpuSrc);
#endif

#ifndef pbstg_memcpy_u
#if defined(PBOS_UNIX) && defined(PS_UNICODE)
#define pbstg_memcpy_u(a,b,c)	memcpy_UShortString_Len((a), (USHORT*)(b), ((c)/sizeof(TCHAR)))
#else
#define pbstg_memcpy_u(a,b,c)	pbstg_memcpy((a),(b),(c))
#endif
#endif


#define flipUShortArray(Buffer,lSize)   { \
											for(int i = 0; i < (lSize); i++) \
											{ \
												flipUSHORT(&((Buffer)[i])); \
											} \
										}

#ifdef PBOS_UNIX

		PBWINAPI(void, pbstg_s_utf32_flip_utf16)(USHORT* u16, LPTSTR u32, int len);
		PBWINAPI(void, pbstg_s_utf16_flip_utf32)(LPTSTR u32, USHORT* u16, int len);
		PBWINAPI(void, pbstg_s_utf32_utf16)(USHORT* u16, LPTSTR u32, int len);
		PBWINAPI(void, pbstg_s_utf16_utf32)(LPTSTR u32, USHORT* u16, int len);

		/*
		#define utf32_flip_utf16(u16, u32, len ) pbstg_s_utf32_flip_utf16((u16), (u32), (len) )
		#define utf16_flip_utf32(u32, u16, len ) pbstg_s_utf16_flip_utf32((u32), (u16), len) )
		#define utf32_utf16(u16, u32,len ) pbstg_s_utf32_utf16((u16), (u32),(len) )
		#define utf16_utf32(u32, u16, len ) pbstg_s_utf16_utf32((u32), (u16), (len) )
		*/


#ifdef BYTE_SWAP
#define pbstg_s_unicode_wintounix(unixstring, winstring, len) pbstg_s_utf16_flip_utf32((unixstring), (winstring), (len))
#define pbstg_s_unicode_unixtowin(winstring, unixstring, len) pbstg_s_utf32_flip_utf16((winstring), (unixstring), (len))
#else
#define pbstg_s_unicode_wintounix(unixstring, winstring, len) pbstg_s_utf16_utf32((unixstring), (winstring), (len))
#define pbstg_s_unicode_unixtowin(winstring, unixstring, len) pbstg_s_utf32_utf16((winstring), (unixstring), (len))
#endif

		PBWINAPI(LPTSTR, pbstg_n_unicode_wintounix)(PVOID winstring, int nLength);

		PBWINAPI(USHORT*, pbstg_n_unicode_unixtowin)(PVOID unixstring, int nLength);

		PBWINAPI(LPTSTR, pbstg_n_unicode_wintounix_onpool)(ppbstg_anchor stgthis, PVOID winstring, int nLength);
		PBWINAPI(USHORT*, pbstg_n_unicode_unixtowin_onpool)(ppbstg_anchor stgthis, PVOID unixstring, int nLength);

#define pbstg_unicode_wintounix(winstring)  pbstg_n_unicode_wintounix((winstring),(-1))
#define pbstg_unicode_unixtowin(unixstring) pbstg_n_unicode_unixtowin((unixstring), (-1))

#define pbstg_unicode_wintounix_onpool(stgthis, winstring) pbstg_n_unicode_wintounix_onpool((stgthis), (winstring), (-1))
#define pbstg_unicode_unixtowin_onpool(stgthis, unixstring) pbstg_n_unicode_unixtowin_onpool((stgthis), (unixstring), (-1))


#endif

#ifdef __cplusplus
	}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#if defined (USE_SYBHEAP)

#pragma message ("Using Sybheap")

// ***** DOINC including spbheap.h *****
	// DOINC skipping duplicate include
#if !defined(_AIX)
#if defined malloc
#undef malloc
#endif

#if defined _alloca
#undef _alloca
#endif

#if defined alloca
#undef alloca
#endif

#if defined realloc
#undef realloc
#endif

#if defined calloc
#undef calloc
#endif

#if defined free
#undef free
#endif

#ifdef __cplusplus
	extern "C++"
	{
#ifndef PBDOM
#ifdef PBOS_LINUX
		inline void* _cdecl operator new(size_t size) throw(std::bad_alloc)
#else
		inline void* _cdecl operator new(size_t size)
#endif
		{
			return PbHeap_malloc(size);
		}
#ifdef PBOS_LINUX
		inline void _cdecl operator delete(void* p)throw()
#else
		inline void _cdecl operator delete(void* p)
#endif
		{
			PbHeap_free(p);
		}

#if _MSC_VER >=1300 || defined(PBOS_UNIX) 
#ifdef PBOS_LINUX
		inline void* _cdecl operator new[](size_t size)throw(std::bad_alloc)
#else
		inline void* _cdecl operator new[](size_t size)
#endif
		{
			return PbHeap_malloc(size);
		}
#ifdef PBOS_LINUX	
			inline void _cdecl operator delete[](void* p)throw()
#else
			inline void _cdecl operator delete[](void* p)
#endif
		{
			PbHeap_free(p);
		}
#endif
#endif
			/*
			inline void *__cdecl operator new(size_t, void *_P)
			{
				return (_P);
			}

			inline void _cdecl operator delete(void*, void*)
			{
			}
			*/
	}//extern "C++"
#endif


#define malloc PbHeap_malloc
#define _alloca PbHeap_malloc
#define alloca PbHeap_malloc
#define realloc PbHeap_realloc
#define calloc PbHeap_calloc
#define free PbHeap_free
#define _INC_MALLOC             
#endif
#endif   //use_sybheap

#endif /* PBSTG_H */

// DOINC popped back into header 'rtccode.h'
// ***** DOINC including shdebug.h *****
//**************************************************************************
//
//                            Copyright 1989
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :    shdebug.h
//
//    Author   :    Jim Kosko
//
//    Purpose  :    Definitions for runtime debug utility.
//
//****************************************************************************

#ifndef SHDEBUG_H
#define SHDEBUG_H

//****************************************************************************
// Includes
//****************************************************************************

#ifndef OSWINDOW_H
// ***** DOINC including oswindow.h *****
	// DOINC skipping duplicate include
#endif
#ifndef PBSTG_H
// ***** DOINC including pbstg.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OSIO_H
// ***** DOINC including osio.h *****
/*                                                                         */
/* *********************************************************************** */
/*                                                                         */
/*                 Copyright Powersoft Corporation 1991-1994               */
/*                                                                         */
/*       Powersoft Corporation ("Powersoft") claims copyright in this      */
/*     program and documentation as an unpublished work, versions of       */
/*     which were first licensed on the date indicated in the foregoing    */
/*     notice. Claim of copyright does not imply waiver of Powersoft's     */
/*     other rights. See Notice of Proprietary Rights.                     */
/*                                                                         */
/*                 NOTICE OF PROPRIETARY RIGHTS                            */
/*                                                                         */
/*       This program and documentation are confidential trade             */
/*     secrets and the property of Powersoft.  Use, examination,           */
/*     reproduction, copying, disassembly, decompilation, transfer         */
/*     and/or disclosure to others are strictly prohibited except by       */
/*     express written agreement with Powersoft.                           */
/*                                                                         */
/* ----------------------------------------------------------------------- */
/*                                                                         */
/*    Filename :    osio.h                                                 */
/*                                                                         */
/*    Author   :    Jim Kosko                                              */
/*                                                                         */
/*    Purpose  :    Wrapper for MS/Windows Long I/O functions              */
/*                                                                         */
/*    Usage    :                                                           */
/*                                                                         */
/*     Mimics corresponding _lxxxx MS windows routines.                    */
/*     Use typedefs and flags defined here.                                */
/*                                                                         */
/*     fd              = os_lopen (LPSTR filename, INT flag);              */
/*     fd              = os_lcreat (LPSTR filename, INT flag);             */
/*     error           = os_lclose (OS_LFILE fd);                          */
/*     new_offset      = os_llseek (OS_LFILE fd, LONG offset, INT origin); */
/*     nbytes_read     = os_lread (OS_LFILE fd, LPSTR buffer, INT nbytes); */
/*     nbytes_written  = os_lwrite (OS_LFILE fd, LPSTR buffer, INT nbytes);*/
/*     new_offset      = os_lrewind (OS_LFILE fd);                         */
/*                                                                         */
/* *********************************************************************** */

/* *********************************************************************** */
/*  Insure file is not include twice                                       */
/* *********************************************************************** */

#ifndef OSIO_H
#define OSIO_H

#ifndef PBOS_WIN
#define os_fprintf _os_fprintf
#endif

#if (defined(PBOS_NT) || defined(PBOS_WIN40) || defined(PBOS_UNIX) )
#define PBFILELENGTH( h ) GetFileSize( (HANDLE) h, NULL )
#else
#define PBFILELENGTH( h ) _filelength( h )
#endif

/* *********************************************************************** */
/*  Includes                                                               */
/* *********************************************************************** */

// ***** DOINC including osstdarg.h *****
//**************************************************************************
//
//                            Copyright 1989 
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :	osstdarg.h	
//
//    Author   :	Jim Kosko
//
//    Purpose  : 	Wrapper for stdarg.h. 
//						Extensions for building variable argument lists.
//
//****************************************************************************

#ifndef OSSTDARG_H
#define OSSTDARG_H

//****************************************************************************
// Includes
//****************************************************************************

// ***** DOINC including ospascal.h *****
	// DOINC skipping duplicate include
// ***** DOINC including pbstg.h *****
	// DOINC skipping duplicate include

#if defined(PBOS_UNIX) || defined(PBOS_MAC) // Some UNIX compilers don't automajically include std headers
#include <stdarg.h>
#endif

//****************************************************************************
// Assume C declarations for C++
//****************************************************************************

#ifdef __cplusplus
	extern "C" {
#endif	/* __cplusplus */

		//****************************************************************************
		// Macros to decode variable argument lists.
		//****************************************************************************

#ifdef PBWIN32
		typedef va_list             os_va_list;
#define os_va_start(ap,v)   va_start(ap, v)
#define os_va_arg(ap,t)     va_arg(ap, t)
#define os_va_skiparg(ap,t) va_arg(ap, t)
#define os_va_end(ap)       va_end(ap)
#define	OS_VA_CAST		    va_list
#else
		typedef TCHAR FAR* os_va_list;
#define os_va_start(ap,v) ap = (os_va_list)&v + sizeof(v)
#define os_va_arg(ap,t) ((t FAR *)(ap += sizeof(t)))[-1]
#define os_va_skiparg(ap,t) ap += sizeof(t)
#define os_va_end(ap) ap = NULL
#define	OS_VA_CAST		    LPTSTR  
#endif


		//****************************************************************************
		// Grow block holding intermediate argument list frame.
		//****************************************************************************

		typedef struct tag_os_stackgrowblock
		{
			PVOID	        stackframe;         // (PSH_GROWBLOCK)
			pbstg_subpool	stackframe_subpool;
		} os_stackgrowblock, FAR* pos_stackgrowblock;


		//****************************************************************************
		// Prototypes/Macros to build dynamic argument lists.
		//		os_vabuild_start (poolid)		- Begin new arg list.
		//		os_vabuild_arg (INT, i)			- For passing simple arguments, must be
		//													lvalue.
		//		os_vabuild_ptrarg (&i)			- For reference args or for putting ptr
		//													directly on arg list w/o intermediate
		//													lvalue variable.
		//		frame = os_vabuild_end (&len)	- Retrieve new arg list.
		//****************************************************************************

		PBWINAPI(VOID, os_vabuild_start)
			(
				ppbstg_anchor      stgthis,
				pos_stackgrowblock pStackFrame,
				pbstg_subpool      subpool

				);

#define  			os_vabuild_arg(stgthis,pStackFrame,type,argument)  			\
								os_vabuild_add (stgthis,pStackFrame, sizeof(type), &(argument))

		PBWINAPI(VOID, os_vabuild_ptrarg)
			(
				ppbstg_anchor     stgthis,
				pos_stackgrowblock pStackFrame,
				PVOID             argument
				);

		PBWINAPI(PVOID, os_vabuild_end)
			(
				ppbstg_anchor     stgthis,
				pos_stackgrowblock pStackFrame,
				PUINT             frame_len
				);

		//****************************************************************************
		// Non-public Prototypes
		//****************************************************************************

		PBWINAPI(VOID, os_vabuild_add)
			(
				ppbstg_anchor     stgthis,
				pos_stackgrowblock  pStackFrame,
				UINT              size,
				PVOID             arg
				);

#ifdef __cplusplus
	}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif // OSSTDARG_H
// DOINC popped back into header 'osio.h'


/* *********************************************************************** */
/*  Assume C declarations for C++                                          */
/* *********************************************************************** */

#ifdef __cplusplus
	extern "C" {
#endif  /* __cplusplus */

		/* *********************************************************************** */
		/*  File descriptor type                                                   */
		/* *********************************************************************** */

#if (!defined (PBOS_MAC) || (defined(PBOS_MAC) && defined(GENERATED_CODE_BUILD)) )
#if (!defined (PBOS_UNIX) || (defined(PBOS_UNIX) && defined(GENERATED_CODE_BUILD)) )
// gmoison CODEGEN
#ifndef _INC_WINDOWS
		typedef int         HFILE;
#endif
#endif
#endif

#define OS_LFILE    HFILE

		/* *********************************************************************** */
		/*  I/O error flag returned from functions                                 */
		/* *********************************************************************** */

#define OS_IOERROR      -1

/* *********************************************************************** */
/*  Flags for os_lopen                                                     */
/* *********************************************************************** */

#define OPEN_READ       0           /* Open for read */
#define OPEN_WRITE      1           /* Open for write */
#define OPEN_READWRITE  2           /* Open for read/write */

/* *********************************************************************** */
/*  FLAGS for os_lcreat                                                    */
/* *********************************************************************** */

#define CREAT_NORMAL        0       /* Create normal file */
#define CREAT_RO            1       /* Create read-only file */
#define CREAT_HIDDEN        2       /* Create hidden file */
#define CREAT_SYSTEM        3       /* Create system file */

/* *********************************************************************** */
/*  Flags for os_lseek                                                     */
/* *********************************************************************** */

#define LSEEK_BOF           0       /* Offset from beginning of file */
#define LSEEK_COF           1       /* Offset from current pos in file */
#define LSEEK_EOF           2       /* Offset from end of file */

/* *********************************************************************** */
/*  Standard file descriptors                                              */
/* *********************************************************************** */

#define os_stdin            0
#define os_stdout           1
#define os_stderr           2

/* *********************************************************************** */
/*  Definitions of PB Long I/O functions                                   */
/* *********************************************************************** */

#define os_lopen                _lopen
#define os_lclose               _lclose
#define os_lcreat               _lcreat
#define os_llseek               _llseek
#define os_lread(fd,p,n)        _lread(fd,(LPSTR)(p),n)
#define os_lwrite(fd,p,n)       _lwrite(fd,(LPCSTR)(p),n)
#define os_ltrunc(fd)     		os_lwrite (fd, NULL, 0)
#define os_ltell(fd)     		os_llseek (fd, 0L, LSEEK_COF)
#define os_lrewind(fd)     		os_llseek (fd, 0L, LSEEK_BOF);


/* *********************************************************************** */
/*  Prototypes                                                             */
/* *********************************************************************** */

		PBWINAPI(INT, os_vfprintf)
			(
				OS_LFILE,
				LPTSTR,
				os_va_list
				);

		PBCDECLAPI(INT, os_fprintf)
			(
				OS_LFILE filedes,
				LPTSTR format,
				...
				);

		/* johnf: these should be removed after Unicode conversion */
#define os_vsprintf         wvsprintf
#define os_sprintf          wsprintf
/* end of obsolete functions */

#ifndef pbstg_sprintf
#define pbstg_sprintf		wsprintf
#endif

#ifndef pbstg_vsprintf
#define pbstg_vsprintf		wvsprintf
#endif

#ifndef pbstg_wsprintf
#define pbstg_wsprintf		wsprintf
#endif

#ifndef pbstg_wvsprintf
#define pbstg_wvsprintf		wvsprintf
#endif

/* *********************************************************************** */
/*  Define wsprintf and wvsprintf depending on OS                          */
/* *********************************************************************** */

#ifdef PBWIN32

#ifndef WINAPI
#define WINAPI      __stdcall
#endif

#ifndef WINAPIV
#define WINAPIV     __cdecl
#endif

#ifndef PBOS_UNIX
#ifndef _INC_WINDOWS
		typedef TCHAR* LPTSTR;
		typedef const TCHAR* LPCTSTR;
#endif
#endif

#if (!defined(PBOS_NT) && !defined(PBOS_WIN40))
#if !defined(PBOS_UNIX)
		//int WINAPI wvsprintfA(LPTSTR, LPCTSTR, os_va_list arglist);
//#define wvsprintf  wvsprintfA
#endif
#endif

#if (!defined(PBOS_NT) && !defined(PBOS_WIN40))
#if !defined(PBOS_UNIX)
		//int WINAPIV wsprintfA(LPTSTR, LPCTSTR, ...);
//#define wsprintf  wsprintfA
#endif
#endif

#else /* !PBWIN32 */

#ifndef WINAPIV
#define WINAPIV     cdecl
#endif

#ifndef PBOS_MAC
#ifndef  PBOS_UNIX
#ifndef _INC_WINDOWS
#ifndef PBSTG_H
		typedef TCHAR FAR* LPTSTR;
		typedef const TCHAR FAR* LPCTSTR;
#endif
#endif
#endif
#endif

		PBCDECLAPI(int, wsprintf) (LPSTR, LPCSTR, ...);

#if !defined(PBOS_UNIX) && !defined(PBOS_MAC)
		PBWINAPI(int, wvsprintf) (LPSTR, LPCSTR, const VOID FAR*);
#endif

#endif /* !PBWIN32 */

		/* *********************************************************************** */
		/*  Prototypes for Windows I/O functions, Don't use these directly.        */
		/* *********************************************************************** */

#ifndef OSWINDOW_H
		PBWINAPI(OS_LFILE, _lopen)     (LPCTSTR, int);
		PBWINAPI(HFILE, _lclose)       (OS_LFILE);
		PBWINAPI(OS_LFILE, _lcreat)    (LPCTSTR, int);
		PBWINAPI(LONG, _llseek)        (OS_LFILE, long, int);
		PBWINAPI(UINT, _lread)         (OS_LFILE, void HUGEPTR*, UINT);
		PBWINAPI(UINT, _lwrite)        (OS_LFILE, const void HUGEPTR*, UINT);


#endif /* OSWINDOW_H */

#ifdef __cplusplus
	}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif /* OSIO_H */
// DOINC popped back into header 'shdebug.h'
#endif
// for codegen, we want to skip including this logging stuff
// DOINC told to skip 5 lines...

//****************************************************************************
// Assume C declarations for C++
//****************************************************************************

#ifdef __cplusplus
	extern "C" {
#endif  /* __cplusplus */

#ifndef PBOS_WIN
#define sh_dbg_out _sh_dbg_out
#endif

		//****************************************************************************
		// Debug codes
		//****************************************************************************

#define DBG_ALWAYS                      (00)
#define DBG_SHOW_CONSOLE                (1)

#define DBG_MEMORY_TRACE                (2)
#define DBG_OB_MEM_TRACE                (3)
#define DBG_CM_MEM_TRACE                (4)
#define DBG_GR_MEM_TRACE                (5)
#define DBG_OB_TRACE_LVALUE_SBPL        (6)
#define DBG_MEM_LEAK_BUILD_EXE_DLL		(7)
#define DBG_MEM_LEAK_REBUILD			(8)

#define DBG_PARSE_TRACE                 (10)
#define DBG_LEX_TRACE                   (11)
#define DBG_PARSETREE_DUMP              (12)
#define DBG_CM_EXPR                     (13)
#define DBG_LEX_QUEUE_TRACE             (14)
#define DBG_PARSE_DETAILS               (15)
#define DBG_LEX_DETAILS                 (16)
#define DBG_CM_PCODE                    (17)
#define DBG_CM_DISP_SEMFUN_NAME         (18)
#define DBG_CM_EXCEPTION_HANDLING		(19)

#define DBG_OBJ_TRACE                   (20)
#define DBG_OBJ_IO                      (21)
#define OB_DBG_OBJ_INH					(22)
#define OB_DBG_OBJ_REF					(23)
#define OB_DBG_GROUP_TRACE				(24)
#define OB_DBG_CLASS_TRACE				(25)
#define OB_DBG_CLASS_QUERY				(26)
#define OB_DBG_GROUP_MEM				(27)
#define OB_DBG_FIELD_TRACE				(28)
#define OB_DBG_IO_STAT					(29)

#define DBG_CALLS_TRACE                 (30)
#define DBG_PCODE_TRACE                 (31)
#define DBG_ENGINE_TRACE                (32)
#define DBG_EVENTS_TRACE                (33)
#define DBG_PCODE_DETAILS               (34)
#define DBG_PCODE_DETAILS_NO_DEBUG      (35)
#define OB_DBG_PCODE_DUMP               (36)
#define OB_DBG_PCODE_LINE_NO_INFO       (37)
#define DBG_OB_REQUEST_QUEUE			(38)

#define DBG_ACTIVE_OBJ                  (40)
#define DBG_ARG_LIST                    (41)
#define OB_DBG_SYMTAB_TRACE				(42)
#define OB_DBG_DMP_GROUP				(43)
#define OB_DBG_DMP_GROUP_DETAIL			(44)
#define OB_DBG_DMP_GROUP_PCODE			(45)
#define OB_DBG_DMP_GROUP_ON_LOAD		(46)
#define OB_DBG_DMP_GROUP_ON_SAVE		(47)

#define DBG_TYPE_COMPILE                (50)
#define DBG_CODEGEN_TYPDEF              (51)
#define OB_DBG_COMPILE_LIST             (52)
#define OB_DBG_COMPILE_LIST_DETAILS		(53)
#define OB_DBG_DESCRIPTOR_PROP_SAVELOAD	(54)
#define DBG_REBUILD						(55)
#define DBG_REBUILD_DETAIL				(56)

#define DBG_SQL                         (60)

#define DBG_SCAN_LEX_TRACE              (71)
#define DBG_SCAN_PARSETREE_DUMP         (72)

#define DBG_PPCS_LEX_TRACE              (76)
#define DBG_PPCS_PARSETREE_DUMP         (77)

#define DBG_CM_OPT_PEEPHOLE_ANALYZE     (80)
#define DBG_CM_OPT_PEEPHOLE_TRACE       (81)
#define DBG_CM_OPT_PEEPHOLE_DUMP        (82)
#define DBG_CM_OPT_PEEPHOLE_DETAILS     (83)
#define DBG_CM_OPT_PEEPHOLE_LINE_INFO   (84)
#define DBG_CM_OPT_PRE_PCODE            (85)
#define DBG_CM_OPT_POST_PCODE           (86)

#define DBG_CGEN_TRACE                  (90)
#define DBG_CGEN_TIME                   (91)
#define DBG_CGEN_TRACE_NULL_FN          (92)
#define DBG_CGEN_DUMP_PCODE             (93)
#define DBG_CGEN_DUMP_PCODE_USAGE       (94)
#define DBG_CGEN_STATS                  (95)
#define DBG_CGEN_USE_MS_COMP            (96)
#define DBG_CGEN_NO_COMP                (97)
#define DBG_CGEN_GEN_DEBUG              (98)
#define DBG_CGEN_GEN_TRACE              (99)
#define DBG_CGEN_GEN_LINE_INFO          (100)
#define DBG_CGEN_DEV_ENV	        	(101)

#define DBG_GARBAGE_COLLECTION_DETAIL	(110)
#define DBG_GARBAGE_COLLECTION			(111)

#define DBG_DW_EVENTS_TRACE             (200)
#define DBG_DW_SETROWPOS_TRACE          (201)
#define DBG_DW_PAINT_TRACE              (202)
#define DBG_DW_PRINT_TRACE              (203)
#define DBG_DW_GENERAL_TRACE            (204)
#define DBG_DW_UTILITY_TRACE            (205)
#define DBG_DW_DATA_TRACE               (206)
#define DBG_DW_EDIT_TRACE               (207)
#define DBG_DW_EXPRESSION_TRACE         (208)
#define DBG_DW_CROSSTAB_TRACE           (209)
#define DBG_DW_RICH_TEXT_TRACE          (210)
#define DBG_DW_DATE_TRACE               (211)
#define DBG_DW_SYNC_TRACE				(212)
#define DBG_DW_BGRAPH_TRACE				(213)
#define DBG_DW_SAVE_TRACE				(214)
#define DBG_DW_LOAD_TRACE				(215)
#define DBG_DW_STG_TRACE				(216)
#define DBG_DW_TABLE_TRACE				(217)
#define DBG_DW_MEMORY_TRACE				(218)
#define DBG_DW_HTML_TABLE_TRACE			(219)
#define DBG_DW_MEMORY_LOG_TRACE			(220)
#define DBG_DW_BLOB_TRACE               (221)

#define DBG_BGR_INTERFACE_TRACE         (250)
#define DBG_BGR_SHOW_TRACE              (251)
#define DBG_BGR_PLOT_TRACE              (252)

#define OB_DBG_INST_IMAGE_TRACE         (300)
#define OB_DBG_INST_IMAGE_DETAIL        (301)

#define DBG_PROF_ACTIVITY_READ          (400)
#define DBG_PROF_BUILD_TRACE            (401)

#define DBG_ODBC_ENVTRACE				(500)
#define DBG_DBI_TRACE					(501)
#define DBG_OLEDB_TRACE					(502)

#define DBG_IMT_TYPE_TRACE				(600)
#define DBG_IMT_SIMPLETYPE_TRACE		(601)
#define DBG_IMT_METHOD_TRACE			(602)
#define DBG_IMT_VARIABLE_TRACE			(603)
#define DBG_IMT_EDIT_SESSION_TRACE		(604)

#define DBG_ROI_MISC					(650)
#define DBG_ROI_INFO					(651)
#define DBG_ROI_START_STOP				(652)
#define DBG_ROI_CTOR_DTOR				(653)
#define DBG_ROI_ADDREF_RELEASE			(654)
#define DBG_ROI_SAVE_LOAD				(655)
#define DBG_ROI_PAINTING				(656)
#define DBG_ROI_DND_CLIP				(657)
#define DBG_ROI_ARG_CONV				(658)
#define DBG_ROI_INTERFACES				(659)
#define DBG_ROI_DLGS					(660)
#define DBG_ROI_INBOUND					(661)


//****************************************************************************
// Debug node structure definition
//****************************************************************************
		typedef struct sh_dbg_node
		{
			INT     unused;
			INT     code;
		} SH_DBG_NODE;

#define PSH_DBG_NODE    SH_DBG_NODE FAR *

		//****************************************************************************
		// Debug this block
		//****************************************************************************
		typedef struct sh_dbg_this
		{
			ppbstg_anchor   stgthis;
			INT             sh_dbg_state;                       //      = OFF;
			INT             dbg_state;                          //      = OFF;
			LPTSTR           dbg_outfile;                        //      = NULL;

			OS_LFILE        dbg_fd_out;
			INT             dbg_open_count;                     //      = 0;
			INT             first_open;                         //      = TRUE;

			PSH_DBG_NODE    dbg_nodes;                          //      = NULL;
			INT             num_dbg_nodes;                      //      = 0;

			INT             dbg_indent_count;                   //      = 0;

			INT             header_flag;                        //      = ON;
			INT             indent_flag;                        //      = ON;
			INT             console_flag;                       //      = OFF;

		} SH_DBG_THIS;

#define PSH_DBG_THIS    SH_DBG_THIS FAR *

		//****************************************************************************
		// Macros
		//****************************************************************************

#ifndef NO_SH_DBG

#define SH_DBG_CONSOLE_INIT()										\
	sh_dbg_console_init()
#define SH_DBG_CONSOLE_OUT(theStr)									\
	sh_dbg_console_out(theStr)
#define SH_DBG_CONSOLE_LOCK()										\
	sh_dbg_console_lock()
#define SH_DBG_CONSOLE_UNLOCK()										\
	sh_dbg_console_unlock()

#define SH_DBG_INIT(stgthis)                                        \
	sh_dbg_init (stgthis)

#define SH_DBG_TERM(stgthis)                                        \
	sh_dbg_term (stgthis)

#define SH_DBG_READ_INPUT(dbgthis,infile)                           \
	sh_dbg_read_input (dbgthis,infile)

#define SH_DBG_OUTFILE(dbgthis,filename)                            \
	sh_dbg_outfile (dbgthis,filename)

// for codegen, we want to skip including this logging stuff
#ifdef DVDBGLOG_H
#define SH_DBG_RUNNING(dbgthis)                                     \
	((((dbgthis)->sh_dbg_state)||PBDevDbgTraceActive()))
#else
#define SH_DBG_RUNNING(dbgthis)                                     \
	((((dbgthis)->sh_dbg_state)))
#endif

#define SH_DBG_OPEN(dbgthis)                                        \
	{                                                               \
	if ((dbgthis)->sh_dbg_state)                                    \
		sh_dbg_open (dbgthis);                                      \
	}

#define SH_DBG_CLOSE(dbgthis)                                       \
	{                                                               \
	if ((dbgthis)->sh_dbg_state)                                    \
		sh_dbg_close (dbgthis);                                     \
	}

#define SH_DBG_SET(dbgthis,code)                                    \
	sh_dbg_set (dbgthis,code)

#define SH_DBG_DEL(dbgthis,code)                                    \
	sh_dbg_del (dbgthis,code)

#define SH_DBG_HEADER(dbgthis,state)                                \
	sh_dbg_header (dbgthis,state);                              	\

#define SH_DBG_INDENT(dbgthis,state)                                \
	sh_dbg_indent (dbgthis,state);                              	\

#define SH_DBG_OUT(dbgthis,args)                                    \
	{                                                               \
	if (SH_DBG_RUNNING(dbgthis))                                    \
		{                                                           \
		sh_dbg_set_this (dbgthis);                                  \
		(void) sh_dbg_out args;                                     \
		}                                                           \
	}

#define SH_DBG_START_INDENT(dbgthis)                                \
	{                                                               \
	if (SH_DBG_RUNNING(dbgthis))                                    \
		sh_dbg_start_indent (dbgthis);                              \
	}

#define SH_DBG_END_INDENT(dbgthis)                                  \
	{                                                               \
	if (SH_DBG_RUNNING(dbgthis))                                    \
		sh_dbg_end_indent (dbgthis);                                \
	}

#define SH_DBG_ENTER(dbgthis,code,string)                           \
	{                                                               \
	if (SH_DBG_RUNNING(dbgthis))                                    \
		(void) sh_dbg_enter (dbgthis,code,string);                  \
	}

#define SH_DBG_LEAVE(dbgthis,code,string)                           \
	{                                                               \
	if (SH_DBG_RUNNING(dbgthis))                                    \
		(void) sh_dbg_leave (dbgthis,code,string);                  \
	}

#define SH_DBG_ON(dbgthis)                                          \
	sh_dbg_on (dbgthis)

#define SH_DBG_OFF(dbgthis)                                         \
	sh_dbg_off (dbgthis)

#define SH_DBG_QUERY(dbgthis,code)                                  \
	(SH_DBG_RUNNING(dbgthis) && sh_dbg_query (dbgthis,code))

#define SH_DBG_IS_HDR_ON(dbgthis)                                   \
	sh_dbg_is_hdr_on (dbgthis)

#define SH_DBG_IS_INDENT_ON(dbgthis)                                \
	sh_dbg_is_indent_on (dbgthis)

#else

#define SH_DBG_CONSOLE_INIT()								{}
#define SH_DBG_CONSOLE_OUT(theStr)							{}
#define SH_DBG_CONSOLE_LOCK()								{}
#define SH_DBG_CONSOLE_UNLOCK()								{}

#define SH_DBG_INIT(stgthis)                                ( NULL )
#define SH_DBG_TERM(stgthis)                                {}
#define SH_DBG_READ_INPUT(dbgthis,infile)                   {}
#define SH_DBG_OUTFILE(dbgthis,filename)                    {}
#define SH_DBG_OPEN(dbgthis)                                {}
#define SH_DBG_CLOSE(dbgthis)                               {}
#define SH_DBG_SET(dbgthis,code)                            {}
#define SH_DBG_DEL(dbgthis,code)                            {}
#define SH_DBG_HEADER(dbgthis,state)                        {}
#define SH_DBG_INDENT(dbgthis,state)                        {}
#define SH_DBG_OUT(dbgthis,args)                            {}
#define SH_DBG_START_INDENT(dbgthis)                        {}
#define SH_DBG_END_INDENT(dbgthis)                          {}
#define SH_DBG_ENTER(dbgthis,code,string)                   {}
#define SH_DBG_LEAVE(dbgthis,code,string)                   {}
#define SH_DBG_ON(dbgthis)                                  {}
#define SH_DBG_OFF(dbgthis)                                 {}
#define SH_DBG_QUERY(dbgthis,code)                          FALSE
#define SH_DBG_IS_HDR_ON(dbgthis)                           {}
#define SH_DBG_IS_INDENT_ON(dbgthis)                        {}
#endif

//****************************************************************************
// Prototypes
//****************************************************************************

		PBWINAPI(VOID, sh_dbg_console_init) (VOID);
		PBWINAPI(VOID, sh_dbg_console_out) (LPTSTR string);
		VOID sh_dbg_console_fmt(LPTSTR lpstrFormat, ...);
		PBWINAPI(VOID, sh_dbg_console_lock) (VOID);
		PBWINAPI(VOID, sh_dbg_console_unlock) (VOID);

		PBWINAPI(PSH_DBG_THIS, sh_dbg_init) (ppbstg_anchor);
		PBWINAPI(PSH_DBG_THIS, sh_dbg_this) (VOID);
		PBWINAPI(VOID, sh_dbg_term) (PSH_DBG_THIS dbgthis);
		PBWINAPI(INT, sh_dbg_read_input) (PSH_DBG_THIS dbgthis, LPTSTR dbg_infile);
		PBWINAPI(VOID, sh_dbg_outfile) (PSH_DBG_THIS dbgthis, LPTSTR filename);
		PBWINAPI(INT, sh_dbg_open) (PSH_DBG_THIS dbgthis);
		PBWINAPI(INT, sh_dbg_close) (PSH_DBG_THIS dbgthis);
		PBWINAPI(INT, sh_dbg_set) (PSH_DBG_THIS dbgthis, INT dbg_code);
		PBWINAPI(INT, sh_dbg_del) (PSH_DBG_THIS dbgthis, INT dbg_code);
		PBWINAPI(VOID, sh_dbg_header) (PSH_DBG_THIS dbgthis, INT header_state);
		PBWINAPI(VOID, sh_dbg_indent) (PSH_DBG_THIS dbgthis, INT indent_state);
		PBWINAPI(VOID, sh_dbg_set_this) (PSH_DBG_THIS dbgthis);
		PBCDECLAPI(INT, sh_dbg_out) (INT code, LPTSTR format_str, ...);
		PBWINAPI(VOID, sh_dbg_start_indent) (PSH_DBG_THIS dbgthis);
		PBWINAPI(VOID, sh_dbg_end_indent) (PSH_DBG_THIS dbgthis);
		PBWINAPI(INT, sh_dbg_enter) (PSH_DBG_THIS dbgthis, INT dbg_code, LPTSTR string);
		PBWINAPI(INT, sh_dbg_leave) (PSH_DBG_THIS dbgthis, INT dbg_code, LPTSTR string);
		PBWINAPI(VOID, sh_dbg_on) (PSH_DBG_THIS dbgthis);
		PBWINAPI(VOID, sh_dbg_off) (PSH_DBG_THIS dbgthis);
		PBWINAPI(INT, sh_dbg_query) (PSH_DBG_THIS dbgthis, INT dbg_code);
		PBWINAPI(INT, sh_dbg_is_hdr_on) (PSH_DBG_THIS dbgthis);
		PBWINAPI(INT, sh_dbg_is_indent_on) (PSH_DBG_THIS dbgthis);


		//****************************************************************************
		// Assertion macro
		//****************************************************************************

		PBWINAPI(void, osAssert)(LPTSTR, LPTSTR, int);

#if !defined(PSVER_R) && !defined(PSNOASSERTS)

#define SH_ASSERT(dbgthis,exp,msg) 										 	\
	((void)																	\
		(																	\
			!(exp) ?		 												\
		 	(																\
		 		(															\
	 				SH_DBG_RUNNING(dbgthis) ?								\
					(														\
			  			sh_dbg_set_this (dbgthis),							\
			  			sh_dbg_out(DBG_ALWAYS,PBTEXT("Assert Error: ")PBTEXT(#exp)PBTEXT("\n")msg)	\
					) : 													\
					0														\
		  		),															\
		  		osAssert(PBTEXT(#exp)PBTEXT("\n")msg, PBTEXT(__FILE__), __LINE__), 					\
	  	  		0															\
	  		) :																\
			0																\
	  	)																	\
	)

#else

#define SH_ASSERT(dbgthis,exp,msg) 		((void)0)

#endif

#define SH_INTERNAL_ERROR(dbgthis,msg) 						  	 			\
	((void)																	\
		(																	\
	 		(															  	\
				SH_DBG_RUNNING(dbgthis) ?								  	\
				(														  	\
	  				sh_dbg_set_this (dbgthis),							  	\
	  				sh_dbg_out(DBG_ALWAYS,PBTEXT("Internal Error: ")msg)	\
				) : 													  	\
				0														  	\
  			),															  	\
	  		osAssert(msg, PBTEXT(__FILE__), __LINE__), 				\
  			0															  	\
		)																  	\
	)


#ifdef __cplusplus
	}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif // SHDEBUG_H

// DOINC popped back into header 'rtccode.h'
// ***** DOINC including pbassert.h *****
/*                                                                         */
/* *********************************************************************** */
/*                                                                         */
/*                 Copyright Powersoft Corporation 1992                    */
/*                                                                         */
/*       Powersoft Corporation ("Powersoft") claims copyright in this      */
/*     program and documentation as an unpublished work, versions of       */
/*     which were first licensed on the date indicated in the foregoing    */
/*     notice. Claim of copyright does not imply waiver of Powersoft's     */
/*     other rights. See Notice of Proprietary Rights.                     */
/*                                                                         */
/*                 NOTICE OF PROPRIETARY RIGHTS                            */
/*                                                                         */
/*       This program and documentation are confidential trade             */
/*     secrets and the property of Powersoft.  Use, examination,           */
/*     reproduction, copying, disassembly, decompilation, transfer         */
/*     and/or disclosure to others are strictly prohibited except by       */
/*     express written agreement with Powersoft.                           */
/*                                                                         */
/* ----------------------------------------------------------------------- */
/*                                                                         */
/*    Filename :    pbassert.h                                             */
/*                                                                         */
/*    Author   :    Dan Zehme                                              */
/*                                                                         */
/*    Purpose  :    Assertion Macros                                       */
/*                                                                         */
/* *********************************************************************** */

#ifndef PBASSERT_H
#define PBASSERT_H

#ifdef __cplusplus
	extern "C" {
#endif

#if defined(PSVER_D) || defined(PSVER_P)

		PBWINAPI(void, osAssert)(LPTSTR, LPTSTR, int);
#define PB_VERIFY_FALSE(exp)	((void)( (exp) && (osAssert(PBTEXT( #exp ), PBTEXT(__FILE__),__LINE__),0) ))
#define PB_VERIFY_NULL(exp)		PB_VERIFY_FALSE(exp)
#define PB_VERIFY(exp)			PB_VERIFY_FALSE(!(exp))
#define PB_ASSERT(exp)			PB_VERIFY(exp)

#else

#define PB_VERIFY_FALSE(exp)	(exp)
#define PB_VERIFY_NULL(exp)		(exp)
#define PB_VERIFY(exp)			(exp)
#define PB_ASSERT(exp) 			((void)0)

#endif

#ifdef __cplusplus
	} /* end of 'extern "C" {' */
#endif

#endif /* PBASSERT_H */
// DOINC popped back into header 'rtccode.h'

#ifdef GENERATED_CODE_BUILD
#ifndef LPBOOL
#define LPBOOL  BOOL FAR *
#endif
#endif

// ***** DOINC including obcurent.h *****
// $RCSfile: obcurent.h $;$Revision: 4.19 $
//**************************************************************************
//
//                            Copyright 1989 
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :	obcurent.h	
//
//    Author   :	Jim Kosko
//
//    Purpose  : 	Definitions for PB object manager currency routines.
//
//****************************************************************************

#ifndef OBCURENT_H
#define OBCURENT_H

//****************************************************************************
// Includes
//****************************************************************************

#ifndef OBDEFINE_H
// ***** DOINC including obdefine.h *****
//**************************************************************************
//
//                            Copyright 1989
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :        obdefine.h
//
//    Author   :        Jim Kosko
//
//    Purpose  :        General definitions for PB object manager.
//
//****************************************************************************

#ifndef OBDEFINE_H
#define OBDEFINE_H


//****************************************************************************
// Assume C declarations for C++
//****************************************************************************

#ifdef __cplusplus
	extern "C" {
#endif  /* __cplusplus */

		//****************************************************************************
		// Includes
		//****************************************************************************

#include <limits.h>
// ***** DOINC including pbstg.h *****
	// DOINC skipping duplicate include
// ***** DOINC including pbcom.h *****
//		Copyright Sybase, Inc. 1998
//
//	Sybase, Inc. ("Sybase") claims copyright in this
//	program and documentation as an unpublished work, versions of
//	which were first licensed on the date indicated in the foregoing
//	notice.  Claim of copyright does not imply waiver of Sybase's
//	other rights.

#ifndef PBCOM_H
#define PBCOM_H

//-------------------------------------------------------------------
// Include windows before OLE does
#ifdef GENERATED_CODE_BUILD

typedef unsigned long   ULONG;
/*
#define HRESULT long
#define SCODE long
#define FACILITY_ITF                    4
#define FACILITY_NULL					0
#define SEVERITY_SUCCESS                0
#define SEVERITY_ERROR                  1
#define SUCCEEDED(Status) ((HRESULT)(Status) >= 0)
#define FAILED(Status) ((HRESULT)(Status)<0)
#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )
#define ResultFromScode(sc) ((HRESULT)((SCODE)(sc) & 0x800FFFFF))
#define E_FAIL              MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_NULL, 8)
#define STDMETHODCALLTYPE       __export __cdecl
#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE
#define REFIID              ULONG

class IUnknown
		{
			// Overrides from IUnknown
			virtual HRESULT STDMETHODCALLTYPE QueryInterface(
				REFIID riid,
				LPVOID FAR* ppObject) = 0;

			virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;

			virtual ULONG STDMETHODCALLTYPE Release(void) = 0;
		};
		*/
#else
#ifndef OSWINDOW_H
// ***** DOINC including oswindow.h *****
	// DOINC skipping duplicate include
#endif

// Include the appropriate COM header
// ***** DOINC including objbase.h *****
/*#!perl
MapHeaderToDll("objbase.h", "ole32.dll");
ActivateAroundFunctionCall("ole32.dll");
#IgnoreFunction("CreateDataAdviseHolder"); # this function occurs in ole2.h and objbase.h
										   # The wrapped one is in objbase.h
IgnoreFunction("CoBuildVersion"); # deprecated
IgnoreFunction("CoGetCurrentProcess"); # never fails => hard to wrap well
IgnoreFunction("CoAddRefServerProcess"); # never fails => hard to wrap well
IgnoreFunction("CoReleaseServerProcess"); # never fails => hard to wrap well
IgnoreFunction("DebugCoGetRpcFault"); # not documented
IgnoreFunction("DebugCoSetRpcFault"); # not documented
IgnoreFunction("wIsEqualGUID");
DeclareFunctionErrorValue("CoLoadLibrary", "NULL");
DeclareFunctionErrorValue("StringFromGUID2" , "0");
DeclareFunctionErrorValue("CoTaskMemAlloc", "NULL");
DeclareFunctionErrorValue("CoTaskMemRealloc", "NULL");
IgnoreFunction("DllGetClassObject"); # client function prototyped (like WinMain)
IgnoreFunction("DllCanUnloadNow"); # client function prototyped (like WinMain)
*/

//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       objbase.h
//
//  Contents:   Component object model defintions.
//
//----------------------------------------------------------------------------

#include <rpc.h>
#include <rpcndr.h>

#if !defined( _OBJBASE_H_ )
#define _OBJBASE_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <pshpack8.h>

#ifdef _MAC
#ifndef _WLM_NOFORCE_LIBS

#ifdef _WLMDLL
#ifdef _DEBUG
#pragma comment(lib, "oledlgd.lib")
#pragma comment(lib, "msvcoled.lib")
#else
#pragma comment(lib, "oledlg.lib")
#pragma comment(lib, "msvcole.lib")
#endif
#else
#ifdef _DEBUG
#pragma comment(lib, "wlmoled.lib")
#pragma comment(lib, "ole2uid.lib")
#else
#pragma comment(lib, "wlmole.lib")
#pragma comment(lib, "ole2ui.lib")
#endif
#pragma data_seg(".drectve")
		static char _gszWlmOLEUIResourceDirective[] = "/macres:ole2ui.rsc";
#pragma data_seg()
#endif

#pragma comment(lib, "uuid.lib")

#ifdef _DEBUG
#pragma comment(lib, "ole2d.lib")
#pragma comment(lib, "ole2autd.lib")
#else
#pragma comment(lib, "ole2.lib")
#pragma comment(lib, "ole2auto.lib")
#endif

#endif // !_WLM_NOFORCE_LIBS
#endif // _MAC

#ifdef _OLE32_
#define WINOLEAPI        STDAPI
#define WINOLEAPI_(type) STDAPI_(type)
#else

#ifdef _68K_
#ifndef REQUIRESAPPLEPASCAL
#define WINOLEAPI        EXTERN_C DECLSPEC_IMPORT HRESULT PASCAL
#define WINOLEAPI_(type) EXTERN_C DECLSPEC_IMPORT type PASCAL
#else
#define WINOLEAPI        EXTERN_C DECLSPEC_IMPORT PASCAL HRESULT
#define WINOLEAPI_(type) EXTERN_C DECLSPEC_IMPORT PASCAL type
#endif
#else
#define WINOLEAPI        EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define WINOLEAPI_(type) EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#endif

#endif

		/****** Interface Declaration ***********************************************/

		/*
		 *      These are macros for declaring interfaces.  They exist so that
		 *      a single definition of the interface is simulataneously a proper
		 *      declaration of the interface structures (C++ abstract classes)
		 *      for both C and C++.
		 *
		 *      DECLARE_INTERFACE(iface) is used to declare an interface that does
		 *      not derive from a base interface.
		 *      DECLARE_INTERFACE_(iface, baseiface) is used to declare an interface
		 *      that does derive from a base interface.
		 *
		 *      By default if the source file has a .c extension the C version of
		 *      the interface declaratations will be expanded; if it has a .cpp
		 *      extension the C++ version will be expanded. if you want to force
		 *      the C version expansion even though the source file has a .cpp
		 *      extension, then define the macro "CINTERFACE".
		 *      eg.     cl -DCINTERFACE file.cpp
		 *
		 *      Example Interface declaration:
		 *
		 *          #undef  INTERFACE
		 *          #define INTERFACE   IClassFactory
		 *
		 *          DECLARE_INTERFACE_(IClassFactory, IUnknown)
		 *          {
		 *              // *** IUnknown methods ***
		 *              STDMETHOD(QueryInterface) (THIS_
		 *                                        REFIID riid,
		 *                                        LPVOID FAR* ppvObj) PURE;
		 *              STDMETHOD_(ULONG,AddRef) (THIS) PURE;
		 *              STDMETHOD_(ULONG,Release) (THIS) PURE;
		 *
		 *              // *** IClassFactory methods ***
		 *              STDMETHOD(CreateInstance) (THIS_
		 *                                        LPUNKNOWN pUnkOuter,
		 *                                        REFIID riid,
		 *                                        LPVOID FAR* ppvObject) PURE;
		 *          };
		 *
		 *      Example C++ expansion:
		 *
		 *          struct FAR IClassFactory : public IUnknown
		 *          {
		 *              virtual HRESULT STDMETHODCALLTYPE QueryInterface(
		 *                                                  IID FAR& riid,
		 *                                                  LPVOID FAR* ppvObj) = 0;
		 *              virtual HRESULT STDMETHODCALLTYPE AddRef(void) = 0;
		 *              virtual HRESULT STDMETHODCALLTYPE Release(void) = 0;
		 *              virtual HRESULT STDMETHODCALLTYPE CreateInstance(
		 *                                              LPUNKNOWN pUnkOuter,
		 *                                              IID FAR& riid,
		 *                                              LPVOID FAR* ppvObject) = 0;
		 *          };
		 *
		 *          NOTE: Our documentation says '#define interface class' but we use
		 *          'struct' instead of 'class' to keep a lot of 'public:' lines
		 *          out of the interfaces.  The 'FAR' forces the 'this' pointers to
		 *          be far, which is what we need.
		 *
		 *      Example C expansion:
		 *
		 *          typedef struct IClassFactory
		 *          {
		 *              const struct IClassFactoryVtbl FAR* lpVtbl;
		 *          } IClassFactory;
		 *
		 *          typedef struct IClassFactoryVtbl IClassFactoryVtbl;
		 *
		 *          struct IClassFactoryVtbl
		 *          {
		 *              HRESULT (STDMETHODCALLTYPE * QueryInterface) (
		 *                                                  IClassFactory FAR* This,
		 *                                                  IID FAR* riid,
		 *                                                  LPVOID FAR* ppvObj) ;
		 *              HRESULT (STDMETHODCALLTYPE * AddRef) (IClassFactory FAR* This) ;
		 *              HRESULT (STDMETHODCALLTYPE * Release) (IClassFactory FAR* This) ;
		 *              HRESULT (STDMETHODCALLTYPE * CreateInstance) (
		 *                                                  IClassFactory FAR* This,
		 *                                                  LPUNKNOWN pUnkOuter,
		 *                                                  IID FAR* riid,
		 *                                                  LPVOID FAR* ppvObject);
		 *              HRESULT (STDMETHODCALLTYPE * LockServer) (
		 *                                                  IClassFactory FAR* This,
		 *                                                  BOOL fLock);
		 *          };
		 */

#if defined(__cplusplus) && !defined(CINTERFACE)
		 //#define interface               struct FAR
#define interface struct
#define STDMETHOD(method)       virtual HRESULT STDMETHODCALLTYPE method
#define STDMETHOD_(type,method) virtual type STDMETHODCALLTYPE method
#define STDMETHODV(method)       virtual HRESULT STDMETHODVCALLTYPE method
#define STDMETHODV_(type,method) virtual type STDMETHODVCALLTYPE method
#define PURE                    = 0
#define THIS_
#define THIS                    void
#define DECLARE_INTERFACE(iface)    interface DECLSPEC_NOVTABLE iface
#define DECLARE_INTERFACE_(iface, baseiface)    interface DECLSPEC_NOVTABLE iface : public baseiface


#if !defined(BEGIN_INTERFACE)
#if defined(_MPPC_)  && \
    ( (defined(_MSC_VER) || defined(__SC__) || defined(__MWERKS__)) && \
    !defined(NO_NULL_VTABLE_ENTRY) )
#define BEGIN_INTERFACE virtual void a() {}
#define END_INTERFACE
#else
#define BEGIN_INTERFACE
#define END_INTERFACE
#endif
#endif

#else

#define interface               struct

#define STDMETHOD(method)       HRESULT (STDMETHODCALLTYPE * method)
#define STDMETHOD_(type,method) type (STDMETHODCALLTYPE * method)
#define STDMETHODV(method)       HRESULT (STDMETHODVCALLTYPE * method)
#define STDMETHODV_(type,method) type (STDMETHODVCALLTYPE * method)

#if !defined(BEGIN_INTERFACE)
#if defined(_MPPC_)
#define BEGIN_INTERFACE       void    *b;
#define END_INTERFACE
#else
#define BEGIN_INTERFACE
#define END_INTERFACE
#endif
#endif


#define PURE
#define THIS_                   INTERFACE FAR* This,
#define THIS                    INTERFACE FAR* This
#ifdef CONST_VTABLE
#undef CONST_VTBL
#define CONST_VTBL const
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    const struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef const struct iface##Vtbl iface##Vtbl; \
                                const struct iface##Vtbl
#else
#undef CONST_VTBL
#define CONST_VTBL
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef struct iface##Vtbl iface##Vtbl; \
                                struct iface##Vtbl
#endif
#define DECLARE_INTERFACE_(iface, baseiface)    DECLARE_INTERFACE(iface)

#endif




		 /****** Additional basic types **********************************************/


#ifndef FARSTRUCT
#ifdef __cplusplus
#define FARSTRUCT   FAR
#else
#define FARSTRUCT
#endif  // __cplusplus
#endif  // FARSTRUCT



#ifndef HUGEP
#if defined(_WIN32) || defined(_MPPC_)
#define HUGEP
#else
#define HUGEP __huge
#endif // WIN32
#endif // HUGEP


#ifdef _MAC
#if !defined(OLE2ANSI)
#define OLE2ANSI
#endif
#endif

#include <stdlib.h>

#define LISet32(li, v) ((li).HighPart = ((LONG) (v)) < 0 ? -1 : 0, (li).LowPart = (v))

#define ULISet32(li, v) ((li).HighPart = 0, (li).LowPart = (v))






#define CLSCTX_INPROC           (CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER)

// With DCOM, CLSCTX_REMOTE_SERVER should be included
#if (_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM) // DCOM
#define CLSCTX_ALL              (CLSCTX_INPROC_SERVER| \
                                 CLSCTX_INPROC_HANDLER| \
                                 CLSCTX_LOCAL_SERVER| \
                                 CLSCTX_REMOTE_SERVER)

#define CLSCTX_SERVER           (CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER|CLSCTX_REMOTE_SERVER)
#else
#define CLSCTX_ALL              (CLSCTX_INPROC_SERVER| \
                                 CLSCTX_INPROC_HANDLER| \
                                 CLSCTX_LOCAL_SERVER )

#define CLSCTX_SERVER           (CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER)
#endif


// class registration flags; passed to CoRegisterClassObject
		typedef enum tagREGCLS
		{
			REGCLS_SINGLEUSE = 0,       // class object only generates one instance
			REGCLS_MULTIPLEUSE = 1,     // same class object genereates multiple inst.
										// and local automatically goes into inproc tbl.
										REGCLS_MULTI_SEPARATE = 2,  // multiple use, but separate control over each
																	// context.
																	REGCLS_SUSPENDED = 4,  // register is as suspended, will be activated
																								// when app calls CoResumeClassObjects
																								REGCLS_SURROGATE = 8   // must be used when a surrogate process
																															// is registering a class object that will be
																															// loaded in the surrogate
		} REGCLS;

		// interface marshaling definitions
#define MARSHALINTERFACE_MIN 500 // minimum number of bytes for interface marshl


//
// Common typedefs for paramaters used in Storage API's, gleamed from storage.h
// Also contains Storage error codes, which should be moved into the storage
// idl files.
//


#define CWCSTORAGENAME 32

/* Storage instantiation modes */
#define STGM_DIRECT             0x00000000L
#define STGM_TRANSACTED         0x00010000L
#define STGM_SIMPLE             0x08000000L

#define STGM_READ               0x00000000L
#define STGM_WRITE              0x00000001L
#define STGM_READWRITE          0x00000002L

#define STGM_SHARE_DENY_NONE    0x00000040L
#define STGM_SHARE_DENY_READ    0x00000030L
#define STGM_SHARE_DENY_WRITE   0x00000020L
#define STGM_SHARE_EXCLUSIVE    0x00000010L

#define STGM_PRIORITY           0x00040000L
#define STGM_DELETEONRELEASE    0x04000000L
#if (WINVER >= 400)
#define STGM_NOSCRATCH          0x00100000L
#endif /* WINVER */

#define STGM_CREATE             0x00001000L
#define STGM_CONVERT            0x00020000L
#define STGM_FAILIFTHERE        0x00000000L

#define STGM_NOSNAPSHOT         0x00200000L
#if (_WIN32_WINNT >= 0x0500)
#define STGM_DIRECT_SWMR        0x00400000L
#endif

/*  flags for internet asyncronous and layout docfile */
#define ASYNC_MODE_COMPATIBILITY    0x00000001L
#define ASYNC_MODE_DEFAULT          0x00000000L

#define STGTY_REPEAT                0x00000100L
#define STG_TOEND                   0xFFFFFFFFL

#define STG_LAYOUT_SEQUENTIAL       0x00000000L
#define STG_LAYOUT_INTERLEAVED      0x00000001L

#define STGFMT_STORAGE          0
#define STGFMT_NATIVE           1
#define STGFMT_FILE             3
#define STGFMT_ANY              4
#define STGFMT_DOCFILE          5

// This is a legacy define to allow old component to builds
#define STGFMT_DOCUMENT         0

/* here is where we pull in the MIDL generated headers for the interfaces */
		typedef interface    IRpcStubBuffer     IRpcStubBuffer;
		typedef interface    IRpcChannelBuffer  IRpcChannelBuffer;

#include <wtypes.h>
#include <unknwn.h>
#include <objidl.h>

#ifdef _OLE32_
#ifdef _OLE32PRIV_
		BOOL _fastcall wIsEqualGUID(REFGUID rguid1, REFGUID rguid2);
#define IsEqualGUID(rguid1, rguid2) wIsEqualGUID(rguid1, rguid2)
#else
#define __INLINE_ISEQUAL_GUID
#endif  // _OLE32PRIV_
#endif  // _OLE32_

#include <guiddef.h>

#ifndef INITGUID
#include <cguid.h>
#endif

		// COM initialization flags; passed to CoInitialize.
		typedef enum tagCOINIT
		{
			COINIT_APARTMENTTHREADED = 0x2,      // Apartment model

#if  (_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM) // DCOM
  // These constants are only valid on Windows NT 4.0
  COINIT_MULTITHREADED = 0x0,      // OLE calls objects on any thread.
  COINIT_DISABLE_OLE1DDE = 0x4,      // Don't use DDE for Ole1 support.
  COINIT_SPEED_OVER_MEMORY = 0x8,      // Trade memory for speed.
#endif // DCOM
		} COINIT;





		/****** STD Object API Prototypes *****************************************/

		WINOLEAPI_(DWORD) CoBuildVersion(VOID);

		/* init/uninit */

		WINOLEAPI  CoInitialize(IN LPVOID pvReserved);
		WINOLEAPI_(void)  CoUninitialize(void);
		WINOLEAPI  CoGetMalloc(IN DWORD dwMemContext, OUT LPMALLOC FAR* ppMalloc);
		WINOLEAPI_(DWORD) CoGetCurrentProcess(void);
		WINOLEAPI  CoRegisterMallocSpy(IN LPMALLOCSPY pMallocSpy);
		WINOLEAPI  CoRevokeMallocSpy(void);
		WINOLEAPI  CoCreateStandardMalloc(IN DWORD memctx, OUT IMalloc FAR* FAR* ppMalloc);

#if (_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM) // DCOM
		/* #!perl PoundIf("CoInitializeEx", "(_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)");
		*/
		WINOLEAPI  CoInitializeEx(IN LPVOID pvReserved, IN DWORD dwCoInit);

		/* #!perl PoundIf("CoGetCallerTID", "(_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)");
		*/
		WINOLEAPI  CoGetCallerTID(LPDWORD lpdwTID);
#endif // DCOM

#if (_WIN32_WINNT >= 0x0501)
		WINOLEAPI  CoRegisterInitializeSpy(IN LPINITIALIZESPY pSpy, OUT ULARGE_INTEGER* puliCookie);
		WINOLEAPI  CoRevokeInitializeSpy(IN ULARGE_INTEGER uliCookie);

		WINOLEAPI  CoGetContextToken(ULONG_PTR* pToken);
#endif

#if DBG == 1
		WINOLEAPI_(ULONG) DebugCoGetRpcFault(void);
		WINOLEAPI_(void) DebugCoSetRpcFault(ULONG);
#endif

#if (_WIN32_WINT >= 0x0500)

		typedef struct tagSOleTlsData
		{
			void* pvReserved0[2];
			DWORD dwReserved0[3];
			void* pvReserved1[1];
			DWORD dwReserved1[3];
			void* pvReserved2[4];
			DWORD dwReserved2[1];
			void* pCurrentCtx;
		} SOleTlsData;

#endif

		/* COM+ APIs */

		WINOLEAPI     CoGetObjectContext(IN REFIID riid, OUT LPVOID FAR* ppv);

		/* register/revoke/get class objects */

		WINOLEAPI  CoGetClassObject(IN REFCLSID rclsid, IN DWORD dwClsContext, IN LPVOID pvReserved,
			IN REFIID riid, OUT LPVOID FAR* ppv);
		WINOLEAPI  CoRegisterClassObject(IN REFCLSID rclsid, IN LPUNKNOWN pUnk,
			IN DWORD dwClsContext, IN DWORD flags, OUT LPDWORD lpdwRegister);
		WINOLEAPI  CoRevokeClassObject(IN DWORD dwRegister);
		WINOLEAPI  CoResumeClassObjects(void);
		WINOLEAPI  CoSuspendClassObjects(void);
		WINOLEAPI_(ULONG) CoAddRefServerProcess(void);
		WINOLEAPI_(ULONG) CoReleaseServerProcess(void);
		WINOLEAPI  CoGetPSClsid(IN REFIID riid, OUT CLSID* pClsid);
		WINOLEAPI  CoRegisterPSClsid(IN REFIID riid, IN REFCLSID rclsid);

		// Registering surrogate processes
		WINOLEAPI  CoRegisterSurrogate(IN LPSURROGATE pSurrogate);

		/* marshaling interface pointers */

		WINOLEAPI CoGetMarshalSizeMax(OUT ULONG* pulSize, IN REFIID riid, IN LPUNKNOWN pUnk,
			IN DWORD dwDestContext, IN LPVOID pvDestContext, IN DWORD mshlflags);
		WINOLEAPI CoMarshalInterface(IN LPSTREAM pStm, IN REFIID riid, IN LPUNKNOWN pUnk,
			IN DWORD dwDestContext, IN LPVOID pvDestContext, IN DWORD mshlflags);
		WINOLEAPI CoUnmarshalInterface(IN LPSTREAM pStm, IN REFIID riid, OUT LPVOID FAR* ppv);
		WINOLEAPI CoMarshalHresult(IN LPSTREAM pstm, IN HRESULT hresult);
		WINOLEAPI CoUnmarshalHresult(IN LPSTREAM pstm, OUT HRESULT FAR* phresult);
		WINOLEAPI CoReleaseMarshalData(IN LPSTREAM pStm);
		WINOLEAPI CoDisconnectObject(IN LPUNKNOWN pUnk, IN DWORD dwReserved);
		WINOLEAPI CoLockObjectExternal(IN LPUNKNOWN pUnk, IN BOOL fLock, IN BOOL fLastUnlockReleases);
		WINOLEAPI CoGetStandardMarshal(IN REFIID riid, IN LPUNKNOWN pUnk,
			IN DWORD dwDestContext, IN LPVOID pvDestContext, IN DWORD mshlflags,
			OUT LPMARSHAL FAR* ppMarshal);


		WINOLEAPI CoGetStdMarshalEx(IN LPUNKNOWN pUnkOuter, IN DWORD smexflags,
			OUT LPUNKNOWN FAR* ppUnkInner);

		/* flags for CoGetStdMarshalEx */
		typedef enum tagSTDMSHLFLAGS
		{
			SMEXF_SERVER = 0x01,       // server side aggregated std marshaler
			SMEXF_HANDLER = 0x02        // client side (handler) agg std marshaler
		} STDMSHLFLAGS;


		WINOLEAPI_(BOOL) CoIsHandlerConnected(IN LPUNKNOWN pUnk);

		// Apartment model inter-thread interface passing helpers
		WINOLEAPI CoMarshalInterThreadInterfaceInStream(IN REFIID riid, IN LPUNKNOWN pUnk,
			OUT LPSTREAM* ppStm);

		WINOLEAPI CoGetInterfaceAndReleaseStream(IN LPSTREAM pStm, IN REFIID iid,
			OUT LPVOID FAR* ppv);

		WINOLEAPI CoCreateFreeThreadedMarshaler(IN LPUNKNOWN  punkOuter,
			OUT LPUNKNOWN* ppunkMarshal);

		/* dll loading helpers; keeps track of ref counts and unloads all on exit */

		WINOLEAPI_(HINSTANCE) CoLoadLibrary(IN LPOLESTR lpszLibName, IN BOOL bAutoFree);
		WINOLEAPI_(void) CoFreeLibrary(IN HINSTANCE hInst);
		WINOLEAPI_(void) CoFreeAllLibraries(void);
		WINOLEAPI_(void) CoFreeUnusedLibraries(void);
#if  (_WIN32_WINNT >= 0x0501)
		/* #!perl PoundIf("CoFreeUnusedLibrariesEx", "(_WIN32_WINNT >= 0x0501)");
		*/
		WINOLEAPI_(void) CoFreeUnusedLibrariesEx(IN DWORD dwUnloadDelay, IN DWORD dwReserved);
#endif

#if (_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM) // DCOM

		/* Call Security. */

		/* #!perl PoundIf("CoInitializeSecurity", "(_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)");
		*/
		WINOLEAPI CoInitializeSecurity(
			IN PSECURITY_DESCRIPTOR         pSecDesc,
			IN LONG                         cAuthSvc,
			IN SOLE_AUTHENTICATION_SERVICE* asAuthSvc,
			IN void* pReserved1,
			IN DWORD                        dwAuthnLevel,
			IN DWORD                        dwImpLevel,
			IN void* pAuthList,
			IN DWORD                        dwCapabilities,
			IN void* pReserved3);

		/* #!perl PoundIf("CoGetCallContext", "(_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)");
		*/
		WINOLEAPI CoGetCallContext(IN REFIID riid, OUT void** ppInterface);

		/* #!perl PoundIf("CoQueryProxyBlanket", "(_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)");
		*/
		WINOLEAPI CoQueryProxyBlanket(
			IN  IUnknown* pProxy,
			OUT DWORD* pwAuthnSvc,
			OUT DWORD* pAuthzSvc,
			OUT OLECHAR** pServerPrincName,
			OUT DWORD* pAuthnLevel,
			OUT DWORD* pImpLevel,
			OUT RPC_AUTH_IDENTITY_HANDLE* pAuthInfo,
			OUT DWORD* pCapabilites);

		/* #!perl PoundIf("CoSetProxyBlanket", "(_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)");
		*/
		WINOLEAPI CoSetProxyBlanket(
			IN IUnknown* pProxy,
			IN DWORD                     dwAuthnSvc,
			IN DWORD                     dwAuthzSvc,
			IN OLECHAR* pServerPrincName,
			IN DWORD                     dwAuthnLevel,
			IN DWORD                     dwImpLevel,
			IN RPC_AUTH_IDENTITY_HANDLE  pAuthInfo,
			IN DWORD                     dwCapabilities);

		/* #!perl PoundIf("CoCopyProxy", "(_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)");
		*/
		WINOLEAPI CoCopyProxy(
			IN  IUnknown* pProxy,
			OUT IUnknown** ppCopy);

		/* #!perl PoundIf("CoQueryClientBlanket", "(_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)");
		*/
		WINOLEAPI CoQueryClientBlanket(
			OUT DWORD* pAuthnSvc,
			OUT DWORD* pAuthzSvc,
			OUT OLECHAR** pServerPrincName,
			OUT DWORD* pAuthnLevel,
			OUT DWORD* pImpLevel,
			OUT RPC_AUTHZ_HANDLE* pPrivs,
			OUT DWORD* pCapabilities);

		/* #!perl PoundIf("CoImpersonateClient", "(_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)");
		*/
		WINOLEAPI CoImpersonateClient();

		/* #!perl PoundIf("CoRevertToSelf", "(_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)");
		*/
		WINOLEAPI CoRevertToSelf();

		/* #!perl PoundIf("CoQueryAuthenticationServices", "(_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)");
		*/
		WINOLEAPI CoQueryAuthenticationServices(
			OUT DWORD* pcAuthSvc,
			OUT SOLE_AUTHENTICATION_SERVICE** asAuthSvc);

		/* #!perl PoundIf("CoSwitchCallContext", "(_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)");
		*/
		WINOLEAPI CoSwitchCallContext(IN IUnknown* pNewObject, OUT IUnknown** ppOldObject);

#define COM_RIGHTS_EXECUTE 1
#define COM_RIGHTS_SAFE_FOR_SCRIPTING 2

#endif // DCOM

		/* helper for creating instances */

		WINOLEAPI CoCreateInstance(IN REFCLSID rclsid, IN LPUNKNOWN pUnkOuter,
			IN DWORD dwClsContext, IN REFIID riid, OUT LPVOID FAR* ppv);


#if (_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM) // DCOM

		/* #!perl PoundIf("CoGetInstanceFromFile", "(_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)");
		*/
		WINOLEAPI CoGetInstanceFromFile(
			IN COSERVERINFO* pServerInfo,
			IN CLSID* pClsid,
			IN IUnknown* punkOuter, // only relevant locally
			IN DWORD                       dwClsCtx,
			IN DWORD                       grfMode,
			IN OLECHAR* pwszName,
			IN DWORD                       dwCount,
			IN OUT MULTI_QI* pResults);

		/* #!perl PoundIf("CoGetInstanceFromIStorage", "(_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)");
		*/
		WINOLEAPI CoGetInstanceFromIStorage(
			IN COSERVERINFO* pServerInfo,
			IN CLSID* pClsid,
			IN IUnknown* punkOuter, // only relevant locally
			IN DWORD                       dwClsCtx,
			IN struct IStorage* pstg,
			IN DWORD                       dwCount,
			IN OUT MULTI_QI* pResults);

		/* #!perl PoundIf("CoCreateInstanceEx", "(_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)");
		*/
		WINOLEAPI CoCreateInstanceEx(
			IN REFCLSID                    Clsid,
			IN IUnknown* punkOuter, // only relevant locally
			IN DWORD                       dwClsCtx,
			IN COSERVERINFO* pServerInfo,
			IN DWORD                       dwCount,
			IN OUT MULTI_QI* pResults);

#endif // DCOM

		/* Call related APIs */
#if (_WIN32_WINNT >= 0x0500 ) || defined(_WIN32_DCOM) // DCOM

/* #!perl PoundIf("CoGetCancelObject", "(_WIN32_WINNT >= 0x0500 ) || defined(_WIN32_DCOM)");
*/
		WINOLEAPI CoGetCancelObject(IN DWORD dwThreadId, IN REFIID iid, OUT void** ppUnk);

		/* #!perl PoundIf("CoSetCancelObject", "(_WIN32_WINNT >= 0x0500 ) || defined(_WIN32_DCOM)");
		*/
		WINOLEAPI CoSetCancelObject(IN IUnknown* pUnk);

		/* #!perl PoundIf("CoCancelCall", "(_WIN32_WINNT >= 0x0500 ) || defined(_WIN32_DCOM)");
		*/
		WINOLEAPI CoCancelCall(IN DWORD dwThreadId, IN ULONG ulTimeout);

		/* #!perl PoundIf("CoTestCancel", "(_WIN32_WINNT >= 0x0500 ) || defined(_WIN32_DCOM)");
		*/
		WINOLEAPI CoTestCancel();

		/* #!perl PoundIf("CoEnableCallCancellation", "(_WIN32_WINNT >= 0x0500 ) || defined(_WIN32_DCOM)");
		*/
		WINOLEAPI CoEnableCallCancellation(IN LPVOID pReserved);

		/* #!perl PoundIf("CoDisableCallCancellation", "(_WIN32_WINNT >= 0x0500 ) || defined(_WIN32_DCOM)");
		*/
		WINOLEAPI CoDisableCallCancellation(IN LPVOID pReserved);

		/* #!perl PoundIf("CoAllowSetForegroundWindow", "(_WIN32_WINNT >= 0x0500 ) || defined(_WIN32_DCOM)");
		*/
		WINOLEAPI CoAllowSetForegroundWindow(IN IUnknown* pUnk, IN LPVOID lpvReserved);

		/* #!perl PoundIf("DcomChannelSetHResult", "(_WIN32_WINNT >= 0x0500 ) || defined(_WIN32_DCOM)");
		*/
		WINOLEAPI DcomChannelSetHResult(IN LPVOID pvReserved, IN ULONG* pulReserved, IN HRESULT appsHR);

#endif

		/* other helpers */

		WINOLEAPI StringFromCLSID(IN REFCLSID rclsid, OUT LPOLESTR FAR* lplpsz);
		WINOLEAPI CLSIDFromString(IN LPOLESTR lpsz, OUT LPCLSID pclsid);
		WINOLEAPI StringFromIID(IN REFIID rclsid, OUT LPOLESTR FAR* lplpsz);
		WINOLEAPI IIDFromString(IN LPOLESTR lpsz, OUT LPIID lpiid);
		WINOLEAPI_(BOOL) CoIsOle1Class(IN REFCLSID rclsid);
		WINOLEAPI ProgIDFromCLSID(IN REFCLSID clsid, OUT LPOLESTR FAR* lplpszProgID);
		WINOLEAPI CLSIDFromProgID(IN LPCOLESTR lpszProgID, OUT LPCLSID lpclsid);
		WINOLEAPI CLSIDFromProgIDEx(IN LPCOLESTR lpszProgID, OUT LPCLSID lpclsid);
		WINOLEAPI_(int) StringFromGUID2(IN REFGUID rguid, OUT LPOLESTR lpsz, IN int cchMax);

		WINOLEAPI CoCreateGuid(OUT GUID FAR* pguid);

		WINOLEAPI_(BOOL) CoFileTimeToDosDateTime(
			IN FILETIME FAR* lpFileTime, OUT LPWORD lpDosDate, OUT LPWORD lpDosTime);
		WINOLEAPI_(BOOL) CoDosDateTimeToFileTime(
			IN WORD nDosDate, IN WORD nDosTime, OUT FILETIME FAR* lpFileTime);
		WINOLEAPI  CoFileTimeNow(OUT FILETIME FAR* lpFileTime);


		WINOLEAPI CoRegisterMessageFilter(IN LPMESSAGEFILTER lpMessageFilter,
			OUT LPMESSAGEFILTER FAR* lplpMessageFilter);

#if (_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM) // DCOM
		/* #!perl PoundIf("CoRegisterChannelHook", "(_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)");
		*/
		WINOLEAPI CoRegisterChannelHook(IN REFGUID ExtensionUuid, IN IChannelHook* pChannelHook);
#endif // DCOM

#if (_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM) // DCOM
		/* Synchronization API */

		/* #!perl PoundIf("CoWaitForMultipleHandles", "(_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)");
		*/
		WINOLEAPI CoWaitForMultipleHandles(IN DWORD dwFlags,
			IN DWORD dwTimeout,
			IN ULONG cHandles,
			IN LPHANDLE pHandles,
			OUT LPDWORD  lpdwindex);

		/* Flags for Synchronization API and Classes */

		typedef enum tagCOWAIT_FLAGS
		{
			COWAIT_WAITALL = 1,
			COWAIT_ALERTABLE = 2,
			COWAIT_INPUTAVAILABLE = 4
		}COWAIT_FLAGS;

#endif // DCOM

		/* for flushing OLESCM remote binding handles */

#if  (_WIN32_WINNT >= 0x0501)
		WINOLEAPI CoInvalidateRemoteMachineBindings(LPOLESTR pszMachineName);
#endif

		/* TreatAs APIS */

		WINOLEAPI CoGetTreatAsClass(IN REFCLSID clsidOld, OUT LPCLSID pClsidNew);
		WINOLEAPI CoTreatAsClass(IN REFCLSID clsidOld, IN REFCLSID clsidNew);


		/* the server dlls must define their DllGetClassObject and DllCanUnloadNow
		 * to match these; the typedefs are located here to ensure all are changed at
		 * the same time.
		 */

		 //#ifdef _MAC
		 //typedef STDAPICALLTYPE HRESULT (* LPFNGETCLASSOBJECT) (REFCLSID, REFIID, LPVOID *);
		 //#else
		typedef HRESULT(STDAPICALLTYPE* LPFNGETCLASSOBJECT) (REFCLSID, REFIID, LPVOID*);
		//#endif

		//#ifdef _MAC
		//typedef STDAPICALLTYPE HRESULT (* LPFNCANUNLOADNOW)(void);
		//#else
		typedef HRESULT(STDAPICALLTYPE* LPFNCANUNLOADNOW)(void);
		//#endif

		STDAPI  DllGetClassObject(IN REFCLSID rclsid, IN REFIID riid, OUT LPVOID FAR* ppv);

		STDAPI  DllCanUnloadNow(void);


		/****** Default Memory Allocation ******************************************/
		WINOLEAPI_(LPVOID) CoTaskMemAlloc(IN SIZE_T cb);
		WINOLEAPI_(LPVOID) CoTaskMemRealloc(IN LPVOID pv, IN SIZE_T cb);
		WINOLEAPI_(void)   CoTaskMemFree(IN LPVOID pv);

		/****** DV APIs ***********************************************************/

		/* This function is declared in objbase.h and ole2.h */
		WINOLEAPI CreateDataAdviseHolder(OUT LPDATAADVISEHOLDER FAR* ppDAHolder);

		WINOLEAPI CreateDataCache(IN LPUNKNOWN pUnkOuter, IN REFCLSID rclsid,
			IN REFIID iid, OUT LPVOID FAR* ppv);


		/****** Storage API Prototypes ********************************************/


		WINOLEAPI StgCreateDocfile(IN const OLECHAR FAR* pwcsName,
			IN DWORD grfMode,
			IN DWORD reserved,
			OUT IStorage FAR* FAR* ppstgOpen);

		WINOLEAPI StgCreateDocfileOnILockBytes(IN ILockBytes FAR* plkbyt,
			IN DWORD grfMode,
			IN DWORD reserved,
			OUT IStorage FAR* FAR* ppstgOpen);

		WINOLEAPI StgOpenStorage(IN const OLECHAR FAR* pwcsName,
			IN  IStorage FAR* pstgPriority,
			IN  DWORD grfMode,
			IN  SNB snbExclude,
			IN  DWORD reserved,
			OUT IStorage FAR* FAR* ppstgOpen);
		WINOLEAPI StgOpenStorageOnILockBytes(IN ILockBytes FAR* plkbyt,
			IN  IStorage FAR* pstgPriority,
			IN  DWORD grfMode,
			IN  SNB snbExclude,
			IN  DWORD reserved,
			OUT IStorage FAR* FAR* ppstgOpen);

		WINOLEAPI StgIsStorageFile(IN const OLECHAR FAR* pwcsName);
		WINOLEAPI StgIsStorageILockBytes(IN ILockBytes FAR* plkbyt);

		WINOLEAPI StgSetTimes(IN OLECHAR const FAR* lpszName,
			IN FILETIME const FAR* pctime,
			IN FILETIME const FAR* patime,
			IN FILETIME const FAR* pmtime);

		WINOLEAPI StgOpenAsyncDocfileOnIFillLockBytes(IN IFillLockBytes* pflb,
			IN  DWORD grfMode,
			IN  DWORD asyncFlags,
			OUT IStorage** ppstgOpen);

		WINOLEAPI StgGetIFillLockBytesOnILockBytes(IN ILockBytes* pilb,
			OUT IFillLockBytes** ppflb);

		WINOLEAPI StgGetIFillLockBytesOnFile(IN OLECHAR const* pwcsName,
			OUT IFillLockBytes** ppflb);


		WINOLEAPI StgOpenLayoutDocfile(IN OLECHAR const* pwcsDfName,
			IN  DWORD grfMode,
			IN  DWORD reserved,
			OUT IStorage** ppstgOpen);

		// STG initialization options for StgCreateStorageEx and StgOpenStorageEx
#define STGOPTIONS_VERSION 2

		typedef struct tagSTGOPTIONS
		{
			USHORT usVersion;            // Versions 1 and 2 supported
			USHORT reserved;             // must be 0 for padding
			ULONG ulSectorSize;          // docfile header sector size (512)
			const WCHAR* pwcsTemplateFile;  // version 2 or above 
		} STGOPTIONS;

		WINOLEAPI StgCreateStorageEx(IN const WCHAR* pwcsName,
			IN  DWORD grfMode,
			IN  DWORD stgfmt,              // enum
			IN  DWORD grfAttrs,             // reserved
			IN  STGOPTIONS* pStgOptions,
			IN  void* reserved,
			IN  REFIID riid,
			OUT void** ppObjectOpen);

		WINOLEAPI StgOpenStorageEx(IN const WCHAR* pwcsName,
			IN  DWORD grfMode,
			IN  DWORD stgfmt,              // enum
			IN  DWORD grfAttrs,             // reserved
			IN  STGOPTIONS* pStgOptions,
			IN  void* reserved,
			IN  REFIID riid,
			OUT void** ppObjectOpen);


		//
		//  Moniker APIs
		//

		WINOLEAPI  BindMoniker(IN LPMONIKER pmk, IN DWORD grfOpt, IN REFIID iidResult, OUT LPVOID FAR* ppvResult);

		WINOLEAPI  CoInstall(
			IN  IBindCtx* pbc,
			IN  DWORD          dwFlags,
			IN  uCLSSPEC* pClassSpec,
			IN  QUERYCONTEXT* pQuery,
			IN  LPWSTR         pszCodeBase);

		WINOLEAPI  CoGetObject(IN LPCWSTR pszName, IN BIND_OPTS* pBindOptions, IN REFIID riid, OUT void** ppv);
		WINOLEAPI  MkParseDisplayName(IN LPBC pbc, IN LPCOLESTR szUserName,
			OUT ULONG FAR* pchEaten, OUT LPMONIKER FAR* ppmk);
		WINOLEAPI  MonikerRelativePathTo(IN LPMONIKER pmkSrc, IN LPMONIKER pmkDest, OUT LPMONIKER
			FAR* ppmkRelPath, IN BOOL dwReserved);
		WINOLEAPI  MonikerCommonPrefixWith(IN LPMONIKER pmkThis, IN LPMONIKER pmkOther,
			OUT LPMONIKER FAR* ppmkCommon);
		WINOLEAPI  CreateBindCtx(IN DWORD reserved, OUT LPBC FAR* ppbc);
		WINOLEAPI  CreateGenericComposite(IN LPMONIKER pmkFirst, IN LPMONIKER pmkRest,
			OUT LPMONIKER FAR* ppmkComposite);
		WINOLEAPI  GetClassFile(IN LPCOLESTR szFilename, OUT CLSID FAR* pclsid);

		WINOLEAPI  CreateClassMoniker(IN REFCLSID rclsid, OUT LPMONIKER FAR* ppmk);

		WINOLEAPI  CreateFileMoniker(IN LPCOLESTR lpszPathName, OUT LPMONIKER FAR* ppmk);

		WINOLEAPI  CreateItemMoniker(IN LPCOLESTR lpszDelim, IN LPCOLESTR lpszItem,
			OUT LPMONIKER FAR* ppmk);
		WINOLEAPI  CreateAntiMoniker(OUT LPMONIKER FAR* ppmk);
		WINOLEAPI  CreatePointerMoniker(IN LPUNKNOWN punk, OUT LPMONIKER FAR* ppmk);
		WINOLEAPI  CreateObjrefMoniker(IN LPUNKNOWN punk, OUT LPMONIKER FAR* ppmk);

		WINOLEAPI  GetRunningObjectTable(IN DWORD reserved, OUT LPRUNNINGOBJECTTABLE FAR* pprot);

#include <urlmon.h>
#include <propidl.h>

		//
		// Standard Progress Indicator impolementation
		//
		WINOLEAPI CreateStdProgressIndicator(IN HWND hwndParent,
			IN  LPCOLESTR pszTitle,
			IN  IBindStatusCallback* pIbscCaller,
			OUT IBindStatusCallback** ppIbsc);

		//12ea2135-0f75-4d97-821a-c78c710d42b8
		/*#!perl
		SetInsertionPoint("objbase.h", "12ea2135-0f75-4d97-821a-c78c710d42b8");
		*/

#ifndef RC_INVOKED
#include <poppack.h>
#endif // RC_INVOKED

#endif     // __OBJBASE_H__
		// DOINC popped back into header 'pbcom.h'
		// ***** DOINC including cguid.h *****
		//+-------------------------------------------------------------------------
		//
		//  Microsoft Windows
		//  Copyright (c) Microsoft Corporation. All rights reserved.
		//
		//  File:       cguid.h
		//
		//--------------------------------------------------------------------------

#ifndef __CGUID_H__
#define __CGUID_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
		extern "C" {
#endif

			extern const IID GUID_NULL;
			extern const IID CATID_MARSHALER;
			extern const IID IID_IRpcChannel;
			extern const IID IID_IRpcStub;
			extern const IID IID_IStubManager;
			extern const IID IID_IRpcProxy;
			extern const IID IID_IProxyManager;
			extern const IID IID_IPSFactory;
			extern const IID IID_IInternalMoniker;
			extern const IID IID_IDfReserved1;
			extern const IID IID_IDfReserved2;
			extern const IID IID_IDfReserved3;
			extern const CLSID CLSID_StdMarshal;
			extern const CLSID CLSID_AggStdMarshal;
			extern const CLSID CLSID_StdAsyncActManager;
			extern const IID IID_IStub;
			extern const IID IID_IProxy;
			extern const IID IID_IEnumGeneric;
			extern const IID IID_IEnumHolder;
			extern const IID IID_IEnumCallback;
			extern const IID IID_IOleManager;
			extern const IID IID_IOlePresObj;
			extern const IID IID_IDebug;
			extern const IID IID_IDebugStream;
			extern const CLSID CLSID_PSGenObject;
			extern const CLSID CLSID_PSClientSite;
			extern const CLSID CLSID_PSClassObject;
			extern const CLSID CLSID_PSInPlaceActive;
			extern const CLSID CLSID_PSInPlaceFrame;
			extern const CLSID CLSID_PSDragDrop;
			extern const CLSID CLSID_PSBindCtx;
			extern const CLSID CLSID_PSEnumerators;
			extern const CLSID CLSID_StaticMetafile;
			extern const CLSID CLSID_StaticDib;
			extern const CLSID CID_CDfsVolume;
			extern const CLSID CLSID_DCOMAccessControl;
			extern const CLSID CLSID_StdGlobalInterfaceTable;
			extern const CLSID CLSID_ComBinding;
			extern const CLSID CLSID_StdEvent;
			extern const CLSID CLSID_ManualResetEvent;
			extern const CLSID CLSID_SynchronizeContainer;
			extern const CLSID CLSID_AddrControl;

			//********************************************
			//
			// CD Forms CLSIDs
			//
			//********************************************

			//
			// Form Kernel objects
			//
			extern const CLSID CLSID_CCDFormKrnl;
			extern const CLSID CLSID_CCDPropertyPage;
			extern const CLSID CLSID_CCDFormDialog;

			//
			// Control objects
			//
			extern const CLSID CLSID_CCDCommandButton;
			extern const CLSID CLSID_CCDComboBox;
			extern const CLSID CLSID_CCDTextBox;
			extern const CLSID CLSID_CCDCheckBox;
			extern const CLSID CLSID_CCDLabel;
			extern const CLSID CLSID_CCDOptionButton;
			extern const CLSID CLSID_CCDListBox;
			extern const CLSID CLSID_CCDScrollBar;
			extern const CLSID CLSID_CCDGroupBox;

			//
			// Property Pages
			//
			extern const CLSID CLSID_CCDGeneralPropertyPage;
			extern const CLSID CLSID_CCDGenericPropertyPage;
			extern const CLSID CLSID_CCDFontPropertyPage;
			extern const CLSID CLSID_CCDColorPropertyPage;
			extern const CLSID CLSID_CCDLabelPropertyPage;
			extern const CLSID CLSID_CCDCheckBoxPropertyPage;
			extern const CLSID CLSID_CCDTextBoxPropertyPage;
			extern const CLSID CLSID_CCDOptionButtonPropertyPage;
			extern const CLSID CLSID_CCDListBoxPropertyPage;
			extern const CLSID CLSID_CCDCommandButtonPropertyPage;
			extern const CLSID CLSID_CCDComboBoxPropertyPage;
			extern const CLSID CLSID_CCDScrollBarPropertyPage;
			extern const CLSID CLSID_CCDGroupBoxPropertyPage;
			extern const CLSID CLSID_CCDXObjectPropertyPage;

			extern const CLSID CLSID_CStdPropertyFrame;

			extern const CLSID CLSID_CFormPropertyPage;
			extern const CLSID CLSID_CGridPropertyPage;

			extern const CLSID CLSID_CWSJArticlePage;
			extern const CLSID CLSID_CSystemPage;

			extern const CLSID CLSID_IdentityUnmarshal;
			extern const CLSID CLSID_InProcFreeMarshaler;

			extern const CLSID CLSID_Picture_Metafile;
			extern const CLSID CLSID_Picture_EnhMetafile;
			extern const CLSID CLSID_Picture_Dib;

			//
			// Enumerations
			//
			extern const GUID GUID_TRISTATE;

#ifdef __cplusplus
		}
#endif


#endif // __CGUID_H__
		// DOINC popped back into header 'pbcom.h'

#ifdef PBOS_UNIX
	// Definitions so 32-bit IDL generated headers will compile in 16-bit
#define DECLSPEC_UUID(x)
#endif // PBOS_UNIX
#endif //GENERATED_CODE_BUILD

// Allow the build to work with newer MIDL compilers
#ifndef MIDL_INTERFACE
#define MIDL_INTERFACE(a) struct
#endif


/*-------------------------------------------------------------------
  IUnknown implementation macros

class CSample : public IMyInterface // IMyInterface is derived from IUnknown
{
	PB_Unknown_Delcare(); // defines interface and m_cRef

	// IMyInteraface methods

	CSample();
};

CSample::CSample()
{
	PB_Unknown_Construct();
}

PB_Unknown_QueryInterface(CSample, IMyInterface)
PB_Unknown_AddRef(CSample)
PB_Unknown_Release(CSample)

*/

#define PB_Unknown_Declare() \
	private: \
		LONG m_cRef; \
	public: \
		virtual HRESULT STDMETHODCALLTYPE QueryInterface( \
			/* [in] */ REFIID riid, \
			/* [iid_is][out] */ void **ppvObject); \
		virtual ULONG STDMETHODCALLTYPE AddRef( void); \
		virtual ULONG STDMETHODCALLTYPE Release( void);

#define PB_Unknown_Construct() \
	m_cRef = 1

#define PB_Unknown_QueryInterface(T, I) \
	STDMETHODIMP T ::QueryInterface(REFIID riid, void **ppvObject) \
	{ \
		*ppvObject = NULL; \
		if (riid == IID_IUnknown || riid == IID_##I) \
		{ \
			*ppvObject = (I *)this; \
			AddRef(); \
			return S_OK; \
		} \
		return E_NOINTERFACE; \
	}

#define PB_Unknown_AddRef(T) \
	STDMETHODIMP_(ULONG) T ::AddRef() \
	{ \
		InterlockedIncrement(&m_cRef); \
		return m_cRef; \
	}

#define PB_Unknown_Release(T) \
	STDMETHODIMP_(ULONG) T ::Release() \
	{ \
		InterlockedDecrement(&m_cRef); \
		if (m_cRef == 0) \
		{ \
			delete this; \
			return 0; \
		} \
		return m_cRef; \
	}


/*-------------------------------------------------------------------
   IDispatch implementation macros

class CSample : public IMyInterface // IMyInterface is derived from IDispatch
{
	PB_Dispatch_Declare();	// defines interface and m_pITypeInfo

	// IMyInteraface methods

	CSample();
	~CSample();
};

CSample::CSample()
{
	PB_Dispatch_Construct(LIBID_MyTypelibrary, majorversion, minorversion, IMyInterface);
}

CSample::~CSample()
{
	PB_Dispatch_Destruct();
}

PB_Dispatch_QueryInterface(CSample, IMyInterface)
PB_Dispatch_AddRef(CSample)
PB_Dispatch_Release(CSample)
PB_Dispatch_GetTypeInfoCount(CSample)
PB_Dispatch_GetTypeInfo(CSample)
PB_Dispatch_GetIDsOfNames(CSample)
PB_Dispatch_Invoke(CSample)

*/

#define PB_Dispatch_Declare() \
		PB_Unknown_Declare() \
	private: \
		ITypeInfo* m_pITypeInfo; \
	public: \
		virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount( \
			/* [out] */ UINT *pctinfo); \
		virtual HRESULT STDMETHODCALLTYPE GetTypeInfo( \
			/* [in] */ UINT iTInfo, \
			/* [in] */ LCID lcid, \
			/* [out] */ ITypeInfo **ppTInfo); \
		virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames( \
			/* [in] */ REFIID riid, \
			/* [size_is][in] */ LPOLESTR *rgszNames, \
			/* [in] */ UINT cNames, \
			/* [in] */ LCID lcid, \
			/* [size_is][out] */ DISPID *rgDispId); \
		virtual /* [local] */ HRESULT STDMETHODCALLTYPE Invoke( \
			/* [in] */ DISPID dispIdMember, \
			/* [in] */ REFIID riid, \
			/* [in] */ LCID lcid, \
			/* [in] */ WORD wFlags, \
			/* [out][in] */ DISPPARAMS *pDispParams, \
			/* [out] */ VARIANT *pVarResult, \
			/* [out] */ EXCEPINFO *pExcepInfo, \
			/* [out] */ UINT *puArgErr); 

#define PB_Dispatch_Construct(L, major, minor, I) \
	PB_Unknown_Construct(); \
	ITypeLib* pITypeLib = NULL; \
	m_pITypeInfo = NULL; \
	if (SUCCEEDED(::LoadRegTypeLib(L, major, minor, 0x00, &pITypeLib))) \
	{ \
		pITypeLib->GetTypeInfoOfGuid(IID_##I, &m_pITypeInfo); \
		pITypeLib->Release(); \
	}

#define PB_Dispatch_Destruct() \
	if (m_pITypeInfo) \
		m_pITypeInfo->Release();

#define PB_Dispatch_QueryInterface(T, I) \
	STDMETHODIMP T ::QueryInterface(REFIID riid, void **ppvObject) \
	{ \
		*ppvObject = NULL; \
		if (riid == IID_IUnknown || riid == IID_IDispatch || riid == IID_##I) \
		{ \
			*ppvObject = (I *)this; \
			AddRef(); \
			return S_OK; \
		} \
		return E_NOINTERFACE; \
	} 

#define PB_Dispatch_AddRef(T) \
	PB_Unknown_AddRef(T)

#define PB_Dispatch_Release(T) \
	PB_Unknown_Release(T)

#define PB_Dispatch_GetTypeInfoCount(T) \
	STDMETHODIMP T ::GetTypeInfoCount(/* [out] */ UINT *pctinfo) \
	{ \
		*pctinfo = 1; \
		return S_OK; \
	}

#define PB_Dispatch_GetTypeInfo(T) \
	STDMETHODIMP T ::GetTypeInfo( \
		/* [in] */ UINT iTInfo, \
		/* [in] */ LCID lcid, \
		/* [out] */ ITypeInfo **ppTInfo) \
	{ \
		*ppTInfo = NULL; \
	\
		if (iTInfo != 0) \
			return DISP_E_BADINDEX; \
	\
		*ppTInfo = m_pITypeInfo; \
		(*ppTInfo)->AddRef(); \
		return S_OK; \
	}

#define PB_Dispatch_GetIDsOfNames(T) \
	STDMETHODIMP T ::GetIDsOfNames( \
			/* [in] */ REFIID riid, \
			/* [size_is][in] */ LPOLESTR *rgszNames, \
			/* [in] */ UINT cNames, \
			/* [in] */ LCID lcid, \
			/* [size_is][out] */ DISPID *rgDispId) \
	{ \
		if (riid != IID_NULL) \
			return DISP_E_UNKNOWNINTERFACE; \
	 \
		return m_pITypeInfo->GetIDsOfNames(rgszNames, cNames, rgDispId); \
	} 

#define PB_Dispatch_Invoke(T) \
	STDMETHODIMP T ::Invoke( \
		/* [in] */ DISPID dispIdMember, \
		/* [in] */ REFIID riid, \
		/* [in] */ LCID lcid, \
		/* [in] */ WORD wFlags, \
		/* [out][in] */ DISPPARAMS *pDispParams, \
		/* [out] */ VARIANT *pVarResult, \
		/* [out] */ EXCEPINFO *pExcepInfo, \
		/* [out] */ UINT *puArgErr) \
	{ \
		if (riid != IID_NULL) \
			return DISP_E_UNKNOWNINTERFACE; \
	\
		::SetErrorInfo(0, NULL); \
		return m_pITypeInfo->Invoke((IDispatch*)this, \
			dispIdMember, wFlags, pDispParams, \
			pVarResult, pExcepInfo, puArgErr); \
	} 


//-------------------------------------------------------------------
//
// Powerbuilder result definitions and values
//
// The return value of PB APIs and methods is a PowerBuilder HRESULT.
// PowerBuilder specific error codes defined using the facility FACILITY_ITF.
// The code values are broken into two pieces: module and code.  This
// allows different groups and headers to define sets of error codes.
//
// HRESULTs are merely a 32-bit value with several fields encoded 
// in the value.  The parts of a HRESULT are shown below.
//      
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-+-+---------------------+-----------+-------------------+
//  |S|R|C|N|r|    Facility         | PB Module |       Code        |
//  +-+-+-+-+-+---------------------+-----------+-------------------+
//
//  where
//
//      S - Severity - indicates success/fail
//
//          0 - Success
//          1 - Fail
//
//      R, C, N, r - As defined by HRESULT in winerror.h
//
//      Facility - is the facility code. For internal PB APIs and functions
//                                 this is always FACILITY_ITF
//
//      PB Module - An internal identifier to enable the caller to identify
//                                 the source of the error or warning. See Below
//
//      Code - is the module's return code
//
//      Other useful macros and stuff not found in this header file:
//
//      SUCCEEDED(result) - Returns true if a given PBRESULT indicates success or a warning
//
//      FAILED(result)    - Returns true if a given HRESULT indicates failure


// Create a PowerBuilder specific HRESULT value from component pieces
//  sev - either SEVERITY_ERROR or SEVERITY_SUCCESS
//  module - One of the module codes found in the PB_RESULT_MODULE enum below (0 to 64)
//  code - result code ranging from 0 to 1023 (0x0000 to 0x3FF)

#ifndef PBRESULT
#define PBRESULT HRESULT
#endif

#ifndef MAKE_PBRESULT
#define MAKE_PBRESULT(sev,module,code) \
	MAKE_HRESULT(sev, FACILITY_ITF, ((ULONG)(module)<<10) | ((ULONG)(code)&0x03FF))
#endif

		typedef enum
		{
			PBMODULE_SYSTEM,                        // System or external API module.
			PBMODULE_UNKNOWN,                       // Module not specified. (see below)
			PBMODULE_VM,                            // VM - Virtual Machine/Runtime Engine
			PBMODULE_OBJ,                           // Object manager
			PBMODULE_COMP,                          // Compiler
			PBMODULE_FUN,                           // Runtime functions
			PBMODULE_STG,                           // Storage
			PBMODULE_DW,                            // DataWindow
			PBMODULE_SMI,                           // Service Manager Interface
			PBMODULE_DPB,                           // Distributed PowerBuilder
			PBMODULE_MIBLOB,                        // Machine Independent blob
			PBMODULE_SHR							// PBSHR Module
			// maxiumum of 64 elements
		} PB_RESULT_MODULE, FAR* PPB_RESULT_MODULE;

		// Return the code of the PBRESULT (10 bits)
#ifndef PBRESULT_CODE
#define PBRESULT_CODE(hr)    ((hr) & 0x03FF)
#endif

//  Return the Powerbuilder module - 6 bits
//  RETURNS a PB_RESULT_MODULE value (see above)
#ifndef PBRESULT_MODULE
#define PBRESULT_MODULE(hr)  ((PB_RESULT_MODULE)(((hr) >> 10) & 0x003F))
#endif

// Because 16-bit defined HRESULT and SCODE differently, here are
// HRESULT versions of the most common SCODEs.  HR() is a shorter
// conversion macro for converting SCODEs to HRESULTs.

#define HR(hr) ResultFromScode(hr)

#define PBS_OK              HR(S_OK)
#define PBS_FALSE           HR(S_FALSE)
#define PBE_UNEXPECTED      HR(E_UNEXPECTED)	// relatively catastrophic failure
#define PBE_NOTIMPL         HR(E_NOTIMPL)		// not implemented
#define PBE_OUTOFMEMORY     HR(E_OUTOFMEMORY)	// ran out of memory
#define PBE_INVALIDARG      HR(E_INVALIDARG)	// one or more arguments are invalid
#define PBE_NOINTERFACE     HR(E_NOINTERFACE)	// no such interface supported
#define PBE_POINTER         HR(E_POINTER)		// invalid pointer
#define PBE_HANDLE          HR(E_HANDLE)		// invalid handle
#define PBE_ABORT           HR(E_ABORT)			// operation aborted
#define PBE_FAIL            HR(E_FAIL)			// unspecified error
#define PBE_ACCESSDENIED    HR(E_ACCESSDENIED)	// general access denied error

// These are obsolete return codes that just map to some above
#define PB_FAIL					PBE_FAIL
#define PB_SUCCESS				PBS_OK

// This section subdivides PBMODULE_UNKNOWN.
// List the range used and the header or idl file that defines the actual codes.
// Please use multiples of 8.
// 0x000 - 0x007	pbreg.idl
// 0x008 - 0x00f    pbapp.h


#endif // PBCOM_H
// DOINC popped back into header 'obdefine.h'

		typedef PVOID FAR* PPVOID;

		// Don't include these definitions when building the machine code
		// exe header file.
#ifndef  GENERATED_CODE_BUILD
		EXTERN_C const GUID GUID_OB_THIS;
		EXTERN_C const IID IID_IMARSHALING_FACTORY;
		EXTERN_C const IID IID_IREMOTABLE_REQUEST;
		EXTERN_C const IID IID_ICONNECTION;
		EXTERN_C const IID IID_IDPB_REPLY;
		EXTERN_C const IID IID_IJAG_REPLY;
		EXTERN_C const IID IID_IJAG_OBJECT_REMOTE;
		EXTERN_C const IID IID_IREMOTE_OBJECT;
		EXTERN_C const IID IID_ILOCAL_SESSION;
#endif

		//****************************************************************************
		// Generic bitfield handlers
		//****************************************************************************

#define ob_modify_bitfield(bitfields,value,shift,mask)      \
    ( ((value) << (shift)) | ((bitfields) & ~(mask)) )

#define ob_set_bitfield(bitfields,casttype,value,shift,mask)    \
    ((bitfields) = (casttype) ob_modify_bitfield (bitfields,(casttype)value,shift,(casttype)mask))

#define ob_get_bitfield(bitfields,casttype,shift,mask)                                  \
    ((casttype) (((bitfields) & mask) >> shift))

//****************************************************************************
// Define Illegal values
//****************************************************************************

#define OB_SYM_NOT_DEFINED              0xFFFF
#define OB_CONST_NOT_DEFINED            0xFFFF
#define UNDECLARED_ROUT                 0xFFFF
#define OB_NO_EVT_TOKEN                 0xFFFF

//****************************************************************************
// Status flag values for Object Manager data structures.
//      NOTE: NOTINIT and INIT values used for runtime checking of variables.
//                      A variable at runtime will always start out set to USED, therefore
//                      it is set to NOTINIT (status == 1). When initialized, status is
//                      set to INIT
//****************************************************************************

		typedef enum ob_status
		{
			FREE = 0,
			USED = 1,
			OB_NOTINIT = 1,
			OB_INIT = 0

		} OB_STATUS, FAR* POB_STATUS;


		//****************************************************************************
		// Pointer to object group
		//****************************************************************************

		typedef struct ob_group FAR* POB_GROUP;

		//****************************************************************************
		// Object grouping types
		//****************************************************************************

		typedef enum ob_group_types
		{
			OB_SIMPLE,
			OB_ARRAY

		} OB_GROUPTYPE, FAR* POB_GROUPTYPE;

		//****************************************************************************
		// Object reference types
		//****************************************************************************

		typedef enum ob_ref_types
		{
			OB_DIRECT_REF = 0,
			OB_GLOBAL_REF = 1,
			OB_ARGUMENT_REF = 2,
			OB_ANCESTOR_REF = 2,            // Classes only
			OB_ARGUMENT_READONLY = 3

		} OB_REFTYPE, FAR* POB_REFTYPE;

		//****************************************************************************
		// Field types
		//****************************************************************************

		typedef enum
		{
			OB_TYPEDEF_FIELD = 0,                    // For instance variables
			OB_INSTVAR_FIELD = 1,
			OB_GLOBAL_VAR = 0,                    // For globally scoped variables
			OB_SHARED_VAR = 1

		} OB_FIELD_TYPE, FAR* POB_FIELD_TYPE;

		//****************************************************************************
		// Field access values
		//****************************************************************************

		typedef enum
		{
			OB_PUBLIC_MEMBER,
			OB_PRIVATE_MEMBER,
			OB_PROTECTED_MEMBER,
			OB_SYSTEM_MEMBER

		} OB_MEMBER_ACCESS, FAR* POB_MEMBER_ACCESS;

		//****************************************************************************
		// Object data styles
		//****************************************************************************

		typedef enum ob_data_styles
		{
			UNDECLARED_STYLE = 0,
			INT_STYLE = 1,
			FLOAT_STYLE = 2,
			PTR_STYLE = 3,
			CONST_STYLE = 4,
			ID_STYLE = 5,
			OBINST_STYLE = 6,
			LONG_STYLE = 7

		} OB_DATASTYLE, FAR* POB_DATASTYLE;

		//****************************************************************************
		// Define Symbol levels
		//****************************************************************************

#define OB_LOCAL                0
#define OB_GLOBAL               1
#define OB_SHARED               2
#define OB_PROPERTY             3
#define OB_PARENT_PROPERTY      4

//****************************************************************************
// Define basic ID type
//****************************************************************************

		typedef USHORT      OB_BASE_ID;

		//****************************************************************************
		// Define Group Handle
		//****************************************************************************

		// Group id for internal use only, Group handle for external use
		typedef OB_BASE_ID        OB_GROUP_ID, FAR* POB_GROUP_ID;
		typedef OB_GROUP_ID       OB_GROUP_HNDL, FAR* POB_GROUP_HNDL;

#define ob_group_compare(grouphndl1,grouphndl2) \
    ((grouphndl1) == (grouphndl2))

#define ob_undefine_group_hndl(grouphndl) \
    ((grouphndl) = OB_SYM_NOT_DEFINED)

#define ob_is_group_hndl_defined(grouphndl) \
    ((grouphndl) != OB_SYM_NOT_DEFINED)


		//****************************************************************************
		// Define Class ids & Class handles
		//****************************************************************************

		typedef OB_BASE_ID        OB_CLASS_ID, FAR* POB_CLASS_ID;

		typedef struct ob_class_hndl
		{
			OB_GROUP_HNDL   group_hndl;
			OB_CLASS_ID     class_id;

		} OB_CLASS_HNDL, FAR* POB_CLASS_HNDL;

#define ob_class_compare(classhndl1,classhndl2) \
    ((classhndl1).class_id == (classhndl2).class_id && \
        (((classhndl1).class_id == UNDECLARED_TYPE) || \
            (ob_group_compare ((classhndl1).group_hndl, (classhndl2).group_hndl))))

		// to compare class handles with indirection, use ot_class_compare

#define ob_get_class_hndl_id(classhndl) \
    ((classhndl).class_id)

#define ob_get_class_group_hndl(classhndl) \
    ((classhndl).group_hndl)

#define ob_set_class_hndl(classhndl,grouphndl,classid) \
    {                                           \
        (classhndl).group_hndl = grouphndl;     \
        (classhndl).class_id = classid;         \
    }

#define ob_undefine_class_id(classid) \
    ((classid) = UNDECLARED_TYPE)

#define ob_undefine_class_hndl(classhndl) \
    ((classhndl).class_id = UNDECLARED_TYPE)

#define ob_undefine_class_hndl_ex(classhndl)            \
    {                                                   \
        ((classhndl).class_id = UNDECLARED_TYPE);       \
        ob_undefine_group_hndl((classhndl).group_hndl); \
    }


#define ob_is_class_hndl_defined(classhndl) \
    ((classhndl).class_id != UNDECLARED_TYPE)

//****************************************************************************
// New runtime object id
//****************************************************************************


		typedef PVOID            OB_INST_ID;
		typedef OB_INST_ID       FAR* POB_INST_ID;

#define ob_inst_compare(obinst1,obinst2) \
    ((obinst1) == (obinst2))

#define OB_INST_DEFINED(obinst)                                         \
    (obinst != NULL)

#define ob_is_obinst_defined(obinst)                            \
    OB_INST_DEFINED(obinst)

#define ob_undefine_obinst(obinst)                                      \
    ((obinst) = NULL)

#define UNDEFINED_OBINST NULL


		//****************************************************************************
		//  New Array stuff
		//****************************************************************************

		typedef PVOID           OB_ARRAY_ID, FAR* POB_ARRAY_ID;

		//****************************************************************************
		// Other Id definitions
		//****************************************************************************

		typedef OB_BASE_ID  OB_EVT_ID, FAR* POB_EVT_ID;
		typedef OB_BASE_ID  OB_EVT_TOKEN_ID, FAR* POB_EVT_TOKEN_ID;
		typedef OB_BASE_ID  OB_VTABLE_ID, FAR* POB_VTABLE_ID;
		typedef OB_BASE_ID  OB_PROTO_ID, FAR* POB_PROTO_ID;
		typedef OB_BASE_ID  OB_ROUT_ID, FAR* POB_ROUT_ID;
		typedef OB_BASE_ID  OB_MODULE_ID, FAR* POB_MODULE_ID;
		typedef OB_BASE_ID  OB_SYM_ID, FAR* POB_SYM_ID;
		typedef ULONG       OB_CONST_REF, FAR* POB_CONST_REF;

		//****************************************************************************
		// Level and id masks and shifts
		//****************************************************************************

#define ID_MASK                         0x7FFF
#define LEVEL_MASK                      0x8000

#define ID_SHIFT                        0
#define LEVEL_SHIFT                     15

//****************************************************************************
// Low-level structure access macros.
//****************************************************************************

#define ob_get_id(cid)                                                      \
    ob_get_bitfield(cid,OB_BASE_ID,ID_SHIFT,ID_MASK)

#define ob_get_level(cid)                                               \
    ob_get_bitfield(cid,USHORT,LEVEL_SHIFT,LEVEL_MASK)

//****************************************************************************
// Type class masks
//****************************************************************************

#define TYPE_ID_MASK                    0x3FFF
#define TYPE_KIND_MASK                  0xC000

#define TYPE_ID_SHIFT                   0
#define TYPE_KIND_SHIFT                 14

//****************************************************************************
// Low-level structure access macros.
//****************************************************************************

#define ob_get_type_id(tid)                                                     \
    (OB_BASE_ID)(((tid) & TYPE_ID_MASK) >> TYPE_ID_SHIFT)

#define ob_get_type_kind(tid)                                                   \
    ((OB_TYPE_KIND) (((tid) & (OB_CLASS_ID) TYPE_KIND_MASK) >> TYPE_KIND_SHIFT))

#define ob_set_type_kind(tid,new_class)         \
    ((tid) = (OB_BASE_ID)(((new_class) << TYPE_KIND_SHIFT) | ((tid) & ~TYPE_KIND_MASK)))

//****************************************************************************
// Type class definitions
//              Note: must fit in reserved 2 bits in type field.
//****************************************************************************

		typedef enum
		{
			OB_SIMPLE_TYPE,
			OB_SYSTEM_TYPE,
			OB_USER_TYPE,
			OB_UNDEFINED_TYPE

		} OB_TYPE_KIND, FAR* POB_TYPE_KIND;

		//****************************************************************************
		// Special Constant for undeclared types.
		//****************************************************************************

#define UNDECLARED_TYPE  (OB_CLASS_ID) (OB_UNDEFINED_TYPE << TYPE_KIND_SHIFT)

//****************************************************************************
// Object allocation types
//****************************************************************************

		typedef enum
		{
			OB_DYN,
			OB_STATIC,
			OB_ASSOC

		} OB_ALLOC_TYPE, FAR* POB_ALLOC_TYPE;

		//****************************************************************************
		// Function types
		//****************************************************************************

		typedef enum ob_func_type
		{
			OB_LOCAL_FUNC_DEF,
			OB_GLOBAL_FUNC_REF,
			OB_DLL_FUNC_DEF,
			OB_SYSTEM_FUNC_DEF,
			OB_RPC_FUNC_DEF,
			OB_SYSDLL_FUNC_DEF,
			OB_PSPP_FUNC_DEF
		} OB_FUNC_TYPE, FAR* POB_FUNC_TYPE;

		typedef enum ob_protoarg_type
		{
			OB_ARG_VAL,
			OB_ARG_REF,
			OB_ARG_VARLIST,
			OB_ARG_READONLY

		} OB_PROTOARG_TYPE, FAR* POB_PROTOARG_TYPE;


		//****************************************************************************
		// Script Types
		//****************************************************************************

		typedef enum ob_script_type
		{
			OB_EXTERNAL_FUNC_SCRIPT,
			OB_OBJECT_FUNC_SCRIPT,
			OB_EVENT_SCRIPT,
			OB_EVENTCALL_SCRIPT

		} OB_SCRIPT_TYPE, FAR* POB_SCRIPT_TYPE;


		//****************************************************************************
		// Routine types
		//****************************************************************************

		typedef enum
		{
			OB_FUNCTION,
			OB_EVENT,
			OB_ANY_ROUT_TYPE
		} OB_ROUT_TYPE;

#define POB_ROUT_TYPE   OB_ROUT_TYPE FAR *

		//****************************************************************************
		// Routine type shifts and masks
		//****************************************************************************

#define ROUTID_MASK                     0x7FFF
#define ROUTTYPE_MASK                   0x8000

#define ROUTID_SHIFT                    0
#define ROUTTYPE_SHIFT                  15

//****************************************************************************
// Routine type access macros
//****************************************************************************

#define ob_get_routid(cid)                              \
    (OB_ROUT_ID) (((cid) & ROUTID_MASK) >> ROUTID_SHIFT)

#define ob_get_routtype(cid)                                            \
    (OB_ROUT_TYPE) (((cid) & ROUTTYPE_MASK) >> ROUTTYPE_SHIFT)

#define ob_set_routtype(cid,new_type)           \
    ((cid) = (OB_BASE_ID)((new_type << ROUTTYPE_SHIFT) | ((cid) & ~ROUTTYPE_MASK)))

//****************************************************************************
// Subpool typedef
//****************************************************************************

		typedef pbstg_subpool OB_SUBPOOL;


		//****************************************************************************
		// Decimal Precision Constants
		//****************************************************************************

#define OB_MAX_PRECISION                                30
#define OB_PRECISION_NOT_DEFINED                        31

//****************************************************************************
// Maximum value Constants
//****************************************************************************

#ifdef PBWIN32
#define OB_MAX_STRING_LEN                               ULONG_MAX - 1UL
#else
#define OB_MAX_STRING_LEN                               60000UL
#endif
#define OB_MAX_STRING_CONST_LEN                         60000L

//****************************************************************************
// Source block types
//****************************************************************************

		typedef enum
		{
			OB_FORWARD_BLOCK,
			OB_VAR_BLOCK,
			OB_VAR_DECL_BLOCK,
			OB_TYPEDEF_BLOCK,
			OB_ON_EVT_BLOCK,
			OB_FUNC_BLOCK,
			OB_SUBROUTINE_BLOCK,
			OB_PROTOTYPE_BLOCK,
			OB_INSTVAR_BLOCK,
			OB_FWDPROTO_BLOCK,
			OB_NAMESPACE_BLOCK

		} OB_SOURCE_BLK_TYPE, FAR* POB_SOURCE_BLK_TYPE;

		//****************************************************************************
		//      Global reference style
		//****************************************************************************

		typedef enum ob_glob_refstyle
		{
			OB_GLOB_PARENT_REF = 0,
			OB_GLOB_ATTR_REF = 1,
			OB_GLOB_OTHER_REF = 2,
			OB_GLOB_NOT_REF = 3

		} OB_GLOB_REFSTYLE, FAR* POB_GLOB_REFSTYLE;

		//****************************************************************************
		// Binary data type
		//****************************************************************************

		typedef enum
		{
			OB_UNBOUNDED_BINARY = 0,
			OB_FIXED_BINARY = 1

		} OB_BINARY_DYNTYPE, FAR* POB_BINARY_DYNTYPE;

#define ob_set_binary_dyntype(obthis,data,dyntype)                                                              \
    ob_set_data_typeargs(data,dyntype)

#define ob_get_binary_dyntype(obthis,data)                                                                              \
    ((OB_BINARY_DYNTYPE) ob_get_data_typeargs (data))

		//****************************************************************************
		// Data flags masks and shifts (relative to typeargs field, not entire OB_INFO)
		//****************************************************************************

#define DATA_OBJTYPE_MASK                       0x0001
#define DATA_INSTTYPE_MASK                      0x0002

#define DATA_OBJTYPE_SHIFT                      0
#define DATA_INSTTYPE_SHIFT                     1

//****************************************************************************
// Object type flag
//****************************************************************************

		typedef enum
		{
			OB_OBJECT_TYPE = 0,
			OB_NON_OBJECT_TYPE = 1

		} OB_OBJECT_TYPE_FLAG, FAR* POB_OBJECT_TYPE_FLAG;

#define ob_get_typeargs_objtype(obthis,typeargs)                         \
    ob_get_bitfield(typeargs,OB_OBJECT_TYPE_FLAG,DATA_OBJTYPE_SHIFT,DATA_OBJTYPE_MASK)

#define ob_get_data_objtype(obthis,data)                                 \
    ob_get_typeargs_objtype (obthis, ob_get_data_typeargs (data))

#define ob_set_data_objtype(data,objtype)                               \
    ob_set_data_typeargs                                                \
        (                                                               \
        data,                                                           \
        ob_modify_bitfield                                              \
            (                                                           \
            ob_get_data_typeargs(data),                                 \
            objtype,                                                    \
            DATA_OBJTYPE_SHIFT,                                         \
            DATA_OBJTYPE_MASK                                           \
            )                                                           \
        )

		//****************************************************************************
		// Object auto-instantiate flag
		//****************************************************************************

		typedef enum
		{
			OB_MANUAL_INSTANTIATE = 0,
			OB_AUTO_INSTANTIATE = 1

		} OB_INSTANTIATE_TYPE, FAR* POB_INSTANTIATE_TYPE;

#define ob_get_typeargs_insttype(obthis,typeargs)                                                       \
    ob_get_bitfield(typeargs,OB_INSTANTIATE_TYPE,DATA_INSTTYPE_SHIFT,DATA_INSTTYPE_MASK)

#define ob_get_data_insttype(obthis,data)                                                               \
    ob_get_typeargs_insttype (obthis, ob_get_data_typeargs (data))

		//****************************************************************************
		// Object typeargs construction macro
		//****************************************************************************

#define ob_build_obj_typeargs(typeargs,objtype,insttype)                                                \
    ((typeargs)   = ((objtype) << DATA_OBJTYPE_SHIFT)               |                                       \
                    ((insttype) << DATA_INSTTYPE_SHIFT)                                            \
    )

#ifdef __cplusplus
	}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif // OBDEFINE_H


// DOINC popped back into header 'obcurent.h'
#endif
#ifndef OBDATA_H
// ***** DOINC including obdata.h *****
//**************************************************************************
//
//                            Copyright 1989 
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :	obdata.h	
//
//    Author   :	Jim Kosko
//
//    Purpose  : 	PB Object manager data storage structure.
//
//****************************************************************************

#ifndef OBDATA_H
#define OBDATA_H

//****************************************************************************
// Includes
//****************************************************************************

#ifndef OBDEFINE_H
// ***** DOINC including obdefine.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBTHIS_H
// ***** DOINC including obthis.h *****
//**************************************************************************
//
//                            Copyright 1989 
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :	obthis.h	
//
//    Author   :	Jim Kosko
//
//    Purpose  : 	obthis
//
//****************************************************************************

#ifndef OBTHIS_H
#define OBTHIS_H

//****************************************************************************
//	Includes
//****************************************************************************

#ifndef OSPASCAL_H
// ***** DOINC including ospascal.h *****
	// DOINC skipping duplicate include
#endif
#ifndef PBSTG_H
// ***** DOINC including pbstg.h *****
	// DOINC skipping duplicate include
#endif
#ifndef SHDEBUG_H
// ***** DOINC including shdebug.h *****
	// DOINC skipping duplicate include
#endif
#ifndef SHLIST_H
// ***** DOINC including shlist.h *****
//**************************************************************************
//
//                            Copyright 1989 
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :    shlist.h
//
//    Author   :    Kim Sheffield from Jim Kosko
//
//    Purpose  : 	Descriptions of PB list container classes.
//
//****************************************************************************


//****************************************************************************
// Make sure file doesn't get included twice
//****************************************************************************

#ifndef SHLIST_H
#define SHLIST_H

//****************************************************************************
//	Includes
//****************************************************************************

// ***** DOINC including shlnode.h *****
//**************************************************************************
//
//                            Copyright 1989 
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :	shlnode.hxx
//
//    Author   :    Jim Kosko (converted to c by KAS)
//
//    Purpose  :    Descriptions of PB list node classes.
//
//****************************************************************************


//****************************************************************************
// Make sure file doesn't get included twice
//****************************************************************************

#ifndef SHLNODE_H
#define SHLNODE_H

//***************************************************************************
//
//    Name:      class list_node
//
//    Synopsis:  Node structure for sh_list class.
//
//    Notes:     
//
//***************************************************************************

	typedef	union shlnode_prev
	{
		struct shlistnode FAR* prev;     // Previous item on list
		PVOID                    vprev;
	} SHLNODE_PREV, FAR* PSHLNODE_PREV;

	typedef union shlnode_next
	{
		struct shlistnode FAR* next;     // Next item on list
		PVOID                    vnext;
	} SHLNODE_NEXT, FAR* PSHLNODE_NEXT;

	typedef union shlnode_data
	{
		PVOID            data;      // Pointer to actual data on list node
		PVOID            vdata;
	} SHLNODE_DATA, FAR* PSHLNODE_DATA;

	typedef struct shlistnode
	{
		SHLNODE_PREV p;
		SHLNODE_NEXT n;
		SHLNODE_DATA d;

	} shlnode;
#define PSHLNODE  shlnode FAR *

	//****************************************************************************
	//    Function prototypes
	//****************************************************************************

	VOID shlnode_ins_before(PSHLNODE self, PSHLNODE currnode);
	VOID shlnode_ins_after(PSHLNODE self, PSHLNODE currnode);
	VOID shlnode_remove(PSHLNODE self);
	PSHLNODE shlnode_new(PVOID userdata, ppbstg_anchor sa, pbstg_subpool subpool);
#define shlnode_delete(sa, self) pbstg_free(sa, self)
	PVOID shlnode_update(PSHLNODE self, PVOID newdata);
#define shlnode_get_next(self) (self->n.next)
#define SHLNODE_GET_NEXT(self) ((self)?(self)->n.next:NULL)
#define shlnode_get_prev(self) (self->p.prev)
#define SHLNODE_GET_PREV(self) ((self)?(self)->p.prev:NULL)
#define shlnode_get_data(self) (self->d.data)
#define SHLNODE_GET_DATA(self) ((self)?(self)->d.data:NULL)
#define SHLNODE_GET_DATA_ADDRESS(self) ((self)? &(self)->d.vdata: NULL)

#endif // SHLNODE_H
	// DOINC popped back into header 'shlist.h'

#ifdef __cplusplus
	extern "C"
	{
#endif

		enum INSERT_RETCODE
		{
			INS_ERROR,
			INSERTED,
			LIST_DUPLICATE
		};

		//****************************************************************************
		//	Typedef for list handle
		//****************************************************************************

		typedef PVOID  SH_LIST_HANDLE;

		//***************************************************************************
		//
		//    Name:      class sh_list
		//
		//    Synopsis:  Double linked circular queue.
		//
		//    Notes:     
		//
		//***************************************************************************

		typedef union shlisthead
		{
			PSHLNODE       head;                      // Head of list
			PVOID          vhead;
		} SHLISTHEAD, FAR* PSHLISTHEAD;

		typedef union shlisttail
		{
			PSHLNODE       tail;                      // Tail of list
			PVOID          vtail;
		} SHLISTTAIL, FAR* PSHLISTTAIL;


		typedef struct shlistx
		{
			SHLISTHEAD h;
			SHLISTTAIL t;
			PSHLNODE           current;                   // Current node on list
			ppbstg_anchor      sa;                        // Storage anchor
			pbstg_subpool      subpool;                   // Allocation subpool
			UINT               count;                     // Items on list
		} shlist;
#define PSHLIST shlist FAR *

		//****************************************************************************
		//      Function prototypes
		//****************************************************************************
		PBWINAPI(VOID, shlist_delete)(PSHLIST self);
		PBWINAPI(PVOID, shlist_deleteFree)(PSHLIST self);
		PBWINAPI(PVOID, shlist_get_next) (PSHLIST self);

		// Get Next element of the specified SHLIST, 'pshlnode_current' is of type
		// PSHLNODE and will hold the currency for accessing the shlist (assumes SHLIST_GET_FIRST_EX
		// was used to initialize the pshlnode_current at least once).
#define SHLIST_GET_NEXT_EX(self,pshlnode_current) ((self) ?								\
								 (pshlnode_current = (  ( pshlnode_current != NULL && pshlnode_current != (self)->t.tail ) ? \
														  SHLNODE_GET_NEXT(pshlnode_current) : NULL) , \
								   SHLNODE_GET_DATA(pshlnode_current) ):	 \
								NULL)

#define SHLIST_GET_NEXT(self) ((self) ?								\
								 ((self)->current = (  ( (self)->current != NULL && (self)->current != (self)->t.tail ) ? \
														  SHLNODE_GET_NEXT((self)->current) : NULL) , \
								   SHLNODE_GET_DATA((self)->current) ):	 \
								NULL)
#define SHLIST_GET_NEXT_NODE(self,node) \
	 ( ((node) && (node) != (self)->t.tail ) ? SHLNODE_GET_NEXT((node)) : NULL) 

		PBWINAPI(PVOID, shlist_get_prev) (PSHLIST self);
		PBWINAPI(INT, shlist_putafter) (PSHLIST self, PSHLNODE node);
		PBWINAPI(INT, shlist_addafter) (PSHLIST self, PVOID data);
		PBWINAPI(INT, shlist_addbefore) (PSHLIST self, PVOID data);
		PBWINAPI(PVOID, shlist_remove) (PSHLIST self);
		PBWINAPI(INT, shlist_insert_at_curr) (PSHLIST self, PVOID userdata);
		PBWINAPI(INT, shlist_insert) (PSHLIST self, PVOID userdata);
		PBWINAPI(PSHLIST, shlist_new)(ppbstg_anchor sa, pbstg_subpool subpool);
		PBWINAPI(PSHLNODE, shlist_curr_node) (PSHLIST self);
		PBWINAPI(UINT, shlist_get_count)(PSHLIST self);
#define SHLIST_GET_COUNT(self) ((self)? (self)->count: 0)
		PBWINAPI(PVOID, shlist_get_first) (PSHLIST self);
#define SHLIST_GET_FIRST(self) ((self)? \
								 ((self)->current = (self)->h.head, SHLNODE_GET_DATA((self)->current) )	: \
								 NULL)
		// Get First element of the specified SHLIST, 'pshlnode_current' is of type
		// PSHLNODE and will hold the currency for accessing the shlist.
#define SHLIST_GET_FIRST_EX(self,pshlnode_current) ((self)? \
								 ( pshlnode_current = (self)->h.head, SHLNODE_GET_DATA(pshlnode_current) )	: \
								 NULL)

#define SHLIST_GET_FIRST_NODE(self) ((self)? ((self)->h.head) :NULL)

		PBWINAPI(PVOID, shlist_get_last) (PSHLIST self);

		// Get Last element of the specified SHLIST, 'pshlnode_current' is of type
		// PSHLNODE and will hold the currency for accessing the shlist.
#define SHLIST_GET_LAST_EX(self,pshlnode_current) ((self)? \
								 (pshlnode_current = (self)->t.tail, SHLNODE_GET_DATA(pshlnode_current) )	: \
								 NULL)

#define SHLIST_GET_LAST(self) ((self)? \
								 ((self)->current = (self)->t.tail, SHLNODE_GET_DATA((self)->current) )	: \
								 NULL)
		PBWINAPI(PVOID, shlist_get_curr) (PSHLIST self);
#define SHLIST_GET_CURR(self) ((self)? \
								 SHLNODE_GET_DATA((self)->current)	: \
								 NULL)
#define SHLIST_GET_CURR_DATA_ADRRESS(self)  ((self)? \
								 SHLNODE_GET_DATA_ADDRESS((self)->current): \
								 NULL)

		PBWINAPI(PVOID, shlist_update) (PSHLIST self, PVOID newdata);
		PBWINAPI(SH_LIST_HANDLE, shlist_get_handle) (PSHLIST self);
		PBWINAPI(VOID, shlist_set_current) (PSHLIST self, SH_LIST_HANDLE handle);
		// Make traverse a special case of traversal where user has no data
#define shlist_traverse(t, f) shlist_traversal(t, NULL, f)
		PBWINAPI(INT, shlist_traversal)(PSHLIST self, PVOID data, PASCALFAR_INT_PROC trav_func); // traverse list
		PBWINAPI(LPTSTR FAR*, shlist_sort)(PSHLIST self, PASCALFAR_INT_PROC compare_func, int options);
		PBWINAPI(LPTSTR FAR*, shlist_sort_param)(PSHLIST self, PVOID lpData, PASCALFAR_INT_PROC compare_func, int options);
#define SORT_SORTLIST 0x1   // list should be updated
#define SORT_NOARRAY  0x2   // don't return sorted array
#define SORT_ERASELIST 0x4  // clear list; don't use with SORTLIST

		// Make the specified data the current node
#define SHLIST_FIND(self, data) { PVOID searchdata; \
	for (searchdata = SHLIST_GET_FIRST(self); \
		searchdata != NULL && searchdata != (PVOID)(data); \
		searchdata = SHLIST_GET_NEXT(self)); }

#ifdef __cplusplus
	}
#endif

#endif // SHLIST_H
	// DOINC popped back into header 'obthis.h'
#endif
#ifndef OBDEFINE_H
// ***** DOINC including obdefine.h *****
	// DOINC skipping duplicate include
#endif
#ifndef SHGRWBLK_H
// ***** DOINC including shgrwblk.h *****
//**************************************************************************
//
//                            Copyright 1989 
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :	shgrwblk.h	
//
//    Author   :	Jim Kosko
//
//    Purpose  : 	Definitions for PB grow blocks.
//
//****************************************************************************

#ifndef SHGRWBLK_H
#define SHGRWBLK_H

#ifndef OSPASCAL_H
// ***** DOINC including ospascal.h *****
	// DOINC skipping duplicate include
#endif
#ifndef PBSTG_H
// ***** DOINC including pbstg.h *****
	// DOINC skipping duplicate include
#endif

//****************************************************************************
// Grow block struct
//****************************************************************************

	typedef struct sh_growblock
	{
		PVOID 			block;
		UINT				incr;
		UINT				size;
		UINT				pos;
		UINT				struct_size;

	} SH_GROWBLOCK, FAR* PSH_GROWBLOCK;


	//****************************************************************************
	// Macros
	//****************************************************************************

#define sh_grwblk_no_entries(grwblk) 	\
	((grwblk)->pos)

#define sh_grwblk_set_no_entries(grwblk,no_entries) 	\
	((grwblk)->pos = (no_entries))

#define sh_grwblk_data(grwblk)	\
	((grwblk)->block)

#define sh_grwblk_free_data(stgthis,data) \
	pbstg_free (stgthis, data)

#define sh_grwblk_loc(grwblk,i) 			\
	((PVOID) (((LPBYTE) ((grwblk)->block)) + ((grwblk)->struct_size * (i))))

#define sh_grwblk_pos(grwblk,loc) 			\
	( ( (LPBYTE) loc - (LPBYTE) ((grwblk)->block) ) / (grwblk)->struct_size )

#define sh_get_grwblk_item(grwblk,i,type) 		\
	((type) sh_grwblk_loc (grwblk,i))

#define sh_grwblk_reset(grwblk) 		\
	{							\
		(grwblk)->block = NULL;	\
		(grwblk)->pos = 0; 		\
		(grwblk)->size = 0;		\
	}

#define sh_grwblk_clear(stgthis,grwblk) 	\
	{										\
	pbstg_free (stgthis, (grwblk)->block);	\
	sh_grwblk_reset(grwblk);				\
	}

//****************************************************************************
// Prototypes
//****************************************************************************

#ifdef    __cplusplus
	extern "C" {
#endif    /* __cplusplus */

		PBWINAPI(VOID, sh_grwblk_init)
			(
				PSH_GROWBLOCK 		grwblk,
				UINT 					incr,
				UINT 					str_size
				);

		PBWINAPI(PSH_GROWBLOCK, sh_new_grwblk)
			(
				ppbstg_anchor 		stgthis,
				UINT 					increment,
				UINT 					struct_size,
				pbstg_subpool			subpool
				);

		PBWINAPI(VOID, sh_set_grwblk_item)
			(
				ppbstg_anchor 		stgthis,
				PSH_GROWBLOCK 		grwblk,
				UINT 				pos,
				PVOID 				item,
				pbstg_subpool		subpool
				);

		PBWINAPI(UINT, sh_add_to_grwblk)
			(
				ppbstg_anchor 		stgthis,
				PSH_GROWBLOCK 		grwblk,
				PVOID 				item,
				pbstg_subpool		subpool
				);

		PBWINAPI(VOID, sh_append_to_grwblk)
			(
				ppbstg_anchor 		stgthis,
				PSH_GROWBLOCK 		grwblk,
				PVOID 				item_array,
				UINT 				array_len,
				pbstg_subpool		subpool
				);

		PBWINAPI(VOID, sh_grwblk_delete)
			(
				ppbstg_anchor 		stgthis,
				PSH_GROWBLOCK 		grwblk
				);

		PBWINAPI(PVOID, sh_grwblk_close)
			(
				ppbstg_anchor 		stgthis,
				PSH_GROWBLOCK 		grwblk,
				PUINT 				no_items
				);

#ifdef    __cplusplus
	}	// extern "C" {
#endif    /* __cplusplus */

#endif // SHGRWBLK_H

// DOINC popped back into header 'obthis.h'
#endif
#ifndef OBDATA_H
// ***** DOINC including obdata.h *****
	// DOINC skipping duplicate include
#endif

// for codegen, we want to skip including windows stuff
// DOINC told to skip 7 lines...

//****************************************************************************
// Assume C declarations for C++
//****************************************************************************

#ifdef __cplusplus
	extern "C" {
#endif	/* __cplusplus */

		// ****************************************************************************
		// Callback function type definitions
		// ****************************************************************************

		typedef PBCALLBACK(INT, *RT_BREAK_PROC) (PVOID, PVOID);

		// Legal indices for the rtBreakCallback array argument to rt_start_debug
#define PD_BREAKPOINT_INDEX			0  
#define PD_DEL_WATCHPOINT_INDEX		1
// Size of rtBreakCallback array
#define PD_SIZE						2

// ****************************************************************************
// Runtime mode
// ****************************************************************************

		typedef enum rt_mode
		{
			RT_DEVELOPMENT_MODE,
			RT_RUNTIME_MODE

		} RT_MODE, FAR* PRT_MODE;

		// ****************************************************************************
		// Optimize mode
		// ****************************************************************************

		typedef enum rt_opt_mode
		{
			RT_OPTIMIZED,
			RT_NOT_OPTIMIZED

		} RT_OPT_MODE, FAR* PRT_OPT_MODE;

		//****************************************************************************
		// Forward references for typedefs
		//****************************************************************************

#if defined(__cplusplus) && defined(__WATCOMC__)
		struct ot_eval_node;
		struct cm_this;
#endif
#define POT_EVAL_NODE struct ot_eval_node FAR *
#define PCM_THIS struct cm_this FAR *

		//****************************************************************************
		// Object manager mode
		//****************************************************************************

		typedef enum ob_mode
		{

			OB_LINK_AS_YOU_GO_MODE,                   // Link as you go
			OB_BUILD_EXE_MODE,                        // Building executable
			OB_RUN_EXE_MODE,                          // Running executable
			OB_COMPILE_MODE,                          // Compiling
			OB_DEBUG_MODE,                            // Debugging
			OB_DEFAULT_MODE,                          // Default
			OB_BUILD_APPL_REPORT,                     // Building application report
			OB_BUILD_COMPILE_LIST_MODE,               // Building compile list
			OB_BUILD_OBJECT_REPORT,                   // Building object report
			OB_OBJECT_LOAD                            // We can save lib object names during this mode

		} OB_MODE, FAR* POB_MODE;

		//****************************************************************************
		// EXE code type
		//****************************************************************************

		typedef enum ob_exe_code_type
		{

			OB_PCODE_EXE,
			OB_CCODE_EXE

		} OB_EXE_CODE_TYPE, FAR* POB_EXE_CODE_TYPE;

		//****************************************************************************
		// Runtime Error information structure for use while running C-Code
		//****************************************************************************

		typedef struct ob_runtime_error_info
		{
			POB_GROUP			group;
			OB_CLASS_ID			class_id;
			LPTSTR				routine_name;	// this string should NOT be freed.
			UINT				line_no;
			OB_SCRIPT_TYPE		script_type;
		} OB_RUNTIME_ERROR_INFO, FAR* POB_RUNTIME_ERROR_INFO;

		// Flags for various purposes

#define INET_NS_PLUGIN_MASK		0x0001				// 1 bit
#define REMOTE_DISPLAY_MASK		0x0002				// 1 bit
#define COMP_OLE_AUTO_MASK		0x0004				// 1 bit - ole automation server object
#define COMP_COM_GEN_MASK		0x0008				// 1 bit - generated COM server object
#define RESULTSET_MASK			0x0010				// 1 bit - Jaguar 1.1 style resultset generated
#define POPULATE_ERROR_MASK		0x0020				// 1 bit - Processing PopulateError

#define INET_NS_PLUGIN_SHIFT	0
#define REMOTE_DISPLAY_SHIFT	1
#define COMP_OLE_AUTO_SHIFT		2
#define COMP_COM_GEN_SHIFT		3
#define RESULTSET_SHIFT			4
#define POPULATE_ERROR_SHIFT	5

// Macros for the above flags

#define obGetNSPlugin(obthis)		\
	(BOOL)ob_get_bitfield(obthis->GeneralFlags,ULONG,INET_NS_PLUGIN_SHIFT,	\
		INET_NS_PLUGIN_MASK)

#define obGetRemoteDisplay(obthis)		\
	(BOOL)ob_get_bitfield(obthis->GeneralFlags,ULONG,REMOTE_DISPLAY_SHIFT,	\
		REMOTE_DISPLAY_MASK)

#define obGetComponentOleAuto(obthis)		\
	(BOOL)ob_get_bitfield(obthis->GeneralFlags,ULONG,COMP_OLE_AUTO_SHIFT,	\
		COMP_OLE_AUTO_MASK)

#define obGetComponentComGen(obthis)		\
	(BOOL)ob_get_bitfield(obthis->GeneralFlags,ULONG,COMP_COM_GEN_SHIFT,	\
		COMP_COM_GEN_MASK)

#define obGetResultsetFlag(obthis)		\
	(BOOL)ob_get_bitfield(obthis->GeneralFlags,ULONG,RESULTSET_SHIFT,	\
		RESULTSET_MASK)

#define obGetPopulateErrFlag(obthis)		\
	(BOOL)ob_get_bitfield(obthis->GeneralFlags,ULONG,POPULATE_ERROR_SHIFT,	\
		POPULATE_ERROR_MASK)


#define obSetNSPlugin(obthis,val)		\
	ob_set_bitfield(obthis->GeneralFlags,ULONG,(ULONG)val,INET_NS_PLUGIN_SHIFT,	\
		INET_NS_PLUGIN_MASK)

#define obSetRemoteDisplay(obthis,val)		\
	ob_set_bitfield(obthis->GeneralFlags,ULONG,(ULONG)val,REMOTE_DISPLAY_SHIFT,	\
		REMOTE_DISPLAY_MASK)

#define obSetComponentOleAuto(obthis,val)		\
	ob_set_bitfield(obthis->GeneralFlags,ULONG,(ULONG)val,COMP_OLE_AUTO_SHIFT,	\
		COMP_OLE_AUTO_MASK)

#define obSetComponentComGen(obthis,val)		\
	ob_set_bitfield(obthis->GeneralFlags,ULONG,(ULONG)val,COMP_COM_GEN_SHIFT,	\
		COMP_COM_GEN_MASK)

#define obSetResultsetFlag(obthis,val)		\
	ob_set_bitfield(obthis->GeneralFlags,ULONG,(ULONG)val,RESULTSET_SHIFT,	\
		RESULTSET_MASK)

#define obSetPopulateErrFlag(obthis,val)		\
	ob_set_bitfield(obthis->GeneralFlags,ULONG,(ULONG)val,POPULATE_ERROR_SHIFT,	\
		POPULATE_ERROR_MASK)

#define OB_UNDEFINED_THREAD_ID		0xFFFFFFFF

//////////////////////////////////////////////////////////////////////////////////////
//
// Categories (i.e. 1-bit flags) and access macros for security
//

#define SECURE_MODE_NO_DB_MODIFY					0
#define SECURE_MODE_NO_DB_STORED_PROC				1
#define SECURE_MODE_NO_DB							2
#define SECURE_MODE_NO_CONNECT_OTHER_PB				3
#define SECURE_MODE_NO_CONNECT_NONSECURE_PB			4
#define SECURE_MODE_NO_OLE							5
#define SECURE_MODE_NO_PRINT						6

// Macros for the above flags
// get and set secure mode categories
//
#define ob_get_secure_mode_category(obthis, category)							\
	(((obthis)->SecureRuntimeSession & ((ULONG)1 << (category))) != 0)

// Turn off category bit in flag word, by a shift and then a one's complement
// Then or in the valueMESSAGEBOX(
#define ob_set_secure_mode_category(obthis, category,  value)					\
	((obthis)->SecureRuntimeSession = 											\
	  (ULONG)((obthis)->SecureRuntimeSession & ~(1 << (category)) | 			\
	  		((value) ? 1 : 0) << (category)))

#define ob_compare_secure_modes(obthis, secure_mode_1, secure_mode_2)			\
	(((secure_mode_1) & (secure_mode_2)) == (secure_mode_1))

//
// The following preset values for security mode will also be provided:
//
#define SECURE_MODE_OFF	((ULONG) 0)
// Default security settings (All categories other than SECURE_MODE_NO_PRINT are restricted).
#define SECURE_MODE_DEFAULT	(~((ULONG)1 << SECURE_MODE_NO_PRINT))
// Maximum security restrictions (all restrictions applicable)
#define SECURE_MODE_MAX	((ULONG) ULONG_MAX)

//
// End of secure mode definitions
//
////////////////////////////////////////////////////////////////////////////////////

		typedef struct ob_response_window_stack_node
		{
			UINT			routine_level;
			INT		expr_stack_ptr;
		} ResponseWindowStackNode;

		//****************************************************************************
		//	Pointer to Current object group and object group stack
		//****************************************************************************

#pragma pack(push,1)
#ifndef POB_THIS_DEFINED
#define POB_THIS_DEFINED
		typedef struct ob_this FAR* POB_THIS;
#endif

#if defined(__cplusplus) && !defined(GENERATED_CODE_BUILD)
		typedef struct ob_this : public IUnknown
		{
#else
		typedef struct ob_this
		{
			void* __vtbl;
#endif
			POB_THIS			 obthis;	   			// Allows old code to keep working
			POB_THIS			 rtthis;                // Allows old code to keep working

			PSH_DBG_THIS   		dbgthis;				// Debugger this pointer
			ppbstg_anchor  		stgthis;				// Storage manager this pointer
			UINT 		   		curr_pcode;				// Current pcode Instruction
			BOOL           		pcode_done;             // End of pcode block indicator.
			PSHLIST        		pBreakPointList;        // Pointer to breakpoint list
			INT           		bStep;                  // Processing step mode
			RT_BREAK_PROC  		rtBreakCallback[PD_SIZE]; // Debugger call back function
			PVOID          		pUserData;              // Pointer to user data (if any)
			PSHLIST		   		pTransactionList;		// Pointer to runtime trans list.
			BOOL           		bIgnoreErrors;          // Ignore runtime error flag
			BOOL           		bTerminateRuntime;		// Terminate runtime flag
			OB_CLASS_HNDL  		clshndl;                // Current class handle
			OB_CLASS_HNDL  		appclshndl;             // Application class handle
			OB_EVT_ID      		event_id;               // Event ID
			OB_INST_ID     		appinst;                // Application instance
			pbstg_subpool  		subpool;				// Runtime subpool
			RT_MODE        		mode;                   // Runtime mode
			PVOID          		smthis;                 // Semantic this pointer
			OB_MODE        		obMode;                 // Object manager mode
			UINT           		iPCodeCounter;          // PCode execution counter
			RT_OPT_MODE	   		opt_mode;				// Optimization mode
			PSHLIST		   		pDllList;				// List of opened DLLs.
			PVOID		   		curr_pcode_blk;			// Current pcode block
			UINT		   		iContextCount;			// Number of run contexts
														// 	only valid in primary rtthis
			BOOL		   		bHaltClose;				// Halt close processing flag
			BOOL		   		bDontTerminate;			// Dont terminate after error
			UINT				curr_line_block_loc;	// Current line_block loc.
			UINT				last_break_line_no;		// Last line numbers...
			UINT				last_pcode_line_no;		// ...
			PVOID FAR* pThreadStart;			// Points to start of thread
			PVOID FAR* pThreadNode;			// Points to cur. thread node
			UINT				halt_close_nest;		// Count of nested halt close
			PCM_THIS			cmthis;					// Current compiler context

			PSHLIST       		pLibraryList;           // Current library list
			PSHLIST       		pNameList;              // Library entry name list
			PVOID         		pGroupList;             // Pointer to group list nodes
			PVOID         		pLookSymKeyFunction;    // Group name hash key function
			PVOID         		scnthis;                // Scanner this pointer
			UINT          		iGroupListIncr;         // Group list increment
			UINT          		iGroupListPos;          // Group list position
			UINT          		iGroupListSize;         // Group list size
			pbstg_subpool       client_subpool;         // Client subpool
			pbstg_subpool  		perm_subpool;           // Permanent subpool
			pbstg_subpool  		result_subpool;         // Intermediate results
			pbstg_subpool  		temp_subpool;           // Temporary subpool
			PSHLIST       		group_stack;			// List of groups ids currently in use
			PVOID         		curr_obj_group;
			PVOID         		sys_typedef_group;
			PVOID         		curr_routnode;
			OB_INST_ID    		curr_obinst;
			PVOID         		lib_handle;
			PSHLIST       		run_stack;				// Used to maintain Runtime Call Stack 
			PVOID       		rtinst_stack;			// Used to maintain instance list
			LPTSTR         		def_appl_groupname;
			LPTSTR         		def_appl_libname;
			PVOID         		appl_group;
			BOOL          		bInRuntime;
			UINT          		appl_filter;
			PVOID         		hExecutable;
			UINT          		iExeGroupCounter;
			PSHLIST       		pExeGroupList;			// No longer used
			PVOID         		pExeResourceHash;       // Resource list for build .EXE
			POT_EVAL_NODE  		expr_stack;				// maintain params and vars used by pcodes
			UINT          		expr_stack_size;		// size of expression (data) stack
			POT_EVAL_NODE   	expr_stack_ptr;			// current stack entry
			PSHLIST       		arglist_stack;			// NOT USED
			PSHLIST       		error_list;				// list of errors during application build
			BOOL          		bGotLinkError;
			pbstg_subpool  		lvalue_subpool;         // Lvalues
			BOOL          		bNoDuplicateSymbols;
			PSHLIST       		unused;           		// UNUSED
			OB_CLASS_HNDL 		curr_class_hndl;
			OB_ARRAY_ID			curr_array_inst;	  	// Current array inst id.
			UINT		  		ErrorCode;
			BOOL		  		set_return_called;
			OB_GROUP_HNDL 		sys_group_hndl;
			PVOID         		pSavedGroupList;        // Pointer to saved group list nodes
			PVOID				lmithis;	 			// Ptr to Lib Mgr anchor
			PVOID				curr_runstk_node;   	// Ptr to runtime stack node.
			ULONG				ps_options;				// PS executable options
			OB_EXE_CODE_TYPE	exe_code_type;			// CCode or PCode
			LPTSTR				pExecutableName;	   	// current executable
			PVOID				evaled_arglist;			// result of setup_call where args are obtained 
														//   from expr_stack and converted as necessary
			PVOID				lvalue_info;
			UINT                curr_arg_pos;
			POT_EVAL_NODE		return_value;			// return value for current routine
			POT_EVAL_NODE		called_return_value;	// return value for routine just called

			PVOID				p_error_info;			// Error information for CCode
			LONG				routine_level;			// the routine level for CCode

			ULONG				ulDServFlags;			// Flags for distributed PB
			PVOID				working_group;			// Current working group
			PVOID				callback_data;			// Used to store pointer for 
														// callback functions.
			PVOID				callback_data2;			// 2nd instance

			POB_THIS			parentObThis;			// The obthis that was cloned to 

			BOOL                check_for_locked_menu;  // used by 'obinst.cpp' - Currently only used in local object create.
														// can be easily removed	

			//***************************************************************************
			// file I/O buffers
			//***************************************************************************
			LPTSTR				pEntryBuffer;
			TCHAR HUGEPTR* pHugeEntryBuffer;
			LONG				lEntryPos;
			LONG				lEntrySize;

			//***************************************************************************
			// Multi-Tasking, Transaction Pooling, Miscellaneous
			//***************************************************************************
			PVOID				pTransPool;	    		// Transaction Pool 

			// this growblock is used as an array of groupId's to enable the codegen
			// routines to be thread safe and still be able to load the context.
			PSH_GROWBLOCK		pGroupIdArray;
			PVOID				criticalSection;		// general purpose critical section

			PVOID               pCmCompilerError;		// so we can decouple compiler dll

			ULONG				GeneralFlags;
			PVOID               unused_2;			    // some free bytes for the taking ...
			BOOL				bIgnoreLinkErrors;		// ignore link errors.
			UINT 		   		new_next_pcode;			// User set pcode Instruction
			PVOID               pSharedObjMgr;          // shared object manager interface

			// trace facility
			LPVOID				traceStruct;			// tracing structure
			BOOL				bTracing;				// global trace enable flag

			// debugger facility
			PSHLIST        		pWatchPointList;        // Pointer to watchpoint list
			PSHLIST       		dbg_callstk;			// Stack for walking up call stack
			UINT				bStepLine;				// Line number for step to cursor
			INT					bStepRoutineLevel;		// Depth step command started at

			// secure runtime session
			ULONG				SecureRuntimeSession;	// flags for apps downloaded over the Web.

			// garbage collection 
			DWORD				lGCTimeLimit;			// the min time between garbage collection runs
			DWORD				lLastGCTime;			// the time of the end of the last GC run
			BOOL				bGarbageCollecting;		// if we are in the process of garbage collecting

			// object manager request queue
			PVOID				pRequestQueue;			// a pointer to the obj_mgr request queue
			// pointer to error callback function for handling runtime errors
			PVOID				pErrorCallback;

			// windows dispatch handler
			PVOID				pWndDispatchHndlr;		// a pointer to the dispatch handler

			// these should all be protected by ob_enter_critical_section()!!
			DWORD				idOwnerThread;			// the handle the of thread that owns the OBTHIS
			BOOL				bActiveSession;			// indicate that this obthis is an active session

			BOOL				bIsAsyncCall;			// indicates if root of call is async

			PVOID				pLocalSession;
			PVOID				local_variables;		// Current local variables to routine
			UINT				num_variables;			// Number of local variables.
			UINT				curr_stack_bias;		// Current stack bias. Used for gc.

			BOOL				bDeferredDelete;		// indicates if we are deferring the delete
														// of an active session until after all requests
														// have completed processing.
			// Context Feature OB_ICONTEXT pointers
			PVOID				pSessOB_ICONTEXT;
			PVOID				pDefltOB_ICONTEXT;

			// Class Definition (a.k.a. metaclass) local session list
			PSHLIST 			pSessionList;

			LPTSTR				lpstrTypdefPblName;		// if we want to ignore the default of "pbtypvm70.dll"

			BOOL				bNoMessageBoxForError;	// TRUE if we don't want the message box to come up.
			BOOL				bInSystemError;			// TRUE if we are already executing the system error event.
			PVOID				last_break_routine;		// Last routine a breakpoint was processed in.
			BOOL				bInitDebugMode;			// Are we in the debugger and NOT running from within it.
			PVOID				pContextObject;		// The context object

			// remote debugger facility
			PVOID				pLocalDebugSession;	// If non-NULL, the local debug session for Remote debugging
			ULONG				breakpointId;			// unique id for breakpoints

			// GroupLoader stuff.
			PVOID				pGroupLoader;
			//Resulset Marshaling
			PVOID				pResultsetInfo;
			// pointer to error callback state information for functions handling runtime errors
			PVOID				pErrorCallbackState;

			// Exception Handling
			PSHLIST       		exception_stack;		// stack containing the checked exception list
			PVOID				thrown_exception;		// pointer to thrown exception object, 
														//	NULL if none pending
			PVOID				curr_exception;			// pointer to currently handled exception object, 
														//  NULL if not currently handling one
			PSHLIST       		gosub_stack;		    // stack containing the list of gosub return locations

			struct ResponseWindowStack
			{
				ResponseWindowStackNode* stack;
				UINT capacity;
				UINT count;
			} response_window_stack;

			PSHLIST       		objects_creating;		// A list object being created.
			PVOID				pb_session;				// To be used for PSPP
			PVOID				pMetaObject;			// A pointer to the meta object created by a func call
														// and need to be free in the next sf_dot call.
			// PB Accessibility service
			/* pb9 
			PVOID				pACCService;
			BOOL                isInOrcaBootStrap;
			LPTSTR				pCurrMissedTypeWhenOrcaBootStrap;
			BOOL				bInNewBuild;

			PVOID              pb_sessionA;
			BOOL                bJITStart;
			BOOL				bJITOption;
			*/
		} OB_THIS;

#define RT_THIS 	OB_THIS
#define PRT_THIS 	POB_THIS

#pragma pack(pop)

		//****************************************************************************
		// Response Window Stack functions
		//****************************************************************************
		void ob_response_window_stack_push(POB_THIS obthis);
		void ob_response_window_stack_pop(POB_THIS obthis);
		BOOL ob_is_response_window_event_done(POB_THIS obthis);

#define ob_is_response_window_open(obthis) \
	((obthis)->response_window_stack.count > 0)

#define ob_get_top_response_window_routine_level(obthis) \
	(ob_is_response_window_open(obthis) \
	? (obthis)->response_window_stack.stack[(obthis)->response_window_stack.count-1].routine_level \
	: 0)

#define ob_get_top_response_window_expr_stack_ptr(obthis) \
	(ob_is_response_window_open(obthis) \
	? (obthis)->expr_stack + (obthis)->response_window_stack.stack[(obthis)->response_window_stack.count-1].expr_stack_ptr \
	: 0)

		//****************************************************************************
		//****************************************************************************
		// Access Macro Definitions
		//****************************************************************************
#define ob_set_grouploader(obthis, grouploader) \
	((obthis)->pGroupLoader = grouploader)

#define ob_get_grouploader(obthis) \
	((obthis)->pGroupLoader)

#define ob_set_context_object(obthis, context) \
	((obthis)->pContextObject = (PVOID) context)

#define ob_get_context_object(obthis) \
	((IPB_Context *)((obthis)->pContextObject))

#define ob_get_parent_obthis(obthis) \
	((obthis)->parentObThis)

#define ob_set_parent_obthis(obthis, parent) \
	((obthis)->parentObThis = parent)

#define ob_is_child_obthis(obthis) \
	(ob_get_parent_obthis(obthis) != NULL)

#define ob_is_async_call(obthis) \
				((obthis)->bIsAsyncCall)
#define ob_set_is_async_call(obthis,newValue) \
				((obthis)->bIsAsyncCall = (newValue))
#define ob_get_curr_class_hndl(obthis) 						\
				((obthis)->curr_class_hndl)
#define ob_set_curr_class_hndl(obthis,clshndl) 			\
				((obthis)->curr_class_hndl = (clshndl))
#define ob_get_system_group_hndl(obthis) 					\
				((obthis)->sys_group_hndl)

#define ob_get_exe_code_type(obthis)								\
	((obthis)->exe_code_type)
#define ob_set_exe_code_type(obthis,code_type) 						\
	((obthis)->exe_code_type = (code_type))

#define ob_get_curr_error_info(obthis)					\
	( (POB_RUNTIME_ERROR_INFO) ((obthis)->p_error_info) )

#define ob_set_curr_error_info(obthis,error_info)					\
	((obthis)->p_error_info = (error_info))

#define ob_set_exe_name(obthis,exe_name) 			\
				((obthis)->pExecutableName = (exe_name))

#define ob_get_trans_pool_hndl(obthis) 						\
				((obthis)->pTransPool)

#define ob_set_trans_pool_hndl(obthis,trans) 						\
				((obthis)->pTransPool = trans)

#define ob_get_secure_mode(obthis)				   				\
	( (obthis)->SecureRuntimeSession )

#define ob_set_secure_mode(obthis, value)						\
	((obthis)->SecureRuntimeSession = 	(value) )

#define ob_get_gc_time_limit(obthis)							\
	((obthis)->lGCTimeLimit)

#define ob_set_gc_time_limit(obthis, newLimit)					\
	((obthis)->lGCTimeLimit = newLimit)

#define ob_should_garbage_collect(obthis)						\
	((obthis)->lGCTimeLimit < (GetTickCount() - (obthis)->lLastGCTime))

#define ob_set_gc_last_time(obthis)								\
	((obthis)->lLastGCTime = GetTickCount())

#define ob_set_error_callback(obthis,error_func)	\
	((obthis)->pErrorCallback=(PVOID)error_func)

#define ob_get_error_callback(obthis)	\
	((obthis)->pErrorCallback)

#define ob_set_error_callback_state(obthis,state_info)	\
	((obthis)->pErrorCallbackState=(PVOID)state_info)

#define ob_get_error_callback_state(obthis)	\
	((obthis)->pErrorCallbackState)

#define ob_get_routine_level(obthis)							   			\
	((obthis)->routine_level)

// ****************************************************************************
// Macros to set and get current stack bias.
// This is used to fool garbage collection when it is run while closing
// a routine inst so that it ignores the items on the stack which are
// actually arguments to the routine being popped.
// ****************************************************************************

#define ob_set_curr_stack_bias(obthis, bias)				\
			(obthis)->curr_stack_bias = (UINT)bias

#define ob_clear_curr_stack_bias(obthis)					\
			(obthis)->curr_stack_bias = (UINT)0

#define ob_get_curr_stack_bias(obthis)						\
			((UINT) (obthis)->curr_stack_bias)

// Resultset Info for Jaguar 1.1 style resultsets

#define ob_get_resultsetinfo(obthis)						\
			((obthis)->pResultsetInfo)

#define ob_set_resultsetinfo(obthis,pInfo)					\
			((obthis)->pResultsetInfo = (PVOID)pInfo)

// Context Feature


		PBWINAPI(VOID, ob_set_session_icontext)
			(POB_THIS 			obthis,
				PVOID				pNewContext
				);
#define ob_get_session_icontext(obthis)			   			\
	((obthis)->pSessOB_ICONTEXT)

		//****************************************************************************
		// Other macros (internal access only)
		//****************************************************************************

#define ob_get_objmgr_mode(obthis)		(obthis)->obMode

//****************************************************************************
// Routines and definitions to access PS_OPTIONS flags
//****************************************************************************

#define	OB_STOREDPROCS_ALLOWED	0x01
#define OB_DCE_ALLOWED			0x02
#define OB_NOT_ENTERPRISE		0x04			// not running under enterprise

#define ob_set_psoption(obthis,optn)						\
			(obthis)->ps_options |= (ULONG)(optn)

#define ob_get_psoption(obthis,optn)						\
			((obthis)->ps_options & (ULONG)(optn))

#define ob_set_not_enterprise(obthis)	\
			ob_set_psoption (obthis,OB_NOT_ENTERPRISE)
#define ob_not_enterprise(obthis)		\
			ob_get_psoption (obthis,OB_NOT_ENTERPRISE)


// indicate that this obthis is the root one
		PBWINAPI(BOOL, ob_set_main_obthis)
			(
				POB_THIS 			obthis
				);

		// ****************************************************************************
		// Runtime task management calls
		// ****************************************************************************

		//
		// Macro to define and initialize task handle
		//
#ifdef PBWIN32
#define PS_HTASK		DWORD
#else
#ifndef _INC_WINDOWS
		DECLARE_HANDLE(HTASK);
#endif
#define PS_HTASK		HTASK
#endif

		// Used for remote debugging
#define ob_isRemoteDebugging(obthis) ((obthis)->pLocalDebugSession != NULL)

//
// move the specified run environment to the current thread
//
		PBWINAPI(BOOL, rt_move_thread)
			(
				POB_THIS rtthis
				);

		//
		// clear the current thread's knowledge about the PB run environment
		//
		PBWINAPI(VOID, rt_clear_thread)
			(
				);

		PBWINAPI(POB_THIS, rt_get_current_this)
			(
				VOID
				);

		PBWINAPI(BOOL, rt_set_current_this)
			(
				PRT_THIS
				);

		PBWINAPI(BOOL, rt_add_task)
			(
				POB_THIS rtthis
				);

		PBWINAPI(BOOL, rt_free_task)
			(
				VOID
				);

		PBWINAPI(PVOID, rt_get_current_task_info)
			(
				INT info_pos
				);

		PBWINAPI(BOOL, rt_set_current_task_info)
			(
				INT info_pos,
				PVOID user_info
				);

		PBWINAPI(INT, rt_get_free_task_slot)
			(
				VOID
				);

		PBWINAPI(BOOL, rt_is_running_exe)
			(
				VOID
				);

#ifdef __cplusplus

		// This class saves off the current runtime engine task information and will
		// restore same information.
#ifndef PBVM_IGNORE
		class rt_threadtaskinfo_preserve
		{
		private:

			PVOID       lPreserveRTEState0;
			PVOID       lPreserveRTEState1;
			PVOID       lPreserveRTEState2;
			PVOID       lPreserveRTEState3;
			PRT_THIS    lPreservertThis;

		public:

			rt_threadtaskinfo_preserve()
			{
				// preserve state values in slots 0 - 3 and current runtime this
				lPreserveRTEState0 =
					lPreserveRTEState1 =
					lPreserveRTEState2 =
					lPreserveRTEState3 = 0;
				lPreservertThis = 0;
			}

			void Save()
			{
				// preserve state values in slots 0 - 3 and current runtime this
				lPreserveRTEState0 = rt_get_current_task_info(0);
				lPreserveRTEState1 = rt_get_current_task_info(1);
				lPreserveRTEState2 = rt_get_current_task_info(2);
				lPreserveRTEState3 = rt_get_current_task_info(3);
				lPreservertThis = rt_get_current_this();
			}

			void Restore()
			{
				rt_move_thread(lPreservertThis);
				rt_set_current_task_info(0, lPreserveRTEState0);
				rt_set_current_task_info(1, lPreserveRTEState1);
				rt_set_current_task_info(2, lPreserveRTEState2);
				rt_set_current_task_info(3, lPreserveRTEState3);
			}
		};
#endif
#endif

#undef POT_EVAL_NODE 
#undef PCM_THIS 



#ifdef __cplusplus
		}                       /* End of extern "C" { */
#endif	/* __cplusplus */


#endif // OBTHIS_H


// DOINC popped back into header 'obdata.h'
#endif

//****************************************************************************
// Assume C declarations for C++
//****************************************************************************

#ifdef __cplusplus
	extern "C" {
#endif	/* __cplusplus */


		//****************************************************************************
		// Object data structure (union depends on style of data)
		//****************************************************************************

		typedef union ob_value
		{
			SHORT				int_val;		 	// Integer value
			FLOAT				fl_val;				// Float value
			PVOID				ptr;			 	// Ptr to value
			OB_CONST_REF		const_ref;			// Constant value
			PVOID				ob_inst;			// There for compatibility, ptr should be used instead
			USHORT				id;					// Id value
			USHORT				uint_val;			// Unsigned integer
			LONG				long_val;			// Long integer
			ULONG				ulong_val;			// Unsigned Long integer
		//**********************************************************
		// Begin of the new type BYTE
		//**********************************************************
			BYTE				byte_val;			// Byte value
		//**********************************************************
		// End of the new type BYTE
		//**********************************************************

		} OB_VALUE, FAR* POB_VALUE;

		typedef USHORT			OB_INFO_FLAGS, FAR* POB_INFO_FLAGS;

		typedef struct ob_info
		{
			OB_INFO_FLAGS		info;					// Data node info flags
			OB_CLASS_ID			type;					// Data Type

		} OB_INFO, FAR* POB_INFO;

		typedef struct ob_data
		{
			OB_VALUE		   	val;
			OB_INFO_FLAGS		info;					// Data node info flags
			OB_CLASS_ID			type;					// Data Type

		} OB_DATA, FAR* POB_DATA;

		//****************************************************************************
		// FOR MACHINE CODE
		//****************************************************************************

		typedef struct ob_var
		{
			OB_VALUE			val;
			UINT				null_val;
		} OB_VAR, FAR* POB_VAR;

		//****************************************************************************
		// Data flags masks and shifts
		//****************************************************************************

#define DATA_NULLVAL_MASK		0x0001				// 1 bit
#define DATA_TYPEARGS_MASK		0x003e				// 5 bits 
#define DATA_REFTYPE_MASK		0x00c0				// 2 bits
#define DATA_STATUS_MASK		0x0100				// 1 bit
#define DATA_FIELDTYPE_MASK		0x0200				// 1 bit
#define DATA_STYLE_MASK			0x1c00				// 3 bits
#define DATA_GROUP_MASK			0x2000				// 1 bit
#define DATA_ACCESS_MASK		0xc000				// 2 bits

#define DATA_NULLVAL_SHIFT		0
#define DATA_TYPEARGS_SHIFT		1
#define DATA_REFTYPE_SHIFT		6
#define DATA_STATUS_SHIFT		8
#define DATA_FIELDTYPE_SHIFT	9
#define DATA_STYLE_SHIFT		10
#define DATA_GROUP_SHIFT		13
#define DATA_ACCESS_SHIFT		14 

//****************************************************************************
// OB_DATA component access macros.
//****************************************************************************

#define ob_get_data_type(node)   \
	((node)->type)

#define ob_get_data_flags(node)   \
	((node)->info)

#define ob_get_data_val(node)  \
	(PVOID)(&((node)->val))

//****************************************************************************
// Info flags access macros
//****************************************************************************

// gmoison DILBERT -cast info MASKs to match the same type as info
// which is of type OB_INFO_FLAGS 

#define ob_get_info_nullval(info)   \
	((BOOL) ((info) & DATA_NULLVAL_MASK))

#define ob_get_info_typeargs(info)   \
	ob_get_bitfield(info,UINT,DATA_TYPEARGS_SHIFT,(OB_INFO_FLAGS)DATA_TYPEARGS_MASK)

#define ob_get_info_reftype(info)   \
	ob_get_bitfield(info,OB_REFTYPE,DATA_REFTYPE_SHIFT,(OB_INFO_FLAGS)DATA_REFTYPE_MASK)

#define ob_get_info_status(info)   \
	ob_get_bitfield(info,OB_STATUS,DATA_STATUS_SHIFT,(OB_INFO_FLAGS)DATA_STATUS_MASK)

#define ob_get_info_fieldtype(info)   \
	ob_get_bitfield(info,OB_FIELD_TYPE,DATA_FIELDTYPE_SHIFT,(OB_INFO_FLAGS)DATA_FIELDTYPE_MASK)

#define ob_get_info_style(info)   \
	ob_get_bitfield(info,OB_DATASTYLE,DATA_STYLE_SHIFT,(OB_INFO_FLAGS)DATA_STYLE_MASK)

#define ob_get_info_group(info)   \
	ob_get_bitfield(info,OB_GROUPTYPE,DATA_GROUP_SHIFT,(OB_INFO_FLAGS)DATA_GROUP_MASK)

#define ob_get_info_access(info)	\
	ob_get_bitfield(info,OB_MEMBER_ACCESS,DATA_ACCESS_SHIFT,(OB_INFO_FLAGS)DATA_ACCESS_MASK)

//****************************************************************************
// Info flags access macros (from POB_DATA)
//****************************************************************************

#define ob_get_data_typeargs(node)   \
	ob_get_info_typeargs((node)->info)

#define ob_get_data_reftype(node)   \
	ob_get_info_reftype((node)->info)

#define ob_get_data_status(node)   \
	ob_get_info_status((node)->info)

#define ob_get_data_nullval(node)   \
	ob_get_info_nullval((node)->info)

#define ob_get_data_fieldtype(node)   \
	ob_get_info_fieldtype((node)->info)

#define ob_get_data_style(node)   \
	ob_get_info_style((node)->info)

#define ob_get_data_group(node)   \
	ob_get_info_group((node)->info)

#define ob_get_data_access(node)	\
	ob_get_info_access((node)->info)


//****************************************************************************
// POB_DATA component update macros (from POB_DATA)
//****************************************************************************

#define ob_set_data_type(node,typ)   	\
	((node)->type = typ)

#define ob_set_data_flags(node,inf)   	\
	((node)->info = (OB_INFO_FLAGS)(inf))

#define ob_set_data_val(node,value)   	\
	((node)->val = * ((POB_VALUE) (value)))

//****************************************************************************
// Info flags update macros 
//****************************************************************************

#define __ob_set_info(info,value,shift,mask)   						\
	ob_set_bitfield(info,OB_INFO_FLAGS,value,shift,mask)

#define ob_set_info_nullval(info,nullval)	   						\
	((info) = (OB_INFO_FLAGS) ((nullval) | ((info) & ~DATA_NULLVAL_MASK)))

#define ob_set_info_typeargs(info,typeargs)	   						\
	__ob_set_info(info,typeargs,DATA_TYPEARGS_SHIFT,DATA_TYPEARGS_MASK)

#define ob_set_info_reftype(info,reftype)	   						\
	__ob_set_info(info,reftype,DATA_REFTYPE_SHIFT,DATA_REFTYPE_MASK)

#define ob_set_info_status(info,status)	   							\
	__ob_set_info(info,status,DATA_STATUS_SHIFT,DATA_STATUS_MASK)

#define ob_set_info_fieldtype(info,fieldtype)	   					\
	__ob_set_info(info,fieldtype,DATA_FIELDTYPE_SHIFT,DATA_FIELDTYPE_MASK)

#define ob_set_info_style(info,style)  								\
	__ob_set_info(info,style,DATA_STYLE_SHIFT,DATA_STYLE_MASK)

#define ob_set_info_group(info,group)  								\
	__ob_set_info(info,group,DATA_GROUP_SHIFT,DATA_GROUP_MASK)

#define ob_set_info_access(info,access)	   							\
	__ob_set_info(info,access,DATA_ACCESS_SHIFT,DATA_ACCESS_MASK)

//****************************************************************************
// Info flags update macros (from POB_DATA)
//****************************************************************************

#define ob_set_data_typeargs(node,typeargs)	   						\
	ob_set_info_typeargs ((node)->info, typeargs)

#define ob_set_data_reftype(node,reftype)	   						\
	ob_set_info_reftype ((node)->info, reftype)

#define ob_set_data_status(node,status)	   							\
	ob_set_info_status ((node)->info, status)

#define ob_set_data_nullval(node,nullval)	   						\
	ob_set_info_nullval ((node)->info, nullval)

#define ob_set_data_fieldtype(node,fieldtype)	   					\
	ob_set_info_fieldtype ((node)->info, fieldtype)

#define ob_set_data_style(node,style)  								\
	ob_set_info_style ((node)->info, style)

#define ob_set_data_group(node,group)  								\
	ob_set_info_group ((node)->info, group)

#define ob_set_data_access(node,access)	   							\
	ob_set_info_access ((node)->info, access)

//****************************************************************************
// Macro to set style, type and grouping in POB_INFO,ob_set_data_info (node, INT_STYLE, type, OB_SIMPLE, vartype);		\
//****************************************************************************

#define ob_set_data_info(node,style,typ,group,vartype)			   	\
	((node)->info = (OB_INFO_FLAGS) (							   	\
					 (OB_PUBLIC_MEMBER << DATA_ACCESS_SHIFT)	|  	\
					 ((group) << DATA_GROUP_SHIFT)				|  	\
					 (0 << DATA_FIELDTYPE_SHIFT)				|  	\
					 ((style) << DATA_STYLE_SHIFT)				|  	\
					 (USED << DATA_STATUS_SHIFT)				|  	\
					 (OB_DIRECT_REF << DATA_REFTYPE_SHIFT) 		|  	\
					 (0 << DATA_TYPEARGS_SHIFT)),					\
	 (node)->type = (OB_CLASS_ID)typ								\
	)

//****************************************************************************
// Macro to set style, type, grouping, and nullval in POB_INFO
//****************************************************************************

#define ob_set_data_info_nv(node,style,typ,group,nullval)		  	\
	((node)->info = (OB_INFO_FLAGS) (								\
					 (OB_PUBLIC_MEMBER << DATA_ACCESS_SHIFT)	|  	\
					 ((group) << DATA_GROUP_SHIFT)				|  	\
					 (0 << DATA_FIELDTYPE_SHIFT)				|  	\
					 ((style) << DATA_STYLE_SHIFT)				|  	\
					 (USED << DATA_STATUS_SHIFT)				|  	\
					 (OB_DIRECT_REF << DATA_REFTYPE_SHIFT) 		|  	\
					 (0 << DATA_TYPEARGS_SHIFT))				|	\
					 ((USHORT)(nullval)),						  	\
	 (node)->type = (OB_CLASS_ID)typ								\
	)

//****************************************************************************
// Same as ob_set_data_info () except NULLVAL is retained
//****************************************************************************

#define ob_replace_data_info(node,style,typ,group)				  	\
	((node)->info = (OB_INFO_FLAGS) (								\
					 ((node)->info & DATA_NULLVAL_MASK)			| 	\
					 (OB_PUBLIC_MEMBER << DATA_ACCESS_SHIFT)	| 	\
					 ((group) << DATA_GROUP_SHIFT)				| 	\
					 (0 << DATA_FIELDTYPE_SHIFT)				| 	\
					 ((style) << DATA_STYLE_SHIFT)				| 	\
					 (USED << DATA_STATUS_SHIFT)				| 	\
					 (OB_DIRECT_REF << DATA_REFTYPE_SHIFT) 		| 	\
					 (0 << DATA_TYPEARGS_SHIFT)),					\
	 (node)->type = (OB_CLASS_ID)typ								\
	)


//****************************************************************************
// Macro to set (almost) all flags in POB_INFO
//****************************************************************************

#define ob_build_data_info(info,style,group,args,ref,access,fldtyp)   	\
	((info) = (OB_INFO_FLAGS) (((access) << DATA_ACCESS_SHIFT)		| 	\
						 	   ((group) << DATA_GROUP_SHIFT)		| 	\
						 	   ((fldtyp) << DATA_FIELDTYPE_SHIFT)	| 	\
						 	   ((style) << DATA_STYLE_SHIFT)   		| 	\
						 	   (USED << DATA_STATUS_SHIFT)		  	| 	\
						 	   ((ref) << DATA_REFTYPE_SHIFT)   		| 	\
						 	   ((args) << DATA_TYPEARGS_SHIFT))	 		\
	)

//****************************************************************************
// Copy macros
//****************************************************************************

#define ob_copy_data_node(node,value_node)   	\
	(* ((POB_DATA) (node)) = * ((POB_DATA) (value_node)))

//****************************************************************************
// Value access macros
//****************************************************************************

#define ob_get_data_int(node) \
	((node)->val.int_val)

#define ob_get_data_uint(node) \
	((node)->val.uint_val)

//**********************************************************
// Begin of the new type BYTE
//**********************************************************
#define ob_get_data_byte(node) \
	((node)->val.byte_val) //(BYTE) ob_get_data_int(node)	
//**********************************************************
// End of the new type BYTE
//**********************************************************

#define ob_get_data_long(node) \
	((node)->val.long_val)

#define ob_get_data_ulong(node) \
	((node)->val.ulong_val)

#define ob_get_data_float(node) \
	((node)->val.fl_val)

#define ob_get_data_char(node) \
	(TCHAR) ob_get_data_uint(node)

#define ob_get_data_ptr(node) \
	((node)->val.ptr)

#define ob_get_data_const(node) \
	((node)->val.const_ref)

#define ob_get_data_id(node) \
	((node)->val.id)

#define ob_get_data_obinst(node) \
	ob_get_data_ptr (node)

#define ob_get_data_rtinst(node) \
	((POB_RUNTIME_INST) ob_get_data_ptr (node))

#define ob_get_data_array(node) \
	((OB_ARRAY_ID) ob_get_data_ptr (node))

#define ob_get_data_arrayinst(node) \
	((POB_ARRAY_INST) ob_get_data_ptr (node))

//****************************************************************************
// Simple value update macros	- Info flags not used.
//****************************************************************************

#define ob_set_simple_int(node,intval)								\
	{																\
	(node)->val.long_val = (LONG) (intval);							\
	(node)->info = 0;												\
	}

#define ob_set_simple_const(node,constval)							\
	{																\
	(node)->val.const_ref = constval;								\
	(node)->info = 0;												\
	}

#define ob_set_simple_ptr(node,ptrval)								\
	{																\
	(node)->val.ptr = ptrval;										\
	(node)->info = 0;												\
	}

#define ob_set_simple_id(node,idval)								\
	{																\
	(node)->val.id = (USHORT)(idval);								\
	(node)->info = 0;												\
	}

#define ob_set_simple_obinst(node,ptrval)   			   			\
	ob_set_simple_ptr(node,ptrval)

#define ob_set_simple_rtinst(node,ptrval)   			   			\
	ob_set_simple_ptr(node,ptrval)

#define ob_set_simple_array(node,idval)								\
	ob_set_simple_ptr(node,ptrval)

#define ob_set_simple_arrayinst(node,idval)		  					\
	ob_set_simple_ptr(node,ptrval)

//****************************************************************************
// Normal value update macros
//****************************************************************************

#define ob_set_data_int_val(node,intval)							\
	((node)->val.int_val = (SHORT)(intval))							

#define ob_set_data_uint_val(node,uintval)							\
	((node)->val.uint_val = (USHORT)(uintval))						

//**********************************************************
// Begin of the new type BYTE
//**********************************************************
#define ob_set_data_byte_val(node, byteval)							\
	((node)->val.byte_val = (BYTE)(byteval))						
//**********************************************************
// End of the new type BYTE
//**********************************************************

#define ob_set_data_long_val(node,longval)							\
	(node)->val.long_val = longval									

#define ob_set_data_ulong_val(node,ulongval)						\
	(node)->val.ulong_val = ulongval								

#define ob_set_data_float_val(node,flval)							\
	(node)->val.fl_val = flval										

#define ob_set_data_ptr_val(node,ptrval)							\
	(node)->val.ptr = (PVOID) (ptrval)								

#define ob_set_data_dec_val(node,ptrval)							\
	(node)->val.ptr = (PVOID) (ptrval)								

#define ob_set_data_double_val(node,ptrval)							\
	(node)->val.ptr = (PVOID) (ptrval)								

#define ob_set_data_longlong_val(node,ptrval)							\
	(node)->val.ptr = (PVOID) (ptrval)								

#define ob_set_data_string_val(node,ptrval)							\
	(node)->val.ptr = (PVOID) (ptrval)								

#define ob_set_data_bool_val(node,boolval)							\
	ob_set_data_int_val (node, boolval)

#define ob_set_data_char_val(node,charval)							\
	ob_set_data_uint_val (node, charval)

#define ob_set_data_blob_val(node,ptrval)							\
	(node)->val.ptr = (PVOID) (ptrval)								

#define ob_set_data_time_val(node,ptrval)							\
	(node)->val.ptr = (PVOID) (ptrval)								

#define ob_set_data_date_val(node,ptrval)							\
	(node)->val.ptr = (PVOID) (ptrval)								

#define ob_set_data_datetime_val(node,ptrval)				 		\
	(node)->val.ptr = (PVOID) (ptrval)								

#define ob_set_data_const_val(node,constval)						\
	(node)->val.const_ref = constval								

#define ob_set_data_id_val(node,idval)								\
	(node)->val.id = (USHORT)(idval)								

#define ob_set_data_obinst_val(node,ptrval)							\
	ob_set_data_ptr_val(node,ptrval)

#define ob_set_data_rtinst_val(node,ptrval)							\
	ob_set_data_ptr_val(node,ptrval)

#define ob_set_data_array_val(node,idval)							\
	ob_set_data_ptr_val(node,idval)

#define ob_set_data_arrayinst_val(node,idval)						\
	ob_set_data_ptr_val(node,idval)

#define ob_set_data_enum_val(node,enumval)							\
	ob_set_data_int_val (node, enumval)

//OLD WAY
#define ob_set_data_binary_val(node,ptrval)							\
	(node)->val.ptr = (PVOID) (ptrval)								

//****************************************************************************
// Composite value update macros
// Note: vartype parameter is no longer used
//****************************************************************************

#define ob_set_data_int(node,intval,type,vartype)						\
	{																	\
	ob_set_data_int_val(node,intval);									\
	ob_set_data_info (node, INT_STYLE, type, OB_SIMPLE, vartype);		\
	}

#define ob_set_data_uint(node,uintval,type,vartype)						\
	{																	\
	ob_set_data_uint_val(node,uintval);									\
	ob_set_data_info (node, INT_STYLE, type, OB_SIMPLE, vartype);		\
	}

//**********************************************************
// Begin of the new type BYTE
//**********************************************************
#define ob_set_data_byte(node,byteval,type,vartype)						\
	{																	\
	ob_set_data_byte_val(node,byteval);									\
	ob_set_data_info (node, INT_STYLE, type, OB_SIMPLE, vartype);		\
	}
//**********************************************************
// End of the new type BYTE
//**********************************************************

#define ob_set_data_long(node,longval,type,vartype)						\
	{																	\
	ob_set_data_long_val(node,longval);									\
	ob_set_data_info (node, LONG_STYLE, type, OB_SIMPLE, vartype);		\
	}

#define ob_set_data_ulong(node,ulongval,type,vartype)					\
	{																	\
	ob_set_data_ulong_val(node,ulongval);								\
	ob_set_data_info (node, LONG_STYLE, type, OB_SIMPLE, vartype);		\
	}

#define ob_set_data_float(node,flval,type,vartype)						\
	{																	\
	ob_set_data_float_val(node,flval);									\
	ob_set_data_info (node, FLOAT_STYLE, type, OB_SIMPLE, vartype);		\
	}

#define ob_set_data_ptr(node,ptrval,type,vartype)					 	\
	{																 	\
	ob_set_data_ptr_val(node,ptrval);									\
	ob_set_data_info (node, PTR_STYLE, type, OB_SIMPLE, vartype);	 	\
	}

#define ob_set_data_dec(node,ptrval,type,vartype)					 	\
	ob_set_data_ptr(node,ptrval,type,vartype)

#define ob_set_data_double(node,ptrval,type,vartype)   				 	\
	ob_set_data_ptr(node,ptrval,type,vartype)

#define ob_set_data_longlong(node,ptrval,type,vartype)   				 	\
	ob_set_data_ptr(node,ptrval,type,vartype)

#define ob_set_data_string(node,ptrval,type,vartype)		 		 	\
	ob_set_data_ptr(node,ptrval,type,vartype)

#define ob_set_data_blob(node,ptrval,type,vartype)					 	\
	ob_set_data_ptr(node,ptrval,type,vartype)

#define ob_set_data_binary(node,ptrval,type,vartype)		 		 	\
	ob_set_data_blob(node,ptrval,type,vartype)

#define ob_set_data_bool(node,intval,type,vartype)					 	\
	ob_set_data_int(node,intval,type,vartype)

#define ob_set_data_char(node,intval,type,vartype)					 	\
	ob_set_data_uint(node,intval,type,vartype)

#define ob_set_data_enum(node,intval,type,vartype)					 	\
	{																	\
	ob_set_data_int(node,intval,type,vartype);							\
	ob_set_data_objtype(node,OB_NON_OBJECT_TYPE);						\
	}

#define ob_set_data_time(node,ptrval,type,vartype)					 	\
	ob_set_data_ptr(node,ptrval,type,vartype)

#define ob_set_data_date(node,ptrval,type,vartype)					 	\
	ob_set_data_ptr(node,ptrval,type,vartype)

#define ob_set_data_datetime(node,ptrval,type,vartype)					\
	ob_set_data_ptr(node,ptrval,type,vartype)

#define ob_set_data_const(node,constval,type,vartype)					\
	{																	\
	ob_set_data_const_val(node,constval);								\
	ob_set_data_info (node, CONST_STYLE, type, OB_SIMPLE, vartype );	\
	}

#define ob_set_data_id(node,idval,type,vartype)							\
	{																	\
	ob_set_data_id_val(node,idval);										\
	ob_set_data_info (node, ID_STYLE, type, OB_SIMPLE, vartype);		\
	}

#define ob_set_data_obinst(node,ptrval,type,vartype)			   		\
	ob_set_data_ptr(node,ptrval,type,vartype)

#define ob_set_data_rtinst(node,ptrval,type,vartype)			   		\
	ob_set_data_ptr(node,ptrval,type,vartype)

#define ob_set_data_array(node,ptrval,type,vartype)						\
	{																	\
	ob_set_data_ptr(node,ptrval,type,0);  								\
	ob_set_data_group (node, OB_ARRAY);									\
	}

#define ob_set_data_arrayinst(node,ptrval,type,vartype)					\
	{																	\
	ob_set_data_ptr(node,ptrval,type,0);  								\
	ob_set_data_group (node, OB_ARRAY);									\
	}

//****************************************************************************
// Composite value update macros with nullval
//****************************************************************************

#define ob_set_data_undeclared_nv(node,type,nullval)					\
	{																 	\
	ob_set_data_ptr_val(node,NULL);										\
	ob_set_data_info_nv (node, UNDECLARED_STYLE, type, OB_SIMPLE, nullval);\
	}

#define ob_set_data_int_nv(node,intval,type,nullval)	  				\
	{																	\
	ob_set_data_int_val(node,intval);									\
	ob_set_data_info_nv (node, INT_STYLE, type, OB_SIMPLE, nullval);	\
	}

#define ob_set_data_float_nv(node,flval,type,nullval)					\
	{																	\
	ob_set_data_float_val(node,flval);									\
	ob_set_data_info_nv (node, FLOAT_STYLE, type, OB_SIMPLE, nullval);	\
	}

#define ob_set_data_ptr_nv(node,ptrval,type,nullval)					\
	{																 	\
	ob_set_data_ptr_val(node,ptrval);									\
	ob_set_data_info_nv (node, PTR_STYLE, type, OB_SIMPLE, nullval);	\
	}

#define ob_set_data_const_nv(node,constval,type,nullval)				\
	{																	\
	ob_set_data_const_val(node,constval);								\
	ob_set_data_info_nv (node, CONST_STYLE, type, OB_SIMPLE, nullval );	\
	}

#define ob_set_data_id_nv(node,idval,type,nullval)						\
	{																	\
	ob_set_data_id_val(node,idval);										\
	ob_set_data_info_nv (node, ID_STYLE, type, OB_SIMPLE, nullval);		\
	}

#define ob_set_data_obinst_nv(node,ptrval,type,nullval)					\
	ob_set_data_ptr_nv(node,ptrval,type,nullval)

#define ob_set_data_rtinst_nv(node,ptrval,type,nullval)					\
	ob_set_data_ptr_nv(node,ptrval,type,nullval)

#define ob_set_data_arrayinst_nv(node,ptrval,type,nullval)	  			\
	{																	\
	ob_set_data_ptr_nv(node,ptrval,type,nullval);						\
	ob_set_data_group (node, OB_ARRAY);									\
	}

#define ob_set_data_uint_nv(node,uintval,type,nullval)					\
	{																	\
	ob_set_data_uint_val(node,uintval);									\
	ob_set_data_info_nv (node, INT_STYLE, type, OB_SIMPLE, nullval);	\
	}

//**********************************************************
// Begin of the new type BYTE
//**********************************************************
#define ob_set_data_byte_nv(node,byteval,type,nullval)					\
	{																	\
	ob_set_data_byte_val(node,byteval);									\
	ob_set_data_info_nv (node, INT_STYLE, type, OB_SIMPLE, nullval);	\
	}
//**********************************************************
// End of the new type BYTE
//**********************************************************

#define ob_set_data_long_nv(node,longval,type,nullval)					\
	{																	\
	ob_set_data_long_val(node,longval);									\
	ob_set_data_info_nv (node, LONG_STYLE, type, OB_SIMPLE, nullval);	\
	}

#define ob_set_data_ulong_nv(node,ulongval,type,nullval)				\
	{																	\
	ob_set_data_ulong_val(node,ulongval);								\
	ob_set_data_info_nv (node, LONG_STYLE, type, OB_SIMPLE, nullval);	\
	}

#define ob_set_data_char_nv(node,charval,type,nullval)				\
	{																	\
	ob_set_data_int_val (node, charval);								\
	ob_set_data_info_nv (node, INT_STYLE, type, OB_SIMPLE, nullval);	\
	}

#define ob_set_data_string_nv(node,ptrval,type,nullval)				\
	{																	\
	ob_set_data_string_val(node,ptrval);								\
	ob_set_data_info_nv (node, PTR_STYLE, type, OB_SIMPLE, nullval);	\
	}

#define ob_set_data_blob_nv(node,ptrval,type,nullval)				\
	{																	\
	ob_set_data_blob_val(node,ptrval);								\
	ob_set_data_info_nv (node, PTR_STYLE, type, OB_SIMPLE, nullval);	\
	}

#define ob_set_data_double_nv(node,ptrval,type,nullval)				\
	{																	\
	ob_set_data_double_val(node,ptrval);								\
	ob_set_data_info_nv (node, PTR_STYLE, type, OB_SIMPLE, nullval);	\
	}

#define ob_set_data_longlong_nv(node,ptrval,type,nullval)				\
	{																	\
	ob_set_data_longlong_val(node,ptrval);								\
	ob_set_data_info_nv (node, PTR_STYLE, type, OB_SIMPLE, nullval);	\
	}

#define ob_set_data_dec_nv(node,ptrval,type,nullval)				\
	{																	\
	ob_set_data_dec_val(node,ptrval);								\
	ob_set_data_info_nv (node, PTR_STYLE, type, OB_SIMPLE, nullval);	\
	}

#define ob_set_data_time_nv(node,ptrval,type,nullval)				\
	{																	\
	ob_set_data_time_val(node,ptrval);								\
	ob_set_data_info_nv (node, PTR_STYLE, type, OB_SIMPLE, nullval);	\
	}

#define ob_set_data_date_nv(node,ptrval,type,nullval)				\
	{																	\
	ob_set_data_date_val(node,ptrval);								\
	ob_set_data_info_nv (node, PTR_STYLE, type, OB_SIMPLE, nullval);	\
	}

#define ob_set_data_datetime_nv(node,ptrval,type,nullval)				\
	{																	\
	ob_set_data_datetime_val(node,ptrval);								\
	ob_set_data_info_nv (node, PTR_STYLE, type, OB_SIMPLE, nullval);	\
	}


//****************************************************************************
// Composite value replace macros. Leaves NULLVAL intact
//****************************************************************************

#define ob_replace_data_int(node,intval,type)							\
	{																	\
	ob_set_data_int_val(node,intval);									\
	ob_replace_data_info (node, INT_STYLE, type, OB_SIMPLE);			\
	}

#define ob_replace_data_float(node,flval,type)							\
	{																	\
	ob_set_data_float_val(node,flval);									\
	ob_replace_data_info (node, FLOAT_STYLE, type, OB_SIMPLE);			\
	}

#define ob_replace_data_ptr(node,ptrval,type)					 		\
	{																 	\
	ob_set_data_ptr_val(node,ptrval);									\
	ob_replace_data_info (node, PTR_STYLE, type, OB_SIMPLE);	 		\
	}

#define ob_replace_data_const(node,constval,type)						\
	{																	\
	ob_set_data_const_val(node,constval);								\
	ob_replace_data_info (node, CONST_STYLE, type, OB_SIMPLE );			\
	}

#define ob_replace_data_id(node,idval,type)								\
	{																	\
	ob_set_data_id_val(node,idval);										\
	ob_replace_data_info (node, ID_STYLE, type, OB_SIMPLE);				\
	}

#define ob_replace_data_obinst(node,ptrval,type)				 		\
	ob_replace_data_ptr(node,ptrval,type)

#define ob_replace_data_rtinst(node,ptrval,type)				 		\
	ob_replace_data_ptr(node,ptrval,type)

#define ob_replace_data_arrayinst(node,ptrval,type)						\
	ob_replace_data_ptr(node,ptrval,type)

#define ob_replace_data_uint(node,uintval,type)							\
	{																	\
	ob_set_data_uint_val(node,uintval);									\
	ob_replace_data_info (node, INT_STYLE, type, OB_SIMPLE);			\
	}

//**********************************************************
// Begin of the new type BYTE
//**********************************************************
#define ob_replace_data_byte(node,byteval,type)							\
	{																	\
	ob_set_data_byte_val(node,byteval);									\
	ob_replace_data_info (node, INT_STYLE, type, OB_SIMPLE);			\
	}
//**********************************************************
// End of the new type BYTE
//**********************************************************

#define ob_replace_data_long(node,longval,type)							\
	{																	\
	ob_set_data_long_val(node,longval);									\
	ob_replace_data_info (node, LONG_STYLE, type, OB_SIMPLE);			\
	}

#define ob_replace_data_ulong(node,ulongval,type)						\
	{																	\
	ob_set_data_ulong_val(node,ulongval);								\
	ob_replace_data_info (node, LONG_STYLE, type, OB_SIMPLE);			\
	}

//****************************************************************************
// Data declaration query macros
//****************************************************************************

// Returns true if data is declared
#define ob_is_data_declared(node) \
			(ob_get_data_style(node) != UNDECLARED_STYLE)

//****************************************************************************
// Set up data that contains a structure instance
//****************************************************************************

#define ob_set_data_structure(obthis,node)	\
	{																		\
	OB_INFO_FLAGS info;														\
	ob_build_obj_typeargs(info,OB_OBJECT_TYPE,OB_AUTO_INSTANTIATE);			\
	ob_set_data_typeargs(node,info);										\
	}

// Array information
		typedef enum
		{
			OB_UNBOUNDED_ARRAY,             // one dimensional only, 1 is lower bound.
			OB_SIMPLE_ARRAY,                // one dimensional, 1 is lower bound.
			OB_COMPLEX_ARRAY                // multi dimensional or with non-standard
											//    lower bound.

		} OB_ARRAY_SYMBOL_STYLE, FAR* POB_ARRAY_SYMBOL_STYLE;


#ifdef __cplusplus
	}                       /* End of extern "C" { */
#endif	/* __cplusplus */


#endif // OBDATA_H

// DOINC popped back into header 'obcurent.h'
#endif
#ifndef OBTHIS_H
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBTYPDEF_H
// ***** DOINC including obtypdef.h *****
// $RCSfile: obtypdef.h $;$Revision: 4.99 $
//**************************************************************************
//
//                        Copyright 1989 - 1994
//                        Powersoft Corporation
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM POWERSOFT CORPORATION.
//
// ------------------------------------------------------------------------
//
//    Filename :    obtypdef.h
//
//    Author   :    Jim Kosko
//
//    Purpose  :    Structure definitions for data types.
//
//****************************************************************************

#ifndef OBTYPDEF_H
#define OBTYPDEF_H

//****************************************************************************
// Includes
//****************************************************************************

#ifndef OSPASCAL_H
// ***** DOINC including ospascal.h *****
	// DOINC skipping duplicate include
#endif
#ifndef PBSTG_H
// ***** DOINC including pbstg.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBTHIS_H
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBDEFINE_H
// ***** DOINC including obdefine.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBDATA_H
// ***** DOINC including obdata.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBCONST_H
// ***** DOINC including obconst.h *****
// $RCSfile: obconst.h $;$Revision: 4.15 $
//**************************************************************************
//
//                            Copyright 1989 
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :	obconst.h	
//
//    Author   :	Jim Kosko
//
//    Purpose  : 	Constant pool data structure for PB object manager.
//
//****************************************************************************

#ifndef OBCONST_H
#define OBCONST_H

//****************************************************************************
// Includes
//****************************************************************************

#ifndef _LIMITS_H_INCLUDED
#include <limits.h>
#endif
#ifndef OSPASCAL_H
// ***** DOINC including ospascal.h *****
	// DOINC skipping duplicate include
#endif
#ifndef PBSTG_H
// ***** DOINC including pbstg.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBDEFINE_H
// ***** DOINC including obdefine.h *****
	// DOINC skipping duplicate include
#endif
#ifndef SHHASH_H
// ***** DOINC including shhash.h *****
//$Header
//**************************************************************************
//
//                            Copyright 1989-1995 
//                        Powersoft
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM POWERSOFT
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :    shhash.h
//
//    Author   :    Kim Sheffield from shhash.hxx by Jim Kosko
//
//    Purpose  :    Descriptions of PB hash table.
//
//****************************************************************************


//****************************************************************************
// Make sure file doesn't get included twice
//****************************************************************************

#ifndef SHHASH_H
#define SHHASH_H

//****************************************************************************
// Includes
//****************************************************************************
#ifndef OSWINDOW_H
// ***** DOINC including oswindow.h *****
	// DOINC skipping duplicate include
#endif

// ***** DOINC including pbstg.h *****
	// DOINC skipping duplicate include
// ***** DOINC including shlist.h *****
	// DOINC skipping duplicate include

#ifdef __cplusplus
	extern "C"
	{
#endif

		//****************************************************************************
		// Typedef for key function routine
		//****************************************************************************
		typedef PBCALLBACK(PVOID, *KEY_FUNC) (PVOID);
		typedef PBCALLBACK(PVOID, *KEY_FUNC_ARG) (PVOID, PVOID);

		//***************************************************************************
		//    Hash table definition.
		//***************************************************************************

		typedef struct shhashx
		{
			ppbstg_anchor   sa;             // Storage anchor
			pbstg_subpool   subpool;        // storage subpool to alloc in
			PSHLIST  FAR* table;         // Ptr to hash table array
			KEY_FUNC        key_func;       // User data to string function
			PVOID 			key_arg;		// User data for KEY_FUNC 
			INT             no_slots;       // Number of slots in table.
			INT             current_slot;   // Slot most recently used.
			UINT            entries;        // Number entries in hash table
			BOOL            unique;         // Entries unique? t/f
			BOOL            listHash;       // Use list hashing functions
		} shhash;
#define PSHHASH shhash FAR *

		//***************************************************************************
		// Structure used for shhash_statistics
		//***************************************************************************
		typedef struct
		{
			double          optSpread;      // # entries / # slots
			double          actSpread;      // # entries / # lists in use
			INT             maxInList;      // Count of list with most entries
		} HASHSTAT, FAR* PHASHSTAT;


		//***************************************************************************
		// Function prototypes
		//***************************************************************************
		PBWINAPI(PSHHASH, shhash_new)(INT,  // # of slots; use prime # for performance
			KEY_FUNC,       // key func. if NULL data is string
			BOOL,           // unique TRUE/FALSE
			BOOL,           // use list hashing functions?
			ppbstg_anchor,  // Storage manager
			pbstg_subpool);   // Allocation subpool
		PBWINAPI(PSHHASH, shhash_new_arg)(INT, // # of slots; use prime # for performance
			KEY_FUNC_ARG,   // key func. if NULL data is string
			BOOL,           // unique TRUE/FALSE
			BOOL,           // use list hashing functions?
			ppbstg_anchor,  // Storage manager
			pbstg_subpool,	// Allocation subpool
			PVOID);         // Arg for all key functions
		PBWINAPI(void, shhash_delete)(PSHHASH);           // Hash table destructor
		PBWINAPI(void, shhash_clear)(PSHHASH);            // Clear out all hash table entries
		PBWINAPI(PVOID, shhash_get_first)(PSHHASH);   // Get first item in table.
		PBWINAPI(PVOID, shhash_get_next)(PSHHASH);   // Get next item in table.
		PBWINAPI(int, shhash_insert) (PSHHASH, PVOID);   // Insert into table.
#define shhash_get_count(this) this->entries    // Return number of entries
		PBWINAPI(PVOID, shhash_search) (PSHHASH, PVOID);   // Search table.
		PBWINAPI(PVOID, shhash_search_arg) (PSHHASH, PVOID, PVOID);   // Search table.
		PBWINAPI(PVOID, shhash_search_unique)(PSHHASH pThis, PVOID key);
		PBWINAPI(PVOID, shhash_search_unique_arg)(PSHHASH pThis, PVOID key, PVOID arg);
		PBWINAPI(PVOID, shhash_searchNext) (PSHHASH, PVOID);   // Search table for next
		PBWINAPI(PSHLIST, shhash_searchSlot)(PSHHASH, PVOID);  // Search table return slot list
		PBWINAPI(PVOID, shhash_remove) (PSHHASH);          // Remove from table.
		PBWINAPI(PHASHSTAT, shhash_statistics)(PSHHASH, PHASHSTAT); // Get stats
		// Make traverse a special case of traversal where caller has no user data
#define shhash_traverse(t, f) shhash_traversal(t, NULL, f)
		PBWINAPI(BOOL, shhash_traversal)(PSHHASH pthis, PVOID data, PASCALFAR_INT_PROC trav_func);

#ifdef __cplusplus
	}
#endif

#endif // SHHASH_H
	// DOINC popped back into header 'obconst.h'
#endif
#ifndef OBTHIS_H
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBERROR_H
// ***** DOINC including oberror.h *****
//**************************************************************************
//
//                            Copyright 1989 
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :	oberror.h	
//
//    Author   :	Jim Kosko
//
//    Purpose  : 	Definitions for PB object manager error codes.
//
//****************************************************************************

#ifndef OBERROR_H
#define OBERROR_H

//****************************************************************************
// Includes
//****************************************************************************

// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include

//****************************************************************************
// Assume C declarations for C++
//****************************************************************************

#ifdef __cplusplus
	extern "C" {
#endif	/* __cplusplus */

		//****************************************************************************
		// Error codes
		//****************************************************************************

		typedef enum
		{
			OB_SUCCESS,
			OB_OPEN_ERROR,
			OB_READ_ERROR,
			OB_WRITE_ERROR,
			OB_SCAN_ERROR,
			OB_VERSION_ERROR,
			OB_NOTFOUND,
			OB_SEMI_COMPILED_OBJ_ERROR,
			OB_MISSING_ANCESTOR_ERROR,
			OB_DUPLICATE_ANCESTOR_ERROR,
			OB_INTERNAL_OVERFLOW,
			OB_GOT_RUNTIME_ERROR,
			OB_EXECUTION_ERROR,
			OB_GENERAL_ERROR,
			OB_GROUP_WRONG_FORMAT_ERROR

		}	OB_ERROR, FAR* POB_ERROR;


		//****************************************************************************
		// Error access macros
		//****************************************************************************

#define ob_get_error(obthis)				((OB_ERROR) ((obthis)->ErrorCode))
#define ob_set_error(obthis,errcode)	((obthis)->ErrorCode=(UINT) (errcode))

#ifdef __cplusplus
	}                       /* End of extern "C" { */
#endif	/* __cplusplus */


#endif // OBERROR_H

// DOINC popped back into header 'obconst.h'
#endif
#ifndef OBALLOC_H
// ***** DOINC including oballoc.h *****
// $RCSfile: oballoc.h $;$Revision: 4.18 $
//**************************************************************************
//
//                            Copyright 1990 
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :	oballoc.h	
//
//    Author   :	Jim Kosko
//
//    Purpose  : 	PB Object manager allocator
//
//****************************************************************************

#ifndef OBALLOC_H
#define OBALLOC_H

//****************************************************************************
// Includes
//****************************************************************************

#ifndef OSPASCAL_H
// ***** DOINC including ospascal.h *****
	// DOINC skipping duplicate include
#endif
#ifndef PBSTG_H
// ***** DOINC including pbstg.h *****
	// DOINC skipping duplicate include
#endif
#ifndef SHBINARY_H
// ***** DOINC including shbinary.h *****
//**************************************************************************
//
//                            Copyright 1991 
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :	shbinary.h	
//
//    Author   :	Jim Kosko
//
//    Purpose  : 	Public Definitions for binary data type 
//
//****************************************************************************

#ifndef SHBINARY_H
#define SHBINARY_H

//****************************************************************************
// Includes
//****************************************************************************

// ***** DOINC including ospascal.h *****
	// DOINC skipping duplicate include
// ***** DOINC including pbstg.h *****
	// DOINC skipping duplicate include

//****************************************************************************
// Assume C declarations for C++
//****************************************************************************

#ifdef __cplusplus
	extern "C" {
#endif	/* __cplusplus */

		//****************************************************************************
		// Binary data type structure
		//****************************************************************************

		typedef struct shBinary
		{
			ULONG			len;
			BYTE			data[1];					 // Pointed to by PSH_BINARY_DATA

		} SH_BINARY, HUGEPTR* PSH_BINARY;

		typedef BYTE HUGEPTR* PSH_BINARY_DATA;

		//****************************************************************************
		// Binary type manipulation macros
		//****************************************************************************

#define shBinaryAlloc(stgthis,subpool,length,bin_val)	 							\
		(																							\
		(bin_val) = (PSH_BINARY) pbstg_alloc (stgthis, 						 		\
										sizeof(SH_BINARY)+(length), subpool), 			\
		(bin_val)->len = length,																\
		(bin_val)																					\
		)

#define shBinaryReAlloc(stgthis,subpool,length,bin_val)							\
		(																							\
		(bin_val) = (PSH_BINARY) pbstg_realloc (stgthis, (bin_val),			 		\
										sizeof(SH_BINARY)+(length), subpool),			\
		(bin_val)->len = length,																\
		(bin_val)																					\
		)

#define shBinaryFree(stgthis,binval)				  									\
		pbstg_free (stgthis, binval)

#define shGetBinaryLength(stgthis,binval)	  											\
		((binval)->len)

#define shGetBinaryStructLength(stgthis,binval)				 						\
		(sizeof(SH_BINARY) + shGetBinaryLength(stgthis,binval))

#define shGetBinaryData(stgthis,binval,loc)		  	  								\
		   ( ((PSH_BINARY_DATA) ((binval)->data)) + (loc) )

#define shGetBinaryContainingData(stgthis,bindata)	  								\
		((PSH_BINARY) (((PSH_BINARY_DATA) (bindata)) - sizeof(ULONG)))

#define shCopyToBinary(stgthis,binval,loc,newdata,length)  						\
		(pbstg_huge_memcpy (shGetBinaryData (stgthis, binval, loc), 			\
									newdata,	length))

#define shCopyFromBinary(stgthis,buffer,binval,loc,length)	 			 		\
		(pbstg_huge_memcpy (buffer,					  									\
								shGetBinaryData (stgthis, binval, loc), length))

#define shBinaryFill(stgthis,binval,loc,len,chr)		  							\
		(pbstg_huge_memset (shGetBinaryData(stgthis,binval,loc), chr, len))

#define shBinaryCmp(stgthis,bin1,loc1,stream,len)	 								\
		(pbstg_huge_memcmp (shGetBinaryData(stgthis,bin1,loc1), stream, len))

#define shBinaryEquiv(stgthis,bin1,bin2)												\
		(shGetBinaryLength(stgthis,bin1)==shGetBinaryLength(stgthis,bin2) && \
		 shBinaryCmp (stgthis, bin1, 0,													\
		 				  	shGetBinaryData (stgthis, bin2, 0),							\
		 					shGetBinaryLength (stgthis, bin2) ) == 0  					\
		)

#ifdef __cplusplus
	}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif // SHBINARY_H
// DOINC popped back into header 'oballoc.h'
#endif
#ifndef OBTHIS_H
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBDEFINE_H
// ***** DOINC including obdefine.h *****
	// DOINC skipping duplicate include
#endif

//****************************************************************************
// Prototypes
//****************************************************************************

#ifdef _PSDBG

#define obAlloc(obthis, len, subpool) \
	(SH_DBG_RUNNING ((obthis)->dbgthis) ? \
		obAllocDebug (obthis, pbstg_alloc ((obthis)->stgthis, (len), (subpool)), (len), (subpool)) : \
		pbstg_alloc ((obthis)->stgthis, (len), (subpool)))

#define obAllocLval(obthis, len) \
	(SH_DBG_RUNNING ((obthis)->dbgthis) ? \
		obAllocDebug (obthis, pbstg_alloc ((obthis)->stgthis, (len), (obthis)->lvalue_subpool), (len), (obthis)->lvalue_subpool) : \
		pbstg_alloc ((obthis)->stgthis, (len), (obthis)->lvalue_subpool))

#define obAllocDec(obthis, subpool) \
	(SH_DBG_RUNNING ((obthis)->dbgthis) ? \
		(PSH_DEC) obAllocDebug (obthis, shAllocDec ((obthis)->stgthis, (subpool)), (sizeof(SH_DEC)), (subpool)) : \
		shAllocDec ((obthis)->stgthis, (subpool)))

#define obAllo_tstring(obthis, len, subpool) \
	(SH_DBG_RUNNING ((obthis)->dbgthis) ? \
		(LPTSTR) obAllocDebug (obthis, (LPTSTR)pbstg_stralloc ((obthis)->stgthis, (ULONG)(len), (subpool)), (len), (subpool)) : \
		(LPTSTR)pbstg_stralloc ((obthis)->stgthis, (ULONG)(len), (subpool)))

#define obAllo_tstringLval(obthis, len) \
	(SH_DBG_RUNNING ((obthis)->dbgthis) ? \
		(LPTSTR) obAllocDebug (obthis, (LPTSTR)pbstg_stralloc ((obthis)->stgthis, (ULONG)(len), (obthis)->lvalue_subpool), (len), (obthis)->lvalue_subpool) : \
		(LPTSTR)pbstg_stralloc ((obthis)->stgthis, (ULONG)(len), (obthis)->lvalue_subpool))

#define obFree(obthis, addr) \
	(SH_DBG_RUNNING ((obthis)->dbgthis) ? \
		(obFreeDebug (obthis, addr), pbstg_free ((obthis)->stgthis, addr)) : \
		pbstg_free ((obthis)->stgthis, addr))

#else

#define obAlloc(obthis, len, subpool) \
	pbstg_alloc ((obthis)->stgthis, (len), (subpool))

#define obAllocLval(obthis, len) \
	pbstg_alloc ((obthis)->stgthis, (len), (obthis)->lvalue_subpool)

#define obAllocDec(obthis, subpool) \
	shAllocDec ((obthis)->stgthis, (subpool))

#define obAllo_tstring(obthis, len, subpool) \
	(LPTSTR)pbstg_stralloc ((obthis)->stgthis, (ULONG)(len), (subpool))

#define obAllo_tstringLval(obthis, len) \
	(LPTSTR)pbstg_stralloc ((obthis)->stgthis, (len), (obthis)->lvalue_subpool)

#define obFree(obthis, addr) \
		pbstg_free ((obthis)->stgthis, addr)

#endif

#define obStringLen(pstr) \
	pbstg_strlen(pstr)

//****************************************************************************
// Assume C declarations for C++
//****************************************************************************
#ifdef __cplusplus
	extern "C" {
#endif	/* __cplusplus */

		PBWINAPI(PVOID, obAllocDebug)
			(
				POB_THIS 					obthis,
				PVOID						addr,
				ULONG 						len,
				OB_SUBPOOL 					subpool
				);

		PBWINAPI(VOID, obFreeDebug)
			(
				POB_THIS					obthis,
				PVOID						addr
				);

		VOID 						obFreeSubPool
		(
			POB_THIS 					obthis,
			OB_SUBPOOL 					subpool
		);

		PVOID 						obReAlloc
		(
			POB_THIS 					obthis,
			PVOID 						old_addr,
			ULONG 						len,
			OB_SUBPOOL					subpool
		);

		PVOID 						obdbgReAlloc
		(
			POB_THIS 					obthis,
			PVOID 						old_addr,
			ULONG 						len,
			OB_SUBPOOL					subpool,
			LPTSTR						file,
			LONG						line
		);

		PSH_BINARY 					obAllocBlob
		(
			POB_THIS					obthis,
			ULONG						len,
			OB_SUBPOOL					subpool
		);

		PSH_BINARY					obReAllocBlob
		(
			POB_THIS					obthis,
			PSH_BINARY					blob,
			ULONG						len,
			OB_SUBPOOL					subpool
		);

		OB_SUBPOOL 					obGetNextSubPool
		(
			POB_THIS 					obthis
		);

		LPTSTR 						obStrDup
		(
			POB_THIS 					obthis,
			LPTSTR 						string,
			OB_SUBPOOL 					pool
		);

		LPTSTR 						obStrDup2
		(
			LPTSTR	   				string
		);

		LPTSTR 						obdbgStrDup
		(
			POB_THIS 					obthis,
			LPTSTR 						string,
			OB_SUBPOOL 					pool,
			LPTSTR						file,
			LONG						ling
		);

		PSH_BINARY 					obBlobDup
		(
			POB_THIS 					obthis,
			PSH_BINARY					blob,
			OB_SUBPOOL 					pool
		);

		//****************************************************************************
		// End of extern "C" block
		//****************************************************************************

#ifdef __cplusplus
	}                       /* End of extern "C" { */
#endif	/* __cplusplus */

// we are not currently enabling seperate tracking for blobs.
#ifdef PB_ENABLE_ALLOCATION_TRACKING
#define obStrDup( obthis, string, pool ) 		obdbgStrDup( obthis, string, pool, __FILE__, __LINE__ )
#define obReAlloc( obthis, old_addr, len, pool ) 	obdbgReAlloc( obthis, old_addr, len, pool, __FILE__, __LINE__ )
#endif

#endif // OBALLOC_H
// DOINC popped back into header 'obconst.h'
#endif

//****************************************************************************
// Constants
//****************************************************************************

// For now conpool max is 64K even though OB_CONST_REF is now a long.
// This avoids having to deal with huge pointer arithmetic
// 6/4/98 (TJC) since 16 bit is dead, I upped the conpool max.
#define CONPOOL_MAX	   			ULONG_MAX
#define OB_CONPOOL_MAP_INCR		20


//****************************************************************************
// Conpool map types
//****************************************************************************
// IMPORTANT NOTE: If you add a new one, make sure you update the ob_conpool_align_factor array in obconst.cpp!!!
	typedef enum
	{
		OB_CONPOOL_STRING,
		OB_CONPOOL_SHORT,
		OB_CONPOOL_LONG,
		OB_CONPOOL_FLOAT,
		OB_CONPOOL_DOUBLE,
		OB_CONPOOL_DEC,
		OB_CONPOOL_TIME,
		OB_CONPOOL_FUNCARG,
		OB_CONPOOL_ARRAYDEF,
		OB_CONPOOL_DBSTMT,
		OB_CONPOOL_DBOUTVAR,
		OB_CONPOOL_PCODE,
		OB_CONPOOL_FLDNAMEID,
		OB_CONPOOL_ROUTNAMEID,
		OB_CONPOOL_OBINFO,
		OB_CONPOOL_OBDATA,
		OB_CONPOOL_FUNCTMPLTARG,
		OB_CONPOOL_FUNCTMPLT,
		OB_CONPOOL_CLSNAMEID,
		OB_CONPOOL_ARRAYDATA,
		OB_CONPOOL_DBVARS,
		OB_CONPOOL_DBSTMT_INDIRECT,
		OB_CONPOOL_CLASSID,
		OB_CONPOOL_LONGLONG

	} OB_CONPOOL_ITEM_TYPE;

	//****************************************************************************
	// Object Manager Constant pool
	//****************************************************************************
	//****************************************************************************
	// conpool map was changed for SPARC alignment.
	//****************************************************************************

	typedef struct conpool_map
	{
		OB_CONST_REF		offset;
		SHORT				item_type;
		USHORT				no_items;

	} OB_CONPOOL_MAP, FAR* POB_CONPOOL_MAP;

	typedef struct old_conpool_map
	{
		SHORT				item_type;
		OB_CONST_REF		offset;
		USHORT				no_items;

	} OB_OLD_CONPOOL_MAP, FAR* POB_OLD_CONPOOL_MAP;

	typedef struct perm_conpool
	{
		ULONG			   	pool_size;		// Current conpool size.
		ULONG				map_size;		// Current conpool map size.

	} OB_PERM_CONPOOL;


	typedef struct temp_conpool
	{
		LPBYTE			   	pool;	   		// Pointer to memory pool;
		POB_CONPOOL_MAP	   	map;			// Pointer to conpool map
		UINT			   	alloc_incr;		// Allocation increment.
		ULONG			   	next_free; 		// Next free constant slot.
		ULONG				next_maploc;	// Next free map slot.
		OB_SUBPOOL		   	subpool;   		// Memory subpool for conpool

#ifdef PBOS_UNIX
		LPBYTE              unix_pool;
#endif

	} OB_TEMP_CONPOOL;

	typedef struct ob_conpool
	{
		OB_PERM_CONPOOL	   	ps;
		OB_TEMP_CONPOOL	   	ts;

		// Hash table of the text strings that are in the constant pool. 
		// This is used at compile time to eliminate duplicate strings in the pool.  
		// Every occurence of the same string will be represented only once 
		// (the hash data entry will contain the actual contanst pool entry.)
		PSHHASH             strings_in_pool;

	} OB_CONPOOL, FAR* POB_CONPOOL;

	typedef struct ob_con_string_node
	{
		OB_CONST_REF	      name;    // constant string entry in con pool
	} OB_CON_STRING_NODE, FAR* POB_CON_STRING_NODE;

	//****************************************************************************
	// Level and id masks and shifts
	//****************************************************************************

#define CONST_ID_MASK				0x7FFFFFFF
#define CONST_LEVEL_MASK			0x80000000

#define CONST_ID_SHIFT				0
#define CONST_LEVEL_SHIFT			31

//****************************************************************************
// Low-level structure access macros.
//****************************************************************************

#define ob_get_const_id(cid)   								\
	(((cid) & CONST_ID_MASK) >> CONST_ID_SHIFT)

#define ob_set_const_id(cid,new_id)  	 					\
	((cid) = (((ULONG) (new_id)) << CONST_ID_SHIFT) | 		\
			 ((cid) & ~CONST_ID_MASK))

#define ob_get_const_level(cid)   							\
	((UINT) (((cid) & CONST_LEVEL_MASK) >> CONST_LEVEL_SHIFT))

#define ob_set_const_level(cid,new_level)   				\
	((cid) = (((ULONG) (new_level)) << CONST_LEVEL_SHIFT) | \
			 ((cid) & ~CONST_LEVEL_MASK))

//****************************************************************************
// Constant pool macros
//****************************************************************************
#ifndef PBOS_UNIX
#define ob_get_const_data(obthis,conpool,const_loc)			\
	((PVOID) ( (conpool)->ts.pool + ob_get_const_id ((ULONG) (const_loc)) ) )
#else
#define UNIX_POOL_RADIX 2
#define ob_get_const_data(obthis,conpool,const_loc)			\
	((PVOID) ( (conpool)->ts.unix_pool + ((ob_get_const_id ((ULONG) (const_loc)))*UNIX_POOL_RADIX) ) )
#endif
//****************************************************************************
// Constant pool function prototypes
//****************************************************************************
#ifdef    __cplusplus
	extern "C" {
#endif    /* __cplusplus */

		POB_CONPOOL 	 				ob_init_conpool
		(
			POB_THIS 	 			obthis,
			UINT 		 			size_incr,
			OB_SUBPOOL 	 			subpool
		);

		VOID			 				ob_del_conpool
		(
			POB_THIS 	 			obthis,
			POB_CONPOOL  			conpool
		);

		PBWINAPI(OB_CONST_REF, ob_add_const_data)
			(
				POB_THIS 	 			obthis,
				POB_CONPOOL  			conpool,
				PVOID 		 			data,
				OB_CONPOOL_ITEM_TYPE	item_type,
				UINT					nitems,
				ULONG 		 			len
				);

		PVOID 			 				ob_extract_const_data
		(
			POB_THIS 	 			obthis,
			POB_CONPOOL  			conpool,
			OB_CONST_REF 			loc
		);

		VOID 			 				ob_del_const
		(
			POB_THIS 	 			obthis,
			POB_CONPOOL  			conpool,
			OB_CONST_REF 			const_loc
		);

		OB_ERROR 		 				ob_const_write
		(
			POB_THIS 	 			obthis,
			POB_CONPOOL  			conpool
		);

		POB_CONPOOL 	 				ob_const_read
		(
			POB_THIS 	 			obthis,
			UINT 		 			size_incr,
			OB_SUBPOOL 	 			subpool,
			BOOL					flip_mapping
		);

		POB_CONPOOL 	 				ob_const_read_chg
		(
			POB_THIS 	 			obthis,
			UINT 		 			size_incr,
			OB_SUBPOOL 	 			subpool
		);

		POB_CONPOOL 					ob_old_const_read
		(
			POB_THIS 				obthis,
			UINT 	   				alloc_incr,
			OB_SUBPOOL 				subpool
		);

		//***************************************************************************
		//    Name    :  parse_string_value_hash()
		//    Synopsis:  Return the string value for the hash data node
		//    Returns :  LPTSTR to the string in the constant pool
		//***************************************************************************
		PBWINAPI(LPTSTR, parse_stringvalue_hash)(PVOID data);

		//***************************************************************************
		//    Name    :  obconpool_stringvalue_del
		//    Synopsis:  callback function for deleting hashed string values
		//    Returns :  keep tranversing = yes
		//***************************************************************************
		PBWINAPI(BOOL, obconpool_stringvalue_del)(PVOID, PVOID);

#ifdef    __cplusplus
	}	// extern "C" {
#endif    /* __cplusplus */

#define ob_get_conpool_map_item_type(obthis,map_entry)		\
	((OB_CONPOOL_ITEM_TYPE) (map_entry)->item_type)

#define ob_get_conpool_map_item_offset(obthis,map_entry)	\
	((map_entry)->offset)

#endif // OBCONST_H
// DOINC popped back into header 'obtypdef.h'
#endif
#ifndef OBSYMTAB_H
// ***** DOINC including obsymtab.h *****
// $RCSfile: obsymtab.h $;$Revision: 4.5 $
//**************************************************************************
//
//                            Copyright 1989 
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :	obsymtab.h	
//
//    Author   :	Jim Kosko
//
//    Purpose  : 	Symbol table structure for PB object manager.
//
//****************************************************************************

#ifndef OBSYMTAB_H
#define OBSYMTAB_H

//****************************************************************************
// Includes
//****************************************************************************

#ifndef OSPASCAL_H
// ***** DOINC including ospascal.h *****
	// DOINC skipping duplicate include
#endif
#ifndef PBSTG_H
// ***** DOINC including pbstg.h *****
	// DOINC skipping duplicate include
#endif
#ifndef SHHASH_H
// ***** DOINC including shhash.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBTHIS_H
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBCONST_H
// ***** DOINC including obconst.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBALLOC_H
// ***** DOINC including oballoc.h *****
	// DOINC skipping duplicate include
#endif

//****************************************************************************
// Symbol table node structure
//****************************************************************************

	typedef struct ob_sym_node
	{
		OB_SYM_ID		sym_id;
		OB_CONST_REF	name;

	} OB_SYM_NODE;

#define POB_SYM_NODE		OB_SYM_NODE FAR *

	//****************************************************************************
	// Object Manager symbol table.
	//****************************************************************************

	typedef struct ob_symtab
	{
		PSHHASH		table;					// Pointer to actual table.
		INT			no_slots;				// Number of slots in table.
		INT			curr_id;					// Current lookup id for symbol table.
		POB_CONPOOL conpool;             // Symbol table conpool.
		OB_SUBPOOL	subpool;					// Memory subpool for symbol table.

	} OB_SYMTAB;

#define POB_SYMTAB	OB_SYMTAB FAR *

#ifdef    __cplusplus
	extern "C" {
#endif    /* __cplusplus */

		//****************************************************************************
		// Symbol table function prototypes
		//****************************************************************************

#define SYMTAB_NO_ERROR				0
#define SYMTAB_DUP_SYMBOL			1
#define SYMTAB_CONPOOL_FILLED		2
#define SYMTAB_NOT_FOUND			3

		POB_SYMTAB     				ob_init_symtab
		(
			POB_THIS 				obthis,
			INT 						no_slots,
			POB_CONPOOL 			pool,
			OB_SUBPOOL 				subpool
		);

		VOID		 						ob_del_symtab
		(
			POB_THIS 				obthis,
			POB_SYMTAB 				symtab
		);

		POB_SYM_NODE 					ob_sym_declare
		(
			POB_THIS 				obthis,
			POB_SYMTAB 				symtab,
			LPTSTR 					symname,
			PINT						error
		);

		POB_SYM_NODE 					ob_dup_sym_declare
		(
			POB_THIS 				obthis,
			POB_SYMTAB 				symtab,
			LPTSTR 					symname,
			PINT						error
		);

		OB_SYM_ID 						ob_sym_reference
		(
			POB_THIS 				obthis,
			POB_SYMTAB 				symtab,
			LPTSTR 					symname
		);

		OB_SYM_ID 						ob_sym_next_reference
		(
			POB_THIS 				obthis,
			POB_SYMTAB 				symtab,
			LPTSTR 					symname
		);

		VOID 								ob_sym_delete
		(
			POB_THIS 				obthis,
			POB_SYMTAB 				symtab,
			LPTSTR 					sym_name
		);

		VOID 								ob_sym_delete_dup
		(
			POB_THIS 				obthis,
			POB_SYMTAB 				symtab,
			LPTSTR 					sym_name,
			OB_SYM_ID				sym_id
		);

		VOID 								ob_sym_delete_current
		(
			POB_THIS 				obthis,
			POB_SYMTAB 				symtab
		);

		POB_SYM_NODE 					ob_sym_rename
		(
			POB_THIS 				obthis,
			POB_SYMTAB 				symtab,
			LPTSTR 					old_name,
			LPTSTR 					newname,
			PINT						error
		);

		VOID 								ob_sym_load
		(
			POB_THIS 				obthis,
			POB_SYMTAB 				symtab,
			OB_CONST_REF 			nameref,
			OB_SYM_ID 				sym_id
		);

#ifdef    __cplusplus
	}	// extern "C" {
#endif    /* __cplusplus */


#endif // OBSYMTAB_H
// DOINC popped back into header 'obtypdef.h'
#endif
#ifndef OBLOOKUP_H
// ***** DOINC including oblookup.h *****
// $RCSfile: oblookup.h $;$Revision: 4.18 $
//**************************************************************************
//
//                            Copyright 1989 
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :	oblookup.h	
//
//    Author   :	Jim Kosko
//
//    Purpose  : 	Lookup table data structures for PB object manager.
//
//****************************************************************************

#ifndef OBLOOKUP_H
#define OBLOOKUP_H

//****************************************************************************
// Includes
//****************************************************************************

#ifndef OSPASCAL_H
// ***** DOINC including ospascal.h *****
	// DOINC skipping duplicate include
#endif
#ifndef PBSTG_H
// ***** DOINC including pbstg.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBTHIS_H
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBDEFINE_H
// ***** DOINC including obdefine.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBCONST_H
// ***** DOINC including obconst.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBSYMTAB_H
// ***** DOINC including obsymtab.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBDATA_H
// ***** DOINC including obdata.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBERROR_H
// ***** DOINC including oberror.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBALLOC_H
// ***** DOINC including oballoc.h *****
	// DOINC skipping duplicate include
#endif	

//****************************************************************************
// Data flag values
//****************************************************************************

	typedef enum
	{
		OB_NOT_READONLY = 0,
		OB_IS_READONLY = 1

	} OB_LOOKUP_READONLY_VAL;

	typedef enum
	{
		OB_NOT_INDIRECT = 0,
		OB_IS_INDIRECT = 1

	} OB_LOOKUP_INDIRECT_VAL;

	typedef enum
	{
		OB_NOT_CONSTANT = 0,
		OB_IS_CONSTANT = 1

	} OB_LOOKUP_CONSTANT_VAL;

	typedef enum
	{
		OB_NOT_DUPFIELD = 0,
		OB_IS_DUPFIELD = 1

	} OB_LOOKUP_DUPFIELD_VAL;

	//****************************************************************************
	// Data flags masks and shifts
	//****************************************************************************

#define LOOKUP_READONLY_MASK		0x0001				// 1 bit 
#define LOOKUP_INDIRECT_MASK		0x0002				// 1 bit
#define LOOKUP_CONSTANT_MASK		0x0004				// 1 bit
#define LOOKUP_DUPFIELD_MASK		0x0008				// 1 bit
#define LOOKUP_RD_ACCESS_MASK		0x0030				// 2 bits
#define LOOKUP_WR_ACCESS_MASK		0x00C0				// 2 bits

#define LOOKUP_READONLY_SHIFT		0					
#define LOOKUP_INDIRECT_SHIFT		1
#define LOOKUP_CONSTANT_SHIFT		2					
#define LOOKUP_DUPFIELD_SHIFT		3	
#define LOOKUP_RD_ACCESS_SHIFT		4
#define LOOKUP_WR_ACCESS_SHIFT		6

//****************************************************************************
// Object lookup entry structure.
//****************************************************************************

	typedef USHORT			OB_LOOKUP_INFO, FAR* POB_LOOKUP_INFO;

	typedef struct ob_lookup_entry
	{
		OB_LOOKUP_INFO		flags;					// Info flags
		SHORT				padding;
		OB_CONST_REF		sym_info;				// Extended symbol information
													// in Conpool;
		OB_CONST_REF		name;	 				// Name of lookup object
		OB_DATA				data;	 				// Entry data. (Nested struct)

	} OB_LOOKUP_ENTRY, FAR* POB_LOOKUP_ENTRY;

	//****************************************************************************
	// Object lookup table structure.
	//****************************************************************************

	typedef struct perm_lookup
	{
		USHORT	   			alloc_size;			// Current allocation size.

	} OB_PERM_LOOKUP;

	typedef struct temp_lookup
	{
		POB_LOOKUP_ENTRY 	table;				// Pointer to actual table.
		UINT			 	alloc_incr;			// Allocation increment.
		UINT			 	no_slots;			// Number of slots in table.
		UINT			 	slot_incr;			// Slots increment
		UINT			 	no_entries;			// Current number of entries.
		POB_SYMTAB		 	symtab;				// Associated symbol table
		POB_CONPOOL			conpool;	   		// Associated constant pool
		OB_SUBPOOL	  		subpool;	   		// Memory subpool for lookup table

	} OB_TEMP_LOOKUP;

	typedef struct ob_lookup_table
	{
		OB_PERM_LOOKUP	   	ps;
		OB_TEMP_LOOKUP	   	ts;

	} OB_LOOKUP, FAR* POB_LOOKUP;

	//****************************************************************************
	// Macro to set all flags in OB_LOOKUP_INFO
	//****************************************************************************

#define ob_build_lookup_info(info,roflag,indflag,cnstflag)				\
		((info) 		  = (OB_LOOKUP_INFO) (							\
							 ((roflag) << LOOKUP_READONLY_SHIFT)	 |	\
							 ((indflag) << LOOKUP_INDIRECT_SHIFT)	 |	\
							 ((cnstflag) << LOOKUP_CONSTANT_SHIFT)	 |	\
							 (0 << LOOKUP_DUPFIELD_SHIFT)	 		 |	\
							 (0 << LOOKUP_RD_ACCESS_SHIFT)	 		 |	\
							 (0 << LOOKUP_WR_ACCESS_SHIFT))	 			\
		)

//****************************************************************************
// Lookup access macros for use when you already have an OB_LOOKUP_INFO
//****************************************************************************

#define ob_lookup_info_is_readonly(lookup_info)   							\
	((BOOL)(((OB_LOOKUP_READONLY_VAL) (((lookup_info) & 					\
	LOOKUP_READONLY_MASK) >> LOOKUP_READONLY_SHIFT)) == OB_IS_READONLY))

#define ob_lookup_info_is_indirect(lookup_info)   							\
	((BOOL)(((OB_LOOKUP_INDIRECT_VAL) (((lookup_info) & 					\
	LOOKUP_INDIRECT_MASK) >> LOOKUP_INDIRECT_SHIFT)) == OB_IS_INDIRECT))

#define ob_lookup_info_is_constant(lookup_info)   							\
	((BOOL)(((OB_LOOKUP_CONSTANT_VAL) (((lookup_info) & 					\
	LOOKUP_CONSTANT_MASK) >> LOOKUP_CONSTANT_SHIFT)) == OB_IS_CONSTANT))

#define ob_lookup_info_is_dupfield(lookup_info)   							\
	((BOOL)(((OB_LOOKUP_DUPFIELD_VAL) (((lookup_info) & 					\
	LOOKUP_DUPFIELD_MASK) >> LOOKUP_DUPFIELD_SHIFT)) == OB_IS_DUPFIELD))

#define ob_lookup_info_read_access(lookup_info)   							\
	((OB_MEMBER_ACCESS) (((lookup_info) & 									\
						  LOOKUP_RD_ACCESS_MASK) >> LOOKUP_RD_ACCESS_SHIFT))

#define ob_lookup_info_is_read_access_public(lookup_info)   				\
	((BOOL)(((OB_MEMBER_ACCESS) (((lookup_info) & 							\
	LOOKUP_RD_ACCESS_MASK) >> LOOKUP_RD_ACCESS_SHIFT)) == OB_PUBLIC_MEMBER))

#define ob_lookup_info_is_read_access_protected(lookup_info)   				\
	((BOOL)(((OB_MEMBER_ACCESS) (((lookup_info) & 							\
	LOOKUP_RD_ACCESS_MASK) >> LOOKUP_RD_ACCESS_SHIFT)) == OB_PROTECTED_MEMBER))

#define ob_lookup_info_is_read_access_system(lookup_info)   				\
	((BOOL)(((OB_MEMBER_ACCESS) (((lookup_info) & 							\
	LOOKUP_RD_ACCESS_MASK) >> LOOKUP_RD_ACCESS_SHIFT)) == OB_SYSTEM_MEMBER))

#define ob_lookup_info_is_read_access_private(lookup_info)   				\
	((BOOL)(((OB_MEMBER_ACCESS) (((lookup_info) & 							\
	LOOKUP_RD_ACCESS_MASK) >> LOOKUP_RD_ACCESS_SHIFT)) == OB_PRIVATE_MEMBER))

#define ob_lookup_info_write_access(lookup_info)   							\
	((OB_MEMBER_ACCESS) (((lookup_info) & 									\
						  LOOKUP_WR_ACCESS_MASK) >> LOOKUP_WR_ACCESS_SHIFT))

#define ob_lookup_info_is_write_access_public(lookup_info)   				\
	((BOOL)(((OB_MEMBER_ACCESS) (((lookup_info) & 							\
	LOOKUP_WR_ACCESS_MASK) >> LOOKUP_WR_ACCESS_SHIFT)) == OB_PUBLIC_MEMBER))

#define ob_lookup_info_is_write_access_protected(lookup_info)   			\
	((BOOL)(((OB_MEMBER_ACCESS) (((lookup_info) & 							\
	LOOKUP_WR_ACCESS_MASK) >> LOOKUP_WR_ACCESS_SHIFT)) == OB_PROTECTED_MEMBER))

#define ob_lookup_info_is_write_access_system(lookup_info)   				\
	((BOOL)(((OB_MEMBER_ACCESS) (((lookup_info) & 							\
	LOOKUP_WR_ACCESS_MASK) >> LOOKUP_WR_ACCESS_SHIFT)) == OB_SYSTEM_MEMBER))

#define ob_lookup_info_is_write_access_private(lookup_info)   				\
	((BOOL)(((OB_MEMBER_ACCESS) (((lookup_info) & 							\
	LOOKUP_WR_ACCESS_MASK) >> LOOKUP_WR_ACCESS_SHIFT)) == OB_PRIVATE_MEMBER))


//****************************************************************************
// Lookup access macros for use when you already have a POB_LOOKUP_ENTRY
//****************************************************************************

#define ob_lookup_get_entry(lookup,obj_id) \
	(POB_LOOKUP_ENTRY)&((lookup)->ts.table[obj_id])

#define ob_lookup_entry_status(lookup_entry) \
	ob_get_data_status (&((lookup)->data))

#define ob_lookup_entry_name_ref(lookup_entry) \
	((lookup_entry)->name)

#define ob_lookup_entry_name(obthis,looksym,lookup_entry) \
	( (LPTSTR) ob_get_const_data (obthis, (looksym)->ts.conpool, \
				ob_lookup_entry_name_ref((lookup_entry))	\
					) \
	)


#define ob_lookup_entry_data(lookup_entry) \
	(&((lookup_entry)->data))

#define ob_lookup_entry_info(lookup_entry) \
	((lookup_entry)->info)

#define ob_lookup_entry_data_readonly(lookup_entry)   \
	((OB_LOOKUP_READONLY_VAL) ((ob_lookup_entry_info(lookup_entry) & \
	LOOKUP_READONLY_MASK) >> LOOKUP_READONLY_SHIFT))

#define ob_lookup_entry_data_indirect(lookup_entry)   \
	((OB_LOOKUP_INDIRECT_VAL) ((ob_lookup_entry_info(lookup_entry) & \
	LOOKUP_INDIRECT_MASK) >> LOOKUP_INDIRECT_SHIFT))

#define ob_lookup_entry_data_constant(lookup_entry)   \
	((OB_LOOKUP_CONSTANT_VAL) ((ob_lookup_entry_info(lookup_entry) & \
	LOOKUP_CONSTANT_MASK) >> LOOKUP_CONSTANT_SHIFT))

#define ob_lookup_entry_data_dupfield(lookup_entry)   \
	((OB_LOOKUP_DUPFIELD_VAL) ((ob_lookup_entry_info(lookup_entry) & \
	LOOKUP_DUPFIELD_MASK) >> LOOKUP_DUPFIELD_SHIFT))

#define ob_lookup_entry_data_read_access(lookup_entry)   \
	((OB_MEMBER_ACCESS) ((ob_lookup_entry_info(lookup_entry) & \
	LOOKUP_RD_ACCESS_MASK) >> LOOKUP_RD_ACCESS_SHIFT))

#define ob_lookup_entry_data_write_access(lookup_entry)   \
	((OB_MEMBER_ACCESS) ((ob_lookup_entry_info(lookup_entry) & \
	LOOKUP_WR_ACCESS_MASK) >> LOOKUP_WR_ACCESS_SHIFT))

#define ob_lookup_entry_data_id(lookup_entry) \
	ob_get_data_id (ob_lookup_entry_data(lookup_entry))

#define ob_lookup_entry_data_const(lookup_entry) \
	ob_get_data_const (ob_lookup_entry_data(lookup_entry))

#define ob_lookup_entry_is_data_declared(lookup_entry)		\
	ob_is_data_declared (ob_lookup_entry_data(lookup_entry))

#define ob_lookup_entry_data_type(lookup_entry)    \
	ob_get_data_type (ob_lookup_entry_data(lookup_entry))

#define ob_lookup_entry_data_info(lookup_entry)    \
	ob_get_data_flags (ob_lookup_entry_data(lookup_entry))

#define ob_lookup_entry_data_style(lookup_entry)    \
	ob_get_data_style (ob_lookup_entry_data(lookup_entry))

#define ob_lookup_entry_data_group(lookup_entry)    \
	ob_get_data_group (ob_lookup_entry_data(lookup_entry))

#define ob_lookup_entry_data_reftype(lookup_entry)    \
	ob_get_data_reftype (ob_lookup_entry_data(lookup_entry))

#define ob_lookup_entry_data_fieldtype(lookup_entry)    \
	ob_get_data_fieldtype (ob_lookup_entry_data(lookup_entry))

#define ob_lookup_entry_data_access(lookup_entry)    \
	ob_get_data_access (ob_lookup_entry_data(lookup_entry))

#define ob_lookup_entry_data_typeargs(lookup_entry)    \
	ob_get_data_typeargs (ob_lookup_entry_data(lookup_entry))

#define ob_lookup_entry_data_val(lookup_entry)  \
	ob_get_data_val (ob_lookup_entry_data(lookup_entry))


//****************************************************************************
// Lookup access macros
//****************************************************************************

#define ob_lookup_no_entries(lookup) \
	((lookup)->ts.no_entries)

#define ob_lookup_subpool(lookup) \
	((lookup)->ts.subpool)

#define ob_lookup_conpool(obthis,lookup) \
	((lookup)->ts.conpool)

#define ob_lookup_symtab(obthis,symtab) \
	((lookup)->ts.symtab)

#define ob_lookup_reference(obthis,lookup,name) \
	ob_sym_reference (obthis,(lookup)->ts.symtab,name)

#define ob_lookup_next_reference(obthis,lookup,name) \
	ob_sym_next_reference (obthis,(lookup)->ts.symtab,name)

#define ob_lookup_status(lookup,obj_id) \
	ob_get_data_status (&((lookup)->ts.table[obj_id].data))

#define ob_lookup_name_ref(lookup,obj_id) \
	((lookup)->ts.table[obj_id].name)

#define ob_lookup_syminfo_ref(lookup,obj_id) \
	((lookup)->ts.table[obj_id].sym_info)

#define ob_lookup_data(lookup,obj_id) \
	(&((lookup)->ts.table[obj_id].data))

#define ob_lookup_info(lookup,obj_id) \
	((lookup)->ts.table[obj_id].flags)

#define ob_lookup_data_readonly(lookup,obj_id)   \
	((OB_LOOKUP_READONLY_VAL) ((ob_lookup_info(lookup,obj_id) & \
	LOOKUP_READONLY_MASK) >> LOOKUP_READONLY_SHIFT))

#define ob_lookup_data_indirect(lookup,obj_id)   \
	((OB_LOOKUP_INDIRECT_VAL) ((ob_lookup_info(lookup,obj_id) & \
	LOOKUP_INDIRECT_MASK) >> LOOKUP_INDIRECT_SHIFT))

#define ob_lookup_data_constant(lookup,obj_id)   \
	((OB_LOOKUP_CONSTANT_VAL) ((ob_lookup_info(lookup,obj_id) & \
	LOOKUP_CONSTANT_MASK) >> LOOKUP_CONSTANT_SHIFT))

#define ob_lookup_data_dupfield(lookup,obj_id)   \
	((OB_LOOKUP_DUPFIELD_VAL) ((ob_lookup_info(lookup,obj_id) & \
	LOOKUP_DUPFIELD_MASK) >> LOOKUP_DUPFIELD_SHIFT))

#define ob_lookup_data_read_access(lookup,obj_id)   \
	((OB_MEMBER_ACCESS) ((ob_lookup_info(lookup,obj_id) & \
	LOOKUP_RD_ACCESS_MASK) >> LOOKUP_RD_ACCESS_SHIFT))

#define ob_lookup_data_write_access(lookup,obj_id)   \
	((OB_MEMBER_ACCESS) ((ob_lookup_info(lookup,obj_id) & \
	LOOKUP_WR_ACCESS_MASK) >> LOOKUP_WR_ACCESS_SHIFT))

#define ob_lookup_data_id(lookup,obj_id) \
	ob_get_data_id (ob_lookup_data(lookup,obj_id))

#define ob_lookup_data_const(lookup,obj_id) \
	ob_get_data_const (ob_lookup_data(lookup,obj_id))

#define ob_lookup_is_data_declared(lookup,obj_id)		\
	ob_is_data_declared (ob_lookup_data(lookup,obj_id))

#define ob_lookup_data_type(lookup,obj_id)    \
	ob_get_data_type (ob_lookup_data(lookup,obj_id))

#define ob_lookup_data_info(lookup,obj_id)    \
	ob_get_data_flags (ob_lookup_data(lookup,obj_id))

#define ob_lookup_data_style(lookup,obj_id)    \
	ob_get_data_style (ob_lookup_data(lookup,obj_id))

#define ob_lookup_data_group(lookup,obj_id)    \
	ob_get_data_group (ob_lookup_data(lookup,obj_id))

#define ob_lookup_data_reftype(lookup,obj_id)    \
	ob_get_data_reftype (ob_lookup_data(lookup,obj_id))

#define ob_lookup_data_fieldtype(lookup,obj_id)    \
	ob_get_data_fieldtype (ob_lookup_data(lookup,obj_id))

#define ob_lookup_data_access(lookup,obj_id)    \
	ob_get_data_access (ob_lookup_data(lookup,obj_id))

#define ob_lookup_data_typeargs(lookup,obj_id)    \
	ob_get_data_typeargs (ob_lookup_data(lookup,obj_id))

#define ob_lookup_data_val(lookup,obj_id)  \
	ob_get_data_val (ob_lookup_data(lookup,obj_id))


//****************************************************************************
// Lookup update macros
//****************************************************************************

#define ob_lookup_set_conpool(obthis,lookup,pool) \
	((lookup)->ts.conpool = pool)

#define ob_lookup_set_symtab(obthis,lookup,table) \
	((lookup)->ts.symtab = table)

#define ob_lookup_set_name_ref(lookup,obj_id,nam) \
	((lookup)->ts.table[obj_id].name = nam)

#define ob_lookup_set_syminfo_ref(lookup,obj_id,info) \
	((lookup)->ts.table[obj_id].sym_info = info)

#define ob_lookup_set_info(lookup,obj_id,inf) \
	((lookup)->ts.table[obj_id].flags = inf)

#define ob_lookup_set_info_dupfield(info,dupfield) \
	((info) = 														\
		(OB_LOOKUP_INFO) (((dupfield) << LOOKUP_DUPFIELD_SHIFT) | 	\
		((info) & ~LOOKUP_DUPFIELD_MASK)))

#define ob_lookup_set_info_read_access(info,ro_access) \
	((info) = 														\
		(OB_LOOKUP_INFO) (((ro_access) << LOOKUP_RD_ACCESS_SHIFT) | 	\
		((info) & ~LOOKUP_RD_ACCESS_MASK)))

#define ob_lookup_set_info_write_access(info,ro_access) \
	((info) = 														\
		(OB_LOOKUP_INFO) (((ro_access) << LOOKUP_WR_ACCESS_SHIFT) | 	\
		((info) & ~LOOKUP_WR_ACCESS_MASK)))

#define ob_lookup_set_status(lookup,obj_id,stat) \
	ob_set_data_status (ob_lookup_data(lookup,obj_id), stat)

#define ob_lookup_set_data_type(lookup,obj_id,type)    \
	ob_set_data_type (ob_lookup_data(lookup,obj_id), type)

#define ob_lookup_set_data_style(lookup,obj_id,styl)    \
	ob_set_data_style (ob_lookup_data(lookup,obj_id), styl)

#define ob_lookup_set_data_reftype(lookup,obj_id,reftype)    \
	ob_set_data_reftype (ob_lookup_data(lookup,obj_id), reftype)

#define ob_lookup_set_data_group(lookup,obj_id,grouping)    \
	ob_set_data_group (ob_lookup_data(lookup,obj_id), grouping)

#define ob_lookup_set_data_access(lookup,obj_id,access)    \
	ob_set_data_access (ob_lookup_data(lookup,obj_id), access)

#define ob_lookup_set_data_typeargs(lookup,obj_id,typeargs)    \
	ob_set_data_typeargs(ob_lookup_data(lookup,obj_id), typeargs)

#define ob_lookup_set_data_id(lookup,obj_id,idval,type) \
	ob_set_data_id (ob_lookup_data(lookup,obj_id), idval, type, FALSE) 

#define ob_lookup_set_data_const(lookup,obj_id,constval,type) \
	ob_set_data_const (ob_lookup_data(lookup,obj_id), constval, type, FALSE) 

#define ob_lookup_set_data_val(lookup,obj_id,val) \
	ob_set_data_val (ob_lookup_data(lookup,obj_id), val) 

#define ob_lookup_set_data_fieldtype(lookup,obj_id,fieldtype)    \
	ob_set_data_fieldtype (ob_lookup_data(lookup,obj_id), fieldtype)

#define ob_lookup_set_data_dupfield(lookup,obj_id,dupfield)   		\
	ob_lookup_set_info_dupfield(ob_lookup_info(lookup,obj_id),dupfield) 

//****************************************************************************
// Lookup function prototypes
//****************************************************************************

#ifdef    __cplusplus
	extern "C" {
#endif    /* __cplusplus */


		POB_LOOKUP 							ob_init_lookup
		(
			POB_THIS 					obthis,
			UINT 						slots,
			POB_CONPOOL 				conpool,
			POB_SYMTAB 					symtab,
			OB_SUBPOOL 					subpool
		);

		VOID		 						ob_del_lookup
		(
			POB_THIS 					obthis,
			POB_LOOKUP 					lookup
		);

		OB_SYM_ID 							ob_lookup_declare
		(
			POB_THIS 					obthis,
			POB_LOOKUP 					lookup,
			LPTSTR 						name,
			PINT						error
		);

		OB_SYM_ID 							ob_dup_lookup_declare
		(
			POB_THIS 					obthis,
			POB_LOOKUP 					lookup,
			LPTSTR 						name,
			PINT						error
		);

		VOID 								ob_lookup_freeslot
		(
			POB_LOOKUP 					lookup,
			OB_SYM_ID 					sym_id
		);

		INT		 							ob_lookup_rename
		(
			POB_THIS 					obthis,
			POB_LOOKUP 					lookup,
			LPTSTR 						oldname,
			LPTSTR 						newname
		);

		POB_LOOKUP							ob_lookup_copy
		(
			POB_THIS 					obthis,
			POB_LOOKUP 					lookup,
			OB_SUBPOOL 					pool
		);

		OB_ERROR	   						ob_lookup_write
		(
			POB_THIS 					obthis,
			POB_LOOKUP 					lookup
		);

		POB_LOOKUP							ob_lookup_read
		(
			POB_THIS 					obthis,
			UINT 						slots,
			OB_SUBPOOL 					subpool
		);

		POB_SYMTAB							ob_build_symtab
		(
			POB_THIS 					obthis,
			UINT 						noslots,
			POB_LOOKUP 					lookup,
			POB_CONPOOL 				conpool,
			OB_SUBPOOL 					subpool
		);

#ifdef    __cplusplus
	}	// extern "C" {
#endif    /* __cplusplus */


#endif // OBLOOKUP_H
// DOINC popped back into header 'obtypdef.h'
#endif
#ifndef OBLKSYM_H
// ***** DOINC including oblksym.h *****
// $RCSfile: oblksym.h $;$Revision: 4.18 $
//**************************************************************************
//
//                            Copyright 1989 
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :	oblksym.h	
//
//    Author   :	Jim Kosko
//
//    Purpose  : 	Definitions for PB lookup symbol table
//
//****************************************************************************

#ifndef OBLKSYM_H
#define OBLKSYM_H

//****************************************************************************
// Includes
//****************************************************************************

#ifndef OBLOOKUP_H
// ***** DOINC including oblookup.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBCONST_H
// ***** DOINC including obconst.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBSYMTAB_H
// ***** DOINC including obsymtab.h *****
	// DOINC skipping duplicate include
#endif

//****************************************************************************
// Module symbol table structure 
//****************************************************************************

	typedef struct perm_looksym
	{
		USHORT				lookup_slots;
		USHORT				conpool_size;
		USHORT				symtab_slots;

	} OB_PERM_LOOKSYM, FAR* POB_PERM_LOOKSYM;

	typedef struct temp_looksym
	{
		POB_LOOKUP			lookup;
		POB_CONPOOL			conpool;
		POB_SYMTAB			symtab;

	} OB_TEMP_LOOKSYM, FAR* POB_TEMP_LOOKSYM;

	typedef struct ob_look_symtab
	{
		OB_PERM_LOOKSYM ps;
		SHORT			padding;
		OB_TEMP_LOOKSYM ts;

	} OB_LOOK_SYMTAB, FAR* POB_LOOK_SYMTAB;

	//****************************************************************************
	// Access Macros
	//****************************************************************************

#define ob_looksym_conpool(looksym) \
   ((looksym)->ts.conpool)

#define ob_looksym_lookup(looksym) \
	((looksym)->ts.lookup)

#define ob_set_looksym_lookup(looksym,lkup) \
	((looksym)->ts.lookup = (lkup))

#define ob_looksym_get_id(looksym,symid) \
	ob_lookup_data_id ((looksym)->ts.lookup, symid)

#define ob_looksym_get_const(looksym,symid) \
	ob_lookup_data_const ((looksym)->ts.lookup, symid)

#define ob_looksym_get_info(looksym,symid) \
	ob_lookup_info ((looksym)->ts.lookup, symid)

#define ob_looksym_val(looksym,symid) \
	ob_lookup_data_val ((looksym)->ts.lookup, symid)

#define ob_looksym_no_entries(looksym) \
	ob_lookup_no_entries((looksym)->ts.lookup)

#define ob_is_looksym_declared(looksym,symid) \
	ob_lookup_is_data_declared ((looksym)->ts.lookup, symid)

#define ob_looksym_readonly(looksym,symid) \
	ob_lookup_data_readonly ((looksym)->ts.lookup, symid)

#define ob_looksym_indirect(looksym,symid) \
	ob_lookup_data_indirect ((looksym)->ts.lookup, symid)

#define ob_looksym_constant(looksym,symid) \
	ob_lookup_data_constant ((looksym)->ts.lookup, symid)

#define ob_looksym_dupfield(looksym,symid) \
	ob_lookup_data_dupfield ((looksym)->ts.lookup, symid)

#define ob_looksym_read_access(looksym,symid) \
	ob_lookup_data_read_access ((looksym)->ts.lookup, symid)

#define ob_looksym_write_access(looksym,symid) \
	ob_lookup_data_write_access ((looksym)->ts.lookup, symid)

#define ob_looksym_type(looksym,symid) \
	ob_lookup_data_type ((looksym)->ts.lookup, symid)

#define ob_looksym_info(looksym,symid) \
	ob_lookup_data_info ((looksym)->ts.lookup, symid)

#define ob_looksym_style(looksym,symid) \
	ob_lookup_data_style ((looksym)->ts.lookup, symid)

#define ob_looksym_grouping(looksym,symid) \
	ob_lookup_data_group ((looksym)->ts.lookup, symid)

#define ob_looksym_reftype(looksym,symid) \
	ob_lookup_data_reftype ((looksym)->ts.lookup, symid)

#define ob_looksym_fieldtype(looksym,symid) \
	ob_lookup_data_fieldtype ((looksym)->ts.lookup, symid)

#define ob_looksym_access(looksym,symid) \
	ob_lookup_data_access ((looksym)->ts.lookup, symid)

#define ob_looksym_typeargs(looksym,symid) \
	ob_lookup_data_typeargs ((looksym)->ts.lookup, symid)

#define ob_looksym_status(looksym,symid) \
	ob_lookup_status ((looksym)->ts.lookup, symid)

#define ob_looksym_name_ref(looksym,symid) \
	ob_lookup_name_ref ((looksym)->ts.lookup, symid)

#define ob_looksym_syminfo_ref(looksym,symid) \
	ob_lookup_syminfo_ref ((looksym)->ts.lookup, symid)

#define ob_looksym_name(obthis,looksym,symid) \
	( (LPTSTR) ob_get_const_data (obthis, (looksym)->ts.conpool, \
				ob_lookup_name_ref((looksym)->ts.lookup, symid)	\
					) \
	)

#define ob_looksym_arraydef(obthis,looksym,symid) \
	( (POB_ARRAYDEF) ob_get_const_data (obthis, (looksym)->ts.conpool, \
				ob_lookup_syminfo_ref((looksym)->ts.lookup, symid)	\
					) \
	)

#define ob_looksym_data(looksym,symid) \
	ob_lookup_data ((looksym)->ts.lookup, symid)


//****************************************************************************
// Update macros
//****************************************************************************

#define ob_looksym_set_info(looksym,symid,inf) \
	ob_lookup_set_info ((looksym)->ts.lookup, symid, inf)

#define ob_looksym_set_id(looksym,symid,evtid,type) \
	ob_lookup_set_data_id ((looksym)->ts.lookup, symid, evtid, type)

#define ob_looksym_set_const(looksym,symid,constref,type) \
	ob_lookup_set_data_const ((looksym)->ts.lookup, symid, constref, type)

#define ob_looksym_set_val(looksym,symid,val) \
	ob_lookup_set_data_val ((looksym)->ts.lookup, symid, val)

#define ob_looksym_set_type(looksym,symid,type) \
	ob_lookup_set_data_type ((looksym)->ts.lookup, symid, type)

#define ob_looksym_set_grouping(looksym,symid,grouping) \
	ob_lookup_set_data_group ((looksym)->ts.lookup, symid, grouping)

#define ob_looksym_set_access(looksym,symid,access) \
	ob_lookup_set_data_access ((looksym)->ts.lookup, symid, access)

#define ob_looksym_set_typeargs(looksym,symid,typeargs) \
	ob_lookup_set_data_typeargs ((looksym)->ts.lookup, symid, typeargs)

#define ob_looksym_set_reftype(looksym,symid,reftype) \
	ob_lookup_set_data_reftype ((looksym)->ts.lookup, symid, reftype)

#define ob_looksym_set_fieldtype(looksym,symid,fieldtype) \
	ob_lookup_set_data_fieldtype ((looksym)->ts.lookup, symid, fieldtype)

#define ob_looksym_set_arraydef(looksym,symid,arrdef) \
	ob_lookup_set_syminfo_ref ((looksym)->ts.lookup, symid, \
		ob_add_const_data (obthis, ob_looksym_conpool(looksym), arrdef, \
							OB_CONPOOL_ARRAYDEF, 1, 					\
							ob_get_sizeof_arraydef(obthis,				\
								ob_get_arraydef_no_dims(obthis,arrdef))))

#define ob_looksym_set_dupfield(looksym,symid,dupfield) \
	ob_lookup_set_data_dupfield((looksym)->ts.lookup, symid, dupfield)

//****************************************************************************
// Function prototypes
//****************************************************************************

#ifdef    __cplusplus
	extern "C" {
#endif    /* __cplusplus */


		PBWINAPI(LPTSTR, ob_looksym_keyfunc)
			(
				PVOID 						pDataNode,
				PVOID                       tobthis
				);

		VOID           				ob_init_look_symtab
		(
			POB_THIS 					obthis,
			POB_LOOK_SYMTAB 			look_symtab,
			UINT 	   					symtab_slots,
			UINT 	   					lookup_slots,
			UINT 	   					conpool_size,
			OB_SUBPOOL 					subpool
		);

		VOID 		   				ob_reset_look_symtab
		(
			POB_THIS					obthis,
			POB_LOOK_SYMTAB				look_symtab
		);

		VOID 						ob_del_look_symtab
		(
			POB_THIS 					obthis,
			POB_LOOK_SYMTAB 			look_symtab
		);

		OB_SYM_ID 					ob_looksym_declare
		(
			POB_THIS 					obthis,
			POB_LOOK_SYMTAB 			look_symtab,
			LPTSTR 						name,
			PINT						error
		);

		OB_SYM_ID 					ob_dup_looksym_declare
		(
			POB_THIS 					obthis,
			POB_LOOK_SYMTAB 			look_symtab,
			LPTSTR 						name,
			PINT						error
		);

		PBWINAPI(OB_SYM_ID, ob_looksym_reference)
			(
				POB_THIS 					obthis,
				POB_LOOK_SYMTAB 			look_symtab,
				LPTSTR 						name
				);

		OB_SYM_ID					ob_looksym_next_reference
		(
			POB_THIS 					obthis,
			POB_LOOK_SYMTAB 			look_symtab,
			LPTSTR 						name
		);

		PBWINAPI(VOID, ob_looksym_delete)
			(
				POB_THIS 					obthis,
				POB_LOOK_SYMTAB 			look_symtab,
				UINT 						slot
				);

		VOID						ob_looksym_delete_dup
		(
			POB_THIS 					obthis,
			POB_LOOK_SYMTAB 			look_symtab,
			UINT 						slot
		);

		VOID 						ob_looksym_delete_current
		(
			POB_THIS					obthis,
			POB_LOOK_SYMTAB				symtab,
			UINT						id
		);

		INT							ob_looksym_rename
		(
			POB_THIS 					obthis,
			POB_LOOK_SYMTAB 			looksym,
			LPTSTR 						oldname,
			LPTSTR 						newname
		);

		OB_ERROR	   				ob_looksym_write
		(
			POB_THIS 					obthis,
			POB_LOOK_SYMTAB 			looksym
		);

		BOOL 						ob_looksym_read
		(
			POB_THIS 					obthis,
			POB_LOOK_SYMTAB 			looksym,
			OB_SUBPOOL 					subpool
		);

		VOID 						ob_clear_looksym_values
		(
			POB_THIS					obthis,
			POB_LOOK_SYMTAB				looksym
		);

#ifdef    __cplusplus
	}	// extern "C" {
#endif    /* __cplusplus */


#endif // OBLKSYM_H


// DOINC popped back into header 'obtypdef.h'
#endif
#ifndef OBARRAY_H
// ***** DOINC including obarray.h *****

//**************************************************************************
//
//    Copyright 1995 Powersoft Corp.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM POWERSOFT CORPORATION
//
// ------------------------------------------------------------------------
//
//    Filename :        obarray.h
//    Author   :        Jim Kosko
//    Purpose  :        Wrapper for arrays that assumes arrays are vectors
//						of POB_DATAs
//
//****************************************************************************

#ifndef OBARRAY_H
#define OBARRAY_H

#ifndef OBNARRAY_H
// ***** DOINC including obnarray.h *****
//**************************************************************************
//
//    Copyright 1995 Powersoft Corp.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM POWERSOFT CORPORATION
//
// ------------------------------------------------------------------------
//
//    Filename :        obnarray.h
//    Author   :        Jeff Calow
//    Purpose  :        Definitions for new, pointer based, array objects.
//
//****************************************************************************

#ifndef OBNARRAY_H
#define OBNARRAY_H

#ifndef OBDYNARR_H
// ***** DOINC including obdynarr.h *****
//**************************************************************************
//
//    Copyright 1995 Powersoft Corp.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM POWERSOFT CORPORATION
//
// ------------------------------------------------------------------------
//
//    Filename :        obdynarr.h
//    Author   :        Jeff Calow
//    Purpose  :        Definitions for new dynamic arrays.
//
//****************************************************************************

#ifndef OBDYNARR_H
#define OBDYNARR_H

//****************************************************************************
// Includes
//****************************************************************************

#ifndef OBTHIS_H
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
#endif

//****************************************************************************
// Assume C declarations for C++
//****************************************************************************

#ifdef __cplusplus
	extern "C" {
#endif  /* __cplusplus */

#define POB_DYNARRAY struct tag_OB_DYNARRAY FAR *

		// an initialization function is passed the dynamic array and a pointer to the
		// data to be initialized.  The function will be called at any time the array grows.
		typedef PBCDECLCALLBACK(BOOL, *PDYNARR_INIT_FN)(POB_THIS, POB_DYNARRAY, PVOID);

		// This implementation of dynamic arrays guarantee that pointers to existing
		// elements of the array will not be invalidated by the array growing!
		typedef struct tag_OB_DYNARRAY
		{
			POB_THIS			alloc_obthis;
			OB_SUBPOOL			alloc_subpool;

			USHORT				elementSize;
			USHORT				blockSize;

			ULONG				usedSize;
			ULONG				numBlocks;

			PDYNARR_INIT_FN		initFn;
			PVOID				userData;

			LPBYTE* blockArray;
		} OB_DYNARRAY;

#define OB_DYNARRAY_DEFAULT_BLOCK_SIZE	10

		// create a new dynamic array with passed element size and
		// passed block size.  No blocks will be created until necessary.
		// NOTE: elmtSize * blkSize must be less than 64K on 16 bit machines
		// the userData storage management is the responsibility of the user of the
		// dynamic arrays.
		POB_DYNARRAY
			ob_dynarray_create
			(
				POB_THIS			obthis,
				OB_SUBPOOL			subpool,
				USHORT				elmtSize,
				USHORT				blkSize,
				PDYNARR_INIT_FN		initFn,
				PVOID				userData
			);

		// free all storage associated with the dynamic array
		// this assumes that any cleanup on the elements of the array has
		// already been done.
		VOID
			ob_dynarray_free(POB_THIS		obthis
				, POB_DYNARRAY	theArray
			);

		// this copies one dynamic array into another, it assumes that the
		// data elements can be copied using memcpy
		BOOL
			ob_dynarray_copy(POB_THIS		obthis
				, POB_DYNARRAY	destination
				, POB_DYNARRAY	source
			);

		// return a pointer to the data element at 0 based index. If extend
		// is TRUE and the index is past the end of the array, the array will
		// be extended to that index.  If FALSE, an overbound will return NULL
		PBWINAPI(PVOID,
			ob_dynarray_index) (POB_THIS		obthis
				, POB_DYNARRAY	theArray
				, ULONG		index
				, BOOL			extend
				);

		// grow the dynamic array and optionaly initialize it
		PBWINAPI(VOID, ob_dynarray_grow)
			(
				POB_THIS		obthis,
				POB_DYNARRAY	theArray,
				ULONG			limit,
				BOOL			initialize
				);

		// returns the number of elements actually in the array,
		// this may be less than the available room based on the block size
#define ob_dynarray_used_size( obthis, theArray ) \
	( (theArray)->usedSize )

// returns the length, in bytes, of a block in the given array
#define ob_dynarray_block_length( obthis, theArray ) \
	( (theArray)->elementSize * (theArray)->blockSize )

// get the user data that was set at creation time
#define ob_dynarray_get_user_data( array ) \
	((POB_DYNARRAY)(array))->userData

// sanity test the new array code
		VOID
			ob_dynarray_test(POB_THIS obthis);

		VOID
			ob_dynarray_clear(POB_THIS		obthis
				, POB_DYNARRAY	theArray); // CR289662 - partha

#ifdef __cplusplus
	}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif // OBDYNARR_H
// DOINC popped back into header 'obnarray.h'
#endif

//****************************************************************************
// Assume C declarations for C++
//****************************************************************************

#ifdef __cplusplus
	extern "C" {
#endif  /* __cplusplus */

		// TBD this probably belongs somewhere else.
		typedef LPBYTE	TNULL, FAR* PTNULL;

		typedef enum ob_narray_type
		{
			OB_ARRAY_STATIC
			, OB_ARRAY_DYNAMIC

		} OB_NARRAY_TYPE, FAR* POB_NARRAY_TYPE;

#define POB_NARRAY	struct tag_OB_NARRAY FAR *

		// an initialization function is passed the array and a pointer to the
		// data to be initialized.  The function will be called at any time the array
		// needs to be initialize (at create time for a static array and as the array
		// grows for a dynamic array).
		typedef PBCALLBACK(BOOL, *PNARRAY_INIT_FN)(POB_THIS, POB_NARRAY, PVOID);

		// this is the new structure for arrays
		// the data is cast when used,
		// for static arrays, the data and null data is allocated directly after
		// end of the structure.  For dynamic arrays, the data and nullData are allocated
		// as seperate blocks
		// The userData field can be used to store misc user data.
		// NOTE: for alignment purposes, the size of this structure must be in increments
		// of doublewords.
		typedef struct tag_OB_NARRAY
		{
			OB_CLASS_HNDL	elementType;				// 4 bytes
			USHORT			type;						// 2 bytes
		//	OB_NARRAY_TYPE	type;						// 2 bytes
			USHORT			userData;					// 2 bytes

			ULONG			nitems;						// 4 bytes
			USHORT			elementSize;				// 2 bytes
			USHORT			nDims;						// 2 bytes

			PNARRAY_INIT_FN initFn;						// 4 bytes

			PVOID			data;						// 4 bytes
			PTNULL			nullData;					// 4 bytes
			SHORT			bFreeData;					// 2 bytes
			USHORT			padding;					// 2 bytes
			LONG			bounds[2];					// 4 bytes

		} OB_NARRAY;

		// these need to be macro's because they are used in generated code
		// that needs to be C compatable

		// START MACRO'S FOR GENERATED CODE USE

		// check that theIndex is within the lowLimit and the highLimit
		// NOTE: don't pass in an index that contains side effects !!
#define	ob_range_check( theIndex, lowLimit, highLimit ) \
	( ( (theIndex) >= (lowLimit) ) && ( (theVal) <= (highLimit) ) )

// Calculates size of OB_NARRAY bounds vector
#define ob_narray_bounds_size( obthis, ndims )								\
	( (ndims - 1) * 2 * sizeof(LONG) )

// Calculates size of OB_NARRAY header, includes space for bounds
#define ob_narray_header_size( obthis, ndims )								\
	( sizeof(OB_NARRAY) + ob_narray_bounds_size (obthis, ndims) )

// This guy does the huge pointer calculation for data members. It is meant
// for internal use only.
#define ob_narray_get_static_item_HUGE( obthis, array, index )	  			\
	( (VOID *) ( (BYTE HUGEPTR *) ((array)->data)				 			\
						+ ((index) * (array)->elementSize) ) 				\
	)

// Returns the location of the data array
#define ob_narray_static_data_addr( obthis, array )		 	 		   		\
	( (PVOID)																\
		( (LPBYTE) (array) 	 										  		\
			+ ob_narray_header_size (obthis, (array)->nDims) )				\
	)

// Returns the location of the nulldata array
#define ob_narray_static_nulldata_addr( obthis, array )	 	 			   	\
	((PTNULL) ob_narray_get_static_item_HUGE (obthis, array, (array)->nitems))

// for efficiency, this macro assumes that the numDims is a constant
// at generation time and will result in a constant offset
// this will return a pointer to the data
#define ob_narray_index_static( obthis, type, array, index ) 				\
	( (type FAR *) ob_narray_static_data_addr (obthis, array)				\
		     + (index) 										    			\
	)

// If we know the static array crosses a 64k segment boundary, we need
// to use huge math when we index the array
// this will return a pointer to the data
#define ob_narray_index_static_HUGE( obthis, type, array, index ) 			\
	( (type FAR *)															\
	    ( (type HUGEPTR *) ob_narray_static_data_addr (obthis, array)		\
			 + (index) )													\
	)

// dynamic arrays always need to go through the data pointer
// this will return a pointer to the data
#define ob_narray_index_dynamic( obthis, type, array, index ) 				\
	( (type FAR *) ob_dynarray_index( obthis, (POB_DYNARRAY) ((array)->data), 	\
									index, TRUE ) )

// dynamic arrays always need to go through the data pointer
// this will return a pointer to the data
#define ob_narray_grow_dynamic( obthis, array, newSize, initialize ) 		\
	( ob_dynarray_grow( obthis, (POB_DYNARRAY) ((array)->data), 			\
									newSize, initialize ) )

// If we know the static array crosses a 64k segment boundary, we need
// to use huge math when we index the array
// this will return a pointer to the null data
#define ob_narray_static_null ( obthis, array, index ) 						\
	( (PTNULL) 																\
		( (TNULL HUGEPTR *) ob_narray_static_nulldata_addr (obthis, array) 	\
			+ (index) )														\
	)

// this will return a pointer to the null data
#define ob_narray_dynamic_null( obthis, array, index ) \
	((PTNULL) ob_dynarray_index( obthis, (POB_DYNARRAY) ((array)->nullData), index, TRUE )

// END MACRO'S FOR GENERATED CODE USE



// ARRAY creation and destruction functions

// create a static array of the given elementSize, in the given number
// of dimensions with the passed limits.  The limit array is expected to
// be minLimit, maxLimit for each dimension. If a separate stream for null
// values are wanted, pass useNulls as TRUE;
		PBWINAPI(POB_NARRAY,
			ob_narray_create_static) (POB_THIS			obthis
				, OB_SUBPOOL		subpool
				, ULONG			num_items
				, OB_CLASS_HNDL	elmtType
				, USHORT			elmtSize
				, USHORT			numDim
				, PLONG			boundsArray
				, USHORT			userData
				, BOOL				useNulls
				, BOOL				freeData
				, PNARRAY_INIT_FN	initFn
				);

		// create a dynamic array in the given subpool, with the given datatype
		// of the given elementSize.  The block size is determined by the
		// dynamic array code. if a separate stream for null values are wanted,
		// pass useNulls as TRUE;
		PBWINAPI(POB_NARRAY,
			ob_narray_create_dynamic) (POB_THIS		obthis
				, OB_SUBPOOL		subpool
				, OB_CLASS_HNDL	elmtType
				, USHORT			elmtSize
				, USHORT			userData
				, BOOL			useNulls
				, BOOL			freeData
				, PNARRAY_INIT_FN	initFn
				);

		// free up the storage associated with the array
		// NOTE: theArray becomes invalid after this call.
		VOID
			ob_narray_free(POB_THIS		obthis
				, POB_NARRAY		theArray
			);

		// duplicate the passed array in given sub_pool
		POB_NARRAY
			ob_narray_duplicate(POB_THIS	obthis
				, OB_SUBPOOL	subPool
				, POB_NARRAY	theArray
			);

		PBCDECLAPI(BOOL, ob_narray_dynamic_item_init_callback)
			(
				POB_THIS		obthis,
				POB_DYNARRAY	dynArray,
				PVOID			item
				);

		// ARRAY attribute access functions

		// return the type of the array
#define ob_narray_type( obthis, theArray ) \
	((OB_NARRAY_TYPE)((theArray)->type))

// set the type of the array
#define ob_narray_set_type( obthis, theArray, newtype ) \
	((theArray)->type = (newtype))

// return the type of the elements in the array
#define ob_narray_element_type( obthis, theArray ) \
	((theArray)->elementType)

// set the type of the elements in the array
#define ob_set_narray_element_type( obthis, theArray, newElementType ) \
	((theArray)->elementType = newElementType)

// return the size of the elements in the array
#define ob_narray_element_size( obthis, theArray ) \
	((theArray)->elementSize)

// return the number of dimensions in the array
#define ob_narray_num_dimensions( obthis, theArray ) \
	((theArray)->nDims)

// return the array bounds
#define ob_narray_bounds( obthis, theArray ) \
	((theArray)->bounds)

// return the contents of the array userData attribute
#define ob_narray_user_data( obthis, theArray ) \
	((theArray)->userData)

// set the contents of the array userData attribute
#define ob_narray_set_user_data( obthis, theArray, data ) \
	((theArray)->userData = (data))

// return the number of items for a static array
#define ob_narray_num_items_static( obthis, theArray ) \
	 ((theArray)->nitems)

// return if the data contained within the array needs to be free'd
#define ob_narray_free_data( obthis, theArray ) \
	 ((theArray)->bFreeData)

// indicate if the data contained within the array needs to be free'd
#define ob_narray_set_free_data( obthis, theArray, newValue ) \
	 (theArray)->bFreeData = (newValue)

// use this only to calculate number of items from bounds
// (the "nitems" field may sometimes be set to zero)
		ULONG
			ob_narray_calc_num_items_static(POB_THIS obthis
				, POB_NARRAY theArray
			);

		// return the number of items for a dynamic array
#define ob_narray_num_items_dynamic( obthis, theArray ) \
	 ob_dynarray_used_size( obthis, (POB_DYNARRAY) ((theArray)->data) )

// return the number of items contained in the array
#define ob_narray_num_items( obthis, theArray ) \
	(ob_narray_type(obthis,theArray) == OB_ARRAY_DYNAMIC ? \
	 ob_narray_num_items_dynamic( obthis, theArray ) : \
	 ob_narray_num_items_static( obthis, theArray ))

// return the actual size of a bounded theArray in bytes
#define ob_narray_static_size(obthis, theArray)		   						\
	(ob_narray_header_size(obthis, (theArray)->nDims) +						\
		 ob_narray_element_size(obthis, theArray) * 			 			\
		 ob_narray_num_items_static(obthis, theArray))

// return the upper bound given the dimension
#define ob_narray_upper_bound(obthis,theArray,dimension)	\
	(ob_narray_type(obthis,theArray) == OB_ARRAY_DYNAMIC ? \
	 ob_narray_num_items_dynamic( obthis, theArray ) : \
	 ((theArray)->bounds[ (dimension-1) * 2 + 1 ]))


// return the lower bound given the dimension
#define ob_narray_lower_bound(obthis,theArray,dimension) \
	(ob_narray_type(obthis,theArray) == OB_ARRAY_DYNAMIC ? \
	1 : \
	((theArray)->bounds[ (dimension-1) * 2 ]))

// Index into array
#define ob_narray_index( obthis, theArray, type, index ) \
	(ob_narray_type(obthis,theArray) == OB_ARRAY_DYNAMIC ? \
	 ob_narray_index_dynamic( obthis, type, theArray, index ) : \
	 ob_narray_index_static( obthis, type, theArray, index ))

// Index into array using huge arithmetic
#define ob_narray_index_HUGE( obthis, theArray, type, index ) \
	(ob_narray_type(obthis,theArray) == OB_ARRAY_DYNAMIC ? \
	 ob_narray_index_dynamic( obthis, type, theArray, index ) : \
	 ob_narray_index_static_HUGE( obthis, type, theArray, index ))

// Index into nulls
#define ob_narray_null_index( obthis, theArray, index ) \
	(ob_narray_type(obthis,theArray) == OB_ARRAY_DYNAMIC ? \
	 ob_narray_dynamic_null( obthis, theArray, index ) : \
	 ob_narray_static_null( obthis, theArray, index ))

// Index into nulls using huge arithmetic
#define ob_narray_null_index_HUGE( obthis, theArray, index ) \
	(ob_narray_type(obthis,theArray) == OB_ARRAY_DYNAMIC ? \
	 ob_narray_dynamic_null( obthis, theArray, index ) : \
	 ob_narray_static_null_HUGE( obthis, theArray, index ))


// sanity test the new array code
		VOID
			ob_narray_test(POB_THIS obthis);

		VOID ob_narray_clear(POB_THIS	obthis, POB_NARRAY theArray); // CR289662 - partha

#ifdef __cplusplus
	}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif // OBNARRAY_H
// DOINC popped back into header 'obarray.h'
#endif

#ifndef OBDATA_H
// ***** DOINC including obdata.h *****
	// DOINC skipping duplicate include
#endif

//****************************************************************************
// Assume C declarations for C++
//****************************************************************************

#ifdef __cplusplus
	extern "C" {
#endif  /* __cplusplus */


		//****************************************************************************
		// Array instance definition
		//****************************************************************************

		typedef OB_NARRAY 	   	OB_ARRAY_INST, FAR* POB_ARRAY_INST;

		//****************************************************************************
		// Array type definition
		//****************************************************************************

		typedef OB_NARRAY_TYPE  OB_ARRAY_TYPE, FAR* POB_ARRAY_TYPE;

		//****************************************************************************
		// Array symbol type.
		// NOTE:
		//     The above OB_ARRAY_TYPE is used to specify how the array is stored at
		//     runtime. It is used in the OB_ARRAY structure
		//	   The OB_ARRAY_SYMBOL_STYLE is used to specify how the array variable is
		//	   declared. It is used in the symbol table. OB_ARRAY_SYMBOL_STYLE definition
		//		moved to obdata.h
		//****************************************************************************

		//****************************************************************************
		// Array bounds definition structure (Used in symbol tables)
		//****************************************************************************

		typedef struct ob_arraydef
		{
			//	USHORT					no_dims;
			//	OB_ARRAY_SYMBOL_STYLE	array_style;
			USHORT					flags;
			OB_INFO_FLAGS			varinfo;
			LONG					bounds[1];

		} OB_ARRAYDEF, FAR* POB_ARRAYDEF;

#define OB_ARRAY_NODIMS_MASK            0x3FFF		// 14 bits
#define OB_ARRAY_STYLE_MASK             0xC000		// 2 bits

#define OB_ARRAY_NODIMS_SHIFT           0
#define OB_ARRAY_STYLE_SHIFT            14

#define ob_get_arraydef_no_dims(obthis,arrdef)                          	\
	((USHORT) ((((arrdef)->flags) & OB_ARRAY_NODIMS_MASK) >> 				\
				OB_ARRAY_NODIMS_SHIFT))

#define ob_set_arraydef_no_dims(obthis,arrdef,no_dims) 		                \
	((arrdef)->flags = (USHORT) (((no_dims) << OB_ARRAY_NODIMS_SHIFT) |		\
				(((arrdef)->flags) & ~OB_ARRAY_NODIMS_MASK)))

#define ob_get_arraydef_style(obthis,arrdef)                          		\
	((OB_ARRAY_SYMBOL_STYLE) ((((arrdef)->flags) & OB_ARRAY_STYLE_MASK) >> 	\
				OB_ARRAY_STYLE_SHIFT))

#define ob_set_arraydef_style(obthis,arrdef,style)	 		                \
	((arrdef)->flags = (USHORT) (((style) << OB_ARRAY_STYLE_SHIFT) |  		\
				(((arrdef)->flags) & ~OB_ARRAY_STYLE_MASK)))

#define ob_get_arraydef_varinfo(obthis, arrdef)								\
	((arrdef)->varinfo)

#define ob_set_arraydef_varinfo(obthis, arrdef, info)						\
	((arrdef)->varinfo = (info))

#define ob_get_arraydef_bounds(obthis,arrdef)								\
	((arrdef)->bounds)

		// Use with bounded arrays
#define ob_get_arraydef_upper_bound(obthis,arrdef,dimension)				\
	((arrdef)->bounds[ (dimension-1) * 2 + 1 ])

#define ob_get_arraydef_lower_bound(obthis,arrdef,dimension)				\
	((arrdef)->bounds[ (dimension-1) * 2 ])

// Note: the " - 1" takes into account the bounds[1] in the ARRAYDEF definition
#define ob_get_sizeof_arraydef(obthis,no_dims)								\
	(sizeof(OB_ARRAYDEF) + (no_dims * 2 - 1) * sizeof (LONG))

		PBWINAPI(VOID, ob_set_arraydef)
			(
				POB_THIS					obthis,
				POB_ARRAYDEF				arraydef,
				UINT 						no_dims,
				OB_ARRAY_SYMBOL_STYLE		arr_style,
				LONG						bounds[]
				);

		PBWINAPI(ULONG, ob_get_array_len)
			(
				POB_THIS 					obthis,
				POB_ARRAYDEF				arraydef
				);

		PBWINAPI(BOOL, ob_array_item_init_callback)
			(
				POB_THIS 					obthis,
				POB_NARRAY					theArray,
				PVOID						theItem
				);

		//****************************************************************************
		// Runtime Array creation and destruction functions
		//****************************************************************************

#define ob_array_create_and_init_bounded(obthis,nitems,elmtType,varinfo,ndims,bounds)\
	ob_narray_create_static (obthis, obthis->lvalue_subpool, nitems, 		\
					elmtType, sizeof(OB_DATA), ndims, bounds, (USHORT) varinfo, \
					 FALSE, TRUE, (PNARRAY_INIT_FN)ob_array_item_init_callback)

#define ob_array_create_bounded(obthis,nitems,elmtType,varinfo,ndims,bounds)\
	ob_narray_create_static (obthis, obthis->lvalue_subpool, nitems, 		\
					elmtType, sizeof(OB_DATA), ndims, bounds, 				\
					(USHORT) varinfo, FALSE, TRUE, NULL)

#define ob_array_create_unbounded(obthis,elmtType,varinfo) 					\
	ob_narray_create_dynamic( obthis, obthis->lvalue_subpool, elmtType, 	\
							sizeof (OB_DATA), (USHORT) varinfo, FALSE,      \
							TRUE, (PNARRAY_INIT_FN)ob_array_item_init_callback)

// grow an unbounded array
#define ob_array_grow_unbounded( obthis, array, limit, initialize )			\
	ob_narray_grow_dynamic( obthis,(POB_NARRAY) (array), limit, initialize )

// Free just the array
#define ob_array_free(obthis,array)											\
	ob_narray_free (obthis, (POB_NARRAY) (array))

// Free array and it's data
		VOID ob_free_array_data
		(
			POB_THIS          	obthis,
			POB_ARRAY_INST		array_inst
		);

		// duplicate the passed array in given sub_pool
#define ob_array_duplicate(obthis,array)									\
	ob_narray_duplicate (obthis, obthis->lvalue_subpool, (POB_NARRAY) (array))


//****************************************************************************
// Array attribute access functions
//****************************************************************************

// return the type of the array
#define ob_array_type( obthis, array ) 										\
	ob_narray_type (obthis, (POB_NARRAY) (array) )

// set the type of the array
#define ob_array_set_type( obthis, array, typ ) 					   		\
	ob_narray_set_type (obthis, (POB_NARRAY) (array), typ )

// return the type of the elements in the array
#define ob_array_class_hndl(obthis,array)									\
	ob_narray_element_type (obthis, (POB_NARRAY) (array))

// set the type of the elements in the array
#define ob_set_array_class_hndl(obthis,array, elementType)					\
	ob_set_narray_element_type (obthis, (POB_NARRAY) (array), elementType)

#define ob_array_class_id(obthis,array)										\
	ob_get_class_hndl_id(ob_array_class_hndl (obthis, array))

#define ob_array_group_id(obthis,array)										\
	((OB_GROUP_ID) ob_get_class_group_hndl (								\
				ob_array_class_hndl (obthis, array)) )

#define ob_array_group(obthis,array)										\
	ob_group_data (obthis, ob_array_group_id(obthis, array))

// return the contents of the array varinfo attribute
#define ob_array_varinfo( obthis, array ) 									\
	((OB_INFO_FLAGS) ob_narray_user_data ( obthis, (POB_NARRAY) (array) ))

// set the contents of the array varinfo attribute
#define ob_array_set_varinfo( obthis, array, data ) 	  					\
	ob_narray_set_user_data ( obthis, (POB_NARRAY) (array), data )

// return the number of items contained in a bounded array
#define ob_array_num_items_bounded(obthis, array)							\
	ob_narray_num_items_static (obthis, (POB_NARRAY) (array))

// use this to calculate number of items from array bounds
// Note: sometimes array nitem field will be zero
#define ob_array_calc_num_items_bounded(obthis, array)						\
	ob_narray_calc_num_items_static (obthis, (POB_NARRAY) (array))

// return the number of items in an unbounded array
#define ob_array_num_items_unbounded(obthis, array)							\
	ob_narray_num_items_dynamic (obthis, (POB_NARRAY) (array))

// return the number of items given any array
#define ob_array_num_items(obthis, array)									\
	ob_narray_num_items (obthis, (POB_NARRAY) (array))

// return the number of dimensions in the array
#define ob_array_num_dimensions( obthis, array ) 							\
	ob_narray_num_dimensions (obthis, (POB_NARRAY) (array))

// return the array bounds
#define ob_array_bounds( obthis, array ) 									\
	ob_narray_bounds (obthis, (POB_NARRAY) (array))

// return the actual size of a bounded array in bytes
#define ob_array_bounded_size(obthis,array)		   							\
	ob_narray_static_size (obthis, (POB_NARRAY) (array))

// return the upper bound given the dimension
#define ob_array_upper_bound(obthis,array,dimension)				\
	ob_narray_upper_bound (obthis, (POB_NARRAY) (array), dimension)

// return the lower bound given the dimension
#define ob_array_lower_bound(obthis,array,dimension)				\
	ob_narray_lower_bound (obthis, (POB_NARRAY) (array), dimension)

// return if the data contained within the array needs to be free'd
#define ob_array_free_data(obthis, array) \
	ob_narray_free_data (obthis, (POB_NARRAY) (array) )

// indicate if the data contained within the array needs to be free'd
#define ob_array_set_free_data( obthis, array, newValue ) \
	ob_narray_set_free_data (obthis, (POB_NARRAY) (array), (newValue) )

//****************************************************************************
// Array Data Access Functions
//****************************************************************************

// Index into a bounded array
#define ob_array_index_bounded( obthis, array, index ) 	  					\
	ob_narray_index_static_HUGE( obthis, OB_DATA, (POB_NARRAY) (array), index )

// Index into a unbounded array
#define ob_array_index_unbounded( obthis, array, index )  					\
	ob_narray_index_dynamic( obthis, OB_DATA, (POB_NARRAY) (array), index )

// If you don't know the type use ot_array_index or ob_array_index

//****************************************************************************
//	Methods to calculate index from subscripts.
//  NOTE: Both of these guys take 1 based subscripts (which is consistent
//		with internal dimension data) and return a 0 based index (which is
//		consistent with indexes).
//****************************************************************************

// Generalized method given array of subscripts
		ULONG 							ob_array_calc_index_from_subs
		(
			POB_THIS 				obthis,
			POB_ARRAY_INST			theArray,
			PLONG					subs
		);

		// Use this cheaper method if you know the array is 2D
#define ob_array_calc_2D_index(obthis,array,row,col)						\
	(																		\
	 (																		\
	  (col - ob_array_bounds(obthis,array)[2]) * 					  		\
	  (ob_array_bounds(obthis,array)[1]-ob_array_bounds(obthis,array)[0]+1)	\
	 ) + 																	\
	 row - ob_array_bounds(obthis,array)[0]									\
	)

//****************************************************************************
// Array utility functions
//****************************************************************************

		VOID 							ob_convert_array_to_ptr
		(
			POB_THIS 				obthis,
			POB_DATA				array_data_node,
			OB_GROUP_ID				array_group_id
		);

		INT 							ob_convert_array_to_const
		(
			POB_THIS 				obthis,
			POB_GROUP				group,
			POB_DATA	 			data_node
		);

		PBWINAPI(POB_ARRAY_INST, ob_init_array)
			(
				POB_THIS 				obthis,
				POB_ARRAYDEF			arrdef,
				POB_GROUP				group,
				OB_CLASS_ID				class_id,
				BOOL					init_data
				);

		LPTSTR 							ob_build_array_bounds_string
		(
			POB_THIS 				obthis,
			UINT					no_dims,
			PLONG					bounds,
			BOOL					is_unbounded
		);

		//
		// Utility routine that takes an arraydef, allocates a new one
		// and copies the arraydef values. The caller must free the new
		// arraydef using "free".
		PBWINAPI_(HRESULT) ob_create_arraydef_copy(POB_THIS obThis, POB_ARRAYDEF* ppArrayDefNew, POB_ARRAYDEF pArrayDef);

		/* - Start -- CR289662 - partha -- */
		VOID ob_clear_array_data
		(
			POB_THIS          		obthis,
			POB_ARRAY_INST	array_inst,
			BOOL					bArrayShrink
		);

		PBWINAPI(BOOL, ob_array_varinfo_nullval)
			(
				POB_THIS          	obthis,
				POB_ARRAY_INST		array_inst
				);

		PBWINAPI(VOID, ob_array_set_varinfo_nullval)
			(
				POB_THIS          	obthis,
				POB_ARRAY_INST		array_inst,
				BOOL   bNull
				);


		PBWINAPI(VOID, ob_remove_array_data)
			(
				POB_THIS        obthis,
				POB_ARRAY_INST	array_inst,
				BOOL            IsNullVarInfor
				);

#define ob_array_clear(obthis,array)	\
	ob_narray_clear (obthis, (POB_NARRAY) (array))

		/* - End -- CR289662 - partha -- */

#ifdef __cplusplus
	}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif // OBNARRAY_H
// DOINC popped back into header 'obtypdef.h'
#endif
#ifndef OBROUTIN_H
// ***** DOINC including obroutin.h *****
// $RCSfile: obroutin.h $;$Revision: 4.9 $
//**************************************************************************
//
//                            Copyright 1989 
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :	obroutin.h	
//
//    Author   :	Jim Kosko
//
//    Purpose  : 	Routine level data structures for PB object manager.
//
//****************************************************************************

#ifndef OBROUTIN_H
#define OBROUTIN_H

//****************************************************************************
// Includes
//****************************************************************************

#ifndef OSPASCAL_H
// ***** DOINC including ospascal.h *****
	// DOINC skipping duplicate include
#endif
#ifndef PBSTG_H
// ***** DOINC including pbstg.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBTHIS_H
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBCONST_H
// ***** DOINC including obconst.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBLKSYM_H
// ***** DOINC including oblksym.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBPCODE_H
// ***** DOINC including obpcode.h *****
// $RCSfile: obpcode.h $;$Revision: 4.10 $
//**************************************************************************
//
//                            Copyright 1989 
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :	obpcode.h	
//
//    Author   :	Jim Kosko
//
//    Purpose  : 	P-code data structures for PB object manager.
//
//****************************************************************************

#ifndef OBPCODE_H
#define OBPCODE_H

//****************************************************************************
// Includes
//****************************************************************************

#ifndef _LIMITS_H_INCLUDED
#include <limits.h>
#endif
#ifndef OSPASCAL_H
// ***** DOINC including ospascal.h *****
	// DOINC skipping duplicate include
#endif
#ifndef PBSTG_H
// ***** DOINC including pbstg.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBTHIS_H
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBERROR_H
// ***** DOINC including oberror.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBALLOC_H
// ***** DOINC including oballoc.h *****
	// DOINC skipping duplicate include
#endif
//****************************************************************************
// Structure for pcode node
//****************************************************************************

#define OB_PCODE_MAX_OPERANDS 5

	typedef USHORT	OB_PCODE_OPCODE, FAR* POB_PCODE_OPCODE;
	typedef USHORT	OB_PCODE_OPERAND, FAR* POB_PCODE_OPERAND;
	typedef struct ob_pcode_node
	{
		OB_PCODE_OPCODE		opcode; 				// Pcode operator
		OB_PCODE_OPERAND	op1;					// 1st Pcode operand
		OB_PCODE_OPERAND	op2;					// 2nd Pcode operand
		OB_PCODE_OPERAND	op3;					// 3rd Pcode operand
		OB_PCODE_OPERAND	op4;					// 4th Pcode operand
		OB_PCODE_OPERAND	op5;					// 5th Pcode operand

	} OB_PCODE_NODE, FAR* POB_PCODE_NODE;

#define ob_get_pcode_opcode(obthis,pcode)						\
			(((POB_PCODE_NODE) (pcode))->opcode)

#define ob_set_pcode_opcode(obthis,pcode,opcd)					\
			(((POB_PCODE_NODE) (pcode))->opcode = (OB_PCODE_OPCODE)(opcd))

#define ob_get_pcode_op1(obthis,pcode)							\
			(((POB_PCODE_NODE) (pcode))->op1)

#define ob_set_pcode_op1(obthis,pcode,op)						\
			(((POB_PCODE_NODE) (pcode))->op1 = (OB_PCODE_OPERAND)(op))

#define ob_get_pcode_op2(obthis,pcode)							\
			(((POB_PCODE_NODE) (pcode))->op2)

#define ob_set_pcode_op2(obthis,pcode,op)						\
			(((POB_PCODE_NODE) (pcode))->op2 = (OB_PCODE_OPERAND)(op))

#define ob_get_pcode_op3(obthis,pcode)							\
			(((POB_PCODE_NODE) (pcode))->op3)

#define ob_set_pcode_op3(obthis,pcode,op)						\
			(((POB_PCODE_NODE) (pcode))->op3 = (OB_PCODE_OPERAND)(op))

#define ob_get_pcode_op4(obthis,pcode)							\
			(((POB_PCODE_NODE) (pcode))->op4)

#define ob_set_pcode_op4(obthis,pcode,op)						\
			(((POB_PCODE_NODE) (pcode))->op4 = (OB_PCODE_OPERAND)(op))

#define ob_get_pcode_op5(obthis,pcode)							\
			(((POB_PCODE_NODE) (pcode))->op5)

#define ob_set_pcode_op5(obthis,pcode,op)						\
			(((POB_PCODE_NODE) (pcode))->op5 = (OB_PCODE_OPERAND)(op))

#define ob_get_pcode_size(obthis,pcode)							\
			((rt_semfun_args_index (((POB_PCODE_NODE) (pcode))->opcode) \
			 * sizeof (OB_PCODE_OPERAND)) + sizeof (OB_PCODE_OPCODE))

	typedef PFV		OB_THREAD_OPCODE, FAR* POB_THREAD_OPCODE;
	typedef ULONG	OB_THREAD_OPERAND, FAR* POB_THREAD_OPERAND;
	typedef struct ob_thread_node
	{
		OB_THREAD_OPCODE	semantic; 				// Pcode semantic f() pointer
		OB_THREAD_OPERAND	op1;					// 1st Pcode operand
		OB_THREAD_OPERAND	op2;					// 2nd Pcode operand
		OB_THREAD_OPERAND	op3;					// 3rd Pcode operand
		OB_THREAD_OPERAND	op4;					// 4th Pcode operand
		OB_THREAD_OPERAND	op5;					// 5th Pcode operand

	} OB_THREAD_NODE, FAR* POB_THREAD_NODE;

#define ob_get_thread_semantic(obthis,thrd)						\
			(((POB_THREAD_NODE) (thrd))->semantic)

#define ob_set_thread_semantic(obthis,thrd,sem)					\
			(((POB_THREAD_NODE) (thrd))->semantic = (OB_THREAD_OPCODE)(sem))

#define ob_get_thread_op1(obthis,thrd)							\
			(((POB_THREAD_NODE) (thrd))->op1)

#define ob_set_thread_op1(obthis,thrd,op)						\
			(((POB_THREAD_NODE) (thrd))->op1 = (OB_THREAD_OPERAND)(op))

#define ob_get_thread_op2(obthis,thrd)							\
			(((POB_THREAD_NODE) (thrd))->op2)

#define ob_set_thread_op2(obthis,thrd,op)						\
			(((POB_THREAD_NODE) (thrd))->op2 = (OB_THREAD_OPERAND)(op))

#define ob_get_thread_op3(obthis,thrd)							\
			(((POB_THREAD_NODE) (thrd))->op3)

#define ob_set_thread_op3(obthis,thrd,op)						\
			(((POB_THREAD_NODE) (thrd))->op3 = (OB_THREAD_OPERAND)(op))

#define ob_get_thread_op4(obthis,thrd)							\
			(((POB_THREAD_NODE) (thrd))->op4)

#define ob_set_thread_op4(obthis,thrd,op)						\
			(((POB_THREAD_NODE) (thrd))->op4 = (OB_THREAD_OPERAND)(op))

#define ob_get_thread_op5(obthis,thrd)							\
			(((POB_THREAD_NODE) (thrd))->op5)

#define ob_set_thread_op5(obthis,thrd,op)						\
			(((POB_THREAD_NODE) (thrd))->op5 = (OB_THREAD_OPERAND)(op))

	//****************************************************************************
	// Structure for pcode node
	//****************************************************************************

	typedef struct ob_pcode_line_node
	{
		USHORT				line_no;			// Line number
		USHORT				pcode_loc;			// Associated pcode location

	} OB_PCODE_LINE_NODE, FAR* POB_PCODE_LINE_NODE;

	//****************************************************************************
	// Pcode limits
	//****************************************************************************

#define OB_PCODE_ERROR		0xFFFF
#define OB_PCODE_NO_LINE	0xFFFF
#define OB_PCODE_MAX_BLOCK	0xFFF4

//****************************************************************************
// Structure for pcode block
//****************************************************************************

	typedef struct ob_perm_pcode_blk
	{
		USHORT				len;				// Length of pcode block.
		USHORT				no_line_block;		// Number of items in line block.
		USHORT				max_stack_depth;	// Largest depth of stack for block

	} OB_PERM_PCODE_BLK, FAR* POB_PERM_PCODE_BLK;

	typedef struct ob_temp_pcode_blk
	{
		LPBYTE				block;				// Pointer to actual pcode block
		POB_PCODE_LINE_NODE line_block;			// Pointer to line number block
		UINT				len_incr;			// No of bytes to increment.
		UINT				line_block_incr;	// No of incr items in lineblock
		UINT				curr_pos;			// Current end of pcode block.
		UINT				curr_line_pos;		// Current end of lineno block.
		BOOL				block_is_thread;	// TRUE: block translated to thread.
		LPBYTE				thread;				// Pointer to actual pcode thread.
		SHORT				thd_len;			// Length of pcode thread.
		POB_PCODE_LINE_NODE thread_line_block;	// Pointer to thread line no block.
	} OB_TEMP_PCODE_BLK;

	typedef struct ob_pcode_blk
	{
		OB_PERM_PCODE_BLK	ps;
		OB_TEMP_PCODE_BLK	ts;

	} OB_PCODE_BLK, FAR* POB_PCODE_BLK;


	//****************************************************************************
	// Wrapper for pcode structure
	//****************************************************************************

#define ob_get_pcode_block(obthis,pcode_blk)								\
				(((POB_PCODE_BLK) (pcode_blk))->ts.block)

#define ob_set_pcode_block(obthis,pcode_blk,blk)							\
				(((POB_PCODE_BLK) (pcode_blk))->ts.block = (LPBYTE)(blk))

#define ob_get_pcode_blk_len(obthis,pcode_blk)								\
				(((POB_PCODE_BLK) (pcode_blk))->ps.len)

#define ob_set_pcode_blk_len(obthis,pcode_blk,length)						\
				(((POB_PCODE_BLK) (pcode_blk))->ps.len = (USHORT)(length))

#define ob_get_next_pcode_loc(obthis,pcode_blk)								\
				(((POB_PCODE_BLK) (pcode_blk))->ts.curr_pos)

#define ob_get_pcode_curr_pos(obthis,pcode_blk)								\
				(((POB_PCODE_BLK) (pcode_blk))->ts.curr_pos)

#define ob_set_pcode_curr_pos(obthis,pcode_blk,newloc)						\
				(((POB_PCODE_BLK) (pcode_blk))->ts.curr_pos = (UINT)(newloc))

#define ob_get_pcode(obthis,pcode_blk,loc)									\
				((POB_PCODE_NODE) (((POB_PCODE_BLK) pcode_blk)->ts.block + (loc)))

#define ob_get_pcode_line_block(obthis,pcode_blk)							\
				(((POB_PCODE_BLK) (pcode_blk))->ts.line_block)

#define ob_get_pcode_no_line_block(obthis,pcode_blk)						\
				(((POB_PCODE_BLK) (pcode_blk))->ps.no_line_block)

#define ob_set_pcode_no_line_block(obthis,pcode_blk,val)					\
				(((POB_PCODE_BLK) (pcode_blk))->ps.no_line_block = (USHORT)(val))

#define ob_get_pcode_curr_line_pos(obthis,pcode_blk)						\
				(((POB_PCODE_BLK) (pcode_blk))->ts.curr_line_pos)

#define ob_set_pcode_curr_line_pos(obthis,pcode_blk,line_pos)				\
				(((POB_PCODE_BLK) (pcode_blk))->ts.curr_line_pos = (UINT)(line_pos))

#define ob_get_pcode_block_is_thread(obthis,pcode_blk)						\
				(((POB_PCODE_BLK) (pcode_blk))->ts.block_is_thread)

#define ob_set_pcode_block_is_thread(obthis,pcode_blk,isthd)				\
				(((POB_PCODE_BLK) (pcode_blk))->ts.block_is_thread = (BOOL)(isthd))

#define ob_get_pcode_thd_len(obthis,pcode_blk)								\
				(((POB_PCODE_BLK) (pcode_blk))->ts.thd_len)

#define ob_set_pcode_thd_len(obthis,pcode_blk,tlen)							\
				(((POB_PCODE_BLK) (pcode_blk))->ts.thd_len = (SHORT)(tlen))

#define ob_get_pcode_thread(obthis,pcode_blk)								\
				(((POB_PCODE_BLK) (pcode_blk))->ts.thread)

#define ob_set_pcode_thread(obthis,pcode_blk,thrd)							\
				(((POB_PCODE_BLK) (pcode_blk))->ts.thread = (LPBYTE)(thrd))

#define ob_get_pcode_thread_line_block(obthis,pcode_blk)					\
				(((POB_PCODE_BLK) (pcode_blk))->ts.thread_line_block)

#define ob_set_pcode_thread_line_block(obthis,pcode_blk, lblk)				\
				(((POB_PCODE_BLK) (pcode_blk))->ts.thread_line_block = (POB_PCODE_LINE_NODE) (lblk))

#define ob_get_pcode_max_stack(obthis,pcode_blk)					\
				(((POB_PCODE_BLK) (pcode_blk))->ps.max_stack_depth)

#define ob_set_pcode_max_stack(obthis,pcode_blk, sdepth)				\
				(((POB_PCODE_BLK) (pcode_blk))->ps.max_stack_depth = (USHORT)(sdepth))


//****************************************************************************
// Function prototypes
//****************************************************************************

#ifdef    __cplusplus
	extern "C" {
#endif    /* __cplusplus */

		PBWINAPI(POB_PCODE_BLK, ob_init_pcode_blk)
			(
				POB_THIS 		obthis,
				UINT 			no_items,
				UINT			no_line_incr,
				OB_SUBPOOL 		subpool
				);

		INT 					ob_delete_pcode_info
		(
			POB_THIS 		obthis,
			POB_PCODE_BLK	pcode_blk
		);

		PBWINAPI(VOID, ob_del_pcode_blk)
			(
				POB_THIS 		obthis,
				POB_PCODE_BLK 	pcode_blk
				);

		OB_ERROR		   		ob_pcode_write
		(
			POB_THIS 		obthis,
			POB_PCODE_BLK 	complex
		);

		POB_PCODE_BLK			ob_pcode_read
		(
			POB_THIS 		obthis,
			UINT 			lenincr,
			UINT			line_no_incr,
			OB_SUBPOOL 		subpool
		);

		POB_PCODE_BLK			ob_get_pcode_blk
		(
			POB_THIS 		obthis
		);

#ifdef    __cplusplus
	}	// extern "C" {
#endif    /* __cplusplus */


#endif // OBPCODE_H



// DOINC popped back into header 'obroutin.h'
#endif
#ifndef OBALLOC_H
// ***** DOINC including oballoc.h *****
	// DOINC skipping duplicate include
#endif

//****************************************************************************
// Permanent Structure for routine list node
//****************************************************************************

	typedef struct ob_perm_routnode
	{
		USHORT				status;				// Status of node.
		OB_PROTO_ID			proto_id;

	} OB_PERM_ROUTNODE, FAR* POB_PERM_ROUTNODE;

	//****************************************************************************
	// Temporary Structure for routine list node
	//****************************************************************************

	typedef struct ob_routnode
	{
		POB_PERM_ROUTNODE		perm_entry;			// Pointer to parallel permanent entry.
		LPTSTR					source;				// Routine source
		UINT					len;	  			// Routine source length
		POB_PCODE_BLK			pcode;				// Pointer to p-code block.
		OB_LOOK_SYMTAB			rout_symtab;		// Routine symbol table.
		POB_CONPOOL				local_conpool;		// Local constant pool.

	} OB_ROUTNODE, FAR* POB_ROUTNODE;

	//****************************************************************************
	// Structure for routine lists
	//****************************************************************************


	typedef struct ob_perm_routlist
	{
		USHORT					no_slots;			// Number of slots in list.

	} OB_PERM_ROUTLIST;

	typedef struct ob_temp_routlist
	{
		POB_ROUTNODE			list;			   	// Pointer to actual list.
		UINT					alloc_incr;			// Allocation increment.
		UINT					alloc_size;			// Current allocation size.
		POB_PERM_ROUTNODE		perm_list;			// Pointer to actual list.
		UINT					perm_alloc_incr;	// Allocation increment.
		UINT					perm_alloc_size;	// Current allocation size.
		UINT					slot_incr;			// No of slots to increment.
		UINT					next_free;			// Next free slot.
	} OB_TEMP_ROUTLIST;

	typedef struct ob_routlist
	{
		OB_PERM_ROUTLIST		ps;
		OB_TEMP_ROUTLIST		ts;

	} OB_ROUTLIST, FAR* POB_ROUTLIST;


	//****************************************************************************
	// Macro definitions
	//****************************************************************************

#define ob_get_no_routlist_slots(routlist)								\
				((routlist)->ps.no_slots)

#define ob_get_routine(routlist,slot_no)								\
				((routlist)->ts.list + (ob_get_routid(slot_no)))

#define ob_get_curr_routnode(obthis)									\
				((POB_ROUTNODE) ((obthis)->curr_routnode))

#define ob_set_curr_routnode(obthis,routnode)							\
				((obthis)->curr_routnode = (routnode))

#define ob_get_routine_status(obthis,routnode) 							\
				((OB_STATUS) ((routnode)->perm_entry->status))

#define ob_set_routine_status(obthis,routnode,statval) 					\
				((routnode)->perm_entry->status = (USHORT) (statval))

#define ob_get_routine_proto_id(obthis,routnode) 						\
				((routnode)->perm_entry->proto_id)

#define ob_set_routine_proto_id(obthis,routnode,idval) 					\
				((routnode)->perm_entry->proto_id = (OB_PROTO_ID) (idval))

#define ob_get_routine_symtab(obthis,routnode) 							\
				(&(routnode)->rout_symtab)

//****************************************************************************
// Function prototypes
//****************************************************************************

#ifdef    __cplusplus
	extern "C" {
#endif    /* __cplusplus */

		POB_ROUTLIST 							ob_init_routlist
		(
			POB_THIS 						obthis,
			UINT 							noslots,
			OB_SUBPOOL 						subpool
		);

		OB_ROUT_ID								ob_reserve_routines
		(
			POB_THIS 						obthis,
			POB_ROUTLIST 					routlist,
			UINT 							no_routs,
			OB_SUBPOOL 						subpool
		);

		OB_ROUT_ID 								ob_add_routine
		(
			POB_THIS 						obthis,
			POB_ROUTLIST 					routlist,
			OB_ROUT_TYPE 					routtype,
			OB_PROTO_ID 					proto_id,
			OB_SUBPOOL 						subpool
		);

		OB_ROUT_ID								ob_search_routlist
		(
			POB_THIS 						obthis,
			POB_ROUTLIST 					routlist,
			OB_PROTO_ID						proto_id
		);

		POB_ROUTNODE							ob_copy_routine
		(
			POB_THIS 						obthis,
			POB_GROUP						group,
			POB_ROUTNODE					old_routine,
			OB_SUBPOOL						subpool
		);

		INT 									ob_del_routine_copy
		(
			POB_THIS 						obthis,
			POB_ROUTNODE					routine
		);

		VOID 									ob_del_routlist
		(
			POB_THIS 						obthis,
			POB_ROUTLIST 					routlist
		);

		VOID 									ob_del_routine
		(
			POB_THIS 						obthis,
			POB_ROUTNODE 					routine
		);

		INT 									ob_delete_routlist_pcode
		(
			POB_THIS 						obthis,
			POB_ROUTLIST 					routlist
		);

		PBWINAPI(VOID, ob_reuse_routine)
			(
				POB_THIS 						obthis,
				POB_ROUTLIST 					routlist,
				OB_ROUT_ID 						rout_id,
				OB_PROTO_ID 					proto_id,
				OB_SUBPOOL 						subpool,
				BOOL							clear_pcode
				);

		OB_ERROR		   						ob_routlist_write
		(
			POB_THIS 						obthis,
			POB_ROUTLIST 					routlist
		);

		POB_ROUTLIST							ob_routlist_read
		(
			POB_THIS 						obthis,
			UINT 							slot_incr,
			OB_SUBPOOL 						subpool
		);


#ifdef    __cplusplus
	}	// extern "C" {
#endif    /* __cplusplus */


#endif // OBROUTIN_H


// DOINC popped back into header 'obtypdef.h'
#endif
#ifndef OBLKSYM_H
// ***** DOINC including oblksym.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBERROR_H
// ***** DOINC including oberror.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBJAPI_H
// ***** DOINC including objapi.h *****
//**************************************************************************
//
//                            Copyright 1989
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :	objapi.h
//
//    Author   :	Jim Kosko
//
//    Purpose  : 	Object manager API definitions
//
//****************************************************************************

#ifndef OBJAPI_H
#define OBJAPI_H

//****************************************************************************
// Includes
//****************************************************************************
#ifndef OSPASCAL_H
// ***** DOINC including ospascal.h *****
	// DOINC skipping duplicate include
#endif
#ifndef PBSTG_H
// ***** DOINC including pbstg.h *****
	// DOINC skipping duplicate include
#endif
#ifndef SHDEC_H
// ***** DOINC including shdec.h *****
//**************************************************************************
//
//                            Copyright 2004
//                              Sybase Inc.
//
//                              Copyright ?2004
//                      Sybase, Inc. and its subsidiaries.
//  -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -
//  Sybase, Inc.("Sybase") claims copyright in this program and documentation
//  as an unpublished work, versions of which were first licensed on the date
//  indicated in the foregoing notice. This claim of copyright does not imply
//  waiver of Sybase's other rights.
//  -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -
//
//    Filename :    shdec.h
//
//    Author   :    PB kernel team
//
//    Purpose  :    Structure and declarations for PB decimal type
//
//****************************************************************************


#ifndef SHDEC_H
#define SHDEC_H

#ifdef __cplusplus
	extern "C" {
#endif

		// ***** DOINC including osstdlib.h *****
			// DOINC skipping duplicate include

		// fields description of SH_DEC structure
		// flags:
		// bit offset   desc
		// 0            sign, 1 is negative
		// 1            overflow
		// 2            underflow
		// 3            divide by zero
		// 4            undetermined such as 0/0
		// 5-7          unused
		// 8-12         precision 0-30, the max digits after zero point is 30. 31 is a special number
		// 13-15        unused

		// v:
		// v[0] is lowest
		// v[6] is highest
		// Supported value
		//  0.000,000,000,000,000,000,000,000,000,001 to  999,999,999,999,999,999,999,999,999,999
		//  0
		// -0.000,000,000,000,000,000,000,000,000,001 to -999,999,999,999,999,999,999,999,999,999
		//

		// Public use
#define MAX_DECIMAL_SCALE       30 // It should be the same as OB_MAX_PRECISION in obdefine.h
#define MAX_FRACTION_DIGITS     MAX_DECIMAL_SCALE

// internal use only
#define DEC_ARRAY_LEN           7
#define DEC_SIGN_SHIFT          0
#define DEC_OVERFLOW_SHIFT      1
#define DEC_UNDERFLOW_SHIFT     2
#define DEC_DIVIDE_BY_ZERO_SHIFT    3
#define DEC_UNDETERMINED_SHIFT  4
#define DEC_PRECISION_SHIFT     8

		typedef struct _tagSH_DEC
		{
			USHORT v[DEC_ARRAY_LEN];
			USHORT flags;

		//} DEC, SH_DEC, * PDEC, * PSH_DEC;
		} SH_DEC, * PDEC, * PSH_DEC;

		typedef struct
		{
			short            attr;
			short            id;
			unsigned short   sl[4];
			short            msd;
			short            dummy;
		} OLD_IDEC;

		typedef struct
		{
			short            lattr;
			short            lid;
			unsigned long    lsl[2];
			short            lmsd;
			short            ldummy;
		}  OLD_LDEC;

		typedef union
		{
			OLD_IDEC             dc;
			OLD_LDEC             ls;
		} OLD_DEC, FAR* OLD_PDEC;

		PBWINAPI(const SH_DEC*, sh_MAX_DEC)   ();

		PBWINAPI(PSH_DEC, shMaxDec)      (PSH_DEC dst, PSH_DEC src1, PSH_DEC src2);
		PBWINAPI(PSH_DEC, shMinDec)      (PSH_DEC dst, PSH_DEC src1, PSH_DEC src2);
		PBWINAPI(SHORT, shCompareDec)  (PSH_DEC src1, PSH_DEC src2);

		PBWINAPI(PSH_DEC, shAbsDec)      (PSH_DEC dst, PSH_DEC src);
		PBWINAPI(PSH_DEC, shNegateDec)   (PSH_DEC dst, PSH_DEC src);
		PBWINAPI(PSH_DEC, shRoundDec)    (PSH_DEC dst, PSH_DEC src, SHORT n);
		PBWINAPI(PSH_DEC, shTruncDec)    (PSH_DEC dst, PSH_DEC src, SHORT n);

		PBWINAPI(PSH_DEC, shAddDec)      (PSH_DEC dst, PSH_DEC src1, PSH_DEC src2);
		PBWINAPI(PSH_DEC, shSubDec)      (PSH_DEC dst, PSH_DEC src1, PSH_DEC src2);
		PBWINAPI(PSH_DEC, shMultDec)     (PSH_DEC dst, PSH_DEC src1, PSH_DEC src2);
		PBWINAPI(PSH_DEC, shDivDec)      (PSH_DEC dst, PSH_DEC src1, PSH_DEC src2);
		PBWINAPI(PSH_DEC, shModDec)      (PSH_DEC dst, PSH_DEC src1, PSH_DEC src2);
		PBWINAPI(PSH_DEC, shExpDec)      (PSH_DEC dst, PSH_DEC src1, PSH_DEC src2);

		PBWINAPI(PSH_DEC, shIntToDec)    (PSH_DEC dst, SHORT src);
		PBWINAPI(PSHORT, shDecToInt)    (PSHORT dst, PSH_DEC src);
		PBWINAPI(PSH_DEC, shUintToDec)   (PSH_DEC dst, USHORT src);
		PBWINAPI(PUSHORT, shDecToUint)   (PUSHORT dst, PSH_DEC src);
		PBWINAPI(PSH_DEC, shByteToDec)   (PSH_DEC dst, BYTE src);
		PBWINAPI(PBYTE, shDecToByte)   (PBYTE dst, PSH_DEC src);
		PBWINAPI(PSH_DEC, shLongToDec)   (PSH_DEC dst, LONG src);
		PBWINAPI(PLONG, shDecToLong)   (PLONG, PSH_DEC src);
		PBWINAPI(PSH_DEC, shUlongToDec)  (PSH_DEC dst, ULONG src);
		PBWINAPI(PULONG, shDecToUlong)  (PULONG dst, PSH_DEC src);
		PBWINAPI(PSH_DEC, shLonglongToDec) (PSH_DEC dst, PLONGLONG src);
		PBWINAPI(PLONGLONG, shDecToLonglong) (PLONGLONG dst, PSH_DEC src);
		PBWINAPI(PFLOAT, shDecToFloat)  (PFLOAT dst, PSH_DEC src);
		PBWINAPI(PSH_DEC, shFloatToDec)  (PSH_DEC dst, PFLOAT src);
		PBWINAPI(PSH_DEC, shDoubleToDec) (PSH_DEC dst, PDOUBLE src);
		PBWINAPI(PDOUBLE, shDecToDouble) (PDOUBLE dst, PSH_DEC src);

		PBWINAPI(LPTSTR, shDecToAscii)  (LPTSTR dst, PSH_DEC src);
		PBWINAPI(PSH_DEC, shAsciiToDec)  (PSH_DEC dst, LPTSTR src);
		PBWINAPI(PSH_DEC, shAsciiToDecRnd)  (PSH_DEC dst, LPTSTR src, SHORT n);

		PBWINAPI(VOID, shSetDecFractions)  (PSH_DEC d, SHORT n);
		PBWINAPI(VOID, shSetDecNegative)   (PSH_DEC d, BOOL n);
		PBWINAPI(BOOL, shDecSetOverflow)	(PSH_DEC dec, BOOL neg);

		PBWINAPI(LPTSTR, ConvertOldDecToString) (LPTSTR s, OLD_DEC* pAddress);


#define shDecIsZero(dec)                ( !((dec)->v[0] || \
                                         (dec)->v[1] || \
                                         (dec)->v[2] || \
                                         (dec)->v[3] || \
                                         (dec)->v[4] || \
                                         (dec)->v[5] || \
                                         (dec)->v[6]) )

#define shZeroDec(dec)                  (pbstg_memset((dec), 0, sizeof(SH_DEC)), ((dec)->flags = 0x0200) )

#define shPrecDec(dec)                  ( (((dec)->flags) & 0x1f00) >>DEC_PRECISION_SHIFT )
#define _getFlagsBit(dec, n)            ((BOOL) (( dec->flags & (0x0001 << n) ) ? TRUE : FALSE) )
#define shDecIsNegative(dec)            ((BOOL)(_getFlagsBit((dec), DEC_SIGN_SHIFT) ? TRUE : FALSE) )
#define shDecIsOverflow(dec)            ((BOOL)(_getFlagsBit((dec), DEC_OVERFLOW_SHIFT) ? TRUE : FALSE) )
#define shDecIsUnderflow(dec)           ((BOOL)(_getFlagsBit((dec), DEC_UNDERFLOW_SHIFT) ? TRUE : FALSE) )
#define shDecIsDivideByZero(dec)        ((BOOL)(_getFlagsBit((dec), DEC_DIVIDE_BY_ZERO_SHIFT) ? TRUE : FALSE) )
#define shDecIsUndetermined(dec)        ((BOOL)(_getFlagsBit((dec), DEC_UNDETERMINED_SHIFT) ? TRUE : FALSE) )

#define shCopyDec(dst, src)             (pbstg_memcpy ( (dst), (src), sizeof(SH_DEC) ), (PSH_DEC)(dst))
#define shAllocDec(stg, pool)           ((PSH_DEC) pbstg_alloc ((stg), sizeof(SH_DEC), (pool)))
#define shFreeDec(stg, dst)             (pbstg_free ((stg), (dst)))






#define BCD_MAX 32

		// Converts a Decimal to a Binary Coded Decimal byte array.
		// Currently uses Jaguar CTS representation of BCD
		//
		// pByte points to an array allocated to the maximum length of 32
		//  which will hold 64 digits.
		// pnLen will point to the actual length of pByte that was required.
		// pDec points to the decimal that will be used for the source.
		PBWINAPI_(VOID) shDecToBCD(BYTE* pByte, PULONG pnByteLen, PDEC pDec);
		//
		// Converts a Binary Coded Decimal byte array to a decimal.
		// Currently uses Jaguar CTS representation of BCD
		//
		// pByte points to an array of BCD bytes.
		// nLen will point to the actual length of pByte that was passed in.
		// pDec points to an already allocad decimal that will be filled in
		//  with converted values.
		PBWINAPI_(VOID) shBCDToDec(BYTE* pByte, ULONG nByteLen, PDEC pDec);


#ifdef __cplusplus
	}
#endif



#endif // SHDEC_H
	// DOINC popped back into header 'objapi.h'
#endif
#ifndef SHBINARY_H
// ***** DOINC including shbinary.h *****
	// DOINC skipping duplicate include
#endif
#ifndef SHDT_H
// ***** DOINC including shdt.h *****
//**************************************************************************
//
//                            Copyright 1989-1994
//                        Powersoft Corporation
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM POWERSOFT
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :        shdt.h
//
//    Author   :        Kim Sheffield
//
//    Purpose  :        Date/time routines
//
//****************************************************************************


//****************************************************************************
// Insure file is not included twice
//****************************************************************************

#ifndef SHDT_H
#define SHDT_H

#ifdef __cplusplus
	extern "C" {
#endif

		// Type definitions
		typedef struct
		{
			LONG	tm_msec;           // micro seconds
			SHORT	tm_year;          // year - 1900
			BYTE	tm_mon;            // month
			BYTE	tm_mday;           // day
			BYTE	tm_hour;           // hour
			BYTE	tm_min;            // minutes
			BYTE	tm_sec;            // seconds
			BYTE	tm_filler;         // fill out to even # of characters
		} SH_TIME, FAR* PSH_TIME;

		// if tm_hour == SHTIME_TIME_NULL then time is NULL
#define SHTIME_TIME_NULL ((BYTE) (-1))
// if tm_year == SHTIME_DATE_NULL then date     is NULL
#define SHTIME_DATE_NULL ((SHORT) (-32767))

// Prototypes
		PBWINAPI(BOOL, shdtDayName)(short w_day, LPTSTR lpName);
		PBWINAPI(int, shdtDayOfWeek)(PSH_TIME t);
		PBWINAPI(void, shdtBuildTime)(PSH_TIME fTime1, INT year, BYTE	mon, BYTE day,
			BYTE hour, BYTE min, BYTE sec, LONG msec);

#ifndef GENERATED_CODE_BUILD
		PBWINAPI(void, shdtBuildTimeFromSystemTime)(/*in*/SYSTEMTIME* pSysTime, /*out*/ PSH_TIME fTime);
		PBWINAPI(SYSTEMTIME, shdtBuildSystemTimeFromSHTime)(/*in*/ PSH_TIME fTime);
#endif

		PBWINAPI(long, shdtDiffDate)(PSH_TIME fTime1, PSH_TIME fTime2); // Ret # of days
		PBWINAPI(long, shdtDiffTime)(PSH_TIME fTime1, PSH_TIME fTime2); // Ret # of secs
		PBWINAPI(long, shdtDiffMSec)(PSH_TIME fTime1, PSH_TIME fTime2); // Ret # of msecs diff in msec fields ONLY
#define shdtIsDateNull(dt) ((dt)->tm_year == SHTIME_DATE_NULL)
#define shdtIsTimeNull(dt) ((dt)->tm_hour == SHTIME_TIME_NULL)
		PBWINAPI(void, shdtNow)(PSH_TIME fTime); // Returns current time/date
		PBWINAPI(int, shdtParse)(PSH_TIME fTime, LPTSTR sTime, int flags);
		PBWINAPI(int, shdtParseEx)(PSH_TIME fTime, LPTSTR sTime, int flags, LPTSTR dwCultureFormat);
		PBWINAPI(int, shdtParseStringEx)(PSH_TIME fTime, LPTSTR sTime, int flags, BOOL bStrictly);//CR386540
		PBWINAPI(int, shdtParseStringExWithLcid)(PSH_TIME fTime, LPTSTR sTime, int flags, BOOL bStrictly, int uInLcid);
		//CR338987,parse date time to string according the system setting,it is a reverse function of  shdtParse
		// Fortify SCA: (Assert) sTime must be a string buffer of at least 50 characters
		PBWINAPI(void, shdtParseToString)(PSH_TIME fTime, LPTSTR sTime, int flags);
		PBWINAPI(void, shdtRelativeDate)(PSH_TIME oDate, PSH_TIME iDate, long dayCount);
		PBWINAPI(void, shdtToMJDDate)(PSH_TIME pDate, PDOUBLE pMJDDate);
		PBWINAPI(void, shdtToMJDTime)(PSH_TIME pTime, PDOUBLE pMJDTime);
		PBWINAPI(void, shdtToMJDTimestamp)(PSH_TIME pDateTime, PDOUBLE pMJDDate, PDOUBLE pMJDTime);
		PBWINAPI(void, shMJDDateTodt)(PSH_TIME pDate, DOUBLE MJDDate);
		PBWINAPI(void, shMJDTimeTodt)(PSH_TIME pTime, DOUBLE MJDTime);
		PBWINAPI(void, shMJDTimestampTodt)(PSH_TIME pDateTime, DOUBLE MJDDate,
			DOUBLE MJDTime);

#ifdef PS_DBCS
#define shdtSetDateNull(dt) (dt)->tm_year = SHTIME_DATE_NULL, (dt)->tm_filler = 0
#else
#define shdtSetDateNull(dt) (dt)->tm_year = SHTIME_DATE_NULL
#endif

#define shdtSetTimeNull(dt) (dt)->tm_hour = SHTIME_TIME_NULL
		PBWINAPI(void, shdtString)(LPTSTR sdate, LPTSTR stime);

		// Flags for shdtParse
#define DTDATETIME  1       // date time
#define DTDATE      2       // date only
#define DTTIME      3       // time only

// DateTimeKind support 
#define   DTKIND_UNSPECIFIED              0x00
#define   DTKIND_LOCAL		              0x01
#define   DTKIND_UTC		              0x02
#define   DTKIND_ISUTC(p)				((p)->tm_filler & DTKIND_UTC)
#define   DTKIND_ISUNSPECIFIED(p)		(((p)->tm_filler & DTKIND_UNSPECIFIED) == 0)
#define   DTKIND_ISLOCAL(p)				((p)->tm_filler & DTKIND_LOCAL)

// Return codes from shdtParse
#define DTOK        0
#define DTERRDAY    1       // Day does not fall into proper range for month
#define DTERRMONTH  2       // Month does not fall into proper range
#define DTERRSECOND 3       // Second not between 0 and 60
#define DTERRMINUTE 4       // Minute not between 0 and 60
#define DTERRHOUR   5       // Hour not between 0 and 23
#define DTERR       6       // Unspecified error
#define DTERRYEAR   7       // Invalid year
#define DTERRMSECOND 8          // Micro second not between 0 and 999999

#ifdef __cplusplus
	} // extern "C"
#endif

#endif // SHDT_H
// DOINC popped back into header 'objapi.h'
#endif
#ifndef OBDEFINE_H
// ***** DOINC including obdefine.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBDATA_H
// ***** DOINC including obdata.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBTHIS_H
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBERROR_H
// ***** DOINC including oberror.h *****
	// DOINC skipping duplicate include
#endif
#ifndef PBCOM_H
// ***** DOINC including pbcom.h *****
	// DOINC skipping duplicate include
#endif

//****************************************************************************
// Assume C declarations for C++
//****************************************************************************

#ifdef __cplusplus
	extern "C" {
#endif	/* __cplusplus */

		//****************************************************************************
		// Variable access structure
		//****************************************************************************

		/*lint -e10 */

		//****************************************************************************
		// Data info flags masks and shifts
		//****************************************************************************

#define DATA_INFO_CONSTANT_MASK		0x0001				// 1 bit
#define DATA_INFO_INDIRECT_MASK		0x0002				// 1 bit
#define DATA_INFO_ISWRITE_MASK		0x0004				// 1 bit
#define DATA_INFO_ISREAD_MASK		0x0008				// 1 bit
#define DATA_INFO_ISINHERITED_MASK	0x0010				// 1 bit
#define DATA_INFO_ISSYSTEM_MASK		0x0020				// 1 bit
#define DATA_INFO_ISINSTANCE_MASK	0x0040				// 1 bit
#define DATA_INFO_ISPROPERTY_MASK	0x0080				// 1 bit

#define DATA_INFO_CONSTANT_SHIFT	0
#define DATA_INFO_INDIRECT_SHIFT   	1
#define DATA_INFO_ISWRITE_SHIFT   	2
#define DATA_INFO_ISREAD_SHIFT   	3
#define DATA_INFO_ISINHERITED_SHIFT	4
#define DATA_INFO_ISSYSTEM_SHIFT	5
#define DATA_INFO_ISINSTANCE_SHIFT	6
#define DATA_INFO_ISPROPERTY_SHIFT	7


		typedef struct ob_data_info
		{
			OB_SYM_ID			sym_id;
			LPTSTR				name;
			OB_CLASS_HNDL		class_hndl;
			OB_DATA				data;
			LPTSTR				enumname;
			OB_MEMBER_ACCESS	scope;			// public, protected, etc.
			OB_MEMBER_ACCESS	read_access; 	// protected = protectedread, etc.
			OB_MEMBER_ACCESS	write_access;	// protected = protectedwrite, etc.
			UINT				flags;			// constant and indirect
			LPTSTR				set_func;
			LPTSTR				get_func;
			PVOID				lookupObject;	// if ISPROPERTY set rtinst else symtab
			PVOID				pWatchpoint;	// NULL id no data watchpoint
			// isArrayElement and arrayIndex are only used by the debugger for data watchpoints
			BOOL				isArrayElement;	// true if the sym_id is for an array and this is the element
			// This is a column-major linearized index for the array element
			LONG				arrayIndex;
			LPTSTR				array_set_func;
			LPTSTR				array_get_func;
			LPTSTR				array_upper_func;
		} OB_DATA_INFO, FAR* POB_DATA_INFO;

#define ob_get_data_info_constant(flags)   \
	ob_get_bitfield(flags,INT,DATA_INFO_CONSTANT_SHIFT,DATA_INFO_CONSTANT_MASK)

#define ob_get_data_info_indirect(flags)   \
	ob_get_bitfield(flags,INT,DATA_INFO_INDIRECT_SHIFT,DATA_INFO_INDIRECT_MASK)

#define ob_get_data_info_iswrite(flags)   \
	ob_get_bitfield(flags,INT,DATA_INFO_ISWRITE_SHIFT,DATA_INFO_ISWRITE_MASK)

#define ob_get_data_info_isread(flags)   \
	ob_get_bitfield(flags,INT,DATA_INFO_ISREAD_SHIFT,DATA_INFO_ISREAD_MASK)

#define ob_get_data_info_isinherit(flags)   \
	ob_get_bitfield(flags,INT,DATA_INFO_ISINHERITED_SHIFT,DATA_INFO_ISINHERITED_MASK)

#define ob_get_data_info_issystem(flags)   \
	ob_get_bitfield(flags,INT,DATA_INFO_ISSYSTEM_SHIFT,DATA_INFO_ISSYSTEM_MASK)

#define ob_get_data_info_isinstance(flags)   \
	ob_get_bitfield(flags,INT,DATA_INFO_ISINSTANCE_SHIFT,DATA_INFO_ISINSTANCE_MASK)

#define ob_get_data_info_isproperty(flags)   \
	ob_get_bitfield(flags,INT,DATA_INFO_ISPROPERTY_SHIFT,DATA_INFO_ISPROPERTY_MASK)

#define ob_set_data_info_constant(flags,cval)   \
	ob_set_bitfield(flags,INT,cval,DATA_INFO_CONSTANT_SHIFT,DATA_INFO_CONSTANT_MASK)

#define ob_set_data_info_indirect(flags,ival)   \
	ob_set_bitfield(flags,INT,ival,DATA_INFO_INDIRECT_SHIFT,DATA_INFO_INDIRECT_MASK)

#define ob_set_data_info_iswrite(flags,ival)   \
	ob_set_bitfield(flags,INT,ival,DATA_INFO_ISWRITE_SHIFT,DATA_INFO_ISWRITE_MASK)

#define ob_set_data_info_isread(flags,ival)   \
	ob_set_bitfield(flags,INT,ival,DATA_INFO_ISREAD_SHIFT,DATA_INFO_ISREAD_MASK)

#define ob_set_data_info_isinherit(flags,ival)   \
	ob_set_bitfield(flags,INT,ival,DATA_INFO_ISINHERITED_SHIFT,DATA_INFO_ISINHERITED_MASK)

#define ob_set_data_info_issystem(flags,ival)   \
	ob_set_bitfield(flags,INT,ival,DATA_INFO_ISSYSTEM_SHIFT,DATA_INFO_ISSYSTEM_MASK)

#define ob_set_data_info_isinstance(flags,ival)   \
	ob_set_bitfield(flags,INT,ival,DATA_INFO_ISINSTANCE_SHIFT,DATA_INFO_ISINSTANCE_MASK)

#define ob_set_data_info_isproperty(flags,ival)   \
	ob_set_bitfield(flags,INT,ival,DATA_INFO_ISPROPERTY_SHIFT,DATA_INFO_ISPROPERTY_MASK)

		/*lint +e10 */

		//****************************************************************************
		// Function info structure
		//****************************************************************************

		typedef struct ob_arg_info
		{
			LPTSTR			   	argname;		   	// Function argument name
			LPTSTR			   	datatype;			// Function argument data type
			OB_PROTOARG_TYPE	argtype;		   	// Reference or Value arg?
			OB_GROUPTYPE	   	grouping;			// OB_ARRAY or OB_SIMPLE?
			LPTSTR			   	array_bounds; 		// Array bounds string

		} OB_ARG_INFO, FAR* POB_ARG_INFO;

		//****************************************************************************
		// Class info structure
		//****************************************************************************

		typedef struct ob_class_info
		{
			LPTSTR			   	classname;
			OB_CLASS_HNDL		class_hndl;

		} OB_CLASS_INFO, FAR* POB_CLASS_INFO;

		//****************************************************************************
		// Event info structure
		//****************************************************************************

		typedef struct ob_event_info
		{
			LPTSTR			   	event_name;
			LPTSTR			   	token_name;
			OB_CLASS_HNDL		class_hndl;
			OB_VTABLE_ID		vtable_id;
		} OB_EVENT_INFO, FAR* POB_EVENT_INFO;

		//****************************************************************************
		//	Function call type
		//****************************************************************************

		typedef enum
		{
			OB_SYSFUNC_CALL,   			// System function call
			OB_DLLFUNC_CALL,   			// DLL function call
			OB_GLOBFUNC_CALL,  			// External user function call
			OB_OBJFUNC_CALL,   			// Object function call (object in 1st arg)
			OB_LOCALFUNC_CALL, 		  	// Object function call (in current object)
			OB_PARENTFUNC_CALL,			// Object function call (in within object)
			OB_PRIMARYFUNC_CALL			// Object function call (in primary object)

		} OB_CALL_TYPE, FAR* POB_CALL_TYPE;

		//****************************************************************************
		// Prototype reference error type
		//****************************************************************************

		typedef enum
		{
			OB_PROTOREF_OK,		  		// No Error
			OB_PROTOREF_NOTFOUND,  		// Prototype not found
			OB_PROTOREF_BADNOARGS,	  	// Prototype has wrong no. of arguments
			OB_PROTOREF_BADARGS,		// Prototype has incorrect arguments
			OB_PROTOREF_INACCESSABLE,  	// Prototype can be accessed from here.
			OB_PROTOREF_BADREFARG,	  	// Reference argument is passed incorrectly.
			OB_PROTOREF_BAD,			// Something bad, version error, etc.
			OB_PROTOREF_BADREFTYPE,	  	// Prototype has bad reference argument type
			OB_PROTOREF_BADOVERLOAD,	// Prototype has conflicting overloading
			OB_PROTOREF_ANCREFTYPE,		// Prototype was passed auto ancestor by reference
			OB_PROTOREF_AMBIGUOUS		// Conflicting match prototypes found

		} OB_PROTOREF_ERROR, FAR* POB_PROTOREF_ERROR;

		//****************************************************************************
		// Function call info structure
		//****************************************************************************

		typedef struct ob_funccall_info
		{
			LPTSTR			   	funcname;
			POB_CLASS_ID		argtypes;
			UINT			   	no_args;
			OB_CLASS_ID			functype;
			UINT			   	id;
			OB_CALL_TYPE		calltype;
			LPTSTR			   	dllname;
			OB_GROUP_HNDL		group_id;
			OB_CLASS_ID			class_id;

		} OB_FUNCCALL_INFO, FAR* POB_FUNCCALL_INFO;

		//****************************************************************************
		// Array info typedefs
		//
		//	NOTE:	dimensions array at end of ARRAY_INFO struct will be allocated to
		//			a length of no_dims.
		//****************************************************************************

		typedef struct ob_array_dim
		{
			INT		upbound;
			INT		lowbound;

		} OB_ARRAY_DIM, FAR* POB_ARRAY_DIM;

		/*lint -e43 */

		typedef struct ob_array_info_tag
		{
			PVOID				array_data;
			UINT				no_dims;
			OB_ARRAY_DIM		dimensions[1];

		} OB_ARRAY_INFO, FAR* POB_ARRAY_INFO;

		//****************************************************************************
		// Enum info structure
		//****************************************************************************

		typedef struct ob_enum_info
		{
			LPTSTR				name;
			INT					value;

		} OB_ENUM_INFO, FAR* POB_ENUM_INFO;

		/*lint +e43 */

		//****************************************************************************
		// Structures for executable creation
		//****************************************************************************

		typedef enum ob_mac_target
		{
			OB_MAC_POWERPC_TARGET = 0,
			OB_MAC_68K_TARGET,
			OB_MAC_FAT_TARGET
		} OB_MAC_TARGET;

		typedef enum ob_exec_optimize
		{
			OB_OPTIMIZE_SPEED = 0,
			OB_OPTIMIZE_SPACE,
			OB_OPTIMIZE_NONE,
			OB_OPTIMIZE_DEBUG
		} OB_EXEC_OPTIMIZE;

		typedef enum ob_exec_category
		{
			EXEC_CHECKING_REFERENCES = 0,		// Checking application references...
			EXEC_WRITING_OBJECT,					// Writing object <group name> ...
			EXEC_GENERATING_CODE_FOR_OBJECT,		// Generating code for object <group name> ...
			EXEC_COMPILING_FILE,					// Compiling generated code (<file name>) ...
			EXEC_LINKING							// Linking (<file name>) ...
		} OB_EXEC_STAGE;

		typedef struct ob_exec FAR* POB_EXEC;

		// this callback is used to track the progress of the executable build
		typedef PBCALLBACK(BOOL, *OB_EXEC_CALLBACK) (POB_EXEC);

		typedef struct ob_exec
		{
			BOOL			  	bBuildExe;			// Building an EXE (or a DLL)
			BOOL			  	bBuildInterfaceLib;	// Build an interface library, only valid if bBuildExe = FALSE
			BOOL			  	bGenerateCode;		// Generate and compile C code
			BOOL			  	bGenLineInfo;		// Generate Line information
			BOOL			  	bGenTrace;			// Generate Trace information
			BOOL			  	bGen16bit;			// Generate 16 bit executable
			BOOL			  	bOpenServer;		// Application uses open server libs
			OB_EXEC_OPTIMIZE	eOptimize;			// level of optimization
			OB_MAC_TARGET		eMacTarget;			// Macintosh target for compiler

			LPTSTR             	lpszExeName;        // Executable name
			LPTSTR             	lpszIconName;       // Icon or .pbl name

			PVOID             	pLibList;           // Library list
			PVOID             	pGlobals;           // Pointer to PB globals
			PVOID             	hParent;            // Handle to parent window

			INT					iErrorCode;			// exe creation error code
			LPTSTR				lpszErrorArg;		// error argument string is NOT
													// owned, DON'T free it.
			//XP Enhancement - Start
			BOOL    bNewVisualStyleControls;		// Generate New Visual Controls Style
			//XP Enhancement - End

			// message line callback stuff
			OB_EXEC_STAGE		execStage;			// the stage of generation
			LPTSTR				lpszStageArgument;	// the name to be included in the message
			LPTSTR				lpszLibraryName;	// the library name of the entity
			OB_EXEC_CALLBACK	fnCallback;			// the callback for tracking progress

			// skyhook for private generation stuff
			PVOID				pCodeGen;			// pointer to code gen struct
			BOOL				bGenerateCodeOnly;	// Indicates that code should only be gen'd not compiled or linked

			// Version info
			LPTSTR				lpszCompany;		// Company Name
			LPTSTR				lpszDescription;	// Product Description
			LPTSTR				lpszCopyright;		// Legal Copyright
			LPTSTR				lpszProduct;		// Product Name
			LPTSTR				lpszVersion;		// Product Version description string
			LPTSTR				lpszVersionNum;		// Product Version
			LPTSTR				lpszFileVersion;	// File Version description string
			LPTSTR				lpszFileVersionNum;	// File Version
		} OB_EXEC;

		// FALSE from the callback indicates that we should abort
#define OB_EXEC_AT_STAGE( ob_exec, stage, arg, libName ) \
	( ( (ob_exec)->fnCallback != NULL ) ? \
		( \
		(ob_exec)->execStage 			= (stage), \
		(ob_exec)->lpszStageArgument 	= (arg), \
		(ob_exec)->lpszLibraryName 		= (libName), \
		(ob_exec)->fnCallback( (ob_exec) ) \
		) : TRUE )

		typedef struct ob_exec_lib
		{

			BOOL              bDynamic;               // Dynamic switch
			LPTSTR             lpszLibName;            // Library name
			LPTSTR			  lpszDynamicLibFile;	  // Dynamic library name
			LPTSTR			  lpszResFile;			  // Resource file name

		} OB_EXEC_LIB, FAR* POB_EXEC_LIB;


		//****************************************************************************
		// Conflict list structure.
		//****************************************************************************

		typedef struct ob_conflict_list
		{
			OB_ERROR	   		error_type;		   	 // Type of error
			LPTSTR		   		original_group_name; // Group where name originated
			LPTSTR		   		conflict_group_name; // Group where conflict occurs
			LPTSTR		   		class_name;			 // Conflicting name

		} OB_CONFLICT_LIST, FAR* POB_CONFLICT_LIST;

		//****************************************************************************
		// Typedef for source block
		//****************************************************************************

		typedef TCHAR HUGEPTR* POB_SOURCE_BLOCK;

		//****************************************************************************
		// Compile list structure
		//****************************************************************************

		typedef struct ob_compile_list
		{
			LPTSTR				lib_name;
			LPTSTR				entry_name;

		} OB_COMPILE_LIST, FAR* POB_COMPILE_LIST;

		//****************************************************************************
		// Compile list structure
		//****************************************************************************

		typedef struct ob_hierarchy_list
		{
			LPTSTR				class_name;
			OB_CLASS_HNDL		class_hndl;
			UINT				parent_loc;		// Points to another entry on list.
												// -1 if no parent.

		} OB_HIERARCHY_LIST, FAR* POB_HIERARCHY_LIST;


		//****************************************************************************
		// Field type filter
		//****************************************************************************

		typedef enum ob_field_filter
		{
			OB_ANY_FIELDS,
			OB_INSTANCE_FIELDS_ONLY,
			OB_TYPEDEF_FIELDS_ONLY

		} OB_FIELD_FILTER, FAR* POB_FIELD_FILTER;

		//****************************************************************************
		// Structures for application reports
		//****************************************************************************

		typedef struct ob_appl_report
		{

			LPTSTR           lpszLibraryName;        // Library name
			LPTSTR           lpszName;               // Name
			PVOID           pList;                  // Entry list
			UINT            iType;                  // Type
			BOOL	  		bIsInstanced;	  		// TRUE if entry instantiated

		} OB_APPL_REPORT, FAR* POB_APPL_REPORT;

		//****************************************************************************
		// Object manager utility functions
		//****************************************************************************

		PBWINAPI(POB_THIS, ob_mgr_init)
			(
				PSH_DBG_THIS  				dbgthis,
				ppbstg_anchor 				stgthis
				);

		PBWINAPI(POB_THIS, ob_mgr_init_ex)
			(
				PSH_DBG_THIS  				dbgthis,
				ppbstg_anchor 				stgthis,
				LPTSTR						lpstrTypdefPblName
				);

		PBWINAPI(VOID, ob_mgr_restart)
			(
				POB_THIS  					obthis
				);

		PBWINAPI(VOID, ob_mgr_terminate)
			(
				POB_THIS 					obthis
				);

		PBWINAPI(VOID, ob_free_memory)
			(
				POB_THIS 					obthis,
				PVOID 						data
				);

		PBWINAPI(VOID, ob_free_link_error_list)
			(
				POB_THIS 					obthis
				);

		PBWINAPI(PVOID, ob_get_link_error_list)
			(
				POB_THIS 					obthis
				);

		// NOTE: the critical section should not contain anything that would cause
		//       a context switch under WIN16!!!
		PBWINAPI(VOID, ob_enter_critical_section)
			(
				POB_THIS 					obthis
				);

		PBWINAPI(VOID, ob_leave_critical_section)
			(
				POB_THIS 					obthis
				);

		//****************************************************************************
		// Object manager memory management functions
		//		ob_alloc_<TYPE>   - used to allocate memory for an object manager value
		//		ob_realloc_<TYPE) - used to reallocate memory for an object manager value
		//		ob_free_value     - frees a value allocated using ob_alloc_value
		//		ob_free_memory    - frees non value memory such as reports, lib lists,
		//							and info structures
		//****************************************************************************

		PBWINAPI(LPTSTR, ob_alloc_string)
			(
				POB_THIS 					obthis,
				ULONG						len
				);

		PBWINAPI(PSH_BINARY, ob_alloc_blob)
			(
				POB_THIS 					obthis,
				ULONG						len
				);

		PBWINAPI(PSH_DEC, ob_alloc_dec)
			(
				POB_THIS 					obthis
				);

		PBWINAPI(PDOUBLE, ob_alloc_double)
			(
				POB_THIS 					obthis
				);

		PBWINAPI(PLONGLONG, ob_alloc_longlong)
			(
				POB_THIS 					obthis
				);

		PBWINAPI(PSH_TIME, ob_alloc_time)
			(
				POB_THIS 					obthis
				);

		PBWINAPI(LPTSTR, ob_realloc_string)
			(
				POB_THIS 					obthis,
				LPTSTR						string,
				ULONG						len
				);

		PBWINAPI(PSH_BINARY, ob_realloc_blob)
			(
				POB_THIS 					obthis,
				PSH_BINARY					blob,
				ULONG						len
				);

		PBWINAPI(LPTSTR, ob_dup_string)
			(
				POB_THIS 					obthis,
				LPTSTR						string
				);

		PBWINAPI(PSH_BINARY, ob_dup_blob)
			(
				POB_THIS 					obthis,
				PSH_BINARY					blob
				);

		PBWINAPI(PSH_DEC, ob_dup_dec)
			(
				POB_THIS 					obthis,
				PSH_DEC						dec_val
				);

		PBWINAPI(PDOUBLE, ob_dup_double)
			(
				POB_THIS 					obthis,
				PDOUBLE						double_val
				);

		PBWINAPI(PLONGLONG, ob_dup_longlong)
			(
				POB_THIS 					obthis,
				PLONGLONG						longlong_val
				);

		PBWINAPI(PSH_TIME, ob_dup_time)
			(
				POB_THIS 					obthis,
				PSH_TIME					time_val
				);

		PBWINAPI(VOID, ob_free_value)
			(
				POB_THIS 					obthis,
				PVOID 						data
				);

		PBWINAPI(VOID, ob_free_memory)
			(
				POB_THIS 					obthis,
				PVOID 						data
				);

		//****************************************************************************
		// Object manager application/object report functions
		//****************************************************************************

		PBWINAPI(POB_APPL_REPORT, ob_create_appl_report)
			(
				POB_THIS 					obthis
				);

		PBWINAPI(POB_APPL_REPORT, ob_create_object_report)
			(
				POB_THIS         	       	obthis,
				LPTSTR               	   	lib_name,
				LPTSTR                   	object_name,
				OB_CLASS_ID             	class_id
				);

		PBWINAPI(VOID, ob_free_appl_report)
			(
				POB_THIS 					obthis,
				POB_APPL_REPORT 			appl_report
				);

		//****************************************************************************
		// Object manager mode functions
		//****************************************************************************

		PBWINAPI(OB_MODE, ob_get_mode)
			(
				POB_THIS 					obthis
				);

		PBWINAPI(OB_MODE, ob_set_mode)
			(
				POB_THIS 					obthis,
				OB_MODE 					mode
				);

		//****************************************************************************
		// Data Field Access Functions
		//****************************************************************************

		PBWINAPI(POB_DATA, ob_get_field)
			(
				POB_THIS 			obthis,
				OB_INST_ID 			obinst,
				UINT 				field_id,
				POB_DATA			pData
				);

		PBWINAPI(VOID, ob_set_field)
			(
				POB_THIS			obthis,
				OB_INST_ID			obinst,
				UINT				field_id,
				POB_DATA			pData
				);

		// DO NOT USE THE ob_get_field_data function, use the one above instead

		PBWINAPI(POB_DATA, ob_get_field_data)
			(
				POB_THIS 					obthis,
				OB_INST_ID 					obinst,
				UINT 						field_id
				);

		PBWINAPI(ULONG, ob_get_no_fields)
			(
				POB_THIS 			obthis,
				OB_INST_ID 			obinst
				);

		PBWINAPI(OB_INST_ID, ob_get_parent_obinst)
			(
				POB_THIS   	  		obthis,
				OB_INST_ID			obinst
				);

		PBWINAPI(ULONG, ob_get_first_user_field)
			(
				POB_THIS 			obthis,
				OB_INST_ID 			obinst
				);
		//cr 340943
		PBWINAPI(BOOL, ob_group_is_normalized_window)
			(
				POB_THIS       obthis,                     // This pointer
				OB_INST_ID  obInst                  // on inst ID
				);
		PBWINAPI(VOID, ob_group_set_normalized_window)
			(
				POB_THIS       obthis,                     // This pointer
				OB_INST_ID  obInst,                  // on inst ID
				BOOL bValue
				);
		//END cr340943

		PBWINAPI(OB_CLASS_ID, ob_get_field_type)
			(
				POB_THIS 		obthis,
				OB_INST_ID 		obinst,
				UINT			field_id
				);

		PBWINAPI(INT, ob_get_int_field)
			(
				POB_THIS 					obthis,
				OB_INST_ID 					obinst,
				UINT 						field_id
				);

		PBWINAPI(UINT, ob_get_uint_field)
			(
				POB_THIS 					obthis,
				OB_INST_ID 					obinst,
				UINT 						field_id
				);

		PBWINAPI(BYTE, ob_get_byte_field)
			(
				POB_THIS 		obthis,
				OB_INST_ID 		obinst,
				UINT			field_id
				);

		PBWINAPI(LONG, ob_get_long_field)
			(
				POB_THIS 					obthis,
				OB_INST_ID 					obinst,
				UINT 						field_id
				);

		PBWINAPI(ULONG, ob_get_ulong_field)
			(
				POB_THIS 					obthis,
				OB_INST_ID 					obinst,
				UINT 						field_id
				);

		PBWINAPI(PFLOAT, ob_get_float_field)
			(
				POB_THIS 					obthis,
				OB_INST_ID 					obinst,
				UINT 						field_id,
				PFLOAT 						fl
				);

		PBWINAPI(PVOID, ob_get_ptr_field)
			(
				POB_THIS 					obthis,
				OB_INST_ID 					obinst,
				UINT 						field_id
				);

		PBWINAPI(OB_INST_ID, ob_get_inst_field)
			(
				POB_THIS 					obthis,
				OB_INST_ID 					obinst,
				UINT 						field_id
				);

		// Don't really need this. Just adds to the confusion
#define ob_get_obinst_field(obthis,obinst,field_id,pobinst)			\
	((*pobinst) = ob_get_inst_field(obthis,obinst,field_id))

		PBWINAPI(PVOID, ob_get_array_field)
			(
				POB_THIS 					obthis,
				OB_INST_ID 					obinst,
				UINT 						field_id,
				PUINT 						no_items
				);

		PBWINAPI(PVOID, ob_array_index)
			(
				POB_THIS 					obthis,
				PVOID 						array_vals,
				ULONG 						index,
				POB_CLASS_ID				type
				);

		PBWINAPI(POB_DATA, ob_get_indirect_obdata)
			(
				POB_THIS 		obthis,
				OB_INST_ID      obInst,
				POB_DATA_INFO	obInfo
				);

		PBWINAPI(POB_DATA, ob_array_item)
			(
				POB_THIS 					obthis,
				PVOID 						array_vals,
				ULONG 						index
				);

		// Generalized method given array of subscripts
		PBWINAPI(ULONG, ob_array_get_index_from_subs)
			(
				POB_THIS 				obthis,
				OB_ARRAY_ID				theArray,
				PLONG					subs
				);

		// Generalized method given array of subscripts, bounds, and number of bounds
		PBWINAPI(ULONG, ob_array_calc_index)
			(
				POB_THIS 					obthis,
				UINT						numDims,
				PLONG						bounds,
				PLONG						subs
				);

#define	ob_get_dec_field(obthis,obinst,field_id)		\
	((PSH_DEC) ob_get_ptr_field(obthis,obinst,field_id))
#define	ob_get_double_field(obthis,obinst,field_id)		\
	(*(PDOUBLE) ob_get_ptr_field(obthis,obinst,field_id))
#define	ob_get_longlong_field(obthis,obinst,field_id)		\
	(*(PLONGLONG) ob_get_ptr_field(obthis,obinst,field_id))

#define	ob_get_string_field(obthis,obinst,field_id)		\
	((LPTSTR) ob_get_ptr_field(obthis,obinst,field_id))
#define	ob_get_bool_field(obthis,obinst,field_id)		\
	((BOOL) ob_get_int_field(obthis,obinst,field_id))
#define	ob_get_char_field(obthis,obinst,field_id)		\
	((TCHAR) ob_get_int_field(obthis,obinst,field_id))
#define	ob_get_blob_field(obthis,obinst,field_id)		\
	((PSH_BINARY) ob_get_ptr_field(obthis,obinst,field_id))
#define	ob_get_enum_field(obthis,obinst,field_id)		\
	ob_get_int_field(obthis,obinst,field_id)

#define	ob_get_time_field(obthis,obinst,field_id)		\
	((PSH_TIME) ob_get_ptr_field(obthis,obinst,field_id))
#define	ob_get_date_field(obthis,obinst,field_id)		\
	((PSH_TIME) ob_get_ptr_field(obthis,obinst,field_id))
#define	ob_get_datetime_field(obthis,obinst,field_id)		\
	((PSH_TIME) ob_get_ptr_field(obthis,obinst,field_id))

		// OLD WAY
#define	ob_get_str_field(obthis,obinst,field_id)		\
	((LPTSTR) ob_get_ptr_field(obthis,obinst,field_id))
#define	ob_get_binary_field(obthis,obinst,field_id)		\
	((PSH_BINARY) ob_get_ptr_field(obthis,obinst,field_id))

		PBWINAPI(VOID, ob_set_int_field)
			(
				POB_THIS 					obthis,
				OB_INST_ID 					obinst,
				UINT 		  				field_id,
				INT 		  				int_val
				);

		PBWINAPI(VOID, ob_set_uint_field)
			(
				POB_THIS 					obthis,
				OB_INST_ID 					obinst,
				UINT 		  				field_id,
				UINT 		  				uint_val
				);

		PBWINAPI(VOID, ob_set_long_field)
			(
				POB_THIS 					obthis,
				OB_INST_ID 					obinst,
				UINT 		  				field_id,
				LONG 		  				long_val
				);

		PBWINAPI(VOID, ob_set_ulong_field)
			(
				POB_THIS 					obthis,
				OB_INST_ID 					obinst,
				UINT 		  				field_id,
				ULONG 						ulong_val
				);

		PBWINAPI(VOID, ob_set_float_field)
			(
				POB_THIS 					obthis,
				OB_INST_ID 					obinst,
				UINT 		  				field_id,
				FLOAT 						flval
				);

		PBWINAPI(VOID, ob_set_ptr_field)
			(
				POB_THIS 					obthis,
				OB_INST_ID 					obinst,
				UINT 		  				field_id,
				PVOID 						ptrval
				);

		PBWINAPI(VOID, ob_set_array_field)
			(
				POB_THIS 					obthis,
				OB_INST_ID 					obinst,
				UINT 		  				field_id,
				PVOID 						pArray
				);

		PBWINAPI(VOID, ob_set_obinst_field)
			(
				POB_THIS 					obthis,
				OB_INST_ID 					obinst,
				UINT 		  				field_id,
				OB_INST_ID 					obinstval
				);

		PBWINAPI(VOID, ob_set_underlying_object)
			(
				POB_THIS 					obthis,
				OB_INST_ID 					obinst,
				VOID* obj
				);

		PBWINAPI(VOID*, ob_get_underlying_object)
			(
				POB_THIS 					obthis,
				OB_INST_ID 					obinst
				);

#define		ob_set_dec_field(obthis,obinst,field_id,val)		\
				ob_set_ptr_field(obthis,obinst,field_id,val)
#define		ob_set_double_field(obthis,obinst,field_id,val)		\
				ob_set_ptr_field(obthis,obinst,field_id,_dblcpy(obthis,val))
#define		ob_set_longlong_field(obthis,obinst,field_id,val)		\
				ob_set_ptr_field(obthis,obinst,field_id,_longlcpy(obthis,val))

#define		ob_set_string_field(obthis,obinst,field_id,val)		\
				ob_set_ptr_field(obthis,obinst,field_id,val)
#define		ob_set_bool_field(obthis,obinst,field_id,val)		\
				ob_set_int_field(obthis,obinst,field_id,(INT)(val))
#define		ob_set_char_field(obthis,obinst,field_id,val)		\
				ob_set_int_field(obthis,obinst,field_id,(INT)(val))
#define		ob_set_blob_field(obthis,obinst,field_id,val)		\
				ob_set_ptr_field(obthis,obinst,field_id,val)
#define		ob_set_enum_field(obthis,obinst,field_id,val)		\
				ob_set_int_field(obthis,obinst,field_id,val)

#define		ob_set_time_field(obthis,obinst,field_id,val)		\
				ob_set_long_field(obthis,obinst,field_id,(LONG)(val))
#define		ob_set_date_field(obthis,obinst,field_id,val)		\
				ob_set_long_field(obthis,obinst,field_id,(LONG)(val))
#define		ob_set_datetime_field(obthis,obinst,field_id,val)		\
				ob_set_long_field(obthis,obinst,field_id,(LONG)(val))

		// OLD WAY
#define		ob_set_str_field(obthis,obinst,field_id,val)		\
				ob_set_ptr_field(obthis,obinst,field_id,val)
#define		ob_set_binary_field(obthis,obinst,field_id,val)		\
				ob_set_ptr_field(obthis,obinst,field_id),val)

//****************************************************************************
// New set of field access macros (NOW OBSOLETE 3/27/95)
//****************************************************************************

#define ob_put_int_field(obthis,obinst,field_id,int_val)		\
	ob_set_int_field (obthis, obinst, field_id, int_val)

#define ob_put_uint_field(obthis,obinst,field_id,uint_val)	\
	ob_set_uint_field (obthis, obinst, field_id, uint_val)

#define ob_put_long_field(obthis,obinst,field_id,long_val)	\
	ob_set_long_field (obthis, obinst, field_id, long_val)

#define ob_put_ulong_field(obthis,obinst,field_id,ulong_val)	\
	ob_set_ulong_field (obthis, obinst, field_id, ulong_val)

#define ob_put_float_field(obthis,obinst,field_id,float_val)	\
	ob_set_float_field (obthis, obinst, field_id, float_val)

#define ob_put_ptr_field(obthis,obinst,field_id,ptr_val)		\
	ob_set_ptr_field (obthis, obinst, field_id, ptr_val)

#define ob_put_obinst_field(obthis,obinst,field_id,inst_val)	\
	ob_set_obinst_field (obthis, obinst, field_id, inst_val)

#define	ob_put_dec_field(obthis,obinst,field_id,val)			\
	ob_put_ptr_field(obthis,obinst,field_id,val)

#define	ob_put_double_field(obthis,obinst,field_id,val)			\
	ob_put_ptr_field(obthis,obinst,field_id,&(val))

#define	ob_put_longlong_field(obthis,obinst,field_id,val)			\
	ob_put_ptr_field(obthis,obinst,field_id,&(val))

#define	ob_put_bool_field(obthis,obinst,field_id,val)			\
	ob_put_int_field(obthis,obinst,field_id,(INT)(val))

#define	ob_put_str_field(obthis,obinst,field_id,val)			\
	ob_put_ptr_field(obthis,obinst,field_id,val)

#define	ob_put_time_field(obthis,obinst,field_id,val)			\
	ob_put_long_field(obthis,obinst,field_id,(LONG)(val))

#define	ob_put_date_field(obthis,obinst,field_id,val)			\
	ob_put_long_field(obthis,obinst,field_id,(LONG)(val))

#define	ob_put_datetime_field(obthis,obinst,field_id,val)		\
	ob_put_long_field(obthis,obinst,field_id,(LONG)(val))

#define	ob_put_enum_field(obthis,obinst,field_id,val)			\
	ob_put_int_field(obthis,obinst,field_id,val)

#define	ob_put_binary_field(obthis,obinst,field_id,val)			\
	ob_put_ptr_field(obthis,obinst,field_id),val)

//****************************************************************************
// Object manager locking functions
//****************************************************************************


		PBWINAPI(BOOL, ob_is_any_group_locked)
			(
				POB_THIS      				obthis
				);

		PBWINAPI(UINT, ob_get_group_lock_count)
			(
				POB_THIS            	    obthis
				);

		PBWINAPI(BOOL, ob_is_group_locked)
			(
				POB_THIS      				obthis,
				OB_GROUP_HNDL 				group_hndl
				);

		// Return if state is unlocked.  Not converse of ob_is_group_locked because
		// could be system group (additional state).
		PBWINAPI(BOOL, ob_is_group_unlocked)
			(
				POB_THIS       obthis,                     // This pointer
				OB_GROUP_HNDL  obGroupHandle               // Group handle
				);

		PBWINAPI(BOOL, ob_is_group_write_locked)
			(
				POB_THIS                	obthis,
				OB_GROUP_HNDL           	group_hndl
				);


		PBWINAPI(INT, ob_lock_group)
			(
				POB_THIS      				obthis,
				OB_GROUP_HNDL           	group_hndl,
				BOOL                    	write_only
				);


		PBWINAPI(INT, ob_unlock_group)
			(
				POB_THIS      				obthis,
				OB_GROUP_HNDL 				group_hndl
				);


		PBWINAPI(VOID, ob_clear_unlocked_groups)
			(
				POB_THIS  					obthis
				);

		PBWINAPI(VOID, ob_clear_all_other_unlocked_groups)
			(
				POB_THIS  					obthis,
				OB_GROUP_ID					obGroupId
				);

		PBWINAPI(BOOL, ob_is_ancestor_locked)
			(
				POB_THIS obthis,
				OB_GROUP_ID groupid,
				TCHAR cReadWrite
				);

		PBWINAPI(BOOL, ob_is_descendent_locked)
			(
				POB_THIS obthis,
				OB_GROUP_ID groupid,
				TCHAR cReadWrite
				);

		//****************************************************************************
		// Object Group Functions
		//****************************************************************************

		PBWINAPI(INT, ob_validate_liblist)
			(
				POB_THIS		obThis,
				LPTSTR FAR* pLibList,
				UINT           iNumberOfItems
				);

		PBWINAPI(INT, ob_set_liblist)
			(
				POB_THIS 					obthis,
				LPTSTR FAR* lib_list,
				UINT 						no_items,
				BOOL						bCreateNewLoader
				);

		PBWINAPI(INT, ob_add_liblist)
			(
				POB_THIS 					obthis,
				LPTSTR FAR* lib_list,
				UINT 						no_items
				);

		PBWINAPI(LPTSTR FAR*, ob_get_liblist)
			(
				POB_THIS 					obthis,
				PUINT 						no_items
				);

		PBWINAPI(VOID, ob_set_default_appl)
			(
				POB_THIS 					obthis,
				LPTSTR 						lib_name,
				LPTSTR 						appl_group_name
				);

		PBWINAPI(BOOL, ob_load_appl_group)
			(
				POB_THIS 					obthis
				);

		PBWINAPI(OB_GROUP_HNDL, ob_is_group_in_memory)
			(
				POB_THIS 					obthis,
				LPTSTR    					lib_name,
				LPTSTR    					qualified_name
				);

		PBWINAPI(OB_GROUP_HNDL, ob_group_declare)
			(
				POB_THIS 					obthis,
				LPTSTR 						lib_name,
				LPTSTR 						group_name,
				OB_CLASS_ID 				class_id
				);

		PBWINAPI(OB_GROUP_HNDL, ob_group_reference)
			(
				POB_THIS 					obthis,
				LPTSTR 						lib_name,
				LPTSTR 						group_name,
				OB_CLASS_ID 				class_id
				);

		PBWINAPI(LPTSTR, ob_get_group_name)
			(
				POB_THIS 					obthis,
				OB_GROUP_HNDL 				group_hndl
				);

		PBWINAPI(LPTSTR, ob_get_group_full_name)
			(
				POB_THIS        obthis,
				OB_GROUP_HNDL   grouphndl
				);

		PBWINAPI(INT, ob_group_save)
			(
				POB_THIS 					obthis,
				OB_GROUP_HNDL 				group_hndl,
				LPTSTR 						lib_name,
				LPTSTR 						comment
				);
		//CR 340943
		PBWINAPI(INT, ob_group_save_win)
			(
				POB_THIS 					obthis,
				OB_GROUP_HNDL 				group_hndl,
				LPTSTR 						lib_name,
				LPTSTR 						comment,
				BOOL						bSaveNormalize
				);
		//end CR 340943

		PBWINAPI(INT, ob_load_group_source)
			(
				POB_THIS 					obthis,
				OB_GROUP_HNDL 				group_hndl
				);

		PBWINAPI(INT, ob_reload_group_source)
			(
				POB_THIS 					obthis,
				OB_GROUP_HNDL 				group_hndl
				);

		PBWINAPI(INT, ob_rename_group)
			(
				POB_THIS 					obthis,
				OB_GROUP_HNDL 				group_hndl,
				LPTSTR 						new_name
				);

		PBWINAPI(INT, ob_move_group)
			(
				POB_THIS 					obthis,
				OB_GROUP_HNDL 				group_hndl,
				LPTSTR 						lib_name
				);

		PBWINAPI(INT, ob_move_group_with_name)
			(
				POB_THIS 					obthis,
				LPTSTR 						qual_name,
				LPTSTR 						oldlib,
				LPTSTR 						newlib
				);

		PBWINAPI(INT, ob_copy_group_with_name)
			(
				POB_THIS 					obthis,
				LPTSTR 						qual_name,
				LPTSTR 						oldlib,
				LPTSTR 						newlib
				);


		PBWINAPI(VOID, ob_copy_group)
			(
				POB_THIS 					obthis,
				OB_GROUP_HNDL 				group_hndl,
				LPTSTR 						new_name,
				LPTSTR 						lib_name
				);

		PBWINAPI(VOID, ob_delete_group)
			(
				POB_THIS 					obthis,
				OB_GROUP_HNDL 				group_hndl
				);

		PBWINAPI(INT, ob_delete_group_with_name)
			(
				POB_THIS 					obthis,
				LPTSTR 						lib_name,
				LPTSTR 						group_name,
				OB_CLASS_ID 				class_id
				);

		PBWINAPI(VOID, ob_restore_group)
			(
				POB_THIS 					obthis,
				OB_GROUP_HNDL 				group_hndl
				);

		PBWINAPI(VOID, ob_save_working_group)
			(
				POB_THIS 					obthis,
				OB_GROUP_HNDL 				group_hndl
				);

		PBWINAPI(VOID, ob_delete_working_group)
			(
				POB_THIS 					obthis
				);

		PBWINAPI(VOID, ob_restore_working_group)
			(
				POB_THIS 					obthis
				);

		PBWINAPI(VOID, ob_open_group_id)
			(
				POB_THIS 					obthis,
				OB_GROUP_HNDL				group_hndl
				);

		PBWINAPI(VOID, ob_close_group)
			(
				POB_THIS 					obthis
				);

		PBWINAPI(LPTSTR, ob_get_group_lib)
			(
				POB_THIS  					obthis,
				OB_GROUP_HNDL				group_hndl
				);


		PBWINAPI(INT, ob_run_garbage_collection)
			(
				POB_THIS 			obthis,
				BOOL				force
				);

		// delete an instlist returned by ob_get_group_instlist_as_shlist
		PBWINAPI(VOID, ob_delete_instlist_shlist)
			(
				POB_THIS 			obthis,
				PSHLIST				instlist
				);

		PBWINAPI(PSHLIST, ob_get_group_instlist_as_shlist)
			(
				POB_THIS 			obthis,
				OB_GROUP_ID			groupId
				);


		PBWINAPI(VOID, ob_delete_groups_shlist)
			(
				POB_THIS           obthis,
				PSHLIST			 groups
				);


		PBWINAPI(PSHLIST, ob_get_groups_shlist)
			(
				POB_THIS           obthis
				);

		//****************************************************************************
		// Source Functions
		//****************************************************************************


		PBWINAPI(VOID, ob_store_source)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl,
				LPTSTR 						source,
				UINT 						len
				);

		PBWINAPI(INT, ob_init_source)
			(
				POB_THIS 					obthis,
				OB_GROUP_HNDL 				group_hndl,
				LPTSTR 						source,
				UINT 						len
				);

		PBWINAPI(INT, ob_store_global_src)
			(
				POB_THIS 					obthis,
				OB_GROUP_HNDL 				group_hndl,
				LPTSTR 						source,
				UINT 						len
				);

		//PB11 language enhancement -- namespace
		PBWINAPI(INT, ob_store_namespace_decl_src)
			(
				POB_THIS                 obthis,
				OB_GROUP_HNDL            group_hndl,
				LPTSTR                   source,
				UINT                     len
				);

		PBWINAPI(INT, ob_store_shared_src)
			(
				POB_THIS 					obthis,
				OB_GROUP_HNDL 				group_hndl,
				LPTSTR 						source,
				UINT 						len
				);

		PBWINAPI(VOID, ob_store_prototype_source)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl,
				LPTSTR 						source,
				UINT 						len
				);

		PBWINAPI(VOID, ob_store_instvar_source)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl,
				LPTSTR 						source,
				UINT 						len
				);

		PBWINAPI(LPTSTR, ob_get_global_src)
			(
				POB_THIS 					obthis,
				OB_GROUP_HNDL 				group_hndl,
				PUINT 						len
				);

		//PB11 language enhancement -- namespace
		PBWINAPI(LPTSTR, ob_get_namespace_decl_src)
			(
				POB_THIS                 obthis,
				OB_GROUP_HNDL            group_hndl,
				PUINT                    len
				);

		PBWINAPI(LPTSTR, ob_get_shared_src)
			(
				POB_THIS 					obthis,
				OB_GROUP_HNDL 				group_hndl,
				PUINT 						len
				);

		PBWINAPI(LPTSTR, ob_get_prototype_source)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl,
				PUINT 						len
				);

		PBWINAPI(LPTSTR, ob_get_instvar_source)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl,
				PUINT 						len
				);

		PBWINAPI(LPTSTR, ob_get_routine_src)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl,
				OB_VTABLE_ID				index
				);

		PBWINAPI(INT, ob_decl_and_store_routine_src)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL				class_hndl,
				LPTSTR						routname,
				LPTSTR						result_type,
				INT							no_args,
				POB_PROTOARG_TYPE			arg_pass_style,
				LPTSTR FAR* arg_type_names,
				LPTSTR FAR* arg_names,
				POB_GROUPTYPE				arg_grouping,
				LPTSTR 						source,
				UINT						len
				);

		PBWINAPI(VOID, ob_store_routine_src)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl,
				OB_VTABLE_ID				index,
				LPTSTR 						source,
				UINT 						len
				);

		PBWINAPI(INT, ob_store_create_src)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl,
				LPTSTR 						source,
				UINT 						len
				);

		PBWINAPI(INT, ob_store_destroy_src)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl,
				LPTSTR 						source,
				UINT 						len
				);

		PBWINAPI(LPTSTR, ob_get_function_src)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl,
				OB_VTABLE_ID				index
				);

		PBWINAPI(VOID, ob_store_function_src)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl,
				OB_VTABLE_ID				index,
				LPTSTR 						source,
				UINT 						len
				);

		//***************************************************************************
		// PB11 language enhancement -- namespace
		// Add a parameter which represents full qualified name
		//***************************************************************************			

		PBWINAPI(BOOL, ob_symbol_search_extended)
			(
				POB_THIS 			obthis,
				OB_CLASS_HNDL		obClassHandle,
				INT					iCurrScope,
				LPTSTR				pszVarName,
				BOOL				bSkipVars,
				BOOL				bSkipTHIS,
				PUINT				puiLevel,
				PBOOL				pbIsConstantField,
				PBOOL				pbIsPrivateMember,
				LPTSTR* ppszFullName
				);

		PBWINAPI(BOOL, ob_symbol_search)
			(
				POB_THIS 			obthis,
				OB_CLASS_HNDL		obClassHandle,
				INT					iCurrScope,
				LPTSTR				pszVarName,
				BOOL				bSkipVars,
				BOOL				bSkipTHIS,
				PUINT				puiLevel,
				PBOOL				pbIsConstantField
				);


		//****************************************************************************
		// Class manipulation functions
		//****************************************************************************

		PBWINAPI(OB_CLASS_HNDL, ob_class_declare)
			(
				POB_THIS 					obthis,
				OB_GROUP_HNDL 				group_hndl,
				LPTSTR 						class_name,
				OB_CLASS_ID 				parent_class,
				OB_CLASS_ID 				within_class
				);

		//****************************************************************************
		// PB11 language enhancement -- namespace
		//****************************************************************************
		PBWINAPI(LPTSTR, ob_get_full_qualified_typename)
			(
				POB_THIS        				obthis,
				OB_GROUP_HNDL				group_hndl,
				OB_CLASS_ID   				class_id
				);

		PBWINAPI(OB_CLASS_HNDL, ob_class_declare_inh)
			(
				POB_THIS 					obthis,
				OB_GROUP_HNDL 				group_hndl,
				LPTSTR 						class_name,
				OB_CLASS_HNDL 				parent_class,
				OB_CLASS_ID 				within_class
				);

		PBWINAPI(OB_CLASS_HNDL, ob_class_reference)
			(
				POB_THIS 					obthis,
				OB_GROUP_HNDL 				group_hndl,
				LPTSTR 						class_name
				);

		PBWINAPI(LPTSTR, ob_class_name)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl
				);

		//This is a hacked version of ob_class_name the way it worked in PB 4.0
		//because some painter
		//behavior is dependent on getting the non indirected class name,
		//because they actually parse the group name up to the ` (e.g.,
		//w_main`cb_ok).

		PBWINAPI(LPTSTR, ob_class_name_not_indirect)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl
				);

		PBWINAPI(LPTSTR, ob_get_type_name)
			(
				POB_THIS 					obthis,
				POB_DATA					datanode
				);

		PBWINAPI(OB_CLASS_HNDL, ob_classhndl_indirect)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl
				);

		PBWINAPI(OB_CLASS_HNDL, ob_get_parent_class)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl
				);

		PBWINAPI(OB_CLASS_HNDL, ob_get_within_class)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl
				);

		PBWINAPI(VOID, ob_class_delete)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl
				);

		PBWINAPI(INT, ob_class_rename)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl,
				LPTSTR 						new_name
				);

		PBWINAPI(BOOL, ob_is_a_system_class)
			(
				POB_THIS 					obthis,
				LPTSTR 						class_name
				);

		PBWINAPI(BOOL, ob_is_class_inherited)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl
				);

		PBWINAPI(BOOL, ob_is_class_descendant)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				ancestor,
				OB_CLASS_HNDL 				descendant
				);

		PBWINAPI(BOOL, ob_is_inh_from_user_class)
			(
				POB_THIS					obthis,
				OB_CLASS_HNDL				class_hndl
				);

		PBWINAPI(OB_CLASS_HNDL, ob_get_sec_class_ancestor)
			(
				POB_THIS					obthis,
				OB_CLASS_HNDL				sec_class
				);


		PBWINAPI(BOOL, obIsClassAutoinstantiate)
			(
				POB_THIS		obThis,
				OB_CLASS_HNDL	obClassHndl
				);

		PBWINAPI(BOOL, ob_is_class_enum)
			(
				POB_THIS		obThis,
				OB_CLASS_HNDL	obClassHndl
				);

		//****************************************************************************
		// Error type used when determining if an invalid overload is being attempted.
		//****************************************************************************

		typedef enum ob_proto_overload_error
		{
			OB_NO_OVERLOAD_ERROR,
			OB_ARG_TYPE_ERROR,
			OB_RETURN_TYPE_ERROR

		} OB_PROTO_OVERLOAD_ERROR, FAR* POB_PROTO_OVERLOAD_ERROR;


		//****************************************************************************
		// Event functions
		//****************************************************************************


		PBWINAPI(OB_VTABLE_ID, ob_new_event)
			(
				POB_THIS 			obthis,
				OB_CLASS_HNDL		class_hndl,
				LPTSTR 				event_name,
				LPTSTR			  	token_name,	/* optional */
				LPTSTR				result_type,
				INT					no_args,
				POB_PROTOARG_TYPE	arg_pass_style,
				LPTSTR FAR* arg_type_names,
				LPTSTR FAR* arg_names,
				POB_GROUPTYPE		arg_grouping,
				BOOL				is_external_event
				);

		PBWINAPI(INT, ob_update_event)
			(
				POB_THIS 			obthis,
				OB_CLASS_HNDL		class_hndl,
				OB_VTABLE_ID		vtable_id,
				LPTSTR 				event_name,
				LPTSTR			  	token_name,
				LPTSTR				result_type,
				INT					no_args,
				POB_PROTOARG_TYPE	arg_pass_style,
				LPTSTR FAR* arg_type_names,
				LPTSTR FAR* arg_names,
				POB_GROUPTYPE		arg_grouping,
				BOOL				is_external_event,
				INT					no_throws,
				LPTSTR FAR* throws_names
				);

		PBWINAPI(INT, ob_delete_event)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl,
				LPTSTR 						event_name
				);

		PBWINAPI(BOOL, ob_has_events)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl
				);

		PBWINAPI(OB_EVT_TOKEN_ID, ob_get_event_token_id)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl,
				LPTSTR 						event_name,
				POB_VTABLE_ID				vtable_id
				);

		PBWINAPI(OB_VTABLE_ID, ob_get_event_id_from_token)
			(
				POB_THIS					obthis,
				OB_CLASS_HNDL 				class_hndl,
				OB_EVT_TOKEN_ID 			event_token
				);

		PBWINAPI(BOOL, ob_does_event_script_exist)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl,
				OB_VTABLE_ID 				event_id
				);

		//****************************************************************************
		// Event Routine Functions
		//****************************************************************************


		PBWINAPI(LPTSTR, ob_get_routine_name)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl,
				OB_VTABLE_ID				index
				);

		PBWINAPI(VOID, ob_delete_routine)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl,
				OB_VTABLE_ID				index
				);

		PBWINAPI(OB_VTABLE_ID, ob_get_curr_routine)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl
				);

		PBWINAPI(OB_VTABLE_ID, ob_get_curr_function)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl
				);

		PBWINAPI(OB_ROUT_ID, ob_get_routid_from_vtable_id)
			(
				POB_THIS 				obthis,
				OB_CLASS_HNDL			class_hndl,
				OB_VTABLE_ID 			vtable_id
				);

		PBWINAPI(BOOL, ob_is_valid_event_index)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL				class_hndl,
				OB_VTABLE_ID				index
				);

		PBWINAPI(BOOL, ob_has_scripts)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl
				);

		//Get routine type for current class entry. On error, return OB_ANY_ROUT_TYPE.
		PBWINAPI(OB_ROUT_TYPE, ob_get_routine_type)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL				class_hndl,
				OB_VTABLE_ID				index
				);

		//****************************************************************************
		// Function Routine Functions
		//****************************************************************************

		// Returns vtable id's for functions in this class
		PBWINAPI(POB_VTABLE_ID, ob_get_function_vtable_ids)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl,
				BOOL						include_dlls,
				BOOL						include_ancestors,
				PUINT 						no_items
				);

		// Returns vtable id's for functions in this class excluding dll variables
		PBWINAPI(POB_VTABLE_ID, ob_get_function_vtable_ids_for_ide)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl,
				BOOL						include_dlls,
				BOOL						include_ancestors,
				PUINT 						no_items
				);


		// Returns vtable id's for events in this class
		PBWINAPI(POB_VTABLE_ID, ob_get_event_vtable_ids)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl,
				BOOL						include_dlls,
				PUINT 						no_items
				);

		PBWINAPI(LPTSTR, ob_get_function_name)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl,
				OB_VTABLE_ID				index
				);

		PBWINAPI(INT, ob_delete_function)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl,
				OB_VTABLE_ID				index
				);

		PBWINAPI(BOOL, ob_find_routine)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl,
				OB_ROUT_TYPE				routine_type,
				LPTSTR 						routine_name,
				LPTSTR						result_type,
				INT							no_args,
				POB_PROTOARG_TYPE			arg_pass_style,
				LPTSTR FAR* arg_type_names,
				POB_GROUPTYPE				arg_grouping,
				POB_PROTO_OVERLOAD_ERROR	ov_error,
				POB_PROTO_ID				pproto_id,
				POB_VTABLE_ID				pvtable_id
				);

		PBWINAPI(OB_VTABLE_ID, ob_get_vtable_id_from_proto_id)
			(
				POB_THIS 				obthis,
				OB_CLASS_HNDL 			class_hndl,
				OB_PROTO_ID 			proto_id
				);

		//****************************************************************************
		// Function query calls
		//****************************************************************************

		PBWINAPI(LPTSTR FAR*, ob_get_dll_func_names)
			(
				POB_THIS 					obthis,
				PUINT 						no_funcs
				);

		PBWINAPI(LPTSTR FAR*, ob_get_global_func_names_in_lib)
			(
				POB_THIS 					obthis,
				PUINT 						no_funcs,
				LPTSTR 						lib_name
				);

		PBWINAPI(OB_VTABLE_ID, ob_get_global_func_index)
			(
				POB_THIS 					obthis,
				LPTSTR 						name,
				POB_CLASS_HNDL 				class_hndl
				);

		PBWINAPI(OB_VTABLE_ID, ob_get_func_index_in_lib)
			(
				POB_THIS 					obthis,
				LPTSTR 						name,
				LPTSTR 						lib_name,
				POB_CLASS_HNDL 				class_hndl
				);

		PBWINAPI(BOOL, ob_get_proto_is_external_event)
			(
				POB_THIS 				obthis,
				OB_CLASS_HNDL			class_hndl,
				OB_VTABLE_ID			index
				);

		PBWINAPI(POB_ARG_INFO, ob_get_protoarg_info)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl,
				OB_VTABLE_ID				vtable_id,
				PUINT 						no_items,
				LPTSTR FAR* type_name,
				POB_MEMBER_ACCESS 			member_access
				);

		PBWINAPI(POB_ARG_INFO, ob_get_proto_info)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL				class_hndl,
				OB_VTABLE_ID				vtable_id,
				PUINT 						no_args,
				LPTSTR FAR* name,
				LPTSTR FAR* type,
				POB_MEMBER_ACCESS			member_access,
				LPTSTR FAR* dll_lib_name,
				PBOOL						is_obsolete,
				POB_EVT_TOKEN_ID			token,
				POB_ROUT_TYPE				rout_type,
				PBOOL						is_inherit	//TRUE = defined in ancestor
				);

		PBWINAPI(LPTSTR, ob_get_method_signature)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL				class_hndl,
				OB_VTABLE_ID				vtable_id
				);

		PBWINAPI(BOOL, ob_was_event_prototype_changed)
			(
				POB_THIS 				obthis,
				OB_CLASS_HNDL			class_hndl,
				OB_VTABLE_ID			event_id
				);

		PBWINAPI(VOID, ob_get_proto_name_info)
			(
				POB_THIS 				obthis,
				OB_CLASS_HNDL			class_hndl,
				OB_VTABLE_ID			func_id,
				LPTSTR FAR* name,
				PBOOL					is_obsolete
				);

		PBWINAPI(VOID, ob_get_proto_throws_info)
			(
				POB_THIS 				obthis,
				OB_CLASS_HNDL			class_hndl,
				OB_VTABLE_ID			func_id,
				POB_CLASS_ID FAR* throws_list,
				PUINT					no_throws,
				POB_GROUP_ID			group_id
				);

		PBWINAPI(PBRESULT, ob_lookup_routine_by_name)
			(
				POB_THIS 				obthis,
				OB_INST_ID				obInst,
				LPTSTR 					lpstrRoutineName,
				POB_VTABLE_ID			pVtableId,
				PUINT					pNumRoutines,
				POB_ROUT_TYPE			pobRoutineType,
				PUINT					pNoArgs,
				POB_CLASS_ID FAR* ppobArgClassId,	// Caller must free this array
				PBOOL					pbVarArgs
				);

		//****************************************************************************
		// Object Data Query Utilities
		//****************************************************************************


		PBWINAPI(LPTSTR FAR*, ob_get_objnames_of_class)
			(
				POB_THIS 					obthis,
				OB_CLASS_ID 				class_id,
				PUINT 						no_items
				);

		PBWINAPI(BOOL, ob_has_object_of_class)
			(
				POB_THIS 					obthis,
				OB_CLASS_ID 				class_id
				);

		PBWINAPI(POB_CLASS_HNDL, ob_get_obj_classhndls_of_class)
			(
				POB_THIS       				obthis,
				OB_CLASS_ID    				obClassID,
				PUINT          				pNumberOfItems
				);

		PBWINAPI(LPTSTR FAR*, ob_get_objnames_of_class_in_lib)
			(
				POB_THIS 					obthis,
				OB_CLASS_ID 				class_id,
				PUINT 						no_items,
				LPTSTR 						lib_name
				);

		PBWINAPI(OB_CLASS_HNDL, ob_global_reference)
			(
				POB_THIS 					obthis,
				LPTSTR 						class_name,
				POB_GROUP_HNDL 				group_hndl
				);

		PBWINAPI(OB_CLASS_HNDL, ob_global_reference_in_lib)
			(
				POB_THIS 					obthis,
				LPTSTR 						class_name,
				LPTSTR 						lib_name,
				POB_GROUP_HNDL 				group_hndl,
				OB_CLASS_ID 				class_id
				);

		PBWINAPI(OB_CLASS_HNDL, ob_global_reference_of_class)
			(
				POB_THIS 					obthis,
				LPTSTR 						name,
				POB_GROUP_HNDL 				grouphndl,
				OB_CLASS_ID 				of_class
				);

		PBWINAPI(OB_CLASS_HNDL, ob_get_obinst_class_hndl)
			(
				POB_THIS 					obthis,
				OB_INST_ID 					obinst
				);

		PBWINAPI(BOOL, ob_is_a_typedef)
			(
				POB_THIS 					obthis,
				POB_DATA 					data
				);

		PBWINAPI(BOOL, ob_is_an_enum)
			(
				POB_THIS					obthis,
				OB_GROUP_HNDL				group_hndl,
				POB_DATA					data_node
				);

		PBWINAPI(OB_CLASS_ID, ob_get_system_class)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl
				);

		PBWINAPI(OB_CLASS_ID, ob_get_obinst_system_class)
			(
				POB_THIS 					obthis,
				OB_INST_ID 					obinst
				);

		PBWINAPI(OB_GROUP_HNDL, ob_get_obinst_group_hndl)
			(
				POB_THIS 					obthis,
				OB_INST_ID 					obinst
				);

		PBWINAPI(LPTSTR, ob_get_obinst_class_name)
			(
				POB_THIS 					obthis,
				OB_INST_ID 					obinst
				);

		PBWINAPI(LPTSTR FAR*, ob_fetch_fields_of_class)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				in_class,
				OB_CLASS_ID 				of_class,
				OB_FIELD_FILTER				field_filter,
				POB_CLASS_ID FAR* class_list,
				PUINT 						no_items
				);

		PBWINAPI(LPTSTR FAR*, ob_get_fields_of_class)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				in_class,
				OB_CLASS_ID 				of_class,
				POB_CLASS_ID FAR* class_list,
				PUINT 						no_items
				);

		PBWINAPI(POB_DATA_INFO, ob_get_local_var_info)
			(
				POB_THIS 					obthis,
				PUINT 						no_items
				);

		PBWINAPI(POB_DATA_INFO, ob_get_shared_vars_of_class)
			(
				POB_THIS 					obthis,
				OB_GROUP_HNDL 				group_hndl,
				BOOL 						return_shared,
				BOOL 						return_global,
				OB_CLASS_ID 				of_class,
				PUINT 						no_items
				);

		PBWINAPI(POB_DATA_INFO, ob_get_shared_var_info)
			(
				POB_THIS 					obthis,
				OB_GROUP_HNDL 				group_hndl,
				BOOL 						return_shared,
				BOOL 						return_global,
				PUINT 						no_items
				);

		PBWINAPI(POB_DATA_INFO, ob_get_global_vars_of_class)
			(
				POB_THIS 					obthis,
				OB_CLASS_ID 				of_class,
				PUINT 						no_items
				);

		PBWINAPI(POB_DATA_INFO, ob_get_class_field_info)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl,
				PUINT 						no_items
				);

		PBWINAPI(POB_ENUM_INFO, ob_get_enum_info)
			(
				POB_THIS             		obthis,
				OB_CLASS_HNDL        		class_hndl,
				PUINT                		no_enums
				);

		PBWINAPI(POB_EVENT_INFO, ob_get_class_event_info)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl,
				PUINT 						no_events
				);

		PBWINAPI(POB_DATA_INFO, ob_get_instance_field_info)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl,
				PUINT 						no_items
				);
		// If field_filter is TRUE, filters out constants and indirects
		PBWINAPI(POB_DATA_INFO, ob_get_obinst_field_info)
			(
				POB_THIS 					obthis,
				OB_INST_ID 					obinst,
				PUINT 						no_items,
				BOOL						field_filter
				);

		// If field_filter is TRUE, filters out constants and indirects
		PBWINAPI(POB_DATA_INFO, ob_get_obinst_all_field_info)
			(
				POB_THIS 					obthis,
				OB_INST_ID 					obinst,
				PUINT 						no_items,
				BOOL						field_filter
				);

		PBWINAPI(POB_CLASS_INFO, ob_get_classes_within_group)
			(
				POB_THIS 					obthis,
				OB_GROUP_HNDL 				in_group_hndl,
				OB_CLASS_ID 				of_class_id,
				PUINT 						total_items
				);

		PBWINAPI(POB_CLASS_INFO, ob_get_enums_within_group)
			(
				POB_THIS					obthis,
				OB_GROUP_HNDL				in_group_hndl,
				PUINT						total_items
				);

		PBWINAPI(POB_DATA, ob_get_global_var_data)
			(
				POB_THIS 					obthis,
				LPTSTR 						var_name
				);

		PBWINAPI(ULONG, ob_object_reference_count)
			(
				POB_THIS					obthis,
				OB_INST_ID					obinst
				);

		PBWINAPI(POB_DATA_INFO, ob_named_global_var_info)
			(
				POB_THIS					obthis,
				LPTSTR						varname
				);

		PBWINAPI(POB_DATA_INFO, ob_named_shared_var_info)
			(
				POB_THIS					obthis,
				OB_GROUP_HNDL				group_hndl,
				LPTSTR						varname
				);

		PBWINAPI(POB_DATA_INFO, ob_named_special_var_info)
			(
				POB_THIS					obthis,
				LPTSTR						varname
				);

		PBWINAPI(POB_DATA_INFO, ob_named_local_var_info)
			(
				POB_THIS					obthis,
				LPTSTR						varname
				);

		PBWINAPI(POB_DATA_INFO, ob_named_field_info)
			(
				POB_THIS					obthis,
				OB_INST_ID					obinst,
				LPTSTR						fieldname
				);

		//****************************************************************************
		// Array query calls
		//****************************************************************************


		PBWINAPI(POB_ARRAY_INFO, ob_get_array_info)
			(
				POB_THIS					obthis,
				POB_DATA					data_node
				);

		PBWINAPI(LPTSTR, ob_get_array_bounds_string)
			(
				POB_THIS 				obthis,
				OB_GROUP_HNDL			group_hndl,
				POB_DATA				data_node
				);

		PBWINAPI(LPTSTR, ob_get_array_bounds_string_from_field_info)
			(
				POB_THIS 				obthis,
				POB_DATA_INFO       	fieldinfo
				);

		PBWINAPI(PVOID, ob_get_info_watchpoint)
			(
				POB_THIS 				obthis,
				POB_DATA_INFO       	info
				);

		//****************************************************************************
		// Compile Utilities (Here for now)
		//****************************************************************************


		PBWINAPI(INT, ob_compile_lib_entry)
			(
				POB_THIS 					obthis,
				LPTSTR 						lib_name,
				LPTSTR 						entry_name,
				BOOL						write_source
				);

		PBWINAPI(INT, ob_compile_lib_typedefs)
			(
				POB_THIS 					obthis,
				LPTSTR 						lib_name,
				LPTSTR 						entry_name,
				BOOL						bUpdateModifyTime
				);

		PBWINAPI(BOOL, ob_compile_lib_entry_3_pass)
			(
				POB_THIS    obThis,
				LPTSTR      lpszLibraryName,            /* Ptr to library name */
				LPTSTR      lpszEntryName               /* Ptr to entry name */
				);

		PBWINAPI(INT, ob_compile_lib_scripts)
			(
				POB_THIS 					obthis,
				LPTSTR 						lib_name,
				LPTSTR 						entry_name
				);

		PBWINAPI(POB_FUNCCALL_INFO, ob_func_search)
			(
				POB_THIS					obthis,		  // Object Manager This pointer
				LPTSTR						name,		  // Function name
				POB_CLASS_ID				argtypes,	  // Array of actual arg types
				UINT						no_args,	  // Number of args
				POB_CLASS_ID				type,		  // Returned function type
				POB_PROTOREF_ERROR			error		  // Error return code
				);

		PBWINAPI(VOID, ob_del_funccall_info)
			(
				POB_THIS				  	obthis,	   	  // Object Manager This pointer
				POB_FUNCCALL_INFO			funccall_info // Funccall info structure
				);

		//****************************************************************************
		// Link and Runtime Utilities
		//****************************************************************************


		PBWINAPI(INT, ob_link_project)
			(
				POB_THIS 					obthis,
				OB_GROUP_HNDL 				group_hndl
				);

		PBWINAPI(OB_GROUP_HNDL, ob_get_runtime_group_hndl)
			(
				POB_THIS 					obthis
				);

		PBWINAPI(VOID, ob_check_for_locked_menu)
			(
				POB_THIS 					obthis
				);

		PBWINAPI(OB_INST_ID, ob_create_obinst)
			(
				POB_THIS 					obthis,
				OB_CLASS_HNDL 				class_hndl
				);

		//*******************************************************************
		// Instantiate child object and assign to parent field.
		// Presently works only with system object types.
		//*******************************************************************

		PBWINAPI(INT, ob_instantiate_child_object)
			(
				POB_THIS 					obthis,
				OB_INST_ID	 				parent_obinst,
				OB_CLASS_ID					child_type,
				UINT						field_id,
				POB_INST_ID					child_obinst
				);

		//*******************************************************************
		// Instantiate system object
		//*******************************************************************

		PBWINAPI(INT, ob_instantiate_system_object)
			(
				POB_THIS 					obthis,
				OB_CLASS_ID					object_type,
				POB_INST_ID					pObint
				);

		PBWINAPI(INT, ob_destroy_obinst)
			(
				POB_THIS 					obthis,
				OB_INST_ID 					obinst
				);

		PBWINAPI(VOID, ob_set_runtime)
			(
				POB_THIS 					obthis,
				BOOL 					 	bInRuntime
				);

		PBWINAPI(INT, ob_create_executable)
			(
				POB_THIS 					obthis,
				POB_EXEC 					pExecBlock,
				BOOL						bFreeGroups,
				LPTSTR						pManifestInfo
				);

		PBWINAPI(INT, ob_create_library)
			(
				POB_THIS 					obthis,
				POB_EXEC 					pExecBlock
				);

		typedef enum ob_lib_include_type
		{
			EXCLUDE_ALL,
			INCLUDE_REFERENCED,
			INCLUDE_REFERENCED_AND_DWS,
			INCLUDE_INDEPENDENT_OBJECTS,    // CR474377
			INCLUDE_ALL

		} OB_LIB_INCLUDE_TYPE, * POB_LIB_INCLUDE_TYPE;

		typedef LPTSTR* PBD_ARRAY;

		// Create 1 library from multiple source libraries. The enum OB_INCLUDE_TYPE
		// determines what source objects are copied to the target library. If a list of component
		// names is supplied, classes referenced by the components will be copied
		// from source libs that are marked INCLUDE_REFERENCED. INCLUDE_ALL means copy all
		// objects from the source library to the consolidated libary.
		// Also, any objects listed in the PBR file will be added to the consolidated library.
		// INCLUDE_REFERENCED_AND_DWS works like INCLUDE_REFERENCED plus all DW's will be added
		// EXCLUDE_ALL means create a new pbd in the same directory as the source pbl.
		// pPBDArray points to an array of pointers to an array of TCHAR that contains the
		// list of PBDs created (not including the pTargetLibrary). pNumPBD is a pointer to the number
		// of elements in the array. NOTE: The caller should delete this array using delete [] for each
		// element and for the array.  NULL can be passed for both pPBDArray and pNumPBD if the
		// caller is not interested in seeing the list.

		PBWINAPI(INT, ob_create_consolidated_library)
			(
				POB_THIS 					obthis,
				LPTSTR						pTargetLibrary,
				ULONG						nSourceLibs,
				LPTSTR* pSourceLibs,
				POB_LIB_INCLUDE_TYPE		pIncludeLibType,
				ULONG						nComponents,
				LPTSTR* pComponents,
				LPTSTR						pPBRFile,
				PBD_ARRAY* pPBDArray,
				PULONG						pNumPBD,
				LPTSTR* ppErrorMessage
				);

		// this only will work in C++
#ifdef __cplusplus
#ifndef PBGCLSIF_H
// ***** DOINC including pbgclsif.h *****
/* *********************************************************************** */
/*                                                                         */
/*             COPYRIGHT POWERSOFT CORPORATION 1996                        */
/*                                                                         */
/*        POWERSOFT CORPORATION ("POWERSOFT") CLAIMS COPYRIGHT IN THIS     */
/*   PROGRAM AND DOCUMENTATION AS AN UNPUBLISHED WORK, VERSIONS OF         */
/*   WHICH WERE FIRST LICENSED ON THE DATE INDICATED IN THE FOREGOING      */
/*   NOTICE.   CLAIM OF COPYRIGHT DOES NOT IMPLY WAIVER OF POWERSOFT'S     */
/*   OTHER RIGHTS.                                                         */
/*                                                                         */
/* ----------------------------------------------------------------------- */
/*                                                                         */
/*   Filename  : pbgclsif.h                                                */
/*                                                                         */
/*   Author    : David Sotkowitz                                           */
/*                                                                         */
/*   Purpose   : Class Information routines.                               */
/*                                                                         */
/* *********************************************************************** */

#ifndef PBGCLSIF_H
#define PBGCLSIF_H

#ifndef PBGTYPES_H
// ***** DOINC including pbgtypes.h *****
//----------------------------------------------------------------------------
//      pbgtypes.h
//      Basic function and type definitions.
//      "Customer" header for PowerBuilder generators.
//      wrlane  3/10/97
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//      Basic function prototypes
//
//      This duplicates the PBWINAPI declarations found in "ospascal.h".
//----------------------------------------------------------------------------

#ifndef PBGTYPES_H
#define PBGTYPES_H

/* *********************************************************************** */
/* Unicode defines                                                         */
/* *********************************************************************** */
#if defined(PS_UNICODE) && !defined(UNICODE)
#define UNICODE
#endif
#if defined(PS_UNICODE) && !defined(_UNICODE)
#define _UNICODE
#endif

#include <stddef.h>
#include <limits.h>

#ifndef FAR
#ifdef  WIN32
#define FAR
#else
#define FAR     _far
#endif
#endif

#ifndef NEAR
#ifdef WIN32
#define NEAR
#else
#define NEAR    _near
#endif
#endif

#ifndef PASCAL
#ifdef WIN32
#ifdef PBOS_UNIX
#define PASCAL
#else   //  PBOS_UNIX
#define PASCAL          __stdcall
#endif  //  PBOS_UNIX
#else   //      WIN32
#define PASCAL          _pascal
#endif  //  WIN32
#endif  //  defined PASCAL

#ifndef WINAPI
#ifdef  PBOS_NT
#define WINAPI          __stdcall
#else   //      PBOS_NT
#define WINAPI          FAR PASCAL
#endif  //  PBOS_NT
#endif  //  WINAPI

#ifndef PBWINAPI
#ifdef  PBOS_MAC
#ifdef  WIN32
#define PBWINAPI(r, n)  r (n)
#else   //      WIN32
#define PBWINAPI(r, n)  PASCAL r (n)
#endif  //  WIN32
#elif   defined(PBOS_OS2)
#define PBWINAPI(r, n)  FAR PASCAL __loadds r n
#elif   defined(__WATCOMC__) && defined(__cplusplus)
#define PBWINAPI(r, n)  __declspec(dllexport) r ( WINAPI n )
#else   //      PBOS_MAC, PBOS_OS2, WATCOM etc.
#define PBWINAPI(r, n)  r WINAPI n
#endif  //  PBOS_MAC
#endif  //  PBWINAPI

#ifndef PBWINAPI_
#ifdef  PBOS_MAC
#ifdef  WIN32
#define PBWINAPI_(r)    r
#else
#define PBWINAPI_(r)    PASCAL r
#endif  //  WIN32
#elif   defined(PBOS_OS2)
#define PBWINAPI_(r)    FAR PASCAL __loadds r
#elif   defined(__WATCOMC__) && defined(__cpluspllus)
#define PBWINAPI_(r)    __declspec(dllexport) r WINAPI
#else
#define PBWINAPI_(r)    r WINAPI
#endif  //  PBOS_MAC
#endif  //  PBWINAPI_

//----------------------------------------------------------------------------
//      Unicode string handling
//----------------------------------------------------------------------------

#ifndef PBTEXT
#ifdef RC_INVOKED
#define PBTEXT(quote)           quote
#elif defined WIN32
#ifdef UNICODE
#define PBTEXT(quote)           L##quote
#else
#define PBTEXT(quote)           quote
#endif  //  UNICODE
#else
#define PBTEXT(quote)           quote
#endif  //  RC_INVOKED
#endif  //  PBTEXT




//----------------------------------------------------------------------------
//      Basic data types
//----------------------------------------------------------------------------

#ifdef UNICODE
		typedef wchar_t                 PBCHAR;
#else
		typedef char                    PBCHAR;
#endif

#ifndef PBVOID
#define PBVOID                  void
#endif
#ifndef PBBYTE
#define PBBYTE                  unsigned char
#endif
#ifndef PBINT
#define PBINT                   int
#endif
#ifndef PBUINT
#define PBUINT                  unsigned int
#endif
#ifndef PBSHORT
#define PBSHORT                 short
#endif
#ifndef PBUSHORT
#define PBUSHORT                unsigned short
#endif
#ifndef PBLONG
#define PBLONG                  long
#endif
#ifndef PBULONG
#define PBULONG                 unsigned long
#endif
#ifndef PBLONGLONG
#ifndef PBOS_UNIX
#define PBLONGLONG              __int64
#else
#define PBLONGLONG              long long
#endif
#endif
#ifndef PBWORD
#define PBWORD                  unsigned short
#endif
#ifndef PBDWORD
#define PBDWORD                 unsigned long
#endif
#ifndef PBFLOAT
#define PBFLOAT                 float
#endif
#ifndef PBDOUBLE
#define PBDOUBLE                double
#endif
#ifndef PBPVOID
#define PBPVOID                 void FAR *
#endif

#ifndef PBBYTE_NULL
#define PBBYTE_NULL                             UCHAR_MAX
#endif
#ifndef PBCHAR_NULL
#define PBCHAR_NULL                             CHAR_MAX
#endif
#ifndef PBINT_NULL
#define PBINT_NULL                              INT_MAX
#endif
#ifndef PBUINT_NULL
#define PBUINT_NULL                             UINT_MAX
#endif
#ifndef PBSHORT_NULL
#define PBSHORT_NULL                    SHRT_MAX
#endif
#ifndef PBUSHORT_NULL
#define PBUSHORT_NULL                   USHRT_MAX
#endif
#ifndef PBLONG_NULL
#define PBLONG_NULL                             LONG_MAX
#endif
#ifndef PBULONG_NULL
#define PBULONG_NULL                    ULONG_MAX
#endif
#ifndef PBLONGLONG_NULL
#ifndef PBOS_LINUX
#define PBLONGLONG_NULL                    (PBLONGLONG)0x7fffffffffffffffL
#else
#define PBLONGLONG_NULL                    (PBLONGLONG)0x7fffffffffffffffLL
#endif
#endif
#ifndef PBFLOAT_NULL
#define PBFLOAT_NULL                    (PBFLOAT)1E+37
#endif
#ifndef PBDOUBLE_NULL
#define PBDOUBLE_NULL                   (PBDOUBLE)1E+37
#endif

		//----------------------------------------------------------------------------
		//      Simple PB types
		//----------------------------------------------------------------------------

#ifndef PBINDEX
#define PBINDEX                 PBLONG
#endif
#ifndef PBMEMBERID
#define PBMEMBERID              PBLONG
#endif
#ifndef PBBOOL
#define PBBOOL                  PBINT
#endif
#ifndef PBPOINTER
#define PBPOINTER               PBPVOID
#endif
#ifndef PBOBJECTID
#define PBOBJECTID              PBPVOID
#endif

#ifndef PBHANDLE
#ifdef  STRICT
#ifdef  WIN32
#define PBHANDLE                PBPVOID
#else   //  WIN32
#define PBHANDLE                const void NEAR *
#endif  //  WIN32
#else   //  STRICT
#ifdef  WIN32
#define PBHANDLE                PBPVOID
#else   //  WIN32
#define PBHANDLE                PBUINT
#endif  //  WIN32
#endif  //  STRICT
#endif  //  PBHANDLE


#ifndef PBTRUE
#define PBTRUE                  1
#endif
#ifndef PBFALSE
#define PBFALSE                 0
#endif


//----------------------------------------------------------------------------
//      Odds and ends for compliance with Windows, OLE, etc.
//----------------------------------------------------------------------------

#ifndef NOERROR
#define NOERROR         0
#endif
#ifndef S_OK
#define S_OK            0
#endif
#ifndef E_NOINTERFACE
#define E_NOINTERFACE   0x80004002L
#endif

//----------------------------------------------------------------------------
//      PB enumerated types
//----------------------------------------------------------------------------

		enum PBLibraryType
		{
			PBLibraryTypeMachineCode,
			PBLibraryTypePCode,
			PBLibraryTypeCount
		};

		enum PBObjectType
		{
			PBObjectTypeNVO,
			PBObjectTypeCustomVisual,
			PBObjectTypeWindow,
			PBObjectTypeApplication,
			PBObjectTypeCount
		};

		enum PBGeneratorStatus
		{
			PBGeneratorStatusIdle,
			PBGeneratorStatusBusy,
			PBGeneratorStatusCount
		};

		enum PBValueType
		{
			PBValueTypeNull,
			PBValueTypeAny,
			PBValueTypePointer,
			PBValueTypeChar,
			PBValueTypeByte,
			PBValueTypeInt,
			PBValueTypeUInt,
			PBValueTypeShort,
			PBValueTypeUShort,
			PBValueTypeLong,
			PBValueTypeULong,
			PBValueTypeLonglong,
			PBValueTypeDecimal,
			PBValueTypeFloat,
			PBValueTypeDouble,
			PBValueTypeBoolean,
			PBValueTypeDate,
			PBValueTypeTime,
			PBValueTypeDateTime,
			PBValueTypeString,
			PBValueTypeBlob,
			PBValueTypeInstance,
			PBValueTypeArray,
			PBValueTypeUserDefined,
			PBValueTypeCount
		};

		enum PBVariableKind
		{
			PBVariableKindGlobal,
			PBVariableKindShared,
			PBVariableKindInstance,
			PBVariableKindArgument,
			PBVariableKindLocal
		};

		enum PBVariableAccess
		{
			PBVariableAccessPrivate,
			PBVariableAccessPublic,
			PBVariablerAccessProtected,
			PBVariableAccessSystem
		};

		enum PBArgCallConvention
		{
			PBArgCallConventionByReference,
			PBArgCallConventionByValue,
			PBArgCallConventionReadOnly,
			PBArgCallConventionVariableList
		};

		enum PBVariableCardinalityType
		{
			PBVariableCardinalityTypeScalarType,
			PBVariableCardinalityTypeUnboundedArray,
			PBVariableCardinalityTypeBoundedArray
		};

		enum PBScriptKind
		{
			PBScriptKindEvent,
			PBScriptKindFunction
		};

		enum PBTypeCategory
		{
			PBTypeCategorySimpleType,
			PBTypeCategoryEnumeratedType,
			PBTypeCategoryClassOrStructureType
		};

		enum PBSessionSecurityMode
		{
			PBSessionSecurityModeNoDBModify = 0,
			PBSessionSecurityModeNoDBStoredProc,
			PBSessionSecurityModeNoDB,
			PBSessionSecurityModeNoConnectOtherPB,
			PBSessionSecurityModeNoConnectNonsecurePB,
			PBSessionSecurityModeNoOLE,
			PBSessionSecurityModeNoPrint,
			PBSessionSecurityModeCount
		};

		//----------------------------------------------------------------------------
		//      structures
		//----------------------------------------------------------------------------

		//  Bitmap

		typedef struct
		{
			PBHANDLE    hIcon;
		} PBBITMAP;


		//  Interface ID (e.g., UUID or GUID)

		typedef struct
		{
			PBULONG             ulData1;
			PBUSHORT            usData2;
			PBUSHORT            usData3;
			PBBYTE              ucData4[8];
		}   PBID;

		typedef PBID            PBIID;
		typedef PBID            PBCLSID;
		typedef PBID            PBMETAID;

#ifdef __cplusplus
		typedef PBID& PBIDREF;
#else
		typedef PBID* PBIDREF;
#endif
		typedef PBIDREF         PBIIDREF;
		typedef PBIDREF         PBCLSIDREF;
		typedef PBIDREF         PBMETAIDREF;


#endif  //  PBGTYPES_H
		// DOINC popped back into header 'pbgclsif.h'
#endif
#ifndef PBGTYPIF_H
// ***** DOINC including pbgtypif.h *****
//              Copyright Sybase, Inc. 1996
//
//      Sybase, Inc. ("Sybase") claims copyright in this
//      program and documentation as an unpublished work, versions of
//      which were first licensed on the date indicated in the foregoing
//      notice.  Claim of copyright does not imply waiver of Sybase's
//      other rights.
//-----------------------------------------------------------------------------
//      pbgtypif.h
//	PB Generator interface-based basic type declarations.
//	wrlane 6/13/97
//-----------------------------------------------------------------------------

#ifndef PBGTYPIF_H
#define PBGTYPIF_H

#ifndef PBGIUNIF_H
// ***** DOINC including pbgiunif.h *****
//-----------------------------------------------------------------------------
//      pbgiunif.h
//      PBIUnknown interface definition
//      wrlane 3/10/97
//
//      PBIUnkown is the base class for all PowerBuilder interfaces.
//      It defines a minimal, common interface that all other interfaces
//      must support:
//
//      o       QueryInterface
//              Allows a user to see if a particular interface is 
//              supported by an object.
//
//      o       AddRef
//              Increment the internal count of how many other objects 
//              are currently using a given instance.
//
//      o       Release
//              Decrement the internal current user count.
//
//      These functions are declared here as pure virtual functions.  They
//      must be implemented by derived generator interface types.
//      
//      PBIUnknown is based on, and is semantically consistent with, the 
//      OLE IUnknown interface.
//
//-----------------------------------------------------------------------------

#ifndef PBGIUNIF_H
#define PBGIUNIF_H

#ifndef PBGTYPES_H
// ***** DOINC including pbgtypes.h *****
	// DOINC skipping duplicate include
#endif
#ifndef PBGRESLT_H 
// ***** DOINC including pbgreslt.h *****
//-----------------------------------------------------------------------------
//      pbgerslt.h
//
//      PowerBuilder generator error codes.
//-----------------------------------------------------------------------------

#ifndef PBRESULT_H
#define PBRESULT_H

//      TODO:
//      This stuff duplicates what's already found in ./include/pbresult.h.
//      It's repeated here because this header will be used outside of 
//      PowerBuilder, where pbresult.h will not be available.  
//      These headers should be integrated into a single header which
//      is published in a "customer" header area.
//      wrlane 3/11/97

//-----------------------------------------------------------------------------
//
// PBRESULTs are merely a 32-bit value with several fields encoded
// in the value.  The parts of a PBRESULT are shown below.
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-+-+---------------------+-----------+-------------------+
//  |S|R|C|N|r|    Facility         | PB Module |       Code        |
//  +-+-+-+-+-+---------------------+-----------+-------------------+
//
//  where
//
//  S - Severity - indicates success (0) or failure (1)
//  R, C, N, r - unused by PowerBuilder, defined for HRESULT in winerror.h
//  Facility - facility code. For PB APIs and functions, always FACILITY_ITF.
//  PB Module - Identifies the PowerBuilder module that created the error.
//  Code - is the module's return code
//
//  Other useful macros -
//
//  SUCCEEDED(result) - Returns true if a given PBRESULT indicates success
//  FAILED(result)    - Returns true if a given PBRESULT indicates failure
//
//-----------------------------------------------------------------------------


#ifndef PBRESULT
#define PBRESULT                PBLONG
#endif
#ifndef FACILITY_ITF
#define FACILITY_ITF            4
#endif
#ifndef SEVERITY_SUCCESS
#define SEVERITY_SUCCESS        0
#endif
#ifndef SEVERITY_ERROR  
#define SEVERITY_ERROR          1
#endif
#ifndef SUCCEEDED
#define SUCCEEDED(result)       ((result) >= 0)
#endif
#ifndef FAILED
#define FAILED(result)          ((result) < 0)
#endif
#ifndef MAKE_SCODE
#define MAKE_SCODE(sev, fac, code) \
	((long)(((unsigned long)(sev)<<31) | \
	((unsigned long)(fac)<<16) | \
	((unsigned long)(code))))
#endif
#ifndef MAKE_PBRESULT
#define MAKE_PBRESULT(sev, module, code) \
	(MAKE_SCODE(sev, FACILITY_ITF, \
	((((unsigned long)(module))<<10) | (((unsigned long)(code))&0x03FF))))
#endif
#ifndef PBRESULT_CODE
#define PBRESULT_CODE(result)   ((result) & 0x03FF)
#endif
#ifndef PBRESULT_MODULE
#define PBRESULT_MODULE(result) (((result)>>10) & 0x003F)
#endif

#endif  //  PBRESULT_H

//  Generator specific stuff

#ifndef PBGRESLT_H
#define PBGRESLT_H

// ***** DOINC including pbgtypes.h *****
	// DOINC skipping duplicate include

#ifndef PBMODULE_GENERATOR
#define PBMODULE_GENERATOR      15
#endif

#define PBRESULT_OK             0
#define PBRESULT_FAIL \
	MAKE_PBRESULT(SEVERITY_ERROR, PBMODULE_GENERATOR, 0)

#endif  //  PBGRESLT_H


// DOINC popped back into header 'pbgiunif.h'
#endif


		extern "C"
		{
			extern PBIID PBIUnknown_IID;
		};


		class PBIUnknown
		{
		public:

			virtual PBWINAPI_(PBRESULT) QueryInterface(
				PBIIDREF        idInterfaceID,
				PBIUnknown** ppGeneratorInterface) = 0;

			virtual PBWINAPI_(PBULONG) AddRef() = 0;
			virtual PBWINAPI_(PBULONG) Release() = 0;
		};


#endif //  PBGIUIF_H

		// DOINC popped back into header 'pbgtypif.h'
#endif


		extern "C"
		{
			extern PBIID PBIString_IID;
			extern PBIID PBIStringList_IID;
			extern PBIID PBIDateTime_IID;
			extern PBIID PBIDate_IID;
			extern PBIID PBITime_IID;
			extern PBIID PBIDecimal_IID;
			extern PBIID PBIBlob_IID;

			extern PBIID PBIStringToBlob_IID;
			extern PBIID PBIDateTimeToBlob_IID;
			extern PBIID PBIDateToBlob_IID;
			extern PBIID PBITimeToBlob_IID;
			extern PBIID PBIDecimalToBlob_IID;

			extern PBIID PBIDateTimeToString_IID;
			extern PBIID PBIDateToString_IID;
			extern PBIID PBITimeToString_IID;
			extern PBIID PBIDecimalToString_IID;
		};

		//	Forward declarations for convenience.

		class PBIString;
		class PBIStringList;
		class PBIDateTime;
		class PBIDate;
		class PBITime;
		class PBIDecimal;
		class PBIBlob;

		class PBIStringToBlob;
		class PBIDateTimeToBlob;
		class PBIDateToBlob;
		class PBITimeToBlob;
		class PBIDecimalToBlob;

		class PBIDateTimeToString;
		class PBIDateToString;
		class PBITimeToString;
		class PBIDecimalToString;


		//-----------------------------------------------------------------------------
		//      String
		//-----------------------------------------------------------------------------

		class PBIString : public PBIUnknown
		{
		public:

			virtual PBWINAPI_(PBRESULT)    GetValue(PBCHAR** pValue) = 0;
			virtual PBWINAPI_(PBRESULT)    GetLength(PBULONG* pcLength) = 0;
			virtual PBWINAPI_(PBRESULT)    GetValueAt(PBULONG ulOffset, PBCHAR* pChar) = 0;

			virtual PBWINAPI_(PBRESULT)	Append(PBIString* pString) = 0;
			virtual PBWINAPI_(PBRESULT)	InsertAt(PBULONG ulOffset, PBIString* pString) = 0;
			virtual PBWINAPI_(PBRESULT)    SubString(
				PBULONG         ulFrom,
				PBULONG         ulTo,
				PBIString** ppSubString) = 0;

			virtual PBWINAPI_(PBRESULT)    Clone(PBIString** ppString) = 0;
			virtual PBWINAPI_(PBRESULT)    IsNull(PBBOOL* pBool) = 0;
			virtual PBWINAPI_(PBRESULT)    CompareTo(
				PBIString* pString,
				PBINT* piComparison) = 0;
		};

		class PBIStringList : public PBIUnknown
		{
		public:

			virtual PBWINAPI_(PBRESULT)	Add(PBIString*) = 0;
			virtual PBWINAPI_(PBRESULT)	Remove(PBIString*) = 0;

			virtual PBWINAPI_(PBRESULT)	GetCount(PBINDEX* pCount) = 0;

			virtual PBWINAPI_(PBRESULT)	GetFirst(PBIString** pFirst) = 0;
			virtual PBWINAPI_(PBRESULT)	GetNext(PBIString** pNext) = 0;

			virtual PBWINAPI_(PBRESULT)	GetLast(PBIString** pLast) = 0;
			virtual PBWINAPI_(PBRESULT)	GetPrevious(PBIString** pPrevious) = 0;
		};

		class PBIStringToBlob : public PBIUnknown
		{
		public:

			virtual PBWINAPI_(PBRESULT)	GetAsBlob(PBIBlob** ppBlob) = 0;
			virtual PBWINAPI_(PBRESULT)	ReadFromBlob(PBIBlob* pBlob) = 0;
		};

		extern "C"
		{
			PBWINAPI_(PBRESULT) CreatePBIString(
				PBCHAR* pValue,
				PBIString** ppString);

			PBWINAPI_(PBRESULT) CreatePBIStringList(
				PBIStringList** ppStringList);
		};

		//-----------------------------------------------------------------------------

		class PBIDateTime : public PBIUnknown
		{
		public:

			virtual PBWINAPI_(PBRESULT)	GetDate(PBIDate** ppDate) = 0;
			virtual PBWINAPI_(PBRESULT)	GetTime(PBITime** ppTime) = 0;

			virtual PBWINAPI_(PBRESULT)	Clone(PBIDateTime** ppDateTime) = 0;
			virtual PBWINAPI_(PBRESULT)	IsNull(PBBOOL* pBool) = 0;
			virtual PBWINAPI_(PBRESULT)	CompareTo(
				PBIDateTime* pDateTime,
				PBINT* pComparison) = 0;
		};

		class PBIDateTimeToBlob : public PBIUnknown
		{
		public:

			virtual PBWINAPI_(PBRESULT)    GetAsBlob(PBIBlob** ppBlob) = 0;
			virtual PBWINAPI_(PBRESULT)    ReadFromBlob(PBIBlob* pBlob) = 0;
		};

		class PBIDateTimeToString : public PBIUnknown
		{
		public:

			virtual PBWINAPI_(PBRESULT)    GetAsString(PBIString** ppString) = 0;
			virtual PBWINAPI_(PBRESULT)    ReadFromString(PBIString* pString) = 0;
		};

		extern "C"
		{
			PBWINAPI_(PBRESULT) CreatePBIDateTime(
				PBIDate* pDate,
				PBITime* pTime,
				PBIDateTime** ppDateTime);
		};


		//-----------------------------------------------------------------------------

		class PBIDate : public PBIUnknown
		{
		public:

			virtual PBWINAPI_(PBRESULT)	GetYear(PBSHORT* pYear) = 0;
			virtual PBWINAPI_(PBRESULT)	GetMonth(PBINT* pMonth) = 0;
			virtual PBWINAPI_(PBRESULT)	GetDayOfMonth(PBINT* pDay) = 0;
			virtual PBWINAPI_(PBRESULT)	GetDayOfWeek(PBINT* pDay) = 0;

			virtual PBWINAPI_(PBRESULT)	DaysAfter(
				PBIDate* pDate,
				PBLONG* pDaysAfter) = 0;
			virtual PBWINAPI_(PBRESULT)	RelativeDate(
				PBLONG 		iDays,
				PBIDate** ppDate) = 0;

			virtual PBWINAPI_(PBRESULT)    Clone(PBIDate** ppDate) = 0;
			virtual PBWINAPI_(PBRESULT)    IsNull(PBBOOL* pBool) = 0;
			virtual PBWINAPI_(PBRESULT)    CompareTo(
				PBIDate* pDate,
				PBINT* pComparison) = 0;
		};

		class PBIDateToBlob : public PBIUnknown
		{
		public:

			virtual PBWINAPI_(PBRESULT)    GetAsBlob(PBIBlob** ppBlob) = 0;
			virtual PBWINAPI_(PBRESULT)    ReadFromBlob(PBIBlob* pBlob) = 0;
		};

		class PBIDateToString : public PBIUnknown
		{
		public:

			virtual PBWINAPI_(PBRESULT)    GetAsString(PBIString** ppString) = 0;
			virtual PBWINAPI_(PBRESULT)    ReadFromString(PBIString* pString) = 0;

			virtual PBWINAPI_(PBRESULT)	GetDayOfWeekName(PBIString** ppString) = 0;
		};

		extern "C"
		{
			PBWINAPI_(PBRESULT) CreatePBIDateToday(PBIDate** ppDate);
			PBWINAPI_(PBRESULT) CreatePBIDate(
				PBSHORT		iYear,
				PBINT		iMonth,
				PBINT		iDay,
				PBIDate** ppDate);
		};

		//-----------------------------------------------------------------------------

		class PBITime : public PBIUnknown
		{
		public:

			virtual PBWINAPI_(PBRESULT)	GetHour(PBINT* iHour) = 0;
			virtual PBWINAPI_(PBRESULT)	GetMinute(PBINT* iMinute) = 0;
			virtual PBWINAPI_(PBRESULT)	GetSecond(PBINT* iSecond) = 0;

			virtual PBWINAPI_(PBRESULT)	SecondsAfter(
				PBITime* pTime,
				PBLONG* pSecondsAfter) = 0;
			virtual PBWINAPI_(PBRESULT)	RelativeTime(
				PBLONG			lSeconds,
				PBITime** ppTime) = 0;

			virtual PBWINAPI_(PBRESULT)    Clone(PBITime** ppTime) = 0;
			virtual PBWINAPI_(PBRESULT)    IsNull(PBBOOL* pBool) = 0;
			virtual PBWINAPI_(PBRESULT)    CompareTo(
				PBITime* pTime,
				PBINT* pComparison) = 0;
		};

		class PBITimeToBlob : public PBIUnknown
		{
		public:

			virtual PBWINAPI_(PBRESULT)    GetAsBlob(PBIBlob** ppBlob) = 0;
			virtual PBWINAPI_(PBRESULT)    ReadFromBlob(PBIBlob* pBlob) = 0;
		};

		class PBITimeToString : public PBIUnknown
		{
		public:

			virtual PBWINAPI_(PBRESULT)    GetAsString(PBIString** ppString) = 0;
			virtual PBWINAPI_(PBRESULT)    ReadFromString(PBIString* pString) = 0;
		};

		extern "C"
		{
			PBWINAPI_(PBRESULT) CreatePBITimeNow(PBITime** ppTime);
			PBWINAPI_(PBRESULT) CreatePBITime(
				PBINT iHour,
				PBINT iMinute,
				PBINT iSecond,
				PBITime** ppTime);
		};

		//-----------------------------------------------------------------------------

		class PBIDecimal : public PBIUnknown
		{
		public:

			virtual PBWINAPI_(PBRESULT)	Clone(PBIDecimal** ppDecimal) = 0;
			virtual PBWINAPI_(PBRESULT)	IsNull(PBBOOL* pBool) = 0;
			virtual PBWINAPI_(PBRESULT)	CompareTo(
				PBIDecimal* pDecimal,
				PBINT* pComparison) = 0;

			virtual PBWINAPI_(PBRESULT)	GetDecimalAsDouble(PBDOUBLE* pDouble) = 0;
			virtual PBWINAPI_(PBRESULT)	SetDecimalFromDouble(PBDOUBLE) = 0;
		};

		class PBIDecimalToBlob : public PBIUnknown
		{
		public:

			virtual PBWINAPI_(PBRESULT)    GetAsBlob(PBIBlob** ppBlob) = 0;
			virtual PBWINAPI_(PBRESULT)    ReadFromBlob(PBIBlob* pBlob) = 0;
		};

		class PBIDecimalToString : public PBIUnknown
		{
		public:

			virtual PBWINAPI_(PBRESULT)    GetAsString(PBIString** ppString) = 0;
			virtual PBWINAPI_(PBRESULT)    ReadFromString(PBIString* pString) = 0;
		};

		extern "C"
		{
			PBWINAPI_(PBRESULT) CreatePBIDecimal(
				PBIDecimal** ppDecimal);
		};

		//-----------------------------------------------------------------------------

		class PBIBlob : public PBIUnknown
		{
		public:

			virtual PBWINAPI_(PBRESULT)	GetSize(PBULONG* pSize) = 0;
			virtual PBWINAPI_(PBRESULT)	GetData(PBPVOID* ppData) = 0;

			virtual PBWINAPI_(PBRESULT)	InsertData(
				PBULONG 		lOffset,
				PBIBlob* pData) = 0;
			virtual PBWINAPI_(PBRESULT)	ExtractData(
				PBULONG 		lStart,
				PBULONG 		lSize,
				PBIBlob** ppExtract) = 0;

			virtual PBWINAPI_(PBRESULT)	Clone(PBIBlob** ppBlob) = 0;
			virtual PBWINAPI_(PBRESULT)	IsNull(PBBOOL* pBool) = 0;
		};

		extern "C"
		{
			PBWINAPI_(PBRESULT) CreatePBIBlob(
				PBULONG		lSize,
				PBPVOID		pData,
				PBIBlob** ppBlob);
		};

#endif  //  PBGTYPIF_H
		// DOINC popped back into header 'pbgclsif.h'
#endif
#ifndef PBGRUNIF_H
// ***** DOINC including pbgrunif.h *****
//              Copyright Sybase, Inc. 1996
//
//      Sybase, Inc. ("Sybase") claims copyright in this
//      program and documentation as an unpublished work, versions of
//      which were first licensed on the date indicated in the foregoing
//      notice.  Claim of copyright does not imply waiver of Sybase's
//      other rights.
//-----------------------------------------------------------------------------
//      pbgrunif.h
//  Generator runtime interface declarations.
//  wrlane  6/13/97
//-----------------------------------------------------------------------------

#ifndef PBGRUNIF_H
#define PBGRUNIF_H

#ifndef PBGIUNIF_H
// ***** DOINC including pbgiunif.h *****
	// DOINC skipping duplicate include
#endif
#ifndef PBGTYPIF_H
// ***** DOINC including pbgtypif.h *****
	// DOINC skipping duplicate include
#endif

//  Interface ID's

		extern "C"
		{
			extern PBIID PBISession_IID;
			extern PBIID PBISessionSecurity_IID;
			extern PBIID PBIContext_IID;
			extern PBIID PBIInstance_IID;
			extern PBIID PBIArgument_IID;
			extern PBIID PBIValue_IID;
			extern PBIID PBIArray_IID;
			extern PBIID PBIArrayBounds_IID;
			extern PBIID PBIArrayBoundsList_IID;
			extern PBIID PBIException_IID;
			extern PBIID PBInstanceValueDispatch_CLSID;
		};

		//  Forward declarations for convenience.

		class PBISession;
		class PBISessionSecurity;
		class PBIContext;
		class PBIInstance;
		class PBIArgument;
		class PBIValue;
		class PBIArray;
		class PBIArrayBounds;
		class PBIArrayBoundsList;
		class PBIException;

		//  Forward declarations to avoid header include cycles.

		class PBIClassDef;
		class PBITypeDef;
		class PBIScriptDef;

		//-----------------------------------------------------------------------------
		//                              PBISession
		//-----------------------------------------------------------------------------

		class PBISession : public PBIUnknown
		{
		public:

			virtual PBWINAPI_(PBRESULT) CreateInstance(PBIString* pInstanceName, PBIInstance** pInstance) = 0;
			virtual PBWINAPI_(PBRESULT) FindClassDefinition(PBIString* pClassName, PBIClassDef** ppClassDef) = 0;
			virtual PBWINAPI_(PBRESULT) FindTypeDefinition(PBIString* pTypeName, PBITypeDef** ppTypeDef) = 0;
			virtual PBWINAPI_(PBRESULT) FindScriptDefinition(PBIString* pScriptName, PBIScriptDef** ppScriptDef) = 0;
			virtual PBWINAPI_(PBRESULT) GetContext(PBIContext** ppContext) = 0;
			virtual PBWINAPI_(PBRESULT) GetLibraryList(PBIString**) = 0;
			virtual PBWINAPI_(PBRESULT) GetOB_THIS(void**) = 0;

		};

		class PBISessionSecurity : public PBIUnknown
		{
			virtual PBWINAPI_(PBRESULT) IsSecurityModeSet(
				PBSessionSecurityMode eSecurityMode,
				PBBOOL* bIsSet) = 0;
			virtual PBWINAPI_(PBRESULT) SetSecurityMode(
				PBSessionSecurityMode eSecurityMode,
				PBBOOL bSetMode) = 0;
		};

		extern "C"
		{
			PBWINAPI_(PBRESULT) CreatePBISession(
				PBIString* pApplicationName,
				PBIString* pLibraryList,
				PBLibraryType   enmLibraryType,
				PBIContext* pContext,
				PBISession** ppSession);

			PBWINAPI_(PBRESULT) CreatePBISessionEx(
				PBIString* pApplicationName,
				PBIString* pLibraryList,
				PBLibraryType   enmLibraryType,
				PBIContext* pContext,
				PBISession** ppSession);

		};

		//-----------------------------------------------------------------------------
		//                          PBIContext
		//-----------------------------------------------------------------------------

		class PBIContext : public PBIUnknown
		{
		public:

			virtual PBWINAPI_(PBRESULT) GetService(
				PBISession* pSession,
				PBIString* pServiceName,
				PBIInstance* pRequestor,
				PBIInstance** ppService) = 0;
		};

		//-----------------------------------------------------------------------------
		//                      PBIInstance
		//-----------------------------------------------------------------------------

		class PBIInstance : public PBIUnknown
		{
		public:

			//  Get/Set properties, invoke methods by name.

			virtual PBWINAPI_(PBRESULT)    GetProperty(
				PBIString* pPropertyName,
				PBIValue** ppPropertyValue) = 0;
			virtual PBWINAPI_(PBRESULT)    SetProperty(
				PBIString* pPropertyName,
				PBIValue* pPropertyValue) = 0;

			virtual PBWINAPI_(PBRESULT)    PreDoMethod() = 0;
			virtual PBWINAPI_(PBRESULT)    DoMethod(
				PBIString* pMethodName,
				PBIArgument** ppArgs,
				PBINDEX         cArgCount,
				PBIValue** ppResult,
				PBIException** ppException,
				PBINDEX* pBadParamIndex) = 0;
			virtual PBWINAPI_(PBRESULT)    PostDoMethod() = 0;

			//  Get/Set properties, invoke methods by ID.

			virtual PBWINAPI_(PBRESULT)    GetPropertyByID(
				PBMEMBERID      idPropertyID,
				PBIValue** pPropertyValue) = 0;
			virtual PBWINAPI_(PBRESULT)    SetPropertyByID(
				PBMEMBERID      idPropertyID,
				PBIValue* pPropertyValue) = 0;
			virtual PBWINAPI_(PBRESULT)    DoMethodByID(
				PBMEMBERID      idMethodID,
				PBIArgument** ppArgs,
				PBINDEX         cArgCount,
				PBIValue** ppResult,
				PBIException** ppException,
				PBINDEX* pBadParamIndex) = 0;


			//  Fetch the member ids for a list of names

			virtual PBWINAPI_(PBRESULT)    GetIDsForNames(
				PBIString** pMemberNames,
				PBINDEX         iMemberNameCount,
				PBMEMBERID* pMemberIDs) = 0;

			//  Fetch the session and/or class id for this instance

			virtual PBWINAPI_(PBRESULT)    GetSession(
				PBISession** ppSession) = 0;
			virtual PBWINAPI_(PBRESULT)    GetClassID(
				PBObjectType* pClassType) = 0;

			virtual PBWINAPI_(PBRESULT) GetContext(PBIContext** ppContext) = 0;
			virtual PBWINAPI_(PBRESULT) Clone(PBIInstance** ppInstance) = 0;
		};

		extern "C"
		{
			PBWINAPI_(PBRESULT) CreatePBIInstanceByName(
				PBIString* pName,
				PBISession* pSession,
				PBIInstance** ppInstance);

			PBWINAPI_(PBRESULT) CreatePBIInstanceByID(
				void* obInst,
				PBISession* pSession,
				PBIInstance** ppInstance);
		};

		//-----------------------------------------------------------------------------
		//              PBIArgument
		//-----------------------------------------------------------------------------

		class PBIArgument : public PBIUnknown
		{
		public:

			virtual PBWINAPI_(PBRESULT)    GetValue(PBIValue** ppValue) = 0;
			virtual PBWINAPI_(PBRESULT)    SetValue(PBIValue* pValue) = 0;
			virtual PBWINAPI_(PBRESULT)    GetHowPassed(PBArgCallConvention* pHowPassed) = 0;

			virtual PBWINAPI_(PBRESULT) GetSession(PBISession** ppSession) = 0;
			virtual PBWINAPI_(PBRESULT) Clone(PBIArgument** ppArgument) = 0;
		};

		extern "C"
		{
			PBWINAPI_(PBRESULT) CreatePBIArgument(
				PBIValue* pValue,
				PBArgCallConvention eHowPassed,
				PBIArgument** ppArgument);
		};


		//-----------------------------------------------------------------------------
		//              PBIValue
		//-----------------------------------------------------------------------------

		class PBIValue : public PBIUnknown
		{
		public:

			virtual PBWINAPI_(PBRESULT)    IsNullValued(PBBOOL* pBool) = 0;
			virtual PBWINAPI_(PBRESULT)    MakeNullValued(PBBOOL bMakeNull) = 0;

			virtual PBWINAPI_(PBRESULT)    GetValueType(PBValueType* pType) = 0;

			virtual PBWINAPI_(PBRESULT)    GetValueAsChar(PBCHAR* pChar) = 0;
			virtual PBWINAPI_(PBRESULT)    GetValueAsByte(PBBYTE* pByte) = 0;
			virtual PBWINAPI_(PBRESULT)    GetValueAsInt(PBINT* pInt) = 0;
			virtual PBWINAPI_(PBRESULT)    GetValueAsUInt(PBUINT* pUInt) = 0;
			virtual PBWINAPI_(PBRESULT)    GetValueAsShort(PBSHORT* pShort) = 0;
			virtual PBWINAPI_(PBRESULT)    GetValueAsUShort(PBUSHORT* pUShort) = 0;
			virtual PBWINAPI_(PBRESULT)    GetValueAsLong(PBLONG* pLong) = 0;
			virtual PBWINAPI_(PBRESULT)    GetValueAsULong(PBULONG* pULong) = 0;
			virtual PBWINAPI_(PBRESULT)    GetValueAsLonglong(PBLONGLONG* pLonglong) = 0;
			virtual PBWINAPI_(PBRESULT)    GetValueAsDecimal(PBIDecimal** pDecimal) = 0;
			virtual PBWINAPI_(PBRESULT)    GetValueAsFloat(PBFLOAT* pFloat) = 0;
			virtual PBWINAPI_(PBRESULT)    GetValueAsDouble(PBDOUBLE* pDouble) = 0;
			virtual PBWINAPI_(PBRESULT)    GetValueAsBoolean(PBBOOL* pBool) = 0;
			virtual PBWINAPI_(PBRESULT)    GetValueAsDate(PBIDate** pDate) = 0;
			virtual PBWINAPI_(PBRESULT)    GetValueAsTime(PBITime** pTime) = 0;
			virtual PBWINAPI_(PBRESULT)    GetValueAsDateTime(PBIDateTime** pDateTime) = 0;
			virtual PBWINAPI_(PBRESULT)    GetValueAsString(PBIString** pString) = 0;
			virtual PBWINAPI_(PBRESULT)    GetValueAsBlob(PBIBlob** pBlob) = 0;
			virtual PBWINAPI_(PBRESULT)    GetValueAsInstance(PBIInstance** pInstance) = 0;
			virtual PBWINAPI_(PBRESULT)    GetValueAsArray(PBIArray** pArray) = 0;

			virtual PBWINAPI_(PBRESULT)    SetValueFromChar(PBCHAR cValue) = 0;
			virtual PBWINAPI_(PBRESULT)    SetValueFromByte(PBBYTE ubValue) = 0;
			virtual PBWINAPI_(PBRESULT)    SetValueFromInt(PBINT iValue) = 0;
			virtual PBWINAPI_(PBRESULT)    SetValueFromUInt(PBUINT uiValue) = 0;
			virtual PBWINAPI_(PBRESULT)    SetValueFromShort(PBSHORT iValue) = 0;
			virtual PBWINAPI_(PBRESULT)    SetValueFromUShort(PBUSHORT uiValue) = 0;
			virtual PBWINAPI_(PBRESULT)    SetValueFromLong(PBLONG lValue) = 0;
			virtual PBWINAPI_(PBRESULT)    SetValueFromULong(PBULONG ulValue) = 0;
			virtual PBWINAPI_(PBRESULT)    SetValueFromLonglong(PBLONGLONG llValue) = 0;
			virtual PBWINAPI_(PBRESULT)    SetValueFromDecimal(PBIDecimal* pDecimal) = 0;
			virtual PBWINAPI_(PBRESULT)    SetValueFromFloat(PBFLOAT fValue) = 0;
			virtual PBWINAPI_(PBRESULT)    SetValueFromDouble(PBDOUBLE dValue) = 0;
			virtual PBWINAPI_(PBRESULT)    SetValueFromBoolean(PBBOOL bValue) = 0;
			virtual PBWINAPI_(PBRESULT)    SetValueFromDate(PBIDate* pDate) = 0;
			virtual PBWINAPI_(PBRESULT)    SetValueFromTime(PBITime* pTime) = 0;
			virtual PBWINAPI_(PBRESULT)    SetValueFromDateTime(PBIDateTime* pDateTime) = 0;
			virtual PBWINAPI_(PBRESULT)    SetValueFromString(PBIString* pString) = 0;
			virtual PBWINAPI_(PBRESULT)    SetValueFromBlob(PBIBlob* pBlob) = 0;
			virtual PBWINAPI_(PBRESULT)    SetValueFromInstance(PBIInstance* pInstance) = 0;
			virtual PBWINAPI_(PBRESULT)    SetValueFromArray(PBIArray* pArray) = 0;

			virtual PBWINAPI_(PBRESULT) SetValueFromValue(PBIValue* pValue) = 0;

			virtual PBWINAPI_(PBRESULT) GetSession(PBISession** ppSession) = 0;

			virtual PBWINAPI_(PBRESULT) Clone(PBIValue** ppValue) = 0;
		};

		extern "C"
		{
			PBWINAPI_(PBRESULT) CreatePBIValue(
				PBValueType     enmValueType,
				PBISession* pSession,
				PBIValue** ppValue);
		};


		//-----------------------------------------------------------------------------
		//                      PBIArray
		//-----------------------------------------------------------------------------

		class PBIArray : public PBIUnknown
		{
		public:

			virtual PBWINAPI_(PBRESULT)    GetValueAt(
				PBLONG* pSubs,
				PBINDEX     cDimension,
				PBIValue** ppValue) = 0;
			virtual PBWINAPI_(PBRESULT)    SetValueAt(
				PBLONG* pSubs,
				PBINDEX     cDimension,
				PBIValue* pValue) = 0;

			virtual PBWINAPI_(PBRESULT)    GetDimensions(PBINDEX* pDimensions) = 0;
			virtual PBWINAPI_(PBRESULT)    GetBounds(PBIArrayBoundsList** ppArrayBounds) = 0;

			virtual PBWINAPI_(PBRESULT)    GetSession(PBISession** ppSession) = 0;
			virtual PBWINAPI_(PBRESULT) Clone(PBIArray** ppArray) = 0;

			virtual PBWINAPI_(PBRESULT)    IsNullValued(PBBOOL* pBool) = 0;
			virtual PBWINAPI_(PBRESULT)    SetNull() = 0;

		};

		extern "C"    PBWINAPI_(PBRESULT) CreatePBIArray(
			PBIArrayBoundsList * pBoundsList,
			PBValueType             eValueType,
			PBISession * pSession,
			PBIArray * *ppArray);

		extern "C"  PBWINAPI_(PBRESULT) CreatePBIArrayOfObject(
			PBIArrayBoundsList * pBoundsList,
			PBIString * pObjectName,
			PBISession * pSession,
			PBIArray * *ppArray);

		extern "C"    PBWINAPI_(PBRESULT) CreatePBIUnboundedArray(
			PBIArrayBoundsList * pBoundsList,
			PBValueType             eValueType,
			PBISession * pSession,
			PBIArray * *ppArray);

		extern "C"  PBWINAPI_(PBRESULT) CreatePBIUnboundedArrayOfObject(
			PBIArrayBoundsList * pBoundsList,
			PBIString * pObjectName,
			PBISession * pSession,
			PBIArray * *ppArray);

		//-----------------------------------------------------------------------------

		class PBIArrayBounds : public PBIUnknown
		{
		public:

			virtual PBWINAPI_(PBRESULT) GetLowerBound(PBLONG* pLower) = 0;
			virtual PBWINAPI_(PBRESULT) SetLowerBound(PBLONG lLower) = 0;

			virtual PBWINAPI_(PBRESULT) GetUpperBound(PBLONG* pUpper) = 0;
			virtual PBWINAPI_(PBRESULT) SetUpperBound(PBLONG lUpper) = 0;
		};


		class PBIArrayBoundsList : public PBIUnknown
		{
		public:

			virtual PBWINAPI_(PBRESULT)        Add(PBIArrayBounds*) = 0;
			virtual PBWINAPI_(PBRESULT)        Remove(PBIArrayBounds*) = 0;

			virtual PBWINAPI_(PBRESULT)        GetCount(PBINDEX* pCount) = 0;

			virtual PBWINAPI_(PBRESULT)        GetFirst(PBIArrayBounds** pFirst) = 0;
			virtual PBWINAPI_(PBRESULT)        GetNext(PBIArrayBounds** pNext) = 0;

			virtual PBWINAPI_(PBRESULT)        GetLast(PBIArrayBounds** pLast) = 0;
			virtual PBWINAPI_(PBRESULT)        GetPrevious(PBIArrayBounds** pPrevious) = 0;
		};

		extern "C"
		{
			PBWINAPI_(PBRESULT) CreatePBIArrayBounds(
				PBLONG  lLower,
				PBLONG  lUpper,
				PBISession* pSession,
				PBIArrayBounds** ppBounds);

			PBWINAPI_(PBRESULT) CreatePBIArrayBoundsList(
				PBIArrayBoundsList** ppArrayBoundsList);
		};


		//-----------------------------------------------------------------------------
		//      IException
		//-----------------------------------------------------------------------------

		class PBIException : public PBIUnknown
		{
		public:

			virtual PBWINAPI_(PBRESULT)    GetDescription(PBIString** ppString) = 0;
			virtual PBWINAPI_(PBRESULT)    SetDescription(PBIString* pString) = 0;

			virtual PBWINAPI_(PBRESULT) Clone(PBIException** ppException) = 0;
		};

		extern "C"
		{
			PBWINAPI_(PBRESULT) CreatePBIException(
				PBIString* pDescription,
				PBIException** ppException);
		};


#endif  //  PBRUNIFX_H
		// DOINC popped back into header 'pbgclsif.h'
#endif

		extern "C"
		{
			extern PBIID PBIClassDef_IID;
			extern PBIID PBIClassDefList_IID;
			extern PBIID PBIEnumerationDef_IID;
			extern PBIID PBISimpleTypeDef_IID;
			extern PBIID PBIVariableDef_IID;
			extern PBIID PBIVariableDefList_IID;
			extern PBIID PBIScriptDef_IID;
			extern PBIID PBIScriptDefList_IID;
			extern PBIID PBITypeDef_IID;
			extern PBIID PBIVariableCardinalityDef_IID;
			extern PBIID PBIEnumerationItemDef_IID;
		};

		//      Skip over these C++ definitions if we are compiling C code.

#ifdef __cplusplus         

		class PBIScriptDef;
		class PBIScriptDefList;
		typedef PBIScriptDef FAR* PPBIScriptDef;
		typedef PPBIScriptDef FAR* PPPBIScriptDef;
		class PBIVariableDef;
		class PBIVariableDefList;
		typedef PBIVariableDef FAR* PPBIVariableDef;
		typedef PPBIVariableDef FAR* PPPBIVariableDef;
		class PBIClassDef;
		class PBIClassDefList;
		typedef PBIClassDef FAR* PPBIClassDef;
		typedef PPBIClassDef FAR* PPPBIClassDef;
		class PBITypeDef;
		typedef PBITypeDef FAR* PPBITypeDef;
		typedef PPBITypeDef FAR* PPPBITypeDef;
		class PBISimpleTypeDef;
		typedef PBISimpleTypeDef FAR* PPBISimpleTypeDef;
		typedef PPBISimpleTypeDef FAR* PPPBISimpleTypeDef;
		class PBIEnumerationDef;
		typedef PBIEnumerationDef FAR* PPBIEnumerationDef;
		typedef PPBIEnumerationDef FAR* PPPBIEnumerationDef;
		class PBIVariableCardinalityDef;
		typedef PBIVariableCardinalityDef FAR* PPBIVariableCardinalityDef;
		class PBArgDef;
		typedef PBArgDef FAR* PPBArgDef;
		typedef PPBArgDef FAR* PPPBArgDef;
		class PBIEnumerationItemDef;
		typedef PBIEnumerationItemDef FAR* PPBIEnumerationItemDef;
		typedef PPBIEnumerationItemDef FAR* PPPBIEnumerationItemDef;

		//***************************************************************************
		//
		//    Name:             Class PBITypeDef
		//
		//    Synopsis: C++ PBITypeDef which is associated with a Powerscript 
		//                              TypeDefinition
		//
		//    Notes:    
		//
		//***************************************************************************

		class PBITypeDef : public PBIUnknown
		{
		public:

			//
			// Public advertised External Interface which matches the PB MetaClass API
			//
			virtual PBRESULT	GetName(PBIString** ppName) = 0;
			virtual PBRESULT	GetLibraryName(PBIString** ppName) = 0;
			virtual PBRESULT	GetDataTypeOf(PBIString** ppType) = 0;
			virtual PBRESULT	GetCategory(PBTypeCategory* pCategory) = 0;
			virtual PBRESULT	GetIsVariableLength(PBBOOL* pIsVariableLength) = 0;
			virtual PBRESULT	GetIsSystemType(PBBOOL* pIsSystemType) = 0;
			virtual PBRESULT	GetIsVisualType(PBBOOL* pIsVisual) = 0;
			virtual PBRESULT	GetIsStructure(PBBOOL* pIsStructure) = 0;
		};

		class PBISimpleTypeDef : public PBITypeDef
		{
		};

		class PBIEnumerationDef : public PBITypeDef
		{
		public:

			virtual PBRESULT    GetEnumerationValue(PBLONG nIndex, PBLONG* pValue) = 0;
			virtual PBRESULT    GetEnumerationName(PBLONG nIndex, PBIString** ppName) = 0;
			virtual PBRESULT    GetNumEnumerations(PBINDEX* pNumEnumerations) = 0;
		};

		//***************************************************************************
		//
		//    Name:             Class PBIClassDef
		//
		//    Synopsis: C++ PBIClassDef which is associated with a Powerscript ClassDef
		//
		//    Notes:
		//
		//***************************************************************************

		class PBIClassDef : public PBITypeDef
		{
		public:
			//
			// Public advertised External Interface which matches the PB MetaClass API
			//

			virtual PBRESULT        GetAncestorClass(PBIClassDef** ppAncestor) = 0;
			virtual PBRESULT    GetParentClass(PBIClassDef** ppParent) = 0;
			virtual PBRESULT    GetIsAutoinstantiate(PBBOOL* pIsAutoInstantiate) = 0;

			virtual PBRESULT    GetNestedClass(PBLONG nIndex, PBIClassDef** ppNested) = 0;
			virtual PBRESULT        GetNestedClassList(PBIClassDefList** ppNestedList) = 0;

			virtual PBRESULT        GetVariable(PBLONG nIndex, PBIVariableDef** ppVariable) = 0;
			virtual PBRESULT        GetVariableList(PBIVariableDefList** ppVariableList) = 0;

			virtual PBRESULT        GetScript(PBLONG nIndex, PBIScriptDef** pScript) = 0;
			virtual PBRESULT        GetScriptList(PBIScriptDefList** ppScriptList) = 0;

			virtual PBRESULT        FindMatchingFunction(
				PBIString* pname,
				PBIString** ppArgs,
				PBULONG         cArgCount,
				PBIScriptDef** ppScriptDef) = 0;
			virtual PBRESULT   GetBinaryHexAscii(PBIString** ppString) = 0;

			//      Note, we really don't call UpperBound on the arrays, 
			//      use these to find out sizes

			virtual PBRESULT        GetNumNestedClasses(PBINDEX* pNumClasses) = 0;
			virtual PBRESULT        GetNumVariables(PBINDEX* pNumVariables) = 0;
			virtual PBRESULT        GetNumScripts(PBINDEX* pNumScripts) = 0;

			// PropertyList Accessors

			virtual PBRESULT        GetPropertyName(PBLONG n, PBIString** ppName) = 0;
			virtual PBRESULT        GetPropertyValue(PBLONG n, PBIString** ppValue) = 0;
			virtual PBRESULT        FindPropertyValue(PBLONG* pN, PBIString* pName, PBIString** ppValue) = 0;
			virtual PBRESULT        GetNumProperties(PBINDEX* pNumProperties) = 0;
		};

		extern "C"
		{
			PBWINAPI(PBRESULT, CreatePBITypeDef)(
				PBIString* pName,
				PBIString* pLibraryList,
				PBITypeDef** ppTypeDef);

			PBWINAPI(PBRESULT, CreatePBIClassDef)(
				PBIString* pName,
				PBIString* pLibraryList,
				PBIClassDef** ppClassDef);

			PBWINAPI(PBRESULT, CreatePBIScriptDef)(
				PBIString* pName,
				PBIString* pLibraryList,
				PBIScriptDef** ppScriptDef);
		};

		//***************************************************************************
		//	Name:		Class PBIClassDefList
		//	Synopsis:	List of PBIClassDefs
		//	Notes:
		//***************************************************************************

		class PBIClassDefList : public PBIUnknown
		{
		public:

			virtual PBRESULT    Add(PBIClassDef*) = 0;
			virtual PBRESULT    Remove(PBIClassDef*) = 0;

			virtual PBRESULT    GetCount(PBINDEX* pCount) = 0;

			virtual PBRESULT    GetFirst(PBIClassDef** pFirst) = 0;
			virtual PBRESULT    GetNext(PBIClassDef** pNext) = 0;

			virtual PBRESULT    GetLast(PBIClassDef** pLast) = 0;
			virtual PBRESULT    GetPrevious(PBIClassDef** pPrevious) = 0;
		};

		extern "C"
		{
			PBWINAPI_(PBRESULT) CreatePBIClassDefList(
				PBIClassDefList** ppClassDefList);
		};

		//***************************************************************************
		//
		//    Name:             Class PBIVariableDef
		//
		//    Synopsis: Class associated with a Powerscript VariableDef
		//
		//    Notes:    
		//
		//***************************************************************************

		class PBIVariableDef : public PBIUnknown
		{
		public:

			//
			// Public advertised External Interface which matches the PB MetaClass API
			//

			virtual PBRESULT        GetName(PBIString** ppName) = 0;
			virtual PBRESULT        GetTypeInfo(PBITypeDef** ppTypeInfo) = 0;
			virtual PBRESULT    GetCardinality(PBIVariableCardinalityDef** ppCardinality) = 0;
			virtual PBRESULT        GetInitialValue(PBIValue** ppValue) = 0;
			virtual PBRESULT        GetOverridesAncestorValue(PBBOOL* pOverrides) = 0;
			virtual PBRESULT        GetReadAccess(PBVariableAccess* pReadAccess) = 0;
			virtual PBRESULT        GetWriteAccess(PBVariableAccess* pWriteAccess) = 0;
			virtual PBRESULT        GetIsConstant(PBBOOL* pIsConstant) = 0;
			virtual PBRESULT        GetArgumentKind(PBLONG* pKind) = 0;
			virtual PBRESULT        GetCardinality(PBVariableCardinalityType* pType) = 0;
			virtual PBRESULT        GetKind(PBVariableKind* pKind) = 0;
			virtual PBRESULT        GetIsLocallyDefined(PBBOOL* pLocal) = 0;
			virtual PBRESULT        GetIsUserDefined(PBBOOL* pIsUserDefined) = 0;

			// The functions for upperbounds

			virtual PBRESULT        GetNumArrayBounds(PBINDEX* pNumBounds) = 0;
			virtual PBRESULT        GetBoundAt(PBLONG dim, PBLONG bounds[2]) = 0;

			// PropertyList Accessors

			virtual PBRESULT        GetPropertyName(PBLONG n, PBIString** ppName) = 0;
			virtual PBRESULT        GetPropertyValue(PBLONG n, PBIString** ppValue) = 0;
			virtual PBRESULT        FindPropertyValue(PBLONG* pN, PBIString* pName, PBIString** ppValue) = 0;
			virtual PBRESULT        GetNumProperties(PBINDEX* pProperties) = 0;
		};


		//***************************************************************************
		//	Name:			PBIVariableDefList
		//	Synopsis:		List of PBIVariableDefs
		//	Notes:
		//***************************************************************************

		class PBIVariableDefList : public PBIUnknown
		{
		public:

			virtual PBRESULT    Add(PBIVariableDef*) = 0;
			virtual PBRESULT    Remove(PBIVariableDef*) = 0;

			virtual PBRESULT    GetCount(PBINDEX* pCount) = 0;

			virtual PBRESULT    GetFirst(PBIVariableDef** pFirst) = 0;
			virtual PBRESULT    GetNext(PBIVariableDef** pNext) = 0;

			virtual PBRESULT    GetLast(PBIVariableDef** pLast) = 0;
			virtual PBRESULT    GetPrevious(PBIVariableDef** pPrevious) = 0;
		};

		extern "C"
		{
			PBWINAPI_(PBRESULT)	CreatePBIVariableDefList(
				PBIVariableDefList** ppVariableDefList);
		};

		//***************************************************************************
		//
		//    Name:             Class PBIScriptDef
		//
		//    Synopsis: C++ PBIScriptDef which is associated with a Powerscript ScriptDef
		//
		//    Notes:    
		//
		//***************************************************************************

		class PBIScriptDef : public PBIUnknown
		{
		public:

			//
			// Public advertised External Interface which matches the PB MetaClass API
			//

			virtual PBRESULT    GetName(PBIString** ppName) = 0;
			virtual PBRESULT    GetSignature(PBIString** ppSignature) = 0;
			virtual PBRESULT    GetKind(PBScriptKind* pKind) = 0;
			virtual PBRESULT    GetReturnType(PBITypeDef** pType) = 0;
			virtual PBRESULT    GetCardinality(PBIVariableCardinalityDef** ppCardinality) = 0;
			virtual PBRESULT    GetVtableId(PBUSHORT* pID) = 0;
			virtual PBRESULT    GetSource(PBIString** ppSource) = 0;
			virtual PBRESULT    GetIsScripted(PBBOOL* pIsScripted) = 0;
			virtual PBRESULT    GetIsLocallyDefined(PBBOOL* pIsLocal) = 0;
			virtual PBRESULT    GetIsLocallyScripted(PBBOOL* pIsScripted) = 0;

			virtual PBRESULT    GetExternalUserFunction(PBIString** ppName) = 0;
			virtual PBRESULT    GetSystemFunction(PBIString** ppName) = 0;
			virtual PBRESULT    GetAliasName(PBIString** ppName) = 0;
			virtual PBRESULT    GetEventIdName(PBIString** ppName) = 0;
			virtual PBRESULT    GetEventId(PBLONG* pID) = 0;
			virtual PBRESULT    GetIsRPCFunction(PBBOOL* pIsRPC) = 0;
			virtual PBRESULT    GetIsExternalEvent(PBBOOL* pIsExternal) = 0;
			virtual PBRESULT    GetNumArgs(PBINDEX* pNumArgs) = 0;
			virtual PBRESULT    GetArg(PBLONG nIndex, PBIVariableDef** pArg) = 0;
			virtual PBRESULT    GetArgList(PBIVariableDefList** ppArgList) = 0;
			virtual PBRESULT    GetNumLocals(PBINDEX* pNumLocals) = 0;
			virtual PBRESULT    GetLocal(PBLONG nIndex, PBIVariableDef** ppLocal) = 0;
			virtual PBRESULT    GetLocalList(PBIVariableDefList** ppLocalList) = 0;
			virtual PBRESULT        GetAccess(PBVariableAccess* pAccess) = 0;

			// PropertyList Accessors

			virtual PBRESULT    GetPropertyName(PBLONG n, PBIString** ppName) = 0;
			virtual PBRESULT    GetPropertyValue(PBLONG n, PBIString** ppValue) = 0;
			virtual PBRESULT        FindPropertyValue(PBLONG* pN, PBIString* pName, PBIString** ppValue) = 0;
			virtual PBRESULT    GetNumProperties(PBINDEX* pNumProperties) = 0;

			// Throws Accessors

			virtual PBRESULT    GetThrowsType(PBLONG n, PBITypeDef** ppType) = 0;
			virtual PBRESULT    GetNumThrows(PBINDEX* pNumThrows) = 0;
		};


		//***************************************************************************
		//	Name:			PBIScriptDefList
		//	Synopsis:		List of PBIScriptDefs
		//	Notes:
		//***************************************************************************

		class PBIScriptDefList : public PBIUnknown
		{
		public:

			virtual PBRESULT    Add(PBIScriptDef*) = 0;
			virtual PBRESULT    Remove(PBIScriptDef*) = 0;

			virtual PBRESULT    GetCount(PBINDEX* pCount) = 0;

			virtual PBRESULT    GetFirst(PBIScriptDef** pFirst) = 0;
			virtual PBRESULT    GetNext(PBIScriptDef** pNext) = 0;

			virtual PBRESULT    GetLast(PBIScriptDef** pLast) = 0;
			virtual PBRESULT    GetPrevious(PBIScriptDef** pPrevious) = 0;
		};


		extern "C"
		{
			PBWINAPI_(PBRESULT) CreatePBIScriptDefList(
				PBIScriptDefList** ppScriptDefList);
		};


		//***************************************************************************
		//
		//    Name:             Class  PBIVariableCardinalityDef
		//
		//    Synopsis: C++ PBIVariableCardinalityDef which is associated with a Powerscript 
		//                              VariableCardinalityDef
		//
		//    Notes:    
		//
		//***************************************************************************

		class PBIVariableCardinalityDef : public PBIUnknown
		{
		public:

			virtual PBRESULT    GetCardinality(PBVariableCardinalityType* pType) = 0;

			// ArrayBounds member functions
			// Returns lower bound for nth dimension of an array.

			virtual PBRESULT    GetLowerbound(PBLONG n, PBLONG* pLower) = 0;

			// Returns upper bound for nth dimension of an array.

			virtual PBRESULT    GetUpperbound(PBLONG n, PBLONG* pUpper) = 0;

			// Returns the number of dimensions for an array

			virtual PBRESULT    GetNumArrayDimensions(PBINDEX* pNumDimensions) = 0;

		};

		//***************************************************************************
		//
		//    Name:             Class  PBIEnumerationItemDef
		//
		//    Synopsis:                 C++ PBIEnumerationItemDef which is associated 
		//                                              with a Powerscript PBIEnumerationItemDef
		//
		//    Notes:    
		//
		//***************************************************************************

		class PBIEnumerationItemDef : public PBIUnknown
		{
		public:
			virtual PBRESULT    GetName(PBIString** ppName) = 0;
			virtual PBRESULT    GetValue(PBLONG* pValue) = 0;
		};

#endif  //      __cplusplus
#endif  //      PBGCLSIF_H
		// DOINC popped back into header 'objapi.h'
#endif
// create an interface library based on the passed class defs.
// the class def array is expected to contain ancestors first
// if bCreatePbl is TRUE, the destination library will be
// deleted if it already exists, otherwise it will be appended to.
		PBWINAPI(PBRESULT, ob_create_interface_in_library)
			(
				PPBIClassDef		pClassArray[],
				ULONG			ulNumClasses,
				LPTSTR			lpstrDestLibrary,
				LPTSTR			lpstrLibraryComments,
				BOOL			bCreatePbl
				);
#endif

		PBWINAPI(PBRESULT, ob_create_interface_class)
			(
				POB_THIS		obthis,
				OB_CLASS_HNDL	hSourceClass,
				LPTSTR			lpstrDestClassName,
				LPTSTR			lpstrDestLibrary,
				LPTSTR			lpstrComments,
				LPTSTR			lpstrSourceClassName
				);

		PBWINAPI(OB_CLASS_HNDL, ob_init_executable)
			(
				POB_THIS 					obthis,
				LPTSTR 						executable_name
				);

		PBWINAPI(LPTSTR FAR*, ob_scan_source_blocks)
			(
				POB_THIS 					obthis,
				POB_SOURCE_BLOCK 			source,
				ULONG 						src_len,
				PVOID FAR* srcloc,
				PUINT 						no_blocks,
				OB_SUBPOOL 					subpool
				);

		PBWINAPI(INT, ob_create_launcher)
			(
				POB_THIS       			obThis,
				POB_EXEC       			pExecBlock,
				PVOID          			pObjectList
				);

		PBWINAPI(VOID, ob_sanitize_pb_name)
			(
				POB_THIS       			obThis,
				LPTSTR					lpszDestName,
				LONG					destLength,
				LPTSTR       			lpszNameToSanitize
				);

		//****************************************************************************
		//	Error validation routines.
		//****************************************************************************

		PBWINAPI(POB_CONFLICT_LIST, ob_validate_class)
			(
				POB_THIS 			  	obthis,
				OB_CLASS_HNDL		  	class_hndl,
				PUINT				  	no_items
				);

		PBWINAPI(POB_CLASS_HNDL, ob_get_orphaned_classes)
			(
				POB_THIS			  	obthis,
				OB_GROUP_HNDL		  	in_group_hndl,
				PUINT				  	total_items
				);
		// Is type name valid?  Handles both simple types and class types.
		PBWINAPI(BOOL, ob_validate_type_name)
			(
				POB_THIS 				obThis,
				OB_GROUP_HNDL			obGroupHndl,
				LPTSTR					TypeName
				);

		//****************************************************************************
		// Migration utilities
		//****************************************************************************


		PBWINAPI(INT, ob_convert_to_ver2_source)
			(
				POB_THIS 			  	obthis,
				LPTSTR 				  	lib_name,
				LPTSTR 				  	entry_name
				);

		PBWINAPI(BOOL, ob_is_vers2_obj)
			(
				POB_THIS 			  	obthis,
				LPTSTR 				  	lib_name,
				LPTSTR 				  	entry_name,
				PINT 				  	error
				);

		//****************************************************************************
		// Make utilities
		//****************************************************************************

		typedef enum ob_compile_list_type
		{

			OB_INCREMENTAL_LIST,
			OB_FULL_LIST,
			OB_MIGRATION_LIST

		} OB_COMPILE_LIST_TYPE;

		typedef enum ob_inconsistency_type
		{
			OB_NO_INCONSISTENCY = 0x00,
			OB_INCONSISTENT_VERSION = 0x01,
			OB_INCONSISTENT_COMPILE = 0x02

		} OB_INCONSISTENCY_TYPE, FAR* POB_INCONSISTENCY_TYPE;

		PBWINAPI(POB_COMPILE_LIST, ob_build_ordered_compile_list)
			(
				POB_THIS			 		obthis,
				OB_COMPILE_LIST_TYPE		list_type,
				PUINT				 		no_items,
				POB_INCONSISTENCY_TYPE		inconsistency
				);

		PBWINAPI(VOID, ob_free_ordered_compile_list)
			(
				POB_THIS			  	obthis,
				POB_COMPILE_LIST	  	compile_list,
				UINT				  	no_items
				);


		//****************************************************************************
		// Class hierarchy utilities
		//****************************************************************************

		PBWINAPI(POB_HIERARCHY_LIST, ob_build_hierarchy_list)
			(
				POB_THIS			  	obthis,
				PUINT				  	no_items,
				OB_CLASS_ID			  	type
				);

		PBWINAPI(VOID, ob_free_hierarchy_list)
			(
				POB_THIS			  	obthis,
				POB_HIERARCHY_LIST		hierarchy_list,
				UINT				  	no_items
				);


		//****************************************************************************
		//	Object Instance Reference functions
		//****************************************************************************

		PBWINAPI(VOID, ob_clear_instance_ref)
			(
				POB_THIS			 		obthis,
				PVOID				 		back_ptr
				);

		VOID  ob_clear_instance_ref_no_del
		(
			POB_THIS					obthis,
			PVOID						ref_addr
		);

		VOID ob_destroy_meta_object(POB_THIS);

		VOID ob_update_back_reference(POB_THIS, OB_INST_ID, PVOID old_ref_addr, PVOID new_ref_addr);

		// Use ob_insert_instance_ref; don't call this directly
		PBWINAPI(VOID, ob_insert_inst_ref_dbg)
			(
				POB_THIS					obthis,
				OB_INST_ID					obinst,
				PVOID						ref_addr,
				LPTSTR						fileName,
				UINT						lineNo
				);

#define ob_insert_instance_ref(this,inst,addr)	\
	ob_insert_inst_ref_dbg(this,inst,addr,PBTEXT(__FILE__),__LINE__)

#define ob_insert_local_instance_ref(this, inst, addr) \
	ob_insert_local_inst_ref_dbg(this,inst,addr,PBTEXT(__FILE__),__LINE__)

		PBWINAPI(VOID, ob_insert_local_inst_ref_dbg)
			(
				POB_THIS					obthis,
				OB_INST_ID					obinst,
				PVOID						ref_addr,
				LPTSTR						fileName,
				UINT						lineNo
				);

		// Miscellaneous
		PBWINAPI(INT, ob_open_typedef_group)
			(
				POB_THIS 					obThis,
				LPTSTR    					lpszLibraryName,
				LPTSTR    					lpszGroupName,
				BOOL     					bCreateIfNotFound
				);

		PBWINAPI(INT, ob_load_pspp_dlls)
			(
				POB_THIS 					obThis
				);

		PBWINAPI(INT, ob_save_dll_to_pbd)
			(
				int argc,
				LPTSTR* argv
				);

		// PB Extension Support
		PBWINAPI(INT, ob_convert_pbx_to_native_groups)
			(
				POB_THIS	obthis,
				LPCTSTR		pbl_name,
				LPCTSTR		dll_name
				);

		PBWINAPI(HWND, ObPsppCreateControl)
			(
				PVOID	visualObject,
				DWORD dwExStyle,
				LPCTSTR lpWindowName,
				DWORD dwStyle,
				INT x,
				INT y,
				INT nWidth,
				INT nHeight,
				HWND hWndParent,
				HINSTANCE hInstance
				);

		PBWINAPI(INT, ObPsppGetEventID)
			(
				PVOID	visualObj,
				HWND	hWnd,
				UINT	iMsg,
				WPARAM	wParam,
				LPARAM	lParam
				);

		PBWINAPI(VOID, DrawPsppObject)
			(
				POB_THIS obthis,
				HDC hDC,
				int x,
				int y,
				int width,
				int height,
				OB_GROUP_ID group_id,
				OB_CLASS_ID class_id,
				LPCTSTR objectName,
				LPCTSTR tag,
				DWORD backColor,
				BOOL enabled,
				BOOL visible,
				DWORD borderStyle
				);

		HRESULT ob_create_child_obthis
		(
			POB_THIS 					pParentObThis,
			POB_THIS* ppNewObThis
		);

		PBWINAPI(INT, ob_share_typedef_group)
			(
				POB_THIS 					destObThis,
				POB_THIS 					srcObThis
				);

		PBWINAPI(INT, ob_unshare_typedef_group)
			(
				POB_THIS 					obThis
				);

		POB_DATA ob_get_data_from_info
		(
			POB_THIS 		obthis,
			POB_DATA_INFO 	pdata_info
		);

		PBWINAPI(INT, ob_cm_evaluate_expression)
			(
				POB_THIS		obthis,
				LPTSTR			text,
				POB_DATA		result_data_node
				);

		PBWINAPI(BOOL, ob_entryInheritsFromClass)
			(
				POB_THIS	obThis,
				LPTSTR 		lpszLibraryName,
				LPTSTR 		lpszTypeName,
				LPTSTR 		lpszEntryName
				);


		PBWINAPI(OB_CLASS_HNDL, ob_get_class_from_name)
			(
				POB_THIS	obThis,
				LPTSTR 		lpszClassName,
				LPBOOL		pbIsEnum			// TRUE if OBClassHandle is an ENUM
				);


		//****************************************************************************
		// The following routines are used by code gen to obtain variable
		// lvalues and reference packets.
		//****************************************************************************

		PBWINAPI(POB_DATA, ob_local_global_lv)
			(
				POB_THIS			obthis,
				POB_GROUP			group,
				OB_SYM_ID	 		var_id
				);

		PBWINAPI(VOID, ob_local_global_refpkt)
			(
				POB_THIS			obthis,
				POB_DATA 			destination,
				POB_GROUP			group,
				OB_SYM_ID	 		var_id
				);

		PBWINAPI(POB_DATA, ob_shared_global_lv)
			(
				POB_THIS			obthis,
				POB_GROUP			group,
				OB_SYM_ID	 		var_id
				);

		PBWINAPI(VOID, ob_shared_global_refpkt)
			(
				POB_THIS			obthis,
				POB_DATA 			destination,
				POB_GROUP			group,
				OB_SYM_ID	 		var_id
				);

		PBWINAPI(POB_DATA, ob_shared_lv)
			(
				POB_THIS			obthis,
				POB_GROUP			group,
				OB_SYM_ID	 		var_id
				);

		PBWINAPI(VOID, ob_shared_refpkt)
			(
				POB_THIS			obthis,
				POB_DATA 			destination,
				POB_GROUP			group,
				OB_SYM_ID	 		var_id
				);

		PBWINAPI(BOOL, ob_convert_chararray_to_string)
			(
				POB_THIS	obthis,
				POB_DATA	data
				);

		PBWINAPI(HRESULT, obJagResultsetNotify)
			(
				PVOID obthis
				);

		PBWINAPI(VOID, ob_class_delete_and_withinclass)
			(
				POB_THIS 		obthis,
				OB_CLASS_HNDL 	class_hndl,
				OB_CLASS_ID     class_id
				);

		PBWINAPI(INT, ob_find_orphan_class)
			(
				POB_THIS      	obThis,
				LPTSTR          lpszLibraryName,
				LPTSTR          lpszEntryName,
				BOOL            bFoundAncestor
				);

		PBWINAPI(BOOL, ob_nuke_orphan_class)
			(
				POB_THIS      	obThis,
				LPTSTR          lpszLibraryName,
				LPTSTR          lpszEntryName
				);

		PBWINAPI(BOOL, ob_is_ancestor_class_modified)
			(
				POB_THIS      	obThis,
				OB_CLASS_HNDL 	class_hndl
				);

		PBWINAPI(VOID, ob_rebuild_instance_image)
			(
				POB_THIS      	obThis,
				OB_CLASS_HNDL 	class_hndl
				);

		PBWINAPI(POB_COMPILE_LIST, ob_build_compile_list)
			(
				POB_THIS			 		obthis,
				PUINT				 		no_items
				);

#ifdef __cplusplus
	}                       /* End of extern "C" { */
#endif	/* __cplusplus */


#endif // OBJAPI_H
// DOINC popped back into header 'obtypdef.h'
#endif
#ifndef OBCLASS_H
// ***** DOINC including obclass.h *****
// $RCSfile: obclass.h $;$Revision: 4.9 $
//**************************************************************************
//
//                            Copyright 1989 
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :	obclass.h	
//
//    Author   :	Jim Kosko
//
//    Purpose  : 	Prototypes for class manipulations.
//
//****************************************************************************

#ifndef OBCLASS_H
#define OBCLASS_H

#ifndef OBTHIS_H
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
#endif

#ifndef OBTYPDEF_H
// ***** DOINC including obtypdef.h *****
	// DOINC skipping duplicate include
#endif

#ifndef OBCLINST_H
// ***** DOINC including obclinst.h *****
// $RCSfile: obclinst.h $;$Revision: 1.22 $
//**************************************************************************
//
//                        Copyright 1989 - 1995
//                        Powersoft Corporation
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM POWERSOFT CORPORATION.
//
// ------------------------------------------------------------------------
//
//    Filename :	obclinst.h	
//
//    Author   :	Jim Kosko
//
//    Purpose  : 	Definitions for runtime class structure
//
//****************************************************************************

#ifndef OBCLINST_H
#define OBCLINST_H

//****************************************************************************
// Includes
//****************************************************************************
#ifndef OBTHIS_H
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
#endif

#ifdef    __cplusplus
	extern "C" {
#endif    /* __cplusplus */

#ifndef OSCALLC_H
		// ***** DOINC including oscallc.h *****
		//**************************************************************************
		//
		//                            Copyright 1989 
		//                        Computer Solutions Inc.
		//
		//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
		//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
		//    INCORPORATED.
		//
		// ------------------------------------------------------------------------
		//
		//    Filename :	oscallc.h	
		//
		//    Author   :	Jim Kosko
		//
		//    Purpose  : 	Routines for calling C routines dynamically.
		//
		//****************************************************************************

#ifndef OSCALLC_H
#define OSCALLC_H

//****************************************************************************
// Includes
//****************************************************************************

#ifndef OSPASCAL_H
// ***** DOINC including ospascal.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OSSTDARG_H
// ***** DOINC including osstdarg.h *****
	// DOINC skipping duplicate include
#endif
#ifndef PBSTG_H
// ***** DOINC including pbstg.h *****
	// DOINC skipping duplicate include
#endif

//****************************************************************************
// Local definition of HINSTANCE
//****************************************************************************

#ifndef PBOS_MAC 
#ifndef OSWINDOW_H
#undef DECLARE_HANDLE
#define DECLARE_HANDLE(name)    struct name##__ { int unused; }; \
								typedef const struct name##__ NEAR* name
		DECLARE_HANDLE(HINSTANCE);
#endif
#endif


		//****************************************************************************
		// Definition of dynamic callback function pointer
		//****************************************************************************

		typedef PBCALLBACK(void, *OS_CALLC_FUNC) (void);

		//****************************************************************************
		// Prototypes to call C routines with dynamic argument list.
		//****************************************************************************

#ifdef    __cplusplus
		extern "C" {
#endif    /* __cplusplus */

#if defined(PBOS_WIN) || defined(PBOS_MAC) || (defined(PBOS_NT) && defined(_X86_))  || (defined(PBOS_NT) && defined(_ALPHA_)) || defined(PBOS_UNIX)

			PBWINAPI(HINSTANCE, os_openlib)
				(
					LPTSTR           libname,
					PINT            error,
					PBOOL		 	newlib
					);

			PBWINAPI(OS_CALLC_FUNC, os_get_funcptr)
				(
					LPTSTR           funcname,
					HINSTANCE       libhndl
					);

#if (defined(PBOS_NT) && defined(_ALPHA_))
			PBWINAPI(INT, os_callc)
				(
					OS_CALLC_FUNC   funcptr,
					PVOID           stackframe,
					UINT            frame_len,
					PVOID           ret_buffer,
					UINT            ret_buffer_len,
					BOOL		bIsFloatingPoint
					);
#else
#if (defined(PBOS_MAC) || defined(_AIX))
#if (defined(powerc) || defined(_POWER))

#if defined(_AIX)
			typedef BYTE     Boolean;
#define asm
#endif

			typedef struct FloatingPointRegisterStruct {
				double	FValue;
				Boolean	IsDouble;
			}FloatingPointRegisterStruct;

			typedef struct RegisterStruct {
				short			RCount;
				short			FCount;
				unsigned long	RValue[8];
				FloatingPointRegisterStruct	FloatStruct[12];
			}RegisterStruct, * RegisterPtr, ** RegisterHandle;

			asm PBWINAPI(short, os_callc)
				(
					OS_CALLC_FUNC 	func_ptr,
					RegisterPtr		registerPtr,
					void* ret_buffer,
					unsigned short 	ret_length,
					short 			bIsFloatingPoint,
#if defined(PBOS_MAC)
					short			bReturnStruct,
					PVOID			stack_frame,
					UINT			frame_len
#else
					short			bReturnStruct
#endif
					);
#else
			PBWINAPI(short, os_callc)
				(
					OS_CALLC_FUNC 	func_ptr,
					void* stack_frame,
					unsigned short 	frame_len,
					void* ret_buffer,
					unsigned short 	ret_length,
					short 			bIsFloatingPoint
					);
#endif  // MAC or AIX

#else
#if defined (PBOS_UNIX)  /* So far, this is just SPARC version */
#if defined(PBOS_LINUX)
			PBWINAPI(INT, os_callc)
				(
					OS_CALLC_FUNC   func_ptr,
					PVOID           stack_frame,
					UINT            frame_len,
					PVOID           ret_buffer,
					UINT            ret_length,
					UINT            ret_type
					);
#elif !defined(_POWER)   // sparc and hp only 
			PBWINAPI(INT, os_callc)
				(
					OS_CALLC_FUNC   funcptr,
					PVOID           stackframe,
					UINT            frame_len,
					PVOID           ret_buffer,
					UINT            ret_buffer_len,
					UINT            ret_type
					);
#endif

#else
			PBWINAPI(INT, os_callc)
				(
					OS_CALLC_FUNC   funcptr,
					PVOID           stackframe,
					UINT            frame_len,
					PVOID           ret_buffer,
					UINT            ret_buffer_len,
					UINT            ret_type
					);
#endif
#endif
#endif

			PBWINAPI(VOID, os_closelib)
				(
					HINSTANCE       libhndl
					);

			//****************************************************************************
			// Use Dummy definitions for everything else for now.
			//****************************************************************************


#else

#define os_openlib(libname,error,newlib) NULL
#define os_get_funcptr(funcname,libhndl) NULL
#define os_callc(funcptr,stack,framlen,retbuff,buff_len) 0
#define os_closelib(libhndl)

#endif

#ifdef    __cplusplus
		}	// extern "C" {
#endif    /* __cplusplus */

#endif // OSCALLC_H
// DOINC popped back into header 'obclinst.h'
#endif

#ifndef PBCOM_H
// ***** DOINC including pbcom.h *****
	// DOINC skipping duplicate include
#endif

#ifndef OBDATA_H
// ***** DOINC including obdata.h *****
	// DOINC skipping duplicate include
#endif

#ifndef OTPUBLIC_H
// ***** DOINC including otpublic.h *****
//**************************************************************************
//
//                            Copyright 1989
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :	otpublic.h
//
//    Author   :	Jim Kosko
//
//    Purpose  : 	Public Definitions for object tools
//
//****************************************************************************

#ifndef OTPUBLIC_H
#define OTPUBLIC_H

//****************************************************************************
// 	Includes
//****************************************************************************

// ***** DOINC including ospascal.h *****
	// DOINC skipping duplicate include
// ***** DOINC including shdt.h *****
	// DOINC skipping duplicate include
// ***** DOINC including shdec.h *****
	// DOINC skipping duplicate include
// ***** DOINC including shbinary.h *****
	// DOINC skipping duplicate include
// ***** DOINC including objapi.h *****
	// DOINC skipping duplicate include
// ***** DOINC including obdefine.h *****
	// DOINC skipping duplicate include
// ***** DOINC including obdata.h *****
	// DOINC skipping duplicate include
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
// ***** DOINC including ottypes.h *****

// "ottypes" incremental include file
// Generated from "ottypes.tbl" 

#define NO_TYPE 0
#define INT_TYPE 1
#define LONG_TYPE 2
#define FLOAT_TYPE 3
#define DOUBLE_TYPE 4
#define DEC_TYPE 5
#define STRING_TYPE 6
#define BOOL_TYPE 7
#define ANY_TYPE 8
#define UINT_TYPE 9
#define ULONG_TYPE 10
#define BINARY_TYPE 11
#define DATE_TYPE 12
#define TIME_TYPE 13
#define DATETIME_TYPE 14
#define CURSOR_TYPE 15
#define PROC_TYPE 16
#define BASIC_TYPE 17
#define CHAR_TYPE 18
#define HANDLE_TYPE 19
#define LONGLONG_TYPE 20
#define BYTE_TYPE 21
#define NUMBER_OF_ottypes 22

// "ottypes_attr" incremental include file
// Generated from "ottypes.tbl" 

#define OT_NULL_TYPE_ATTR 0
#define OT_MATH_TYPE_ATTR 1
#define OT_SIMPLE_TYPE_ATTR 2
#define OT_RANGE_TYPE_ATTR 3
#define NUMBER_OF_ottypes_attr 4
// DOINC popped back into header 'otpublic.h'
// ***** DOINC including rtthis.h *****
// **************************************************************************
//
//                            Copyright 1989 
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :	rtthis.h	
//
//    Author   :	Jim Kosko
//
//    Purpose  : 	This structure definitions for PB runtime system.
//
// ****************************************************************************

#ifndef RTTHIS_H
#define RTTHIS_H


// ****************************************************************************
// Includes (these need to be outside the #ifdef so include compressor works
// ****************************************************************************

// ***** DOINC including ospascal.h *****
	// DOINC skipping duplicate include
// ***** DOINC including pbstg.h *****
	// DOINC skipping duplicate include
// ***** DOINC including shdebug.h *****
	// DOINC skipping duplicate include
// ***** DOINC including shlist.h *****
	// DOINC skipping duplicate include
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
// ***** DOINC including cmpublic.h *****
//**************************************************************************
//
//                            Copyright 1989
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :    cmpublic.h
//
//    Author   :    Jim Kosko
//
//    Purpose  :    Public Definitions for PB script compiler
//
//****************************************************************************

#ifndef CMPUBLIC_H
#define CMPUBLIC_H

// this leading '_' naming scheme was a way to keep a single .def file across
// all platforms that rely on .defs. Under 16 bit windows (PBOS_WIN)
// the compiler prepends cdecl functions with the '_'. On 32 bit
// compilers that went away. Forcing the '_' back in allows the same .def
// to work on all platforms.  -btaylor
#ifndef PBOS_WIN
#define cm_compiler_error _cm_compiler_error
#define cm_compiler_error_ln _cm_compiler_error_ln
#endif

#ifdef __cplusplus
		extern "C"
		{
#endif /* __cplusplus */

			//****************************************************************************
			// Includes
			//****************************************************************************

#ifndef OSPASCAL_H
// ***** DOINC including ospascal.h *****
	// DOINC skipping duplicate include
#endif
#ifndef PBSTG_H
// ***** DOINC including pbstg.h *****
	// DOINC skipping duplicate include
#endif
#ifndef SHLIST_H
// ***** DOINC including shlist.h *****
	// DOINC skipping duplicate include
#endif
#ifndef SHGRWBLK_H
// ***** DOINC including shgrwblk.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBDEFINE_H
// ***** DOINC including obdefine.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBTHIS_H
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBDATA_H
// ***** DOINC including obdata.h *****
	// DOINC skipping duplicate include
#endif
#ifndef SHHASH_H
// ***** DOINC including shhash.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBJAPI_H
// ***** DOINC including objapi.h *****
	// DOINC skipping duplicate include
#endif

			typedef struct cmdb_main FAR* PCMDB_MAIN;    // Main DB compiler pointer


			//****************************************************************************
			// PB11 language enhancement -- namespace
			// Definition of the namespace separate
			//****************************************************************************
#define PBCMP_SCOPE_SEP         PBTEXT("::")
#define PBCMP_SCOPE_SEP_CHAR    PBTEXTC(':')


//****************************************************************************
// pb extension support
//****************************************************************************
#define	PB_EXTENSION_LOAD_DLL_FAILED				1
#define	PB_EXTENSION_NOT_FOUND_GETDESCRIPTION		2
#define   PB_EXTENSION_PARSE_DESCRIPTION_FAILED		3
#define	PB_EXTENSION_BUILD_GROUP_FAILED				4

//****************************************************************************
// Compile type enum
//****************************************************************************

			typedef enum
			{
				CM_COMPILE_TYPEDEFS_ONLY,
				CM_COMPILE_SCRIPTS_ONLY,
				CM_COMPILE_ALL

			} CM_COMPILE_TYPE;


			//****************************************************************************
			// Getch routine data type
			//****************************************************************************

#define CM_GETCH_PROC   PASCALFAR_CHAR_PROC


//****************************************************************************
// DB Signon routine data type
//****************************************************************************

			typedef PBCALLBACK(PVOID, *CM_DBSIGNON_PROC)
				(
					PVOID                            pbThis
					);

			//****************************************************************************
			//  Bit flag definitions for member: fStateFlags (32 bit flags, 18 available)
			//****************************************************************************

			//      FLAG NAME                       MASK VALUE
#define CM_THIS_POSTED_CALL_MASK        0x00000001      // Flag  1: 1 bit
#define CM_THIS_DYNAMIC_CALL_MASK       0x00000002      // Flag  2: 1 bit
#define CM_THIS_EVENT_CALL_MASK         0x00000004      // Flag  3: 1 bit
#define CM_THIS_OLD_EVENT_CALL_MASK     0x00000008      // Flag  4: 1 bit
#define CM_THIS_POSTED_STAT_MASK        0x00000010      // Flag  5: 1 bit
#define CM_THIS_DYNAMIC_STAT_MASK       0x00000020      // Flag  6: 1 bit
#define CM_THIS_EVENT_STAT_MASK         0x00000040      // Flag  7: 1 bit
#define CM_THIS_IS_CONSTANT_MASK        0x00000080      // Flag  8: 1 bit
#define CM_THIS_IS_READONLY_MASK        0x00000100      // Flag  9: 1 bit
#define CM_THIS_IN_EXPR_MASK            0x00000200      // Flag 10: 1 bit
#define CM_THIS_INV_METH_MASK           0x00000400      // Flag 11: 1 bit
#define CM_THIS_IGNORE_INFO_MASK        0x00000800      // Flag 12: 1 bit
#define CM_THIS_HAVE_INFO_MASK          0x00001000      // Flag 13: 1 bit
#define CM_THIS_IGNORE_OBS_MASK         0x00002000      // Flag 14: 1 bit
#define CM_THIS_IS_GLOBAL_REF_MASK      0x00004000      // Flag 15: 1 bit
#define CM_THIS_HAS_GROUP_MSG_MASK      0x00008000      // Flag 16: 1 bit
#define CM_THIS_HAS_BLOCK_MSG_MASK      0x00010000      // Flag 17: 1 bit
#define CM_THIS_DBCS_COMPATIBLE_MASK    0x00020000      // Flag 18: 1 bit
#define CM_THIS_MIGRATION_PROCESS_MASK  0x00040000      // Flag 19: 1 bit
#define CM_THIS_EXPR_NS_PASSED_MASK 	0x00080000      // Flag 20: 1 bit
#define CM_THIS_CALL_TYPE_MASK 			0x00300000      // Flag 21: 2 bit

// The bits in this mask are preserved when the compiler resets the
//  state flags.

#define CM_THIS_RESET_MASK              0x0007B800  // Preserved state flags:
													//  CM_THIS_IGNORE_INFO_MASK
													//  CM_THIS_HAVE_INFO_MASK
													//  CM_THIS_IGNORE_OBS_MASK
													//  CM_THIS_HAS_GROUP_MSG_MASK
													//  CM_THIS_HAS_BLOCK_MSG_MASK
													//  CM_THIS_DBCS_COMPATIBLE_MASK
													//  CM_THIS_MIGRATION_PROCESS_MASK

//      FLAG NAME                       SHIFT VALUE
#define CM_THIS_POSTED_CALL_SHIFT       0               // Flag  1: 0  bits
#define CM_THIS_DYNAMIC_CALL_SHIFT      1               // Flag  2: 1  bit
#define CM_THIS_EVENT_CALL_SHIFT        2               // Flag  3: 2  bits
#define CM_THIS_OLD_EVENT_CALL_SHIFT    3               // Flag  4: 3  bits
#define CM_THIS_POSTED_STAT_SHIFT       4               // Flag  5: 4  bits
#define CM_THIS_DYNAMIC_STAT_SHIFT      5               // Flag  6: 5  bits
#define CM_THIS_EVENT_STAT_SHIFT        6               // Flag  7: 6  bits
#define CM_THIS_IS_CONSTANT_SHIFT       7               // Flag  8: 7  bits
#define CM_THIS_IS_READONLY_SHIFT       8               // Flag  9: 8  bits
#define CM_THIS_IN_EXPR_SHIFT           9               // Flag 10: 9  bits
#define CM_THIS_INV_METH_SHIFT          10              // Flag 11: 10 bits
#define CM_THIS_IGNORE_INFO_SHIFT       11              // Flag 12: 11 bits
#define CM_THIS_HAVE_INFO_SHIFT         12              // Flag 13: 12 bits
#define CM_THIS_IGNORE_OBS_SHIFT        13              // Flag 14: 13 bits
#define CM_THIS_IS_GLOBAL_REF_SHIFT     14              // Flag 15: 14 bits
#define CM_THIS_HAS_GROUP_MSG_SHIFT     15              // Flag 16: 15 bits
#define CM_THIS_HAS_BLOCK_MSG_SHIFT     16              // Flag 17: 16 bits
#define CM_THIS_DBCS_COMPATIBLE_SHIFT   17              // Flag 18: 17 bits
#define CM_THIS_MIGRATION_PROCESS_SHIFT 18              // Flag 19: 18 bits
#define CM_THIS_EXPR_NS_PASSED_SHIFT 	19      		// Flag 20: 19 bits
#define CM_THIS_CALL_TYPE_SHIFT 		20      		// Flag 21: 20 bits

//****************************************************************************
//  Compiler bit flag support macros
//****************************************************************************

#define cmthis_reset_state_flags(pcmthis)                                   \
    (((PCM_THIS)pcmthis)->fStateFlags &= CM_THIS_RESET_MASK)

#define cmthis_is_posted_call(pcmthis)                                      \
    ob_get_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, BOOL,                \
            CM_THIS_POSTED_CALL_SHIFT, CM_THIS_POSTED_CALL_MASK )

#define cmthis_set_posted_call(pcmthis,value)                               \
    ob_set_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, ULONG, value,            \
            CM_THIS_POSTED_CALL_SHIFT, CM_THIS_POSTED_CALL_MASK )

#define cmthis_is_dynamic_call(pcmthis)                                     \
    ob_get_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, BOOL,                \
            CM_THIS_DYNAMIC_CALL_SHIFT, CM_THIS_DYNAMIC_CALL_MASK )

#define cmthis_set_dynamic_call(pcmthis,value)                              \
    ob_set_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, ULONG, value,            \
            CM_THIS_DYNAMIC_CALL_SHIFT, CM_THIS_DYNAMIC_CALL_MASK )

#define cmthis_is_event_call(pcmthis)                                       \
    ob_get_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, BOOL,                \
            CM_THIS_EVENT_CALL_SHIFT, CM_THIS_EVENT_CALL_MASK )

#define cmthis_set_event_call(pcmthis,value)                                \
    ob_set_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, ULONG, value,            \
            CM_THIS_EVENT_CALL_SHIFT, CM_THIS_EVENT_CALL_MASK )

#define cmthis_is_old_style_event_call(pcmthis)                             \
    ob_get_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, BOOL,                \
            CM_THIS_OLD_EVENT_CALL_SHIFT, CM_THIS_OLD_EVENT_CALL_MASK )

#define cmthis_set_old_style_event_call(pcmthis,value)                      \
    ob_set_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, ULONG, value,            \
            CM_THIS_OLD_EVENT_CALL_SHIFT, CM_THIS_OLD_EVENT_CALL_MASK )

#define cmthis_is_posted_call_set(pcmthis)                                  \
    ob_get_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, BOOL,                \
            CM_THIS_POSTED_STAT_SHIFT, CM_THIS_POSTED_STAT_MASK )

#define cmthis_set_posted_status(pcmthis,value)                             \
    ob_set_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, ULONG, value,            \
            CM_THIS_POSTED_STAT_SHIFT, CM_THIS_POSTED_STAT_MASK )

#define cmthis_is_dynamic_call_set(pcmthis)                                 \
    ob_get_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, BOOL,                \
            CM_THIS_DYNAMIC_STAT_SHIFT, CM_THIS_DYNAMIC_STAT_MASK )

#define cmthis_set_dynamic_status(pcmthis,value)                            \
    ob_set_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, ULONG, value,            \
            CM_THIS_DYNAMIC_STAT_SHIFT, CM_THIS_DYNAMIC_STAT_MASK )

#define cmthis_is_event_call_set(pcmthis)                                   \
    ob_get_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, BOOL,                \
            CM_THIS_EVENT_STAT_SHIFT, CM_THIS_EVENT_STAT_MASK )

#define cmthis_set_event_status(pcmthis,value)                              \
    ob_set_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, ULONG, value,            \
            CM_THIS_EVENT_STAT_SHIFT, CM_THIS_EVENT_STAT_MASK )

#define cmthis_is_item_marked_constant(pcmthis)                             \
    ob_get_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, BOOL,                \
            CM_THIS_IS_CONSTANT_SHIFT, CM_THIS_IS_CONSTANT_MASK )

#define cmthis_set_constant_status(pcmthis,value)                           \
    ob_set_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, ULONG, value,            \
            CM_THIS_IS_CONSTANT_SHIFT, CM_THIS_IS_CONSTANT_MASK )

#define cmthis_is_item_marked_readonly(pcmthis)                             \
    ob_get_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, BOOL,                \
            CM_THIS_IS_READONLY_SHIFT, CM_THIS_IS_READONLY_MASK )

#define cmthis_set_readonly_status(pcmthis,value)                           \
    ob_set_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, ULONG, value,            \
            CM_THIS_IS_READONLY_SHIFT, CM_THIS_IS_READONLY_MASK )

#define cmthis_in_primary_expr(pcmthis)                                     \
    ob_get_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, BOOL,                \
            CM_THIS_IN_EXPR_SHIFT, CM_THIS_IN_EXPR_MASK )

#define cmthis_set_primary_expr_status(pcmthis,value)                           \
    ob_set_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, ULONG, value,            \
            CM_THIS_IN_EXPR_SHIFT, CM_THIS_IN_EXPR_MASK )

#define cmthis_primary_expr_ns_passed(pcmthis)                                     \
    ob_get_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, BOOL,                \
            CM_THIS_EXPR_NS_PASSED_SHIFT, CM_THIS_EXPR_NS_PASSED_MASK )

#define cmthis_set_primary_expr_ns_pass_status(pcmthis,value)                           \
    ob_set_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, ULONG, value,            \
            CM_THIS_EXPR_NS_PASSED_SHIFT, CM_THIS_EXPR_NS_PASSED_MASK )

#define cmthis_get_rout_ref_type(pcmthis)                                     \
    ob_get_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, ULONG,                \
            CM_THIS_CALL_TYPE_SHIFT, CM_THIS_CALL_TYPE_MASK )

#define cmthis_set_rout_ref_type(pcmthis,value)                           \
    ob_set_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, ULONG, value,            \
            CM_THIS_CALL_TYPE_SHIFT, CM_THIS_CALL_TYPE_MASK )

#define cmthis_in_invoke_method(pcmthis)                                    \
    ob_get_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, BOOL,                \
            CM_THIS_INV_METH_SHIFT, CM_THIS_INV_METH_MASK )

#define cmthis_set_invoke_method_status(pcmthis,value)                      \
    ob_set_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, ULONG, value,            \
            CM_THIS_INV_METH_SHIFT, CM_THIS_INV_METH_MASK )

#define cmthis_ignore_information_messages(pcmthis)                         \
    ob_get_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, BOOL,                \
            CM_THIS_IGNORE_INFO_SHIFT, CM_THIS_IGNORE_INFO_MASK )

#define cmthis_set_ignore_information_messages(pcmthis,value)               \
    ob_set_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, ULONG, value,            \
            CM_THIS_IGNORE_INFO_SHIFT, CM_THIS_IGNORE_INFO_MASK )

#define cmthis_have_information_messages(pcmthis)                           \
    ob_get_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, BOOL,                \
            CM_THIS_HAVE_INFO_SHIFT, CM_THIS_HAVE_INFO_MASK )

#define cmthis_set_information_message_status(pcmthis,value)                \
    ob_set_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, ULONG, value,            \
            CM_THIS_HAVE_INFO_SHIFT, CM_THIS_HAVE_INFO_MASK )

#define cmthis_ignore_obsolete_messages(pcmthis)                            \
    ob_get_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, BOOL,                \
            CM_THIS_IGNORE_OBS_SHIFT, CM_THIS_IGNORE_OBS_MASK )

#define cmthis_set_ignore_obsolete_messages(pcmthis,value)                  \
    ob_set_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, ULONG, value,            \
            CM_THIS_IGNORE_OBS_SHIFT, CM_THIS_IGNORE_OBS_MASK )

// for replacement tool
#define cmthis_DBCS_compatible_messages(pcmthis)                            \
    ob_get_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, BOOL,                \
    CM_THIS_DBCS_COMPATIBLE_SHIFT, CM_THIS_DBCS_COMPATIBLE_MASK )

#define cmthis_set_DBCS_compatible_messages(pcmthis,value)                  \
    ob_set_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, ULONG, value,            \
    CM_THIS_DBCS_COMPATIBLE_SHIFT, CM_THIS_DBCS_COMPATIBLE_MASK )

#define cmthis_is_in_migration_process(pcmthis)                         \
    ob_get_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, BOOL,                \
    CM_THIS_MIGRATION_PROCESS_SHIFT, CM_THIS_MIGRATION_PROCESS_MASK )

#define cmthis_set_is_in_migration_process(pcmthis,value)                   \
    ob_set_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, ULONG, value,            \
    CM_THIS_MIGRATION_PROCESS_SHIFT, CM_THIS_MIGRATION_PROCESS_MASK )

#define cmthis_is_global_ref(pcmthis)                                       \
    ob_get_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, BOOL,                \
            CM_THIS_IS_GLOBAL_REF_SHIFT, CM_THIS_IS_GLOBAL_REF_MASK )

#define cmthis_set_global_ref_status(pcmthis,value)                         \
    ob_set_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, ULONG, value,            \
            CM_THIS_IS_GLOBAL_REF_SHIFT, CM_THIS_IS_GLOBAL_REF_MASK )

#define cmthis_has_group_msg(pcmthis)                                       \
    ob_get_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, BOOL,                \
            CM_THIS_HAS_GROUP_MSG_SHIFT, CM_THIS_HAS_GROUP_MSG_MASK )

#define cmthis_set_group_msg_status(pcmthis,value)                          \
    ob_set_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, ULONG, value,            \
            CM_THIS_HAS_GROUP_MSG_SHIFT, CM_THIS_HAS_GROUP_MSG_MASK )

#define cmthis_has_block_msg(pcmthis)                                       \
    ob_get_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, BOOL,                \
            CM_THIS_HAS_BLOCK_MSG_SHIFT, CM_THIS_HAS_BLOCK_MSG_MASK )

#define cmthis_set_block_msg_status(pcmthis,value)                          \
    ob_set_bitfield( ((PCM_THIS)pcmthis)->fStateFlags, ULONG, value,            \
            CM_THIS_HAS_BLOCK_MSG_SHIFT, CM_THIS_HAS_BLOCK_MSG_MASK )


#define cm_set_show_warnings(pcmthis,value)                                 \
    ((PCM_THIS)pcmthis)->bShowWarnings = (value)

#define cm_reset_show_warnings(pcmthis)                                     \
    ((PCM_THIS)pcmthis)->bShowWarnings = FALSE

//****************************************************************************
//  Compiler this structure
//****************************************************************************

			typedef struct cm_this
			{

				PSH_DBG_THIS        dbgthis;                // Debugger this pointer
				POB_THIS            obthis;                 // Object manager this ptr
				PVOID               grthis;                 // Parser this pointer
				ppbstg_anchor       stgthis;                // Storage manager this ptr
				BOOL                code_gen;               // Code generation flag
				BOOL                must_declare;           // Var declaration flag
				PSHLIST             pErrorList;             // Error list pointer
				BOOL                bGotCompileError;       // Compile error flag
				CM_DBSIGNON_PROC    pDBSignonProc;          // Ptr to DB signon proc
				PCMDB_MAIN          pDBCompile;             // Ptr to DB compiler block
				PVOID               curr_group;             // Current group struct
				OB_CLASS_ID         curr_class_id;          // Current class id
				BOOL                init_compile;           // Compiling init source?
				BOOL                bInGroupCompile;        // Started group compile flag
				BOOL                in_forward_ref;         // In forward reference flag
				OB_MODULE_ID        curr_mod_id;            // Current module id
				pbstg_subpool       temp_subpool;           // Compiler temp subpool
				pbstg_subpool       perm_subpool;           // Compiler perm subpool
				BOOL                in_append_block;        // Compiling append block?
				OB_CLASS_ID         curr_rout_type;         // Current routine type.
				BOOL                return_in_script;       // Is return stmt in script?
				LPTSTR              curr_rout_name;         // Current function name.
				BOOL                in_fwdproto_decl;       // In forward prototype decl?
				CM_DBSIGNON_PROC    pDBSignoffProc;         // Ptr to PB signoff proc
				BOOL                in_proto;               // In prototype decl?
				CM_COMPILE_TYPE     compile_type;           // Type of compile
				PSH_GROWBLOCK       expr_context_stack;     // Expression context stack
				UINT                expr_context_pos;       // Expression context pos
				INT                 subscript_state;        // Subscript state
				INT                 no_subscripts;          // No of subscripts
				UINT                array_item_pos;         // No of current array item
				PSH_GROWBLOCK       expr_type_stack;        // Expr type stack
				UINT                expr_type_pos;          // Expr type stack position
				BOOL                in_rvalue_expr;         // In rvalue flag
				PVOID               rout_name_stack;        // Routine name stack
				UINT                rout_name_stack_size;   //  Routine name stack size
				UINT                rout_name_pos;          // Routine name stack pos
				PSH_GROWBLOCK       func_arg_list;          // Function arg list
				PSH_GROWBLOCK       functmplt_arg_list;     // Function template arg list
				PSH_GROWBLOCK       functmplt_list;         // Main function template list
				PSH_GROWBLOCK       func_throws_list;       // list of throws types
				LPTSTR              curr_class_qualifier;   // Current class qualifier
				OB_CLASS_ID         curr_on_class;          // Current on class id.
				INT                 func_qualifier;         // Function qualifier
				LPTSTR              curr_typename;          // Current type name
				BOOL                curr_type_set;          // Is current type set?
				INT                 enum_state;             // Current enum state
				INT                 curr_type_qualifier;    // Current type qualifier
				LPTSTR              curr_sec_class_qualifier;// Curr sec class qualifier
				BOOL                curr_var_global;        // Is Current var a global?
				BOOL                curr_var_external;      // Is Current var a extern?
				INT                 curr_var_block;         // Within a variable block?
				OB_SOURCE_BLK_TYPE  source_type;            // Current source type
				PVOID               pbthis;                 // PB This pointer
				PVOID               curr_pcode;             // Current pcode block.
				PSH_GROWBLOCK       pcode_stack;            // Stack of pcode snippets
				UINT                pcode_stack_pos;        // Current pcode stack pos
				BOOL                idents_have_dashes;     // TRUE if idents have dashes.
				PSH_GROWBLOCK       indir_attr_list;        // List of indirect attr info
				UINT                indir_attr_pos;         // Current indirect attr pos
				PSH_GROWBLOCK       func_arginfo_list;      // List of funcarg info
				PSH_GROWBLOCK       func_exprinfo_list;     // List of assoc arg exprinfo
				UINT                func_arg_pos;           // Current funcarg pos
				BOOL                end_lhs_assign_expr;    // Flags end of lhs of assign
				BOOL                processing_indir_attrs; // Flags indirect attr process
				UINT                arraylist_count;        // No of items in curr arraylist
				PSHHASH             xform_table;            // Hash table for xform_pcodes
				ULONG               fStateFlags;            // State bit fields
				UINT                expr_pcode_start;       // First pcode of current expr
				PVOID               pCurrPrototype;         // Points to current prototype
				BOOL                pcode_lines_on;         // Are pcode lines are used?
				OB_EVT_TOKEN_ID     curr_eventtoken;        // If event, current token
				OB_ROUT_TYPE        obRoutType;             // OB_FUNCTION || OB_EVENT
				BOOL                processing_indir_func;  // Flags indirect attr function
				PSHHASH             pAliasList;             // Table of class alias names

				// The next field is used by ob_compile_source_entry (obgrpio.cpp)
				//  and cm_issue_error (cmerror.cpp) to display a pbl name in the error
				//  window only as often as necessary.

				LPTSTR              pszLastPBLName;         // Last error'd pbl name
				BOOL                sql_free_refpak;        // Free flag for SQL refpaks
				BOOL                bShowWarnings;          // do we show warnings
				BOOL                inGroupScope;           // for toplevel routine check
				BOOL                inEvalContext;          // Is expression evaluation OK?
				OB_CLASS_ID         curr_ext_class_id;      // Is there an externalEvents class?
				PVOID               protoProperties;
				// The ID if the current routine has already had AncestorReturnValue created, else OB_SYM_NOT_DEFINED.
				OB_SYM_ID           AncestorReturnValueId;
				BOOL                isFirstPass;            // true if 1st pass of a typedef only compile
				BOOL                isSecondPass;
				BOOL                bHyperlinkErrors;       // use hyperlink error format

			// hluo
				PSHLIST             pReplacedFuncList;      // List storing the name of replaced functions
				OB_CONST_REF        lPBExtensionName;       // native dll name

				OS_LFILE            log_file;

				// PB11 language enhancement -- namespace
				LPTSTR              namespace_decl;         // namespace declaration
				PSHLIST             using_directive_list;   // List of the statement using directive
				PSHLIST				global_preprocessor_symbols;	//user defined and pre-defined preprocessor_symbols.
				PVOID				ppcsthis;				//Preprocessor parser this pointer
				BOOL				ppcs_debug_symbol_used;		// true if preprocessor debug symbol has been used
			} CM_THIS;

#ifndef PCM_THIS_DEFINED
#define PCM_THIS_DEFINED
			typedef struct cm_this FAR* PCM_THIS;
#endif

			// **************************************************************************
			//   Structure for error handling
			// **************************************************************************

			typedef struct cm_error                       // Error information
			{

				INT        iLevel;                        // Error level
				LPTSTR      lpszMessageNumber;             // Ptr to message number string
				LPTSTR      lpszMessageText;               // Ptr to message text string
				UINT       iColumnNumber;                 // Column number
				UINT       iLineNumber;                   // Line number

			} CM_ERROR, FAR* PCM_ERROR;

			//hluo for replacement tool
#define CM_REPLACE_FUNCTION_NAME_STYLE  1
#define CM_ADD_ENCODING_ARGUMENT_STYLE  2

			typedef struct cm_replaced_func_info
			{
				INT         iBlock;                         // which block
				UINT        iPos;                           // position in the owner block
				LPTSTR      lpszOldFunc;                    // old function name
				LPTSTR      lpszNewFunc;                    // new function name
				INT         iStyle;                         // indicate how to replace

			} CM_REPLACED_FUNC_INFO, FAR* PCM_REPLACED_FUNC_INFO;

			// **************************************************************************
			//   Error levels
			// **************************************************************************

#define CM_INFORMATION_LEVEL  1
#define CM_OBSOLETE_LEVEL     2
#define CM_WARNING_LEVEL      3
#define CM_ERROR_LEVEL        4
#define CM_FATAL_LEVEL        5
#define CM_DBWARNING_LEVEL    6

//****************************************************************************
// Macros to handle compiler flags
//****************************************************************************

#define cmthis_curr_rout_type(pcmthis)                                      \
    (pcmthis->obRoutType)

#define cmthis_set_curr_rout_type(pcmthis,value)                            \
    (pcmthis->obRoutType = value)

#define cmthis_curr_rout_is_event(pcmthis)                                  \
    ((BOOL) (cmthis_curr_rout_type(pcmthis) == OB_EVENT))

#define cmthis_curr_rout_is_function(pcmthis)                               \
    ((BOOL) (cmthis_curr_rout_type(pcmthis) == OB_FUNCTION))

#define cmthis_debug_symbol_used(pcmthis)									\
	(pcmthis->ppcs_debug_symbol_used)

#define cmthis_set_debug_symbol_used(pcmthis, value)						\
	(pcmthis->ppcs_debug_symbol_used = value)

//****************************************************************************
// Data flags masks and shifts
//****************************************************************************

#define CM_DASHESINIDENT_MASK       0x0001          // 1 bit
#define CM_LOGOPSHORTCIRCUIT_MASK   0x0002          // 1 bit
#define CM_RATIONALVARSRCH_MASK     0x0003          // 1 bit

#define CM_DASHESINIDENT_SHIFT      0
#define CM_LOGOPSHORTCIRCUIT_SHIFT  1
#define CM_RATIONALVARSRCH_SHIFT    2

#define cm_get_dashes_in_ident(cmFlags)                                    \
        (((cmFlags) & CM_DASHESINIDENT_MASK) >> CM_DASHESINIDENT_SHIFT)

#define cm_get_logop_short_circuit(cmFlags)                                \
        (((cmFlags) & CM_LOGOPSHORTCIRCUIT_MASK) >> CM_LOGOPSHORTCIRCUIT_SHIFT)

#define cm_get_rational_var_srch(cmFlags)                                  \
        (((cmFlags) & CM_RATIONALVARSRCH_MASK) >> CM_RATIONALVARSRCH_SHIFT)

#define cm_set_dashes_in_ident(cmFlags,val)                                \
        ((cmFlags) = ((val) << CM_DASHESINIDENT_SHIFT) |                        \
                     ((cmFlags) & ~CM_DASHESINIDENT_MASK))

#define cm_set_logop_short_circuit(cmFlags,val)                            \
        ((cmFlags) = ((val) << CM_LOGOPSHORTCIRCUIT_SHIFT) |                    \
                     ((cmFlags) & ~CM_LOGOPSHORTCIRCUIT_MASK))

#define cm_set_rational_var_srch(cmFlags,val)                              \
        ((cmFlags) = ((val) << CM_RATIONALVARSRCH_SHIFT) |                 \
                     ((cmFlags) & ~CM_RATIONALVARSRCH_MASK))

#define cm_set_compiler_flags(cmFlags,dashes,short,ratsrch)                \
        (cmFlags) = (((dashes) << CM_DASHESINIDENT_SHIFT)               |  \
                     ((short) << CM_LOGOPSHORTCIRCUIT_SHIFT)            |  \
                     ((ratsrch) << CM_RATIONALVARSRCH_SHIFT)               \
                    )

//****************************************************************************
// Public prototypes
//****************************************************************************

			PBWINAPI(PCM_THIS, cm_init_script_compiler)
				(
					POB_THIS            obthis,
					ppbstg_anchor       stgthis,
					PVOID               pbThis,
					PVOID               pSignonProc,
					PVOID               pSignoffProc,
					UINT                cmFlags
					);

			PBWINAPI(VOID, cm_enable_debug_symbol)
				(
					PCM_THIS cmthis
					);

			PBWINAPI(VOID, cm_disable_debug_symbol)
				(
					PCM_THIS cmthis
					);

			PBWINAPI(VOID, cm_set_compiler_context)
				(
					PCM_THIS            cmthis,
					POB_THIS            obthis
					);

			PBWINAPI(VOID, cm_terminate)
				(
					PCM_THIS            cmthis
					);

			PBWINAPI(INT, cm_compile_script)
				(
					PCM_THIS            cmthis,
					OB_CLASS_HNDL       classhndl,
					LPTSTR				source
					);

			PBWINAPI(VOID, cm_free_error_list)
				(
					PCM_THIS            cmthis
					);

			PBWINAPI(PSHLIST, cm_get_error_list)
				(
					PCM_THIS            cmthis
					);


			PBWINAPI(PSHLIST, cm_keep_error_list)
				(
					PCM_THIS            cmthis
					);

			PBWINAPI(VOID, cm_combine_error_list)
				(
					PCM_THIS            cmthis,
					PSHLIST				theList,
					BOOL				bInsert
					);


			PBWINAPI(void, cm_compile_namespace_block)
				(
					PCM_THIS			cmthis,
					OB_CLASS_HNDL       class_hndl
					);

			PBWINAPI(INT, cm_group_compile)
				(
					PCM_THIS            cmthis,
					OB_GROUP_HNDL       grouphndl
					);

			PBWINAPI(BOOL, cm_is_word_reserved)
				(
					PCM_THIS            cmthis,
					LPTSTR               name
					);

			PBWINAPI(INT, cm_stream_compile)
				(
					/* PCM_THIS         cmthis, // Not yet */
					OB_GROUP_HNDL       grouphndl,
					LPTSTR               source
					);

			PBWINAPI(INT, cm_src_block_compile)
				(
					PCM_THIS            cmthis,
					OB_GROUP_HNDL       grouphndl,
					LPTSTR FAR* source_blocks,
					PVOID               srcloc,
					UINT                no_blocks,
					CM_COMPILE_TYPE     compile_type
					);

			PBWINAPI(LPTSTR, cm_describe_statement)
				(
					PCM_THIS            cmthis,
					LONG                grouphandle,
					LPTSTR               varname,
					PUINT               no_items,
					OB_CLASS_ID         class_id
					);

			PBCDECLAPI(INT, cm_compiler_error)
				(
					PCM_THIS            cm_this,
					INT                 iMessageID,
					...
					);

			PBCDECLAPI(INT, cm_compiler_error_ln)
				(
					PCM_THIS    cmthis,
					UINT        iLineNumber,
					INT         iMessageID,
					...
					);

			PBWINAPI(PCM_THIS, cm_get_curr_this)
				(
					VOID
					);

			//****************************************************************************
			// Make utilities
			//****************************************************************************

			typedef enum cm_rebuild_type
			{
				CM_REBUILD_INCREMENTAL,             // does an incremental build (2 pass)
				CM_REBUILD_FULL,                    // does a full build (2 pass)
				CM_REBUILD_MIGRATE                  // adds extra pass for migrate (3 pass)
			} CM_REBUILD_TYPE;

			typedef enum cm_rebuild_category
			{
				REBUILD_COMPILE_LIST,               // Creating compilation list
				REBUILD_CREATE_TYPES,               // Creating type structure
				REBUILD_OBJECT_STAGE1,              // Stage1 typedef recompile
				REBUILD_OBJECT_STAGE2,              // Stage2 typedef recompile (only for migrate)
				REBUILD_OBJECT_REGENERATE,          // Regenerating object
				REBUILD_COMPLETE,                   // Finished
				REBUILD_LIB_READONLY                // One of the libraries was read only
			} CM_REBUILD_STAGE;

			typedef enum cm_rebuild_status
			{
				REBUILD_NO_MESSAGES,                // Rebuild was successful, no messages
				REBUILD_MESSAGES,                   // Rebuild was successful with messages
				REBUILD_ERRORS                      // Rebuild failed with errors
			} CM_REBUILD_STATUS, FAR* PCM_REBUILD_STATUS;

			typedef struct cm_rebuild FAR* PCM_REBUILD;

			// this callback is used to track the progress of the executable build
			typedef PBCALLBACK(BOOL, FAR* CM_REBUILD_CALLBACK) (PCM_REBUILD);

			typedef struct cm_rebuild
			{
				PVOID               pGlobals;           // Pointer to PB globals
				UINT                hParent;            // Handle to parent window

				CM_REBUILD_CALLBACK fnCallback;         // the callback for tracking progress

				// message line callback info
				CM_REBUILD_STAGE    rebuildStage;       // the stage of rebuild
				LPTSTR              lpszStageArgument;  // the name to be included in the message
				LPTSTR              lpszLibraryName;    // the library name of the entity

			} CM_REBUILD;

			// FALSE from the callback indicates that we should abort
#define CM_REBUILD_AT_STAGE( cm_rebuild, stage, arg, libName ) \
    ( ( (cm_rebuild)->fnCallback != NULL ) ? \
        ( \
        (cm_rebuild)->rebuildStage          = (stage), \
        (cm_rebuild)->lpszStageArgument     = (arg), \
        (cm_rebuild)->lpszLibraryName       = (libName), \
        (cm_rebuild)->fnCallback( (cm_rebuild) ) \
        ) : TRUE )

			PBWINAPI(BOOL, cm_rebuild_application)
				(
					POB_THIS                obthis,
					CM_REBUILD_TYPE         rebuildType,
					PCM_REBUILD             cmRebuild,
					PCM_REBUILD_STATUS      rebuildStatus
					);

			// caller is responsible for freeing the compile list
			PBWINAPI(BOOL, cm_rebuild_from_compile_list)
				(
					POB_THIS                obthis,
					CM_REBUILD_TYPE         rebuildType,
					PCM_REBUILD             cmRebuild,
					PCM_REBUILD_STATUS      rebuildStatus,
					POB_COMPILE_LIST        pCompileList,
					UINT                    iNumberOfItems,     // returned from ob_build_ordered_compile_list
					OB_INCONSISTENCY_TYPE   inconsistency       // returned from ob_build_ordered_compile_list
					);

			PBWINAPI(BOOL, cm_regen_datawindow)
				(
					POB_THIS                obthis,
					LPTSTR                  lpszLibraryName,
					LPTSTR                  lpszDWName
					);


			PBWINAPI(INT, cm_read_alias_table)
				(
					PCM_THIS        cmthis
					);

			PBWINAPI(LPTSTR, cm_find_alias)
				(
					PCM_THIS    cmthis,
					LPTSTR      pKey,
					LPTSTR      pCurrentName
					);

			PBWINAPI(INT, cm_add_alias_entry)
				(
					PCM_THIS        cmthis,
					LPTSTR          pKey,
					LPTSTR          pName
					);

			PBWINAPI(INT, cm_remove_alias_entry)
				(
					PCM_THIS        cmthis,
					LPTSTR          pKey
					);

			PBWINAPI(INT, cm_write_alias_table)
				(
					PCM_THIS        cmthis
					);

			PBWINAPI(INT, cm_add_global_var)
				(
					POB_THIS    obthis,
					LPTSTR      var_name,
					LPTSTR      type_name
					);


			PBWINAPI(INT, cm_import_pb_extension)
				(
					POB_THIS    obthis,
					LPCTSTR     pbl_name,
					LPCTSTR     dll_name
					);

			PBWINAPI(BOOL, cm_convert_pbl_to_unicode)
				(
					POB_THIS                obthis,
					LPTSTR                  lpszLibraryName
					);


#ifdef __cplusplus
		}
#endif /* __cplusplus */

#endif // CMPUBLIC_H

		// DOINC popped back into header 'rtthis.h'


		//****************************************************************************
		// New rtthis is just a stub for obthis.h
		//****************************************************************************

		// #include "obthis.h" done above
#ifdef __cplusplus
		extern "C"
#endif	/* __cplusplus */
			int PBROI_LibMain(HANDLE hInstance);
		int FN_LibMain(HANDLE hInstance);
		int PBSHR_LibMain(HANDLE hInstance);
#endif // RTTHIS_H

		// DOINC popped back into header 'otpublic.h'
#ifndef OSCALLC_H
// ***** DOINC including oscallc.h *****
	// DOINC skipping duplicate include
#endif

//****************************************************************************
// Assume C declarations for C++
//****************************************************************************

#ifdef __cplusplus
		extern "C" {
#endif	/* __cplusplus */


			//****************************************************************************
			//	Lvalue info struct
			//****************************************************************************

			typedef struct ot_lvalue_info
			{

				OB_GROUP_HNDL		group_hndl;
			} OT_LVALUE_INFO, FAR* POT_LVALUE_INFO;

			//****************************************************************************
			// Function prototypes & macros for Arglists
			//****************************************************************************

			PBWINAPI(POB_DATA, ot_get_next_evaled_arg)
				(
					POB_THIS 					obthis
					);

			PBWINAPI(POB_DATA, ot_get_next_evaled_arg_no_convert)
				(
					POB_THIS        obthis
					);

			PBWINAPI(POB_DATA, ot_get_next_lvalue_arg)
				(
					POB_THIS 					obthis,
					POT_LVALUE_INFO FAR* str
					);

			PBWINAPI(INT, ot_get_simple_intarg)
				(
					POB_THIS 					obthis,
					PBOOL 						null
					);

			PBWINAPI(LONG, ot_get_simple_longarg)
				(
					POB_THIS 					obthis,
					PBOOL 						null
					);

			PBWINAPI(INT, ot_get_intarg)
				(
					POB_THIS 					obthis,
					PBOOL 						null
					);

			PBWINAPI(UINT, ot_get_uintarg)
				(
					POB_THIS 					obthis,
					PBOOL 						null
					);

			PBWINAPI(LONG, ot_get_longarg)
				(
					POB_THIS 					obthis,
					PBOOL 						null
					);

			PBWINAPI(ULONG, ot_get_ulongarg)
				(
					POB_THIS 					obthis,
					PBOOL 						null
					);

			PBWINAPI(PSH_DEC, ot_get_decarg)
				(
					POB_THIS 					obthis,
					PBOOL 						null
					);

			PBWINAPI(PFLOAT, ot_get_floatarg)
				(
					POB_THIS 					obthis,
					PFLOAT 						fl,
					PBOOL 						null
					);

			PBWINAPI(PDOUBLE, ot_get_doublearg)
				(
					POB_THIS 					obthis,
					PDOUBLE 	 				doub,
					PBOOL 						null
					);

			PBWINAPI(PLONGLONG, ot_get_longlongarg)
				(
					POB_THIS 					obthis,
					PLONGLONG 	 				longlong_val,
					PBOOL 						null
					);

			PBWINAPI(POB_INST_ID, ot_get_obinstarg)
				(
					POB_THIS 					obthis,
					POB_INST_ID 				obinst,
					PBOOL 						null
					);

			PBWINAPI(PVOID, ot_get_valptr_arg)
				(
					POB_THIS 					obthis,
					PBOOL 						null
					);

#define 	 	ot_get_str_arg(obthis,nulval)				  	\
						((LPTSTR) ot_get_valptr_arg (obthis, nulval))
#define 	 	ot_get_bool_arg(obthis,nulval) 					\
						((BOOL) ot_get_simple_intarg (obthis, nulval))
#define 	 	ot_get_time_arg(obthis,nulval)					\
						((PSH_TIME) ot_get_valptr_arg (obthis, nulval))
#define 	 	ot_get_date_arg(obthis,nulval)					\
						((PSH_TIME) ot_get_valptr_arg (obthis,nulval))
#define 	 	ot_get_datetime_arg(obthis,nulval)				\
						((PSH_TIME) ot_get_valptr_arg (obthis, nulval))
#define 	 	ot_get_enum_arg(obthis,nulval)					\
						ot_get_simple_intarg (obthis, nulval)
#define 	 	ot_get_binary_arg(obthis,nulval)			  	\
						((PSH_BINARY) ot_get_valptr_arg (obthis, nulval))

#define  		ot_get_int_arg(obthis,nulval) 					\
						ot_get_intarg (obthis, nulval)

#define  		ot_get_uint_arg(obthis,nulval) 					\
						ot_get_uintarg (obthis, nulval)
#define  		ot_get_long_arg(obthis,nulval) 					\
						ot_get_longarg (obthis, nulval)
#define  		ot_get_ulong_arg(obthis,nulval) 			  	\
						ot_get_ulongarg (obthis, nulval)
#define  		ot_get_dec_arg(obthis,nulval) 					\
						ot_get_decarg (obthis, nulval)
#define  		ot_get_float_arg(obthis,fl,nulval) 				\
						ot_get_floatarg (obthis, fl, nulval)
#define  		ot_get_double_arg(obthis,doub,nulval) 			\
						ot_get_doublearg (obthis, doub, nulval)
#define  		ot_get_longlong_arg(obthis,longl,nulval) 			\
						ot_get_longlongarg (obthis, longl, nulval)
#define  		ot_get_obinst_arg(obthis,obinst,nulval) 		\
						ot_get_obinstarg (obthis, obinst, nulval)

			//	OBSOLETE!
			PBWINAPI(UINT, ot_init_arglist)
				(
					POB_THIS 			obthis,
					UINT 		 		nargs
					);

			//****************************************************************************
			// Function prototypes for Tools
			//****************************************************************************

			PBWINAPI(PVOID, ot_get_valptr)
				(
					POB_THIS 			obthis,
					POB_DATA 			data
					);

			PBWINAPI(INT, ot_type_srch)
				(
					LPTSTR						name
					);

			PBWINAPI(INT, ot_type_attr)
				(
					OB_CLASS_ID			type
					);

			PBWINAPI(LPTSTR, ot_get_class_name)
				(
					POB_THIS					obthis,
					POB_GROUP					group,
					OB_CLASS_ID					class_id
					);

			//****************************************************************************
			// Function prototypes Equality checking
			//****************************************************************************

			PBWINAPI(BOOL, ot_is_array_eq)
				(
					POB_THIS 			obthis,
					OB_ARRAY_ID	   		array_id1,
					OB_ARRAY_ID			array_id2,
					PBOOL			   	nullval
					);

			PBWINAPI(BOOL, ot_is_struct_eq)
				(
					POB_THIS 			obthis,
					POB_DATA  			data_node1,
					POB_DATA  			data_node2,
					PBOOL	  			nullval
					);

			//****************************************************************************
			//	Expression evaluation Function Prototypes
			//****************************************************************************

			PBWINAPI(OB_INST_ID, ot_create_obinst_with_name)
				(
					POB_THIS 			obthis,
					POB_DATA 			lvalue_data,
					POT_LVALUE_INFO		lvalue_info,
					LPTSTR				class_name,
					OB_INST_ID			nested_obinst
					);

			PBWINAPI(OB_INST_ID, ot_create_obinst_at_lval)
				(
					POB_THIS 			obthis,
					POB_DATA 			lvalue_data,
					POT_LVALUE_INFO		lvalue_info,
					OB_INST_ID			nested_obinst
					);

			PBWINAPI(POB_INST_ID, ot_get_curr_obinst_expr)
				(
					POB_THIS 			obthis,
					POB_INST_ID 		obinst_buf,
					PBOOL 				nullval
					);

			PBWINAPI(POB_DATA, ot_func_call)
				(
					POB_THIS			obthis,			   	  // Object Manager This pointer
					POB_FUNCCALL_INFO	funccall_info,		  // Funccall info structure
					PVOID FAR* actual_args 		  // Array of actual arguments.
					);

			//****************************************************************************
			//	Return value prototypes and macros
			//****************************************************************************

			PBWINAPI(VOID, ot_set_return_val)
				(
					POB_THIS				obthis,
					POB_DATA				data_node
					);

			PBWINAPI(VOID, ot_set_return_double)
				(
					POB_THIS				obthis,
					PDOUBLE					doub_val,
					BOOL					null_val
					);

			PBWINAPI(VOID, ot_set_return_longlong)
				(
					POB_THIS				obthis,
					PLONGLONG				longl_val,
					BOOL					null_val
					);

			//For subroutines, must tell object manager that it's not returning anything.
			PBWINAPI(VOID, ot_set_return_dec)
				(
					POB_THIS				obthis,
					PSH_DEC					dec_val,
					BOOL					null_val
					);

			PBWINAPI(VOID, ot_no_return_val)
				(
					POB_THIS 			obthis
					);

#define		_return_macro(obthis,var,name,type,nulval)			 			\
					{											  			\
					OB_DATA node;											\
					ob_set_data_##name (&node,var,type,FALSE);				\
					ob_set_data_nullval (&node,nulval);						\
					ot_set_return_val (obthis,&node);						\
					}

#define		ot_return_int(obthis,int_val,nulval)							\
						_return_macro(obthis,int_val,int,INT_TYPE,nulval)
#define		ot_return_uint(obthis,ui_val,nulval)							\
						_return_macro(obthis,ui_val,uint,UINT_TYPE,nulval)
			//**********************************************************
			// Begin of the new type BYTE
			//**********************************************************						
#define		ot_return_byte(obthis,byte_val,nulval)							\
						_return_macro(obthis,byte_val,byte,BYTE_TYPE,nulval)
//**********************************************************
// End of the new type BYTE
//**********************************************************						
#define		ot_return_long(obthis,l_val,nulval)								\
						_return_macro(obthis,l_val,long,LONG_TYPE,nulval)
#define		ot_return_ulong(obthis,ul_val,nulval)							\
						_return_macro(obthis,ul_val,ulong,ULONG_TYPE,nulval)
#define		ot_return_dec(obthis,dec_val,nulval)							\
						ot_set_return_dec (obthis, dec_val, nulval)
#define		ot_return_float(obthis,fl_val,nulval) 							\
						_return_macro(obthis,fl_val,float,FLOAT_TYPE,nulval)
#define		ot_return_double(obthis,d_val,nulval)							\
						ot_set_return_double (obthis, &d_val, nulval)
#define		ot_return_longlong(obthis,longl_val,nulval)							\
						ot_set_return_longlong (obthis, &longl_val, nulval)
#define		ot_return_string(obthis,st_val,nulval)							\
						_return_macro(obthis,st_val,ptr,STRING_TYPE,nulval)
#define		ot_return_bool(obthis,bool_val,nulval)							\
						_return_macro(obthis,bool_val,int,BOOL_TYPE,nulval)
#define		ot_return_char(obthis,char_val,nulval)							\
						_return_macro(obthis,char_val,int,CHAR_TYPE,nulval)
#define		ot_return_blob(obthis,bin_val,nulval)							\
						_return_macro(obthis,bin_val,ptr,BINARY_TYPE,nulval)
#define		ot_return_time(obthis,time_val,nulval)							\
						_return_macro(obthis,time_val,ptr,TIME_TYPE,nulval)
#define		ot_return_date(obthis,date_val,nulval)							\
						_return_macro(obthis,date_val,ptr,DATE_TYPE,nulval)
#define		ot_return_datetime(obthis,date_val,nulval)						\
						_return_macro(obthis,date_val,ptr,DATETIME_TYPE,nulval)

#define		ot_return_obinst(obthis,inst,typ,nulval)						\
						_return_macro(obthis,inst,obinst,typ,nulval)
#define		ot_return_enum(obthis,enum_val,typ,nulval)							\
						_return_macro(obthis,enum_val,enum,typ,nulval)
#define		ot_return_array_any(obthis,array_val,typ,nulval)							\
						_return_macro(obthis,array_val,array,ANY_TYPE,nulval)

//OLD WAY
#define		ot_return_binary(obthis,bin_val,nulval)							\
						_return_macro(obthis,bin_val,ptr,BINARY_TYPE,nulval)


//****************************************************************************
// Utility macros used in set_*_data macros below
//****************************************************************************

#define	_dblcpy(obthis,val)   										\
	( pbstg_memcpy (	   											\
   	  				ob_alloc_double (obthis),						\
				  	&val,				   							\
				  	sizeof (DOUBLE)		   							\
	  			   )												\
	)

#define	_longlcpy(obthis,val)   										\
	( pbstg_memcpy (	   											\
   	  				ob_alloc_longlong (obthis),						\
				  	&val,				   							\
				  	sizeof (LONGLONG)		   							\
	  			   )												\
	)

//****************************************************************************
//	Lvalue assignment macros
//****************************************************************************

#define ot_assign_lvalue_int(obthis,lvalue_data,val,nullval)			   	\
	{																		\
	ob_set_data_nullval (lvalue_data, nullval);								\
	ob_set_data_int_val (lvalue_data, val);									\
	}

#define ot_assign_lvalue_uint(obthis,lvalue_data,val,nullval)				\
	{																		\
	ob_set_data_nullval (lvalue_data, nullval);								\
	ob_set_data_uint_val (lvalue_data, val);								\
	}

//**********************************************************
// Begin of the new type BYTE
//**********************************************************
#define ot_assign_lvalue_byte(obthis,lvalue_data,val,nullval)				\
	{																		\
	ob_set_data_nullval (lvalue_data, nullval);								\
	ob_set_data_byte_val (lvalue_data, val);								\
	}
//**********************************************************
// End of the new type BYTE
//**********************************************************

#define ot_assign_lvalue_long(obthis,lvalue_data,val,nullval)				\
	{																		\
	ob_set_data_nullval (lvalue_data, nullval);								\
	ob_set_data_long_val (lvalue_data, val);								\
	}

#define ot_assign_lvalue_ulong(obthis,lvalue_data,val,nullval)				\
	{																		\
	ob_set_data_nullval (lvalue_data, nullval);								\
	ob_set_data_ulong_val (lvalue_data, val);							  	\
	}

			PBWINAPI(VOID, ot_assign_lvalue_dec)
				(
					POB_THIS				obthis,
					POB_DATA				lvalue_data,
					PSH_DEC					val,
					BOOL					nullval
					);

#define ot_assign_lvalue_float(obthis,lvalue_data,val,nullval)				\
	{																		\
	ob_set_data_nullval (lvalue_data, nullval);								\
	ob_set_data_float_val (lvalue_data, val);								\
	}

			PBWINAPI(VOID, ot_assign_lvalue_double)
				(
					POB_THIS				obthis,
					POB_DATA				lvalue_data,
					DOUBLE					val,
					BOOL					nullval
					);

			PBWINAPI(VOID, ot_assign_lvalue_longlong)
				(
					POB_THIS				obthis,
					POB_DATA				lvalue_data,
					LONGLONG				val,
					BOOL					nullval
					);

			PBWINAPI(VOID, ot_assign_lvalue_blob)
				(
					POB_THIS				obthis,
					POB_DATA				lvalue_data,
					PSH_BINARY				val,
					BOOL					nullval
					);

#define ot_assign_lvalue_bool(obthis,lvalue_data,val,nullval)				\
	ot_assign_lvalue_int (obthis, lvalue_data, val, nullval)

#define ot_assign_lvalue_char(obthis,lvalue_data,val,nullval)				\
	ot_assign_lvalue_int (obthis, lvalue_data, val, nullval)

#define ot_assign_lvalue_ptr(obthis,lvalue_data,val,nullval)				\
	{																		\
   	ot_free_val_ptr (obthis, lvalue_data);									\
   	ob_set_data_nullval (lvalue_data, nullval);								\
   	ob_set_data_style (lvalue_data, PTR_STYLE);								\
	ob_set_data_ptr_val (lvalue_data, val);										\
	}

#define ot_assign_lvalue_string(obthis,lvalue_data,strval,nullval)			\
	ot_assign_lvalue_ptr (obthis, lvalue_data, strval, nullval)

#define ot_assign_lvalue_time(obthis,lvalue_data,timeval,nullval)			\
	ot_assign_lvalue_ptr (obthis, lvalue_data, timeval, nullval)

#define ot_assign_lvalue_date(obthis,lvalue_data,timeval,nullval)			\
	ot_assign_lvalue_ptr (obthis, lvalue_data, timeval, nullval)

#define ot_assign_lvalue_datetime(obthis,lvalue_data,timeval,nullval)  		\
	ot_assign_lvalue_ptr (obthis, lvalue_data, timeval, nullval)

			PBWINAPI(VOID, ot_assign_lvalue_obinst)
				(
					POB_THIS				obthis,
					POB_DATA				lvalue_data,
					OB_INST_ID				val,
					BOOL					nullval
					);

#define ot_assign_lvalue_enum(obthis,lvalue_data,val,nullval)				\
	ot_assign_lvalue_int (obthis, lvalue_data, val, nullval)

			PBWINAPI(VOID, ot_assign_lvalue_array)
				(
					POB_THIS		  		obthis,
					POB_DATA		  		lvalue_data,
					OB_ARRAY_ID	  			rvalue_array,
					BOOL					nullval
					);

			PBWINAPI(VOID, ot_assign_lvalue_any)
				(
					POB_THIS				obthis,
					POB_DATA				lvalue_data,
					POB_DATA				rvalue_data,
					OB_CLASS_ID				rhs_class_id
					);

			//****************************************************************************
			// Lvalue assignment macros currently being used by system functions
			// (NOW OBSOLETE)
			//****************************************************************************

#define	ot_set_lvalue_int(ths,lv,lvi,val)									\
	ot_assign_lvalue_int (ths,lv,val,FALSE)
#define	ot_set_lvalue_uint(ths,lv,lvi,val)									\
	ot_assign_lvalue_uint (ths,lv,val,FALSE)
#define	ot_set_lvalue_long(ths,lv,lvi,val)									\
	ot_assign_lvalue_long (ths,lv,val,FALSE)
#define	ot_set_lvalue_ulong(ths,lv,lvi,val)									\
	ot_assign_lvalue_ulong (ths,lv,val,FALSE)
#define	ot_set_lvalue_dec(ths,lv,lvi,val)									\
	ot_assign_lvalue_dec (ths,lv,val,FALSE)
#define	ot_set_lvalue_float(ths,lv,lvi,val)									\
	ot_assign_lvalue_float (ths,lv,val,FALSE)
#define	ot_set_lvalue_double(ths,lv,lvi,val)								\
	ot_assign_lvalue_double (ths,lv,val,FALSE)
#define	ot_set_lvalue_longlong(ths,lv,lvi,val)								\
	ot_assign_lvalue_longlong (ths,lv,val,FALSE)

#define	ot_set_lvalue_string(ths,lv,lvi,val)							 	\
	ot_assign_lvalue_string (ths,lv,val,FALSE)
#define	ot_set_lvalue_bool(ths,lv,lvi,val)								 	\
	ot_assign_lvalue_bool (ths,lv,val,FALSE)
#define	ot_set_lvalue_char(ths,lv,lvi,val)								 	\
	ot_assign_lvalue_char (ths,lv,val,FALSE)
#define	ot_set_lvalue_blob(ths,lv,lvi,val)							 		\
	ot_assign_lvalue_blob (ths,lv,val,FALSE)

#define	ot_set_lvalue_time(ths,lv,lvi,val)								 	\
	ot_assign_lvalue_time (ths,lv,val,FALSE)
#define	ot_set_lvalue_date(ths,lv,lvi,val)								 	\
	ot_assign_lvalue_date (ths,lv,val,FALSE)
#define	ot_set_lvalue_datetime(ths,lv,lvi,val)							 	\
	ot_assign_lvalue_datetime (ths,lv,val,FALSE)

#define	ot_set_lvalue_obinst(ths,lv,lvi,val,typ)						 	\
	ot_assign_lvalue_obinst (ths,lv,val,FALSE)
#define	ot_set_lvalue_enum(ths,lv,lvi,val,typ)							 	\
	ot_assign_lvalue_enum (ths,lv,val,FALSE)

// Old Way
#define	ot_set_lvalue_binary(ths,lv,lvi,val)							 	\
	ot_assign_lvalue_blob (ths,lv,val,FALSE)

//****************************************************************************
// Routines/Macros to set local vars.
//****************************************************************************

			PBWINAPI(INT, ot_set_local_var)
				(
					POB_THIS   					ths,
					OB_SYM_ID					sym_id,
					POB_DATA   					data_node
					);

			//****************************************************************************
			// Routines/Macros to set shared vars
			//****************************************************************************

			PBWINAPI(INT, ot_set_shared_var)
				(
					POB_THIS			  		ths,
					OB_GROUP_HNDL				group_hndl,
					OB_SYM_ID					sym_id,
					POB_DATA			  		data_node
					);

			//****************************************************************************
			// Routines/Macros to set fields
			//****************************************************************************

			// Use only if data conversion needed (e.g., decimal to integer), otherwise,
			// use ob_set_<type>_field() macros instead.
			PBWINAPI(INT, ot_set_obinst_var)
				(
					POB_THIS					ths,
					OB_INST_ID					ob_inst_id,
					UINT						field_id,
					POB_DATA					data_node
					);

			// OBSOLETE: use the ob_set_<type>_field() macros instead
			//****************************************************************************
			// Routines/Macros to set local array items
			//***************************************************************************

			PBWINAPI(INT, ot_set_local_array_item)
				(
					POB_THIS					ths,
					OB_SYM_ID					sym_id,
					UINT						index,
					POB_DATA					data_node
					);

			//****************************************************************************
			// Routines/Macros to set shared vars
			//****************************************************************************

			PBWINAPI(INT, ot_set_shared_array_item)
				(
					POB_THIS	   					ths,
					OB_GROUP_HNDL					group_hndl,
					OB_SYM_ID						sym_id,
					UINT		   					index,
					POB_DATA	   					data_node
					);

#define	_shrsetarritm(ths,grp,symid,idx,value,name,type)		  	\
	   		{													  	\
	   		OB_DATA node;										  	\
	   		ob_set_data_##name (&node,value,type,FALSE);		  	\
	   		ot_set_shared_array_item (ths,grp,symid,idx,&node);		\
	   		}

#define	ot_set_shared_int_item(ths,grp,symid,idx,val)						\
			_shrsetarritm(ths,grp,symid,idx,val,int,INT_TYPE)
#define	ot_set_shared_uint_item(ths,grp,symid,idx,val)						\
			_shrsetarritm(ths,grp,symid,idx,val,uint,UINT_TYPE)
#define	ot_set_shared_long_item(ths,grp,symid,idx,val)						\
			_shrsetarritm(ths,grp,symid,idx,val,long,LONG_TYPE)
#define	ot_set_shared_ulong_item(ths,grp,symid,idx,val)						\
			_shrsetarritm(ths,grp,symid,idx,val,ulong,ULONG_TYPE)
#define	ot_set_shared_dec_item(ths,grp,symid,idx,val)						\
			_shrsetarritm(ths,grp,symid,idx,val,ptr,DEC_TYPE)
#define	ot_set_shared_float_item(ths,grp,symid,idx,val)						\
			_shrsetarritm(ths,grp,symid,idx,val,float,FLOAT_TYPE)
#define	ot_set_shared_double_item(ths,grp,symid,idx,val)					\
			_shrsetarritm(ths,grp,symid,idx,_dblcpy(ths,val), ptr,DOUBLE_TYPE)
#define	ot_set_shared_longlong_item(ths,grp,symid,idx,val)					\
			_shrsetarritm(ths,grp,symid,idx,_longlcpy(ths,val), ptr,LONGLONG_TYPE)

#define	ot_set_shared_string_item(ths,grp,symid,idx,val)					\
			_shrsetarritm(ths,grp,symid,idx,val,ptr,STRING_TYPE)
#define	ot_set_shared_bool_item(ths,grp,symid,idx,val)						\
			_shrsetarritm(ths,grp,symid,idx,val,int,BOOL_TYPE)
#define	ot_set_shared_char_item(ths,grp,symid,idx,val)						\
			_shrsetarritm(ths,grp,symid,idx,val,int,CHAR_TYPE)
#define	ot_set_shared_blob_item(ths,grp,symid,idx,val)					\
			_shrsetarritm(ths,grp,symid,idx,val,ptr,BINARY_TYPE)

#define	ot_set_shared_time_item(ths,grp,symid,idx,val)						\
			_shrsetarritm(ths,grp,symid,idx,val,ptr,TIME_TYPE)
#define	ot_set_shared_date_item(ths,grp,symid,idx,val)						\
			_shrsetarritm(ths,grp,symid,idx,val,ptr,DATE_TYPE)
#define	ot_set_shared_datetime_item(ths,grp,symid,idx,val)					\
			_shrsetarritm(ths,grp,symid,idx,val,ptr,DATETIME_TYPE)

#define	ot_set_shared_obinst_item(ths,grp,symid,idx,val,typ)				\
			_shrsetarritm(ths,grp,symid,idx,val,obinst,typ)

#define	ot_set_shared_enum_item(ths,grp,symid,idx,val,typ)					\
			_shrsetarritm(ths,grp,symid,idx,val,int,typ)

			//Old Way
#define	ot_set_shared_binary_item(ths,grp,symid,idx,val)					\
			_shrsetarritm(ths,grp,symid,idx,val,ptr,BINARY_TYPE)


//****************************************************************************
// Routines/Macros to set fields
//****************************************************************************

// NOTE THESE CALLS ARE OBSOLETE: Left for compatibility only.

			PBWINAPI(INT, ot_set_obinst_array_item)
				(
					POB_THIS 				ths,
					OB_INST_ID 				obinst,
					UINT 					field_id,
					ULONG 					index,
					POB_DATA 				new_data
					);

#define	_setfldarritm(ths,instid,fldid,idx,value,name,type)			\
			{													   	\
			OB_DATA node;										   	\
			ob_set_data_##name (&node,value,type,FALSE);		   	\
			ot_set_obinst_array_item (ths,instid,fldid,idx,&node);	\
			}

#define	ot_set_obinst_int_item(ths,instid,fldid,idx,val)				\
	  		_setfldarritm(ths,instid,fldid,idx,val,int,INT_TYPE)
#define	ot_set_obinst_uint_item(ths,instid,fldid,idx,val)				\
			_setfldarritm(ths,instid,fldid,idx,val,uint,UINT_TYPE)
#define	ot_set_obinst_long_item(ths,instid,fldid,idx,val)				\
		 	_setfldarritm(ths,instid,fldid,idx,val,long,LONG_TYPE)
#define	ot_set_obinst_ulong_item(ths,instid,fldid,idx,val)				\
		  	_setfldarritm(ths,instid,fldid,idx,val,ulong,ULONG_TYPE)
#define	ot_set_obinst_dec_item(ths,instid,fldid,idx,val)				\
		  	_setfldarritm(ths,instid,fldid,idx,val,ptr,DEC_TYPE)
#define	ot_set_obinst_float_item(ths,instid,fldid,idx,val)			  	\
		 	_setfldarritm(ths,instid,fldid,idx,val,float,FLOAT_TYPE)
#define	ot_set_obinst_double_item(ths,instid,fldid,idx,val)			 	\
		 	_setfldarritm(ths,instid,fldid,idx,_dblcpy(ths,val), ptr,DOUBLE_TYPE)
#define	ot_set_obinst_longlong_item(ths,instid,fldid,idx,val)			 	\
		 	_setfldarritm(ths,instid,fldid,idx,_longlcpy(ths,val), ptr,LONGLONG_TYPE)

#define	ot_set_obinst_string_item(ths,instid,fldid,idx,val)				\
		 	_setfldarritm(ths,instid,fldid,idx,val,ptr,STRING_TYPE)
#define	ot_set_obinst_bool_item(ths,instid,fldid,idx,val)			 	\
		  	_setfldarritm(ths,instid,fldid,idx,val,int,BOOL_TYPE)
#define	ot_set_obinst_char_item(ths,instid,fldid,idx,val)			 	\
		  	_setfldarritm(ths,instid,fldid,idx,val,int,CHAR_TYPE)
#define	ot_set_obinst_blob_item(ths,instid,fldid,idx,val)			 	\
		  	_setfldarritm(ths,instid,fldid,idx,val,ptr,BINARY_TYPE)

#define	ot_set_obinst_time_item(ths,instid,fldid,idx,val)			  	\
			_setfldarritm(ths,instid,fldid,idx,val,ptr,TIME_TYPE)
#define	ot_set_obinst_date_item(ths,instid,fldid,idx,val)			  	\
			_setfldarritm(ths,instid,fldid,idx,val,ptr,DATE_TYPE)
#define	ot_set_obinst_datetime_item(ths,instid,fldid,idx,val)		 	\
 			_setfldarritm(ths,instid,fldid,idx,val,ptr,DATETIME_TYPE)

#define	ot_set_obinst_obinst_item(ths,instid,fldid,idx,val,typ)		 	\
  			_setfldarritm(ths,instid,fldid,idx,val,obinst,typ)

#define	ot_set_obinst_enum_item(ths,instid,fldid,idx,val,typ)		 	\
  			_setfldarritm(ths,instid,fldid,idx,val,int,typ)

			//Old Way
#define	ot_set_obinst_binary_item(ths,instid,fldid,idx,val)			 	\
		  	_setfldarritm(ths,instid,fldid,idx,val,ptr,BINARY_TYPE)


//****************************************************************************
// Array handling utilities
//****************************************************************************

			PBWINAPI(PVOID, ot_get_array_values)
				(
					POB_THIS					obthis,
					POB_DATA					arraynode,
					PUINT						nitems
					);

			// NOTE: This is a special purpose function that should NOT be used for any new code.
			//       The current users will be changed at some point to do something better.
			PBWINAPI(INT, ot_reset_array)
				(
					POB_THIS                	obthis,
					POB_DATA                	array_node,
					ULONG                    	nitems
					);

			//****************************************************************************
			// Get var prototypes and macros
			//****************************************************************************

			PBWINAPI(POB_DATA, ot_get_local_var)
				(
					POB_THIS  				obthis,
					OB_GROUP_HNDL			grphndl,
					OB_SYM_ID				sym_id
					);

			PBWINAPI(POB_DATA, ot_get_shared_var)
				(
					POB_THIS  				obthis,
					OB_GROUP_HNDL			grphndl,
					OB_SYM_ID				sym_id
					);


			//****************************************************************************
			//	Wrapper for ob_get macros
			//****************************************************************************

#define	ot_get_data_nullval(obthis,node) 				  					\
	ob_get_data_nullval(node)
#define	ot_get_data_typeargs(obthis,node) 				  					\
	ob_get_data_typeargs(node)
#define	ot_get_data_style(obthis,node) 				  						\
	ob_get_data_style(node)

#define	ot_get_data_const(obthis,node) 				  						\
	ob_get_data_const(node)

#define	ot_get_data_int(obthis,node) 				  						\
	ob_get_data_int(node)
#define	ot_get_data_uint(obthis,node)				  						\
	ob_get_data_uint(node)
//**********************************************************
// Begin of the new type BYTE
//**********************************************************
#define	ot_get_data_byte(obthis,node)				  						\
	ob_get_data_byte(node)	
//**********************************************************
// End of the new type BYTE
//**********************************************************
#define	ot_get_data_long(obthis,node)				  						\
	ob_get_data_long(node)
#define	ot_get_data_ulong(obthis,node) 				  						\
	ob_get_data_ulong(node)
#define	ot_get_data_dec(obthis,node) 										\
	((PSH_DEC) ot_get_valptr(obthis, node))
#define	ot_get_data_float(obthis, node) 									\
	ob_get_data_float(node)
#define	ot_get_data_double(obthis,node) 									\
	((ot_get_data_nullval( obthis, node )) ? 0.0 : (*(PDOUBLE) ot_get_valptr(obthis, node)))
#define	ot_get_data_longlong(obthis,node) 									\
	((ot_get_data_nullval( obthis, node )) ? 0 : (*(PLONGLONG) ot_get_valptr(obthis, node)))


#define	ot_get_data_string(obthis,node)										\
	((LPTSTR) ot_get_valptr(obthis, node))
#define	ot_get_data_bool(obthis,node)										\
	((BOOL) ob_get_data_int (node))
#define	ot_get_data_char(obthis,node)										\
	((TCHAR) ob_get_data_int (node))
#define	ot_get_data_blob(obthis,node)										\
	((PSH_BINARY) ob_get_data_ptr(node))
#define	ot_get_data_cursor(obthis,node)										\
	((PRTDB_STATEMENT) ob_get_data_ptr(node))
#define	ot_get_data_proc(obthis,node)										\
	((PRTDB_STATEMENT) ob_get_data_ptr(node))


#define	ot_get_data_time(obthis,node)										\
	((PSH_TIME) ot_get_valptr(obthis, node))
#define	ot_get_data_date(obthis,node)										\
	((PSH_TIME) ot_get_valptr(obthis, node))
#define	ot_get_data_datetime(obthis,node) 									\
	((PSH_TIME)ot_get_valptr(obthis,node))


#define	ot_get_data_obinst(obthis,node)										\
	ob_get_data_obinst (node)
#define	ot_get_data_enum(obthis,node)										\
	ob_get_data_int (node)
#define	ot_get_data_array(obthis,node)										\
	ob_get_data_array (node)


// Old Way
#define	ot_get_data_str(obthis,node)										\
	ot_get_data_string (obthis, node)
#define	ot_get_data_binary(obthis,node)										\
	ot_get_data_blob (obthis, node)


//****************************************************************************
//	Data conversion prototypes and macros
//****************************************************************************

			PBWINAPI(OB_CLASS_ID, ot_math_type_convert)
				(
					OB_CLASS_ID				class_id1,
					OB_CLASS_ID				class_id2
					);

			// These functions convert data without freeing original data

			PBWINAPI(INT, ot_get_int_value)
				(
					POB_THIS		  		obthis,
					POB_DATA		  		data_node
					);

			PBWINAPI(UINT, ot_get_uint_value)
				(
					POB_THIS		  		obthis,
					POB_DATA		  		data_node
					);

			//**********************************************************
			// Begin of the new type BYTE
			//**********************************************************
			PBWINAPI(BYTE, ot_get_byte_value)
				(
					POB_THIS		  		obthis,
					POB_DATA		  		data_node
					);
			//**********************************************************
			// End of the new type BYTE
			//**********************************************************

			PBWINAPI(LONG, ot_get_long_value)
				(
					POB_THIS		  		obthis,
					POB_DATA		  		data_node
					);

			PBWINAPI(ULONG, ot_get_ulong_value)
				(
					POB_THIS		  		obthis,
					POB_DATA		  		data_node
					);

			PBWINAPI(PSH_DEC, ot_get_dec_value)
				(
					POB_THIS		  		obthis,
					POB_DATA		  		data_node
					);

			PBWINAPI(FLOAT, ot_get_float_value)
				(
					POB_THIS		  		obthis,
					POB_DATA		  		data_node
					);

			PBWINAPI(DOUBLE, ot_get_double_value)
				(
					POB_THIS		  		obthis,
					POB_DATA		  		data_node
					);

			PBWINAPI(LONGLONG, ot_get_longlong_value)
				(
					POB_THIS		  		obthis,
					POB_DATA		  		data_node
					);

			PBWINAPI(VOID, ot_free_val_ptr)
				(
					POB_THIS		  		obthis,
					POB_DATA		  		data_node
					);

			PBWINAPI(VOID, ot_free_array)
				(
					POB_THIS		  		obthis,
					POB_DATA		  		data_node
					);

			// These functions convert data while freeing original data
			PBWINAPI(INT, ot_convert_to_int)
				(
					POB_THIS		  		obthis,
					POB_DATA		  		data_node
					);

			PBWINAPI(UINT, ot_convert_to_uint)
				(
					POB_THIS		  		obthis,
					POB_DATA		  		data_node
					);

			//**********************************************************
			// Begin of the new type BYTE
			//**********************************************************
			PBWINAPI(BYTE, ot_convert_to_byte)
				(
					POB_THIS		  		obthis,
					POB_DATA		  		data_node
					);
			//**********************************************************
			// End of the new type BYTE
			//**********************************************************

			PBWINAPI(LONG, ot_convert_to_long)
				(
					POB_THIS		  		obthis,
					POB_DATA		  		data_node
					);

			PBWINAPI(ULONG, ot_convert_to_ulong)
				(
					POB_THIS		  		obthis,
					POB_DATA		  		data_node
					);

			PBWINAPI(PSH_DEC, ot_convert_to_dec)
				(
					POB_THIS		  		obthis,
					POB_DATA		  		data_node
					);

			PBWINAPI(FLOAT, ot_convert_to_float)
				(
					POB_THIS		  		obthis,
					POB_DATA		  		data_node
					);

			PBWINAPI(DOUBLE, ot_convert_to_double)
				(
					POB_THIS		  		obthis,
					POB_DATA		  		data_node
					);

			PBWINAPI(LONGLONG, ot_convert_to_longlong)
				(
					POB_THIS		  		obthis,
					POB_DATA		  		data_node
					);

			PBWINAPI(LPTSTR, ot_ansi_lower)
				(
					POB_THIS		  	obthis,
					LPTSTR		  		string
					);

			PBWINAPI(LPTSTR, ot_ansi_upper)
				(
					POB_THIS		  	obthis,
					LPTSTR		  		string
					);

			PBWINAPI(INT, ot_ansi_strcmp)
				(
					POB_THIS              obthis,
					LPTSTR		          stringOne,
					LPTSTR		          stringTwo
					);

			//****************************************************************************
			// Reference packet style definitions
			//****************************************************************************

			typedef enum
			{
				OT_SIMPLE_REF,
				OT_FIELD_REF,
				OT_FIELD_ITEM_REF
			} OT_REFPAK_STYLE;

			//****************************************************************************
			// Reference packet callback function definitions
			//****************************************************************************

			typedef PBCALLBACK(INT, *OT_FIELDUPDATE_FUNC)
				(
					PRT_THIS		rtthis,
					OB_INST_ID		obinst,
					UINT			field_id,
					ULONG			index
					);

			//****************************************************************************
			// Reference packet data structure definition
			//****************************************************************************

			typedef struct ot_ref_pak_simple_ref_tag
			{
				POB_DATA				lvalue;
			} ot_ref_pak_simple_ref; //simple

			typedef struct ot_ref_pak_field_ref_tag
			{
				OB_INST_ID				obinst;
				UINT					field_id;
				OT_FIELDUPDATE_FUNC		field_update_func;
				ULONG					item_index;
			} ot_ref_pak_field_ref;	//field;

			typedef	union ot_ref_tag_union
			{
				ot_ref_pak_simple_ref	simple;
				ot_ref_pak_field_ref	field;
			} OT_REF_TAG_UNION, FAR* POT_REF_TAG_UNION;



			typedef struct ot_ref_pak
			{
				OT_REFPAK_STYLE		style;
				OB_GROUP_HNDL		group_hndl;
				OB_CLASS_ID			type;
				USHORT				flags;

				OT_REF_TAG_UNION	ref;

			} OT_REF_PAK, FAR* POT_REF_PAK;

			// NOTE: These two routines should be used ONLY by the refpak stuff!!!!
			PBWINAPI(POB_DATA, ot_get_field_lv)
				(
					POB_THIS			obthis,
					OB_INST_ID			obInst,
					UINT		 		fieldId
					);

			PBWINAPI(POB_DATA, ot_get_field_item_lv)
				(
					POB_THIS			obthis,
					OB_INST_ID			obInst,
					UINT		 		fieldId,
					ULONG				item_index
					);


			//****************************************************************************
			// RefPak Access methods
			//****************************************************************************
#define ot_access_ref_data(obthis,refpak)	 					  			\
	(																		\
		(refpak)->style == OT_SIMPLE_REF 						   			\
	 		? (refpak)->ref.simple.lvalue 							   		\
	 		: ((refpak)->style == OT_FIELD_REF								\
	 			? ot_get_field_lv (obthis, (refpak)->ref.field.obinst, (refpak)->ref.field.field_id) \
	 			: ot_get_field_item_lv (obthis, (refpak)->ref.field.obinst, (refpak)->ref.field.field_id, (refpak)->ref.field.item_index) \
	 		  )																\
	)

#define ot_access_ref_nullval(obthis,refpak)						  		\
	ot_get_data_nullval (obthis, ot_access_ref_data(obthis,refpak))

#define ot_access_ref_grouphndl(obthis,refpak)						  		\
	((refpak)->group_hndl)

#define ot_access_ref_type(obthis,refpak)						  			\
	((refpak)->type)

#define ot_access_ref_int(obthis,refpak)						  			\
	ot_get_data_int (obthis, ot_access_ref_data(obthis,refpak))

#define ot_access_ref_uint(obthis,refpak)						  			\
	ot_get_data_uint (obthis, ot_access_ref_data(obthis,refpak))

//**********************************************************
// Begin of the new type BYTE
//**********************************************************
#define ot_access_ref_byte(obthis,refpak)						  			\
	ot_get_data_byte (obthis, ot_access_ref_data(obthis,refpak))
//**********************************************************
// End of the new type BYTE
//**********************************************************

#define ot_access_ref_long(obthis,refpak)						  			\
	ot_get_data_long (obthis, ot_access_ref_data(obthis,refpak))

#define ot_access_ref_ulong(obthis,refpak)						  			\
	ot_get_data_ulong (obthis, ot_access_ref_data(obthis,refpak))

#define ot_access_ref_dec(obthis,refpak)						  			\
	ot_get_data_dec (obthis, ot_access_ref_data(obthis,refpak))

#define ot_access_ref_float(obthis,refpak)						  			\
	ot_get_data_float (obthis, ot_access_ref_data(obthis,refpak))

#define ot_access_ref_double(obthis,refpak)						  			\
	ot_get_data_double (obthis, ot_access_ref_data(obthis,refpak))

#define ot_access_ref_longlong(obthis,refpak)						  			\
	ot_get_data_longlong (obthis, ot_access_ref_data(obthis,refpak))

#define ot_access_ref_string(obthis,refpak)								 	\
	ot_get_data_str (obthis, ot_access_ref_data(obthis,refpak))

#define ot_access_ref_bool(obthis,refpak)									\
	ot_get_data_bool (obthis, ot_access_ref_data(obthis,refpak))

#define ot_access_ref_char(obthis,refpak)									\
	ot_get_data_char (obthis, ot_access_ref_data(obthis,refpak))

#define ot_access_ref_blob(obthis,refpak)									\
	ot_get_data_blob (obthis, ot_access_ref_data(obthis,refpak))

#define ot_access_ref_time(obthis,refpak)									\
	ot_get_data_time (obthis, ot_access_ref_data(obthis,refpak))

#define ot_access_ref_date(obthis,refpak)									\
	ot_get_data_date (obthis, ot_access_ref_data(obthis,refpak))

#define ot_access_ref_datetime(obthis,refpak)							 	\
	ot_get_data_datetime (obthis, ot_access_ref_data(obthis,refpak))

#define ot_access_ref_obinst(obthis,refpak)							 		\
	ot_get_data_obinst (obthis, ot_access_ref_data(obthis,refpak))

#define ot_access_ref_enum(obthis,refpak)									\
	ot_get_data_enum (obthis, ot_access_ref_data(obthis,refpak))

#define ot_access_ref_array(obthis,refpak)									\
	ot_get_data_array (obthis, ot_access_ref_data(obthis,refpak))

#define ot_access_refpak_style(obthis,refpak)								\
	(refpak)->style

//****************************************************************************
// Refpak set methods
//****************************************************************************

			PBWINAPI(VOID, ot_assign_ref_int)
				(
					POB_THIS			obthis,
					POT_REF_PAK 		refpak,
					INT					value,
					BOOL				nullval
					);

			PBWINAPI(VOID, ot_assign_ref_uint)
				(
					POB_THIS			obthis,
					POT_REF_PAK 		refpak,
					UINT  				value,
					BOOL				nullval
					);

			//**********************************************************
			// Begin of the new type BYTE
			//**********************************************************
			PBWINAPI(VOID, ot_assign_ref_byte)
				(
					POB_THIS			obthis,
					POT_REF_PAK 		refpak,
					BYTE 				value,
					BOOL				nullval
					);
			//**********************************************************
			// End of the new type BYTE
			//**********************************************************

			PBWINAPI(VOID, ot_assign_ref_long)
				(
					POB_THIS			obthis,
					POT_REF_PAK 		refpak,
					LONG				value,
					BOOL				nullval
					);

			PBWINAPI(VOID, ot_assign_ref_ulong)
				(
					POB_THIS			obthis,
					POT_REF_PAK 		refpak,
					ULONG				value,
					BOOL				nullval
					);

			PBWINAPI(VOID, ot_assign_ref_dec)
				(
					POB_THIS			obthis,
					POT_REF_PAK 		refpak,
					PSH_DEC				value,
					BOOL				nullval
					);

			PBWINAPI(VOID, ot_assign_ref_float)
				(
					POB_THIS			obthis,
					POT_REF_PAK 		refpak,
					FLOAT				value,
					BOOL				nullval
					);

			PBWINAPI(VOID, ot_assign_ref_double)
				(
					POB_THIS			obthis,
					POT_REF_PAK 		refpak,
					DOUBLE				value,
					BOOL				nullval
					);

			PBWINAPI(VOID, ot_assign_ref_longlong)
				(
					POB_THIS			obthis,
					POT_REF_PAK 		refpak,
					LONGLONG			value,
					BOOL				nullval
					);

			PBWINAPI(VOID, ot_assign_ref_string)
				(
					POB_THIS			obthis,
					POT_REF_PAK 		refpak,
					LPTSTR				value,
					BOOL				nullval
					);

			PBWINAPI(VOID, ot_assign_ref_bool)
				(
					POB_THIS			obthis,
					POT_REF_PAK 		refpak,
					BOOL				value,
					BOOL				nullval
					);

			PBWINAPI(VOID, ot_assign_ref_char)
				(
					POB_THIS			obthis,
					POT_REF_PAK 		refpak,
					TCHAR				value,
					BOOL				nullval
					);

			PBWINAPI(VOID, ot_assign_ref_blob)
				(
					POB_THIS			obthis,
					POT_REF_PAK 		refpak,
					PSH_BINARY			value,
					BOOL				nullval
					);

			PBWINAPI(VOID, ot_assign_ref_time)
				(
					POB_THIS			obthis,
					POT_REF_PAK 		refpak,
					PSH_TIME			value,
					BOOL				nullval
					);

			PBWINAPI(VOID, ot_assign_ref_date)
				(
					POB_THIS			obthis,
					POT_REF_PAK 		refpak,
					PSH_TIME			value,
					BOOL				nullval
					);

			PBWINAPI(VOID, ot_assign_ref_datetime)
				(
					POB_THIS			obthis,
					POT_REF_PAK 		refpak,
					PSH_TIME			value,
					BOOL				nullval
					);

			PBWINAPI(INT, ot_assign_ref_obinst)
				(
					POB_THIS			obthis,
					POT_REF_PAK 		refpak,
					OB_INST_ID			value,
					BOOL				nullval,
					OB_CLASS_ID			type
					);

			PBWINAPI(VOID, ot_assign_ref_enum)
				(
					POB_THIS			obthis,
					POT_REF_PAK 		refpak,
					INT					value,
					BOOL				nullval,
					OB_CLASS_ID			type
					);

			PBWINAPI(VOID, ot_assign_ref_array)
				(
					POB_THIS			obthis,
					POT_REF_PAK 		refpak,
					OB_ARRAY_ID			value,
					BOOL				nullval,
					OB_CLASS_ID			type
					);

			PBWINAPI(VOID, ot_assign_ref_any)
				(
					POB_THIS			obthis,
					POT_REF_PAK 		refpak,
					POB_DATA			rvalue_data,
					OB_CLASS_ID			rhs_class_id
					);

			//****************************************************************************
			// Reference argument utilities
			//****************************************************************************


#define ot_is_a_reference_argument(obthis,pobData)							\
	(ob_get_data_reftype (pobData) == OB_ARGUMENT_REF)

//****************************************************************************
// Reference Argument access methods
//****************************************************************************

#define ot_access_refarg_refpak(obthis,arg)							 		\
	((POT_REF_PAK) ob_get_data_ptr(arg))

#define ot_access_refarg_data(obthis,arg)						  			\
	ot_access_ref_data (obthis, ot_access_refarg_refpak(obthis,arg))

#define ot_access_refarg_nullval(obthis,arg)								\
	ot_access_ref_nullval (obthis, ot_access_refarg_refpak(obthis,arg))

#define ot_access_refarg_grouphndl(obthis,arg)								\
	ot_access_ref_grouphndl (obthis, ot_access_refarg_refpak(obthis,arg))

#define ot_access_refarg_int(obthis,arg)						  			\
	ot_access_ref_int (obthis, ot_access_refarg_refpak(obthis,arg))

#define ot_access_refarg_uint(obthis,arg)						  			\
	ot_access_ref_uint (obthis, ot_access_refarg_refpak(obthis,arg))

//**********************************************************
// Begin of the new type BYTE
//**********************************************************
#define ot_access_refarg_byte(obthis,arg)						  			\
	ot_access_ref_byte (obthis, ot_access_refarg_refpak(obthis,arg))
//**********************************************************
// Begin of the new type BYTE
//**********************************************************

#define ot_access_refarg_long(obthis,arg)						  			\
	ot_access_ref_long (obthis, ot_access_refarg_refpak(obthis,arg))

#define ot_access_refarg_ulong(obthis,arg)						  			\
	ot_access_ref_ulong (obthis, ot_access_refarg_refpak(obthis,arg))

#define ot_access_refarg_dec(obthis,arg)						  			\
	ot_access_ref_dec (obthis, ot_access_refarg_refpak(obthis,arg))

#define ot_access_refarg_float(obthis,arg)						  			\
	ot_access_ref_float (obthis, ot_access_refarg_refpak(obthis,arg))

#define ot_access_refarg_double(obthis,arg)									\
	ot_access_ref_double (obthis, ot_access_refarg_refpak(obthis,arg))

#define ot_access_refarg_longlong(obthis,arg)									\
	ot_access_ref_longlong (obthis, ot_access_refarg_refpak(obthis,arg))

#define ot_access_refarg_string(obthis,arg)								 	\
	ot_access_ref_string (obthis, ot_access_refarg_refpak(obthis,arg))

#define ot_access_refarg_bool(obthis,arg)									\
	ot_access_ref_bool (obthis, ot_access_refarg_refpak(obthis,arg))

#define ot_access_refarg_char(obthis,arg)									\
	ot_access_ref_char (obthis, ot_access_refarg_refpak(obthis,arg))

#define ot_access_refarg_blob(obthis,arg)									\
	ot_access_ref_blob (obthis, ot_access_refarg_refpak(obthis,arg))

#define ot_access_refarg_time(obthis,arg)									\
	ot_access_ref_time (obthis, ot_access_refarg_refpak(obthis,arg))

#define ot_access_refarg_date(obthis,arg)									\
	ot_access_ref_date (obthis, ot_access_refarg_refpak(obthis,arg))

#define ot_access_refarg_datetime(obthis,arg)							 	\
	ot_access_ref_datetime (obthis, ot_access_refarg_refpak(obthis,arg))

#define ot_access_refarg_obinst(obthis,arg)									\
	ot_access_ref_obinst (obthis, ot_access_refarg_refpak(obthis,arg))

#define ot_access_refarg_enum(obthis,arg)									\
	ot_access_ref_enum (obthis, ot_access_refarg_refpak(obthis,arg))

#define ot_access_refarg_array(obthis,arg)									\
	ot_access_ref_array (obthis, ot_access_refarg_refpak(obthis,arg))

#define ot_access_refarg_type(obthis,arg)									\
	ot_access_ref_type(obthis, ot_access_refarg_refpak(obthis,arg))

//****************************************************************************
// Refpak set methods
//****************************************************************************

#define ot_assign_refarg_int(obthis,lvalue,val,nullval)			  			\
	ot_assign_ref_int (obthis, (POT_REF_PAK)ob_get_data_ptr(lvalue), val, nullval)

#define ot_assign_refarg_uint(obthis,lvalue,val,nullval)			 		\
	ot_assign_ref_uint (obthis, (POT_REF_PAK)ob_get_data_ptr(lvalue), val, nullval)

//**********************************************************
// Begin of the new type BYTE
//**********************************************************
#define ot_assign_refarg_byte(obthis,lvalue,val,nullval)			 		\
	ot_assign_ref_byte (obthis, (POT_REF_PAK)ob_get_data_ptr(lvalue), val, nullval)
//**********************************************************
// End of the new type BYTE
//**********************************************************

#define ot_assign_refarg_long(obthis,lvalue,val,nullval)			 		\
	ot_assign_ref_long (obthis, (POT_REF_PAK)ob_get_data_ptr(lvalue), val, nullval)

#define ot_assign_refarg_ulong(obthis,lvalue,val,nullval)			  	 	\
	ot_assign_ref_ulong (obthis, (POT_REF_PAK)ob_get_data_ptr(lvalue), val, nullval)

#define ot_assign_refarg_dec(obthis,lvalue,val,nullval)			  			\
	ot_assign_ref_dec (obthis, (POT_REF_PAK)ob_get_data_ptr(lvalue), val, nullval)

#define ot_assign_refarg_float(obthis,lvalue,val,nullval)			  	 	\
	ot_assign_ref_float (obthis, (POT_REF_PAK)ob_get_data_ptr(lvalue), val, nullval)

#define ot_assign_refarg_double(obthis,lvalue,val,nullval)					\
	ot_assign_ref_double (obthis, (POT_REF_PAK)ob_get_data_ptr(lvalue), val, nullval)

#define ot_assign_refarg_longlong(obthis,lvalue,val,nullval)					\
	ot_assign_ref_longlong (obthis, (POT_REF_PAK)ob_get_data_ptr(lvalue), val, nullval)

#define ot_assign_refarg_string(obthis,lvalue,val,nullval)				 	\
	ot_assign_ref_string (obthis, (POT_REF_PAK)ob_get_data_ptr(lvalue), val, nullval)

#define ot_assign_refarg_bool(obthis,lvalue,val,nullval)				 	\
	ot_assign_ref_bool (obthis, (POT_REF_PAK)ob_get_data_ptr(lvalue), val, nullval)

#define ot_assign_refarg_char(obthis,lvalue,val,nullval)				 	\
	ot_assign_ref_char (obthis, (POT_REF_PAK)ob_get_data_ptr(lvalue), val, nullval)

#define ot_assign_refarg_blob(obthis,lvalue,val,nullval)				 	\
	ot_assign_ref_blob (obthis, (POT_REF_PAK)ob_get_data_ptr(lvalue), val, nullval)

#define ot_assign_refarg_time(obthis,lvalue,val,nullval)				 	\
	ot_assign_ref_time (obthis, (POT_REF_PAK)ob_get_data_ptr(lvalue), val, nullval)

#define ot_assign_refarg_date(obthis,lvalue,val,nullval)				 	\
	ot_assign_ref_date (obthis, (POT_REF_PAK)ob_get_data_ptr(lvalue), val, nullval)

#define ot_assign_refarg_datetime(obthis,lvalue,val,nullval)			  	\
	ot_assign_ref_datetime (obthis, (POT_REF_PAK)ob_get_data_ptr(lvalue), val, nullval)

#define ot_assign_refarg_obinst(obthis,lvalue,val,nullval,type)			 	\
	ot_assign_ref_obinst (obthis, (POT_REF_PAK)ob_get_data_ptr(lvalue), val, nullval, type)

#define ot_assign_refarg_enum(obthis,lvalue,val,nullval,type)			 	\
	ot_assign_ref_enum (obthis, (POT_REF_PAK)ob_get_data_ptr(lvalue), val, nullval, type)

// type is ignored!!
#define ot_assign_refarg_array(obthis,lvalue,val,nullval)		   	\
	ot_assign_ref_array (obthis, (POT_REF_PAK)ob_get_data_ptr(lvalue), val, nullval, NO_TYPE)

#define ot_assign_refarg_any(obthis,lvalue,rvalue,rhs_class_id)	 	\
	ot_assign_ref_any (obthis, (POT_REF_PAK)ob_get_data_ptr(lvalue), rvalue, rhs_class_id )

//****************************************************************************
// Object and enum utilities
//****************************************************************************

#define ot_is_enum(obthis, node)									\
	((ob_get_type_kind(ob_get_data_type(node))!= OB_SIMPLE_TYPE) &&	\
		(ob_get_data_style(node) != PTR_STYLE))

#define ot_is_simple_value(obthis, node)									\
	((ob_get_type_kind(ob_get_data_type(node))== OB_SIMPLE_TYPE))

#define ot_is_object(obthis, node)									\
	((ob_get_type_kind(ob_get_data_type(node))!= OB_SIMPLE_TYPE) &&	\
		(ob_get_data_style(node) == PTR_STYLE))

#define ot_get_curr_obinst(obthis)									\
	(((POB_THIS)(obthis))->curr_obinst)

			PBWINAPI(OB_INST_ID, ot_get_nested_obinst)
				(
					POB_THIS                obthis,
					OB_INST_ID				obinst
					);

			//****************************************************************************
			// Macros
			//****************************************************************************

#define ot_is_lvalue_a_class(obthis,data_node)						 		\
	(ob_get_type_kind (ob_get_data_type (data_node)) != OB_SIMPLE_TYPE &&	\
	 ob_get_data_style (data_node) == PTR_STYLE &&							\
	 ob_get_data_group (data_node) != OB_ARRAY &&							\
	 ob_get_data_reftype (data_node) != OB_ARGUMENT_REF)

#define ot_is_lvalue_class_autoinst(obthis,data_node)						\
	(ob_get_data_insttype (obthis,data_node) == OB_AUTO_INSTANTIATE)

#define ot_is_lvalue_class_manualinst(obthis,data_node)				   		\
	(ob_get_data_insttype (obthis,data_node) == OB_MANUAL_INSTANTIATE)

#define ot_is_lvalue_autoinstantiate(obthis,data_node)					 	\
	(ot_is_lvalue_a_class(obthis,data_node) &&									\
	 ot_is_lvalue_class_autoinst(obthis,data_node))

#define ot_is_lvalue_manualinstantiate(obthis,data_node)				   	\
	(ot_is_lvalue_a_class(obthis,data_node) &&									\
	 ot_is_lvalue_class_manualinst(obthis,data_node))

#define ot_is_array(obthis,data_node)						 		\
	(ob_get_data_group (data_node) == OB_ARRAY)

//
// Array functions
//
			PBWINAPI(PVOID, ot_array_create_bounded)
				(
					POB_THIS		obthis,
					ULONG			num_items,
					OB_CLASS_HNDL	elmtType,
					USHORT			varInfo,
					USHORT			numDim,
					PLONG			boundsArray
					);

			PBWINAPI(PVOID, ot_array_create_unbounded)
				(
					POB_THIS		obthis,
					OB_CLASS_HNDL	elmtType,
					USHORT			varInfo
					);


			PBWINAPI(POB_DATA, ot_array_index)
				(
					POB_THIS		obthis,
					PVOID			array,
					ULONG			index
					);

			PBWINAPI(VOID, ot_array_set_free_data)
				(
					POB_THIS		obthis,
					PVOID			array,
					BOOL			newValue
					);

			PBWINAPI(BOOL, ot_array_free_data)
				(
					POB_THIS		obthis,
					PVOID			array
					);

			PBWINAPI(OB_CLASS_ID, ot_array_class_id)
				(
					POB_THIS		obthis,
					PVOID			array
					);

			PBWINAPI(OB_CLASS_HNDL, ot_array_class_hndl)
				(
					POB_THIS		obthis,
					PVOID			array
					);

			PBWINAPI(USHORT, ot_array_num_dimensions)
				(
					POB_THIS		obthis,
					PVOID			array
					);

			PBWINAPI(ULONG, ot_array_num_items)
				(
					POB_THIS		obthis,
					PVOID			array
					);

			PBWINAPI(BOOL, ot_is_array_unbounded)
				(
					POB_THIS		obthis,
					PVOID			array
					);

			// arraydef functions get compiled array information, not runtime array information.
			PBWINAPI(USHORT, ot_get_arraydef_no_dims)
				(
					POB_THIS		obthis,
					PVOID			arrdef
					);

			PBWINAPI(OB_ARRAY_SYMBOL_STYLE, ot_get_arraydef_style)
				(
					POB_THIS		obthis,
					PVOID			arrdef
					);

			PBWINAPI(PLONG, ot_get_arraydef_bounds)
				(
					POB_THIS		obthis,
					PVOID			arrdef
					);

			PBWINAPI(OB_INFO_FLAGS, ot_get_arraydef_varinfo)
				(
					POB_THIS		obthis,
					PVOID			arrdef
					);

			// Use with bounded arrays
			PBWINAPI(LONG, ot_get_arraydef_upper_bound)
				(
					POB_THIS		obthis,
					PVOID			arrdef,
					LONG			dimension
					);

			// Use with bounded arrays
			PBWINAPI(LONG, ot_get_arraydef_lower_bound)
				(
					POB_THIS		obthis,
					PVOID			arrdef,
					LONG			dimension
					);

			//****************************************************************************
			// Random number stuff to ensure we use the same runtime library for
			// randomize and rand.
			//****************************************************************************
			PBWINAPI(VOID, ot_randomize)
				(
					POB_THIS		obthis,
					UINT			iSeed
					);

			PBWINAPI(LONG, ot_rand)
				(
					POB_THIS		obthis,
					LONG			lLimit
					);

			// this is the same as ob call except it does class indirects
			PBWINAPI(BOOL, ot_class_compare)
				(
					POB_THIS   	  		obthis,
					OB_CLASS_HNDL		classHndl1,
					OB_CLASS_HNDL		classHndl2
					);

			PBWINAPI(INT, ot_assign_global_var_obinst)
				(
					POB_THIS			obthis,
					LPTSTR				szName,
					OB_INST_ID			obInst
					);

			/* - Start - CR289662 - partha --*/
			PBWINAPI(VOID, ot_clear_array_data)
				(
					POB_THIS		obthis,
					PVOID		array,
					BOOL			bArrayShrink
					);
			/* - End - CR289662 - partha --*/

#ifdef __cplusplus
		}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif // OTPUBLIC_H
// DOINC popped back into header 'obclinst.h'
#endif

#ifndef OSTIME_H
// ***** DOINC including ostime.h *****
/*                                                                         */
/* *********************************************************************** */
/*                                                                         */
/*                 Copyright Powersoft Corporation 1991-1994               */
/*                                                                         */
/*       Powersoft Corporation ("Powersoft") claims copyright in this      */
/*     program and documentation as an unpublished work, versions of       */
/*     which were first licensed on the date indicated in the foregoing    */
/*     notice. Claim of copyright does not imply waiver of Powersoft's     */
/*     other rights. See Notice of Proprietary Rights.                     */
/*                                                                         */
/*                 NOTICE OF PROPRIETARY RIGHTS                            */
/*                                                                         */
/*       This program and documentation are confidential trade             */
/*     secrets and the property of Powersoft.  Use, examination,           */
/*     reproduction, copying, disassembly, decompilation, transfer         */
/*     and/or disclosure to others are strictly prohibited except by       */
/*     express written agreement with Powersoft.                           */
/*                                                                         */
/* ----------------------------------------------------------------------- */
/*                                                                         */
/*    Filename :    ostime.h                                               */
/*                                                                         */
/*    Author   :    Jim Kosko                                              */
/*                                                                         */
/*    Purpose  :    Wrapper for time.h, sys\timeb.h                        */
/*                                                                         */
/* *********************************************************************** */

/* *********************************************************************** */
/*  Insure file is not include twice                                       */
/* *********************************************************************** */
#ifndef OSTIME_H
#define OSTIME_H

/* *********************************************************************** */
/*  Includes                                                               */
/* *********************************************************************** */

#include <time.h>

#ifndef OSWINDOW_H
// ***** DOINC including oswindow.h *****
	// DOINC skipping duplicate include
#endif

/* gmoison DILBERT  - Added UNIX  */
#if ( defined ( _MSC_VER) ||defined(PBOS_UNIX))
#include <sys/timeb.h>
#endif

/* *********************************************************************** */
/*  Typedefs                                                               */
/* *********************************************************************** */

		typedef time_t TIME_T, FAR* PTIME_T;
		typedef struct tm TM, FAR* PTM;

#if defined(_MSC_VER) || defined(PBOS_UNIX) || defined(PBOS_MAC)	//rja Dilbert
#if defined(PBOS_NT) || defined(PBOS_MAC)							//rja Dilbert
		typedef struct _timeb TIME_B, FAR* PTIME_B;
#else
		typedef struct timeb TIME_B, FAR* PTIME_B;
#endif 
#endif 
		/* *********************************************************************** */
		/*  Function Prototypes and macros                                         */
		/* *********************************************************************** */

#define osDifftime(timet2,timet1)   difftime(timet2,timet1)
#define osMktime(tmstr)             mktime(tmstr)
#define osTime(pTimet)              time(pTimet)

/* gmoison DILBERT  - Added UNIX  */
#if ( defined ( _MSC_VER) || defined(PBOS_UNIX) || defined(PBOS_MAC) )
#ifdef PBOS_NT
#define osFTime(pTimeb)             _ftime((struct _timeb *) pTimeb)
#elif defined (PBOS_UNIX)
#define osFTime(pTimeb)             ftime((struct _timeb *) pTimeb)
#else
#define osFTime(pTimeb)             _ftime((struct _timeb *) pTimeb)
#endif 
#endif 

#ifdef  PBOS_MAC
#define osLocaltime(timet)          localtime((PTIME_T)timet)
#else
#define osLocaltime(timet)          localtime(timet)
#endif

#endif /* OSTIME_H */

// DOINC popped back into header 'obclinst.h'
#endif

#ifndef PBASSERT_H
// ***** DOINC including pbassert.h *****
	// DOINC skipping duplicate include
#endif

#ifndef OBISESSN_H
// ***** DOINC including obisessn.h *****
//**************************************************************************
//
//                            Copyright 1997 
//                              Sybase Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM SYBASE INC.
//
// ------------------------------------------------------------------------
//
//    Filename :	obisessn.h	
//    Author   :	Jeff Calow
//    Purpose  : 	Interface for an object manager session
//****************************************************************************

#ifndef OBISESSN_H
#define OBISESSN_H

#ifndef PBCOM_H
// ***** DOINC including pbcom.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBTHIS_H
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBQUEUE_H
// ***** DOINC including obqueue.h *****
//**************************************************************************
//
//                            Copyright 1996 
//                              Sybase Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM SYBASE INC.
//
// ------------------------------------------------------------------------
//
//    Filename :	obqueue.h	
//    Author   :	Jeff Calow
//    Purpose  : 	interface for the runtine request queueing mechanism
//****************************************************************************

#ifndef __cplusplus
#error C++ must be used for this header file
#endif

#ifndef OBQUEUE_H
#define OBQUEUE_H

#ifndef GENERATED_CODE_BUILD

#ifndef PBCOM_H
// ***** DOINC including pbcom.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBTHIS_H
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBERROR_H
// ***** DOINC including oberror.h *****
	// DOINC skipping duplicate include
#endif
#ifndef PBASSERT_H
// ***** DOINC including pbassert.h *****
	// DOINC skipping duplicate include
#endif
#ifndef SHSEQNO_H
// ***** DOINC including shseqno.h *****
//**************************************************************************
//
//                            Copyright 1997 
//                              Sybase Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM SYBASE INC.
//
// ------------------------------------------------------------------------
//
//    Filename :	shseqno.h	
//    Author   :	Jeff Calow
//    Purpose  : 	A process level sequence number component (thread safe)
//****************************************************************************
#ifndef SHSEQNO_H
#define SHSEQNO_H

#ifndef OSWINDOW_H
// ***** DOINC including oswindow.h *****
	// DOINC skipping duplicate include
#endif

#define SH_SEQUENCE_NUMBER_INVALID 0

		extern "C" PBWINAPI(ULONG, sh_get_next_sequence_number)();

#endif // SHSEQNO_H
		// DOINC popped back into header 'obqueue.h'
#endif
#ifndef PBGUTIL_H
// ***** DOINC including pbgutil.h *****
//-----------------------------------------------------------------------------
//	pbgutil.h
//
//	PowerBuilder generator facility utility functions.
//
//-----------------------------------------------------------------------------

#ifndef PBGUTIL_H
#define PBGUTIL_H

#ifndef  PBGTYPES_H
// ***** DOINC including pbgtypes.h *****
	// DOINC skipping duplicate include
#endif
#ifndef  PBGRUNIF_H
// ***** DOINC including pbgrunif.h *****
	// DOINC skipping duplicate include
#endif


		extern "C"
		{
			PBWINAPI(PBBOOL, PBUtil_IsEqualPBIID)(PBIIDREF, PBIIDREF);
			PBWINAPI(PBBOOL, PBUtil_IsEqualPBCLSID)(PBCLSIDREF, PBCLSIDREF);
			PBWINAPI(PBRESULT, PBUtil_DescriptionFor)(PBRESULT, PBIString**);
			PBWINAPI(PBRESULT, PBUtil_StringForPBIID)(PBIIDREF, PBIString**);
			PBWINAPI(PBRESULT, PBUtil_StringForPBCLSID)(PBCLSIDREF, PBIString**);

			PBWINAPI(PBRESULT, PBUtil_PBIIDForString)(PBIString* pString, PBIDREF refID);

			PBWINAPI(PBRESULT, PBUtil_PBCLSIDForString)(PBIString*, PBCLSIDREF);
			PBWINAPI(PBRESULT, PBUtil_CopyPBIID)(PBIIDREF, PBIIDREF);
			PBWINAPI(PBRESULT, PBUtil_CopyPBCLSID)(PBCLSIDREF, PBCLSIDREF);

			PBWINAPI(PBRESULT, PBUtil_CreatePBID)(PBIDREF id);

			PBWINAPI(PBRESULT, PBUtil_ReplaceLibraryPathsIn)(
				PBIString* pOriginalLibraryList,
				PBIString* pNewLibraryPath,
				PBIString** ppNewLibraryList);
		};

#endif	//  PBGUTIL_H

		// DOINC popped back into header 'obqueue.h'
#endif

// this class represents a globally unique token for a logical thread of control
// while the execution may cross multiple OS threads, we want the semantics of 
// request execution would be that of nested calls where the thread token
// is the same.  Each asynchronous call would inherit the current token.
#define THREAD_TOKEN_STRING_SIZE 255
		class OB_THREAD_TOKEN
		{
		private:
			// binary copy is expected for this class
			PBID			d_token;

			VOID initialize()
			{
				pbstg_memset(&d_token, 0, sizeof(PBIID));
			};
		public:
			OB_THREAD_TOKEN()
			{
				initialize();
			};

			OB_THREAD_TOKEN(LPTSTR lpstrFromString)
			{
				PBRESULT result;
				PBIString* pPbString;

				initialize();
				result = CreatePBIString(lpstrFromString, &pPbString);
				PB_ASSERT(SUCCEEDED(result));

				result = PBUtil_PBIIDForString(pPbString, d_token);
				PB_ASSERT(SUCCEEDED(result));

				pPbString->Release();
			};

			VOID
				Generate()
				// this will generate a unique token in an OS dependent fashion
			{
				PBUtil_CreatePBID(d_token);
			};

			INT operator== (OB_THREAD_TOKEN& otherToken)
			{
				BOOL	bResult;
				bResult = PBUtil_IsEqualPBIID(d_token, otherToken.d_token);
				return bResult;
			};

			PBRESULT
				ToString(LPTSTR lpstrBuffer, ULONG ulBufferLen)
			{
				PBRESULT	result;
				PBIString* pPbString;

				result = PBUtil_StringForPBIID(d_token, &pPbString);
				if (SUCCEEDED(result))
				{
					ULONG ulStringLen;
					pPbString->GetLength(&ulStringLen);
					if (ulStringLen < ulBufferLen)
					{
						LPTSTR	lpstrString;
						pPbString->GetValue(&lpstrString);
						pbstg_strcpy(lpstrBuffer, lpstrString);
					}
					else
						result = PB_FAIL;
					pPbString->Release();
				}

				return result;
			};
		};
		typedef OB_THREAD_TOKEN FAR* POB_THREAD_TOKEN;

		// this abstract class is used in a Command Pattern as the command interface
		// concrete instances will be added to the object manager runtime queue and 
		// executed in order
		// concrete classes should inhert from this and implement the execute and destructor
		//
		// the thread token is used to determine if a synchronous request represents a nested
		// call and should be executed right away, or queued.
		class OB_REQUEST : public IUnknown
		{
		private:
			LONG				d_refCount;
			ULONG				d_ulSequenceNumber;

		protected:
			POB_THREAD_TOKEN		d_threadToken;

		public:
			OB_REQUEST()
			{
				d_threadToken = new OB_THREAD_TOKEN();
				d_refCount = 0;
				d_ulSequenceNumber = sh_get_next_sequence_number();
			};

			virtual ~OB_REQUEST()
			{
				delete d_threadToken;
			};
			// the virtual destructor ensures the concrete object can be properly cleaned up

			virtual VOID
				SetThreadToken(OB_THREAD_TOKEN& threadToken)
			{
				*d_threadToken = threadToken;
			};
			virtual VOID
				SetThreadToken(LPTSTR lpstrThreadTokenString)
			{
				delete d_threadToken;
				d_threadToken = new OB_THREAD_TOKEN(lpstrThreadTokenString);
			};
			virtual PBRESULT
				GetThreadToken(OB_THREAD_TOKEN& threadToken)
				// this is called when adding a synchronous call to check for 
				// nested calls.
			{
				threadToken = *d_threadToken;
				return (PB_SUCCESS);
			}

			virtual VOID
				SetSequenceNumber(ULONG ulSequenceNumber) { d_ulSequenceNumber = ulSequenceNumber; };
			// this is called when a request is added to a session to indicate a per session 
			// unique identifier for a particular request.  This sequence number is used
			// by the session's WaitForReply() to wait for a reply.  The reply to the request
			// should have the same sequence number as the request.

			virtual ULONG
				GetSequenceNumber() { return d_ulSequenceNumber; };
			// Get the sequence number associated with the request.

			virtual PBRESULT
				Execute(POB_THIS obthis) = 0;
			// this is called when the request should be executed.
			// the obthis context under which the request was queued is passed in
			// OB_SUCCESS is the expected return value if the request succeeded
			// when this call returns, the object manager will no longer reference
			// the memory and ownwership of the object returns to person who called
			// ob_add_request().  If the owner no longer wants the object, it would
			// be appropriate for a delete this; to be the last thing in the routine.

			virtual PBRESULT
				AbortOccured(POB_THIS obthis) = 0;
			// this is called if the execute or cancel request aborted during execution
			// if this call aborts, the object will be deleted by the object manager under
			// the assumption that the internal state of the object is messed up.

			virtual VOID
				Cancel(POB_THIS obthis) = 0;
			// this is called when the request has been cancelled.
			// the obthis context under which the request was queued is passed in
			// the cancel is unconditional

			virtual BOOL
				IsSynchronous() = 0;
			// this is called when the request is being queued to determine its position 
			// in the queue.  Synchronous requests are queued ahead of asynchronous requests.
			// It is assumed that all synchronous request will have ob_wait_for_reply() for them.
			// (this allows pre-initialization such that the reply can arrive before ob_wait_for_reply()
			// has been called.) If this is not the case, ob_no_wait_for_reply() should be called.

			virtual BOOL
				IsLocal() = 0;
			// this is called when the dispatcher is doing a ob_wait_for_reply(). While waiting for a reply, 
			// only local requests are executed. It is also used for 
			// ExecuteSingleRequest() with bOnlyLocal = TRUE. 

			virtual BOOL
				IsReply() = 0;
			// this is called when the request is being queued to determine if it represents a reply request.
			// If a reply is not being waited for with the particular sequence number, then the reply request
			// is deleted.

			virtual VOID
				MarkObjects(POB_THIS obthis) {};
			// this is called to mark the posted function argument objects and arrays

		// overridden methods
		// IUnknown
			STDMETHODIMP			QueryInterface(REFIID riid, LPVOID FAR* ppObj)
			{
				ppObj = NULL; return E_NOINTERFACE;
			};
			STDMETHODIMP_(ULONG)	AddRef(void)
			{
				return InterlockedIncrement(&d_refCount);
			};
			STDMETHODIMP_(ULONG)	Release(void)
			{
				PB_ASSERT(d_refCount > 0); if (InterlockedDecrement(&d_refCount) == 0) delete this; return 0;
			};

		};
		typedef OB_REQUEST FAR* POB_REQUEST;
		typedef POB_REQUEST FAR* PPOB_REQUEST;

		// Local request - When you need a local request. For this type
		// of request you only have to override the Execute method.
		class OB_LOCAL_REQUEST : public OB_REQUEST
		{
		public:
		public:
			// overridden methods (a reply should never be executed)
			// OB_REQUEST
			PBRESULT
				Execute(POB_THIS obthis) = 0;
			PBRESULT
				AbortOccured(POB_THIS obthis) { return PB_FAIL; };
			VOID
				Cancel(POB_THIS obthis) {};
			BOOL
				IsSynchronous() { return TRUE; };
			BOOL
				IsLocal() { return FALSE; };
			// we use request/reply primarily for external stuff
			BOOL
				IsReply() { return FALSE; };
		};

		class OB_REPLY_REQUEST : public OB_REQUEST
		{
		public:
			// overridden methods (a reply should never be executed)
			// OB_REQUEST
			PBRESULT
				Execute(POB_THIS obthis) { PB_ASSERT(FALSE && PBTEXT("Should never execute reply")); return PB_FAIL; };
			PBRESULT
				AbortOccured(POB_THIS obthis) { return PB_FAIL; };
			VOID
				Cancel(POB_THIS obthis) {};
			BOOL
				IsSynchronous() { return TRUE; };
			BOOL
				IsLocal() { return FALSE; };
			// we use request/reply primarily for external stuff
			BOOL
				IsReply() { return TRUE; };
		};


		// these C routines are used to manipulate the request queue
		extern "C" {

			// add a request to the end of the request queue
			// 		ownership of the request temperarily transfers to the object manager
			//		Asynchronous requests should be deleted at the end of the execute() method.
			//		To be a good citizen, synchronous requests should be set up to send a reply
			//		request and call ob_wait_for_reply() to wait for the reply to come.
			//		a delete pRequest; will be done if the request is cancelled or there is no one
			//		waiting for a reply
			PBWINAPI(PBRESULT, ob_add_request)
				(
					POB_THIS		obthis,
					POB_REQUEST		pRequest
					);

			// prepares for a reply to arrive bearing the passed sequence number.
			// this should be called BEFORE a request is sent to allow for the reply
			// to arrive before the send completes.
			PBWINAPI(PBRESULT, ob_prepare_for_reply)
				(
					POB_THIS			obthis,
					ULONG				ulSequenceNumber
					);

			// get the current thread token associated with the session.
			// This token should be passed for remote synchronous calls
			// to enable the proper nested call semantics.
			PBWINAPI(PBRESULT, ob_get_current_thread_token)
				(
					POB_THIS			obthis,
					POB_THREAD_TOKEN	pThreadToken
					);

			// indicates if an external message loop exists
			// that can be used to ensure that requests get executed.
			// Otherwise, if we are not running our message loop,
			// any added requests will get stuck in the queue.
			// NOTE: THIS MUST BE CALLED IN THE THREAD THAT OWNS THE OBTHIS!!!
			PBWINAPI(VOID, ob_set_external_message_loop)
				(
					POB_THIS		obthis,
					BOOL			bExternalMessageLoop
					);

		} // end of extern "C"
#else
		class OB_REQUEST
		{

		};

		typedef OB_REQUEST FAR* POB_REQUEST;
		typedef POB_REQUEST FAR* PPOB_REQUEST;
#endif // GENERATED_CODE_BUILD
#endif // OBQUEUE_H

		// DOINC popped back into header 'obisessn.h'
#endif

// forward declaration
		typedef class OB_REQUEST FAR* POB_REQUEST;
		typedef class OB_OBJECT FAR* POB_OBJECT;
		typedef POB_OBJECT FAR* PPOB_OBJECT;
		class OB_RUNTIME_CLASS;
		typedef OB_RUNTIME_CLASS* POB_RUNTIME_CLASS;

		class OB_ISESSION : public IUnknown
		{
		public:
			virtual
				~OB_ISESSION() {};

			virtual ULONG
				GetSessionId() = 0;
			// returns an Id associated with this session

			virtual BOOL
				IsBusy() = 0;
			// indicates if the session is busy

			virtual HRESULT
				Shutdown() = 0;
			// shutdown the session

			virtual HRESULT
				CreateInstance(LPTSTR lpszClassName, PPOB_OBJECT ppObject) = 0;
			// creates an instance of the passed name and returns it

			virtual HRESULT
				AddRequest(POB_REQUEST theRequest) = 0;
			// adds a request to the sessions request queue.

			virtual HRESULT
				ReplyReceived() = 0;
			// This is used to allow a remote session to be told that a reply
			// has been received for an added request.

			virtual HRESULT
				AddObject(POB_OBJECT pObject) = 0;
			// indicates that an object is being added to the session.
			// the session may ignore this call if it wishes.
			virtual HRESULT
				RemoveObject(POB_OBJECT pObject) = 0;
			// indicates that an object is being removed from the session.
			// the session may ignore this call if it wishes.

			virtual HRESULT
				DestroyRemoteObjs() { return PB_SUCCESS; };
		};
		typedef OB_ISESSION FAR* POB_ISESSION;

		class OB_IREMOTE_REFERENCE : public IUnknown
		{
		public:
			virtual ULONG
				GetObjectId() = 0;
			// returns an id that can be used to find this remote reference again
			virtual void
				SetObjectId(ULONG id) = 0;
			// returns an id that can be used to find this remote reference again
			virtual POB_OBJECT
				GetLocalObject() = 0;
			// returns the local object that this reference refers to
			virtual HRESULT
				DestroyObject() = 0;
			// destroys the object and all references to it.
		};
		typedef OB_IREMOTE_REFERENCE FAR* POB_IREMOTE_REFERENCE;
		typedef POB_IREMOTE_REFERENCE FAR* PPOB_IREMOTE_REFERENCE;

		// Interface class for remote sessions (either across the wire or across processes)
		class OB_IREMOTE_SESSION : public OB_ISESSION
		{
		public:
			virtual VOID
				ReleaseRemoteObjects() = 0;
			// deletes any remote objects created within this remote session

			virtual POB_ISESSION
				GetConnectedSession() = 0;
		};

		typedef OB_IREMOTE_SESSION FAR* POB_IREMOTE_SESSION;
		typedef POB_IREMOTE_SESSION FAR* PPOB_IREMOTE_SESSION;

		typedef class OB_ILOCAL_SESSION FAR* POB_ILOCAL_SESSION;

		typedef enum
		{
			OB_SESSION_ACTIVE,
			OB_SESSION_SHUTTING_DOWN,
			OB_SESSION_SHUTDOWN
		} OB_SESSION_STATE;

		typedef enum
		{
			PB_TYPE,
			JAG_TYPE
		} OB_REMREF_TYPE;

		class OB_ILOCAL_SESSION : public OB_ISESSION
		{
		public:
			virtual
				~OB_ILOCAL_SESSION() {};

			virtual POB_THIS
				GetObthis() = 0;
			// get the obthis associated with the local session

			virtual HRESULT
				Activate() = 0;
			// start up a seperate thread to handle requests making this
			// an active session

			virtual HRESULT
				DeActivate() = 0;

			virtual HRESULT
				GetRemoteReference(POB_OBJECT pLocalObject,
					PPOB_IREMOTE_REFERENCE ppRemoteReference,
					OB_REMREF_TYPE  refType = PB_TYPE) = 0;
			// get a remote reference, given a local object from this session.
			// if one does not yet exist, create a new one.
			// TJCTODO - should this be on POB_OBJECT ???
			// SPK - Added defaulted third argument to allow for a Jaguar
			// remote object to be specified. The only difference is the
			// remote object id holds a pointer to a JagObjectRef struct
			// which must be freed upon object destruction.
			virtual HRESULT
				GetRemoteReference(ULONG objectId,
					PPOB_IREMOTE_REFERENCE ppRemoteReference) = 0;
			// get a remote reference, given an objectId.
			// if the remote reference no longer exists, an error is returned.

			virtual HRESULT
				RemoveRemoteReference(POB_IREMOTE_REFERENCE pRemoteReferenceToRemove) = 0;
			// removes stops managing the passed remote reference

			virtual HRESULT
				PrepareForReply(ULONG ulSequenceNumber) = 0;
			// indicate that we expect a reply to arrive with the passed sequence
			// number
			virtual HRESULT
				WaitForReply(PPOB_REQUEST ppReplyRequest) = 0;
			// wait for a reply to arrive with the passed sequence number.
			// nested requests will be executed while we wait, but
			// no remote requests will be executed.  
			// This will fail with OBJ_E_WAIT_CANCELLED 
			// if CancelAllWaitForReply() is called.

			virtual HRESULT
				CancelAllWaitForReply() = 0;
			// cancels all outstanding WaitForReply()'s

			virtual HRESULT
				GetRemoteSession(POB_ISESSION pConnectedSession, PPOB_IREMOTE_SESSION) = 0;
			// Returns a remote session that signifies the dependancy of the passed connected session.
			virtual HRESULT
				ReleaseRemoteSession(POB_IREMOTE_SESSION	pRemoteSessionToRemove) = 0;

			virtual HRESULT
				AddDependantSession(POB_ILOCAL_SESSION pDependantSession) = 0;

			virtual HRESULT
				ReleaseDependantSession(POB_ILOCAL_SESSION	pDependantSessionToRemove) = 0;

			virtual HRESULT
				DestroyRemoteObjs() = 0;

			virtual OB_SESSION_STATE
				GetSessionState() = 0;

			virtual PBRESULT FindType(LPTSTR pName, POB_RUNTIME_CLASS* pRunClass) = 0;

		};

		// get the local session associated with the passed obthis
		// if one does not yet exist, create one.
		extern "C" PBWINAPI(POB_ILOCAL_SESSION, ob_get_local_session)
			(
				POB_THIS		obthis
				);


#endif // OBISESSN_H
		// DOINC popped back into header 'obclinst.h'
#endif

#ifdef    __cplusplus
	}	// extern "C" {
#endif    /* __cplusplus */

//****************************************************************************
// Runtime vtable description structures
//****************************************************************************

	typedef struct
	{
		USHORT		vtab_index;
		PVOID		function;

	} VTAB_INFO, FAR* PVTAB_INFO;

	typedef PVTAB_INFO FAR* PPVTAB_INFO;

	typedef struct
	{
		OB_CLASS_ID	classId;

		USHORT		numFuncs;
		USHORT		numEvents;
		LONG		funcTableOffset;
		LONG		eventTableOffset;
		LONG		classVtableThunked;
	} VTAB_CLASS_INFO, FAR* PVTAB_CLASS_INFO;

	typedef PVTAB_CLASS_INFO FAR* PPVTAB_CLASS_INFO;

	typedef struct
	{
		PVTAB_INFO			routineInfoTable;
		PVTAB_CLASS_INFO	classInfoTable;
	} VTAB_GROUP_INFO, FAR* PVTAB_GROUP_INFO;

	typedef PVTAB_GROUP_INFO FAR* PPVTAB_GROUP_INFO;
	typedef PBCALLBACK(VOID, *OB_PVTAB_FUNC) (POB_THIS, OB_GROUP_ID, PPVTAB_GROUP_INFO);
	typedef PBCALLBACK(INT, *OB_EVENT_FUNC) (POB_THIS, UINT);
	typedef PBCALLBACK(INT, *OB_FUNC_FUNC) (POB_THIS, UINT);

#if (defined(PBOS_UNIX) || defined(PBOS_MAC))
#define VTABLE_INFO_FUNC PBTEXT("getVtableInfo_")
#define VTABLE_INFO_TRAILER PBTEXT("")
#define VTABLE_INFO_UPPERCASE FALSE

#elif defined(PBWIN32)
	// the 32 bit compiler/linker uses stdcall format
#define VTABLE_INFO_FUNC PBTEXT("_getVtableInfo_")
#define VTABLE_INFO_TRAILER PBTEXT("@12")
#define VTABLE_INFO_UPPERCASE FALSE

#else // !PBWIN32 ==> PBWIN16
	// the 16 bit linker uppercases all exports!!
#define VTABLE_INFO_FUNC PBTEXT("GETVTABLEINFO_")
#define VTABLE_INFO_TRAILER PBTEXT("")
#define VTABLE_INFO_UPPERCASE TRUE

#endif // ! PBWIN32

//****************************************************************************
// Runtime class structures
//****************************************************************************
#ifdef PBOS_UNIX
#ifdef GetClassName
#undef GetClassName
#endif
#endif
	typedef struct ob_runtime_vtable
	{
		OS_CALLC_FUNC		func_ptr;

	} OB_RUNTIME_VTABLE, FAR* POB_RUNTIME_VTABLE;

	typedef struct ob_runtime_shared
	{
		INT					dummy;

	} OB_RUNTIME_SHARED, FAR* POB_RUNTIME_SHARED;

	typedef struct ob_global_refs
	{
		INT					dummy;

	} OB_GLOBAL_REFS, FAR* POB_GLOBAL_REFS;

	typedef class OB_RUNTIME_CLASS FAR* POB_RUNTIME_CLASS;
	typedef POB_RUNTIME_CLASS FAR* PPOB_RUNTIME_CLASS;
	typedef class OB_OBJECT FAR* POB_OBJECT;

	typedef struct ob_prototype FAR* POB_PROTOTYPE;
	typedef struct ob_class_entry* POB_CLASS_ENTRY;

	struct IOB_PsppClass;

	class OB_RUNTIME_CLASS
	{
	private:
		POB_GROUP			d_group;
		OB_CLASS_ID			d_class_id;
		USHORT				d_inherit_level;
		POB_RUNTIME_VTABLE	d_function_vtable;
		POB_RUNTIME_CLASS	d_ancestor;

		LPTSTR				d_lpszClassName;
		ULONG				d_no_fields;

		POB_DATA			d_instance_image;			// Copy of Instance Image from class entry
		TIME_T				d_instance_image_ts;		// Timestamp of last instance image built

		IOB_PsppClass* d_pspp_class;

	private:
		PBRESULT invoke(POB_THIS obthis, POB_OBJECT object, OB_VTABLE_ID vtable_id,
			LPTSTR func_name, OB_ROUT_TYPE rout_type, USHORT numArgs,
			OB_DATA args[], BOOL bConvert, BOOL bDuplicate, POB_DATA pResult);
		PBRESULT invokeAsync(POB_THIS obthis, POB_OBJECT object, OB_VTABLE_ID vtable_id,
			LPTSTR func_name, OB_ROUT_TYPE rout_type, USHORT numArgs,
			OB_DATA args[], BOOL bConvert);

	public:
		static VOID* operator new(size_t size, ppbstg_anchor anchor, OB_SUBPOOL subpool);
		static VOID operator delete(VOID* p);

		OB_RUNTIME_CLASS
		(
			POB_THIS 					obthis,
			POB_GROUP					group,
			OB_CLASS_ID					class_id,
			OB_CLASS_ID					parent_class,
			OB_SUBPOOL					subpool,
			IOB_PsppClass* pspp_class = NULL
		);

		~OB_RUNTIME_CLASS();

	public:
		// Data accessor methods
		POB_GROUP	GetGroup() const;
		OB_CLASS_ID	GetClassID() const;
		LPTSTR		GetClassName() const;

		POB_RUNTIME_VTABLE	GetFunctionVtable() const;

		POB_RUNTIME_CLASS	GetAncestorClass() const;

		USHORT		GetInheritLevel() const;

		ULONG		GetNumFields() const;
		VOID		SetNumFields(ULONG fields);

		POB_DATA 	GetInstanceImage() const;
		VOID		SetInstanceImage(POB_DATA inst_image);

		POB_DATA 	GetInstanceImageField(ULONG fieldId) const;

		TIME_T	 	GetInstanceImageTS() const;
		VOID	 	SetInstanceImageTS(TIME_T t);

		IOB_PsppClass* GetPsppClass() const;
		VOID		 SetPsppClass(IOB_PsppClass* pspp_class);

		INT InputCCodeVtable
		(
			POB_THIS		obthis,
			POB_GROUP		group,
			POB_CLASS_ENTRY	class_entry,
			VTAB_CLASS_INFO	vtab_class_info,
			PVTAB_INFO		routine_info,
			OB_SUBPOOL		subpool
		);

	public: // Invokation Methods

		PBRESULT invoke(POB_THIS obthis, POB_OBJECT object, OB_VTABLE_ID vtableId,
			USHORT numArgs, OB_DATA args[], POB_DATA pResult);
		PBRESULT invoke(POB_THIS obthis, POB_OBJECT object, OB_ROUT_TYPE routType,
			LPTSTR name, USHORT numArgs, OB_DATA args[], POB_DATA pResult);
		PBRESULT invokeAsync(POB_THIS obthis, POB_OBJECT object, OB_VTABLE_ID vtableId,
			USHORT numArgs, OB_DATA args[]);
		PBRESULT invokeAsync(POB_THIS obthis, POB_OBJECT object, OB_ROUT_TYPE routType,
			LPTSTR name, USHORT numArgs, OB_DATA args[]);
	public: // Create Instance of runtime class
		PBRESULT CreateInstance(POB_ILOCAL_SESSION pSession, PPOB_OBJECT pObject);
	};

	inline POB_GROUP	OB_RUNTIME_CLASS::GetGroup() const
	{
		return d_group;
	}

	inline OB_CLASS_ID	OB_RUNTIME_CLASS::GetClassID() const
	{
		return d_class_id;
	}

	inline LPTSTR		OB_RUNTIME_CLASS::GetClassName() const
	{
		return d_lpszClassName;
	}

	inline POB_RUNTIME_VTABLE	OB_RUNTIME_CLASS::GetFunctionVtable() const
	{
		return d_function_vtable;
	}

	inline POB_RUNTIME_CLASS	OB_RUNTIME_CLASS::GetAncestorClass() const
	{
		return d_ancestor;
	}

	inline USHORT		OB_RUNTIME_CLASS::GetInheritLevel() const
	{
		return d_inherit_level;
	}

	inline ULONG	OB_RUNTIME_CLASS::GetNumFields() const
	{
		return d_no_fields;
	}

	inline VOID		OB_RUNTIME_CLASS::SetNumFields(ULONG fields)
	{
		d_no_fields = fields;
	};

	inline POB_DATA OB_RUNTIME_CLASS::GetInstanceImage() const
	{
		return d_instance_image;
	};

	inline VOID		OB_RUNTIME_CLASS::SetInstanceImage(POB_DATA inst_image)
	{
		d_instance_image = inst_image;
	};

	inline TIME_T	OB_RUNTIME_CLASS::GetInstanceImageTS() const
	{
		return d_instance_image_ts;
	};

	inline VOID	 	OB_RUNTIME_CLASS::SetInstanceImageTS(TIME_T t)
	{
		d_instance_image_ts = t;
	};

	inline POB_DATA	OB_RUNTIME_CLASS::GetInstanceImageField(ULONG fieldId) const
	{
		PB_ASSERT(fieldId <= d_no_fields);
		PB_ASSERT(d_instance_image != NULL);

		return d_instance_image + fieldId;
	}

	inline IOB_PsppClass* OB_RUNTIME_CLASS::GetPsppClass() const
	{
		return d_pspp_class;
	}

	inline VOID	OB_RUNTIME_CLASS::SetPsppClass(IOB_PsppClass* pspp_class)
	{
		d_pspp_class = pspp_class;
	}

	//****************************************************************************
	// OB_CLASS - Currently this is actually just a OB_RUNTIME_CLASS but we want
	// to change this in the future so that it encapsulates all of the functionality
	// of an OB_RUNTIME_CLASS and an OB_CLASS_ENTRY.
	//****************************************************************************

#define OB_CLASS	OB_RUNTIME_CLASS
#define POB_CLASS	POB_RUNTIME_CLASS

#define GROUP_NAME_LEN	3 * 41

#define ob_get_classinst_group(obthis,classinst)				\
				(((POB_RUNTIME_CLASS)(classinst))->GetGroup())

#define ob_get_classinst_class(obthis,classinst)				\
				(((POB_RUNTIME_CLASS)(classinst))->GetClassID())

#define ob_get_classinst_class_name(obthis,classinst)			\
				(((POB_RUNTIME_CLASS)(classinst))->GetClassName())

#define ob_get_classinst_no_fields(obthis,classinst)				\
				(((POB_RUNTIME_CLASS)(classinst))->GetNumFields())

#define ob_is_autoinstantiate_by_id(obthis, group, class_id) 		\
	( (ob_get_type_kind (class_id) == OB_USER_TYPE ||				\
		ob_get_type_kind (class_id) == OB_SYSTEM_TYPE) &&			\
		!ob_is_type_enum (obthis, group, class_id) &&				\
		ob_is_class_autoinstantiate (obthis, 						\
			ob_class_entry (obthis, &group, &class_id))				\
	)

	extern "C" VOID rtDataInfo(POB_THIS obThis, POB_DATA pobdVal, OB_GROUP_ID obGroupIdCaller,
		POB_GROUP_ID pobGroupId, POB_CLASS_ID pobClassId, POB_GROUPTYPE pobGroupType);

#endif // OBTYPDEF_H
	// DOINC popped back into header 'obclass.h'
#endif

//****************************************************************************
// Member access check type
//****************************************************************************

	typedef enum
	{
		IGNORE_ACCESS_CHECK,
		LOCAL_CLASS_ACCESS_CHECK,
		ANC_CLASS_ACCESS_CHECK,
		FOREIGN_CLASS_ACCESS_CHECK

	}	OB_MEMBER_ACCESS_TYPE, FAR* POB_MEMBER_ACCESS_TYPE;

	//****************************************************************************
	// Function prototypes
	//****************************************************************************


#ifdef    __cplusplus
	extern "C" {
#endif    /* __cplusplus */

		PBWINAPI(INT, ob_class_indirect)
			(
				POB_THIS 					obthis,
				POB_GROUP FAR* group,
				POB_CLASS_ID 				class_id
				);

		BOOL 									ob_is_class_of_class
		(
			POB_THIS 					obthis,
			POB_GROUP 					group,
			OB_CLASS_ID 				class_id,
			POB_GROUP 					of_group,
			OB_CLASS_ID 				of_class_id
		);

#define EXTREF_NO_ERROR				0
#define EXTREF_BAD_GROUP			1
#define EXTREF_MISSING_CLASS		2
#define EXTREF_CONPOOL_FILLED		3

		PBWINAPI(OB_CLASS_ID, ob_add_external_class_ref)
			(
				POB_THIS 					obthis,
				LPTSTR 						name,
				POB_GROUP 					local_group,
				OB_GROUP_ID					ext_group_id,
				OB_CLASS_ID 				ext_class_id,
				OB_GLOB_REFSTYLE 			refstyle,
				PINT							error
				);

		PBWINAPI(OB_CLASS_ID, ob_get_local_class)
			(
				POB_THIS 					obthis,
				POB_GROUP 					group,
				LPTSTR 						name,
				OB_GLOB_REFSTYLE 			refstyle,
				PINT							error
				);

		PBWINAPI(OB_CLASS_ID, ob_get_primary_class)
			(
				POB_THIS 					obthis,
				POB_GROUP FAR* group,
				OB_CLASS_ID 				class_id
				);

#define ob_is_global_ref(obthis,group,class_id)									\
	(ob_looksym_reftype (ob_get_group_type_symtab (obthis, group), 						\
								ob_get_type_id (class_id)) == OB_GLOBAL_REF)

		PBWINAPI(LPTSTR, ob_build_qual_sec_class_name)
			(
				POB_THIS 					obthis,
				LPTSTR 						primary_class_name,
				LPTSTR 						sec_class_name
				);

		PBWINAPI(OB_CLASS_ID, ob_decl_indirect_sec_class)
			(
				POB_THIS 					obthis,
				POB_GROUP 					target_group,
				LPTSTR 						prim_class_name,
				LPTSTR 						sec_class_name,
				PINT			  			error
				);

		OB_CLASS_ID 						ob_decl_ancestor_class
		(
			POB_THIS 					obthis,
			OB_GROUP_ID					ext_group_id,
			OB_CLASS_ID					ext_class_id,
			POB_GROUP 					target_group,
			PINT				  		error
		);

		PBWINAPI(VOID, ob_update_class_ref)
			(
				POB_THIS		  			obthis,
				POB_GROUP					group,
				OB_CLASS_ID					class_id,
				OB_GLOB_REFSTYLE			refstyle,
				BOOL			  			is_prim_parent
				);

		PBWINAPI(VOID, ob_update_glob_class_instflag)
			(
				POB_THIS		  			obthis,
				POB_GROUP					group,
				OB_CLASS_ID					class_id,
				BOOL			  			is_instance
				);

		PBWINAPI(BOOL, ob_is_class_member_accessable)
			(
				POB_THIS		  			obthis,
				OB_MEMBER_ACCESS			member_access,
				OB_MEMBER_ACCESS_TYPE		access_check_type,
				UINT						inheritance_level,
				BOOL						in_system_routine
				);

		INT 								ob_check_conflicting_ancestry
		(
			POB_THIS					obthis,
			POB_GROUP					group,
			OB_CLASS_ID					class_id
		);

		PBWINAPI(POB_RUNTIME_CLASS, ob_get_system_func_class)
			(
				POB_THIS 			obthis
				);

		PBWINAPI(POB_RUNTIME_CLASS, ob_get_global_func_class)
			(
				POB_THIS 			obthis,
				POB_GROUP			pGroup,
				OB_CLASS_ID			classId,
				OB_MODULE_ID		module_id
				);

#ifdef    __cplusplus
	}	// extern "C" {
#endif    /* __cplusplus */

#endif // OBCLASS_H

// DOINC popped back into header 'obtypdef.h'
#endif
#ifndef OBVERS_H
// ***** DOINC including obvers.h *****
//___________________________________________________________________________
//
//                           Copyright ?1989 - 2003
//                      Sybase, Inc. and its subsidiaries.
//  -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -
//  Sybase, Inc.("Sybase") claims copyright in this program and documentation
//  as an unpublished work, versions of which were first licensed on the date
//  indicated in the foregoing notice. This claim of copyright does not imply
//  waiver of Sybase's other rights.
//  -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -
//                      *  Notice of Proprietary Rights  *
//  This program  and documentation  are confidential  trade secrets  and the
//  property of Sybase.  Use, examination, reproduction, copying, disassembly,
//  decompilation, or transfer or disclosure to others is strictly prohibited
//  except by express written agreement with Sybase.
/*____________ ______________________________________________________________
//            '
//  File Name : obvers.h
//
//  Author    : VM Engineering Team
//
//  Purpose   : Definitions for PB object structure versions
//____________.______________________________________________________________
*/

#if !defined ( OBVERS_H )
#define OBVERS_H


//****************************************************************************
// Current Group Version Numbers
//****************************************************************************

// Major Version 0: PB Release 0.0
//      Minor Version 3: Fix OB_DATA status & reftype fields
//      Minor Version 4: Add has_instvar/proto_block flags.
//      Minor Version 5: Add filler byte to array vector.
//      Release 1.0
//              Minor Version 6: Add has_fwdproto flag.
//      Minor Version 7: Add has_typedef_source flag
//      Minor Version 8: Add event_token to TYPEEVENT struct.

// Major Version 1: Create separate group header structure
//      Minor Version 1: Add reference args to complex structure
//              Minor Version 2: Replace typefield structure with lookup table
//              Minor Version 3: Shrink permanent looksym structure. Add arrdef field
//                                                              to OB_FUNC_ARG
//      Minor Version 4: Add name field to OB_FUNC_ARG. Eliminate type and
//                                                              arglist fields from OB_ROUT_NODE.
//      Minor Version 5: Force migrate because of system typedef changes.
//      Minor Version 6: Force a migrate for release candidate 1.
//      Minor Version 7: New events added to master list.
// Release 2.0

// Major Version 2: Convert expressions to pcode
//      Minor Version 1: Add virtual function table to permanent class info
//      Minor Version 2: Force a migrate because of system typedef changes.
//      Minor Version 3: Force a migrate for assignment changes
//      Minor Version 4: Virtual function table contains indirections
//      Minor Version 5: Eliminate unnecessary virtual function tables
//                                                TYP_INHERITED classids stored instead of name constrefs
//      Minor Version 6: Force a migrate to eliminate bad virt tables.
//      Minor Version 7: Force a migrate to resync semantic codes.
//      Minor Version 8: Force a migrate to resync system functions.
//      Minor Version 9: Add Object type and Auto instantiation flags to POBDATA
//      Minor Version 10: Force a migrate to resync system functions.
//      Minor Version 11: Force a migrate to pick up C8.0 date/time format
//      Minor Version 12: Force a migrate to resync system functions.
//      Minor Version 13: Force a migrate to resync system functions.
//      Minor Version 14: Force a migrate to resync system functions.
//      Minor Version 15: Force a migrate to resync system functions.
//      Minor Version 16: Force a migrate to resync system functions.
//      Minor Version 17: Force a migrate to resync system functions.
// Release 3.0

//      Minor Version 18: Change location of functype in a mod_symtab.
//      Minor Version 19: Force a migrate to resync system functions

// Major Version 3: Introduce threaded pcode
//  Minor Version 1:  Add conpool mapping table
//  Minor Version 2:  Add indirect attribute function templates
//  Minor Version 3:  Convert to LONG constant refs and array indexes
//  Minor Version 4:  Force a migrate to resync
//  Minor Version 5:  Add instance image structure
//      Minor Version 6:  Add OB_INHERITED_REF attr to type_symtab.
//  Minor Version 7:  Force a migrate to resync system classes
//  Minor Version 8:  Make all dot function pcode structured the same way.
//  Minor Version 9:  Force a migrate to resync system classes.
//  Minor Version 10:  Force a migrate after renaming system functions.
//  Minor Version 11:  Force a migrate to finish renaming system functions.
//  Minor Version 12:  Force a migrate to fix incorrect compiler pcode
//                                              stream on embedded SQL
//  Minor Version 13:  Force a migrate because permanent event script info
//                                              now contains class_id
//  Minor Version 14:  Compress event virtual table and change size of function
//                                              virtual table.
//  Minor Version 15:   Change function vtables.
//  Minor Version 16:   Generated incorrect pcodes, fix required migrate.
//  Minor Version 17:   Add padding to many structures for SPARC compatibility
//  Minor Version 18:   typdef.scr changes
//  Minor Version 19:   typdef.scr changes
//  Minor Version 20:   typdef.scr changes
//  Minor Version 21:   typdef.scr changes for *WithParm functions to readonly
//  Minor Version 22:   typdef.scr changes; dwObject and rteObject types added
//  Minor Version 23:   Change OB_INST_ID to a pointer
//  Minor Version 24:   Change arrays to pointers
//  Minor Version 25:   Change OB_DATA structure
//  Minor Version 29:   Temp to force migrate for vtable changes
//  Minor Version 30:   Changed lexer format for floating point values, now all double.
//  Minor Version 31:   Added fast event lookup table for RTF to class_entry
//  Minor Version 32:   Changed size of prototype, added flag bits.
//  Minor Version 33:   typdef.scr changes
//  Minor Version 34:   typdef.scr changes
//  Minor Version 35:   typdef.scr changes
//  Minor Version 36:   typdef.scr changes
//  Minor Version 37:   Remove Complex Table
//  Minor Version 38:   typdef.scr changes
//  Minor Version 39:   typdef.scr changes
//  Minor Version 40:   typdef.scr changes
//  Minor Version 41:   typdef.scr changes
//  Minor Version 42:   Add no_system_fields to class entry
//  Minor Version 43:   Added access rights to field info flags
//  Minor Version 44:   Changed pcode structure for event call
//  Minor Version 45:   Being Paranoid
//  Minor Version 46:   Changed array structure to allow transfer between 16/32 bit
//  Minor Version 47:   Added GetParent() to typdef.scr
//  Minor Version 48:   typdef.scr changes
//  Minor Version 49:   compiler adds new constant pool
//  Minor Version 50:   typdef.scr changes
//  Minor Version 51:   typdef.scr changes
//  Minor Version 52:   SQL changes
//  Minor Version 53:   typdef.scr changes
//  Minor Version 54:   typdef.scr changes
//  Minor Version 55:   typdef.scr changes
//  Minor Version 56:   typdef.scr and DataWindow changes
//  Minor Version 57:   typdef.scr changes
//  Minor Version 58:   changed intrinsic p-codes
//  Minor Version 59:   typdef.scr changes
//  Minor Version 60:   typdef.scr changes
//  Minor Version 61:   typdef.scr changes
//  Minor Version 62:   typdef.scr changes
//  Minor Version 63:   typdef.scr changes
//  Minor Version 64:   Add copy flag to conv_any_to_type semantics
//  Minor Version 65:   Add flags to IS_NUMBER, IS_DATE, IS_TIME semantics
//  Minor Version 66:   typdef.scr changes
//  Minor Version 67:   typdef.scr changes
//  Minor Version 68:   typdef.scr changes
//  Minor Version 69:   Removed copy flag from conv_any_to_type semantics
//  Minor Version 70:   typdef.scr changes
//  Minor Version 71:   data window structure changes
//  Minor Version 72:   data window structure changes
//  Minor Version 73:   typdef.scr changes
//  Minor Version 74:   typdef.scr changes
//  Minor Version 75:   embedded sql support changes
//  Minor Version 76:   data window structure changes
//  Minor Version 77:   typdef.scr changes
//  Minor Version 78:   force migrate for release candidate 2
//  Minor Version 79:   force migrate production candidate 1
//  Minor Version 80:   typdef.scr changes
//  Minor Version 81:
//  Minor Version 82:   object manager structure changes
//  Minor Version 83:   typdef.scr changes
//  Minor Version 84:   typdef.scr changes
//  Minor Version 85:   typdef.scr changes for metaclass
//  Minor Version 87    typdef.scr changes for OLE, Context Feature, Registry funcs
//  Minor Version 89:   Added signatures to script prototypes
//  Minor Version 90:   RowChanging Event
//  Minor Version 91:   PluginContextKeyword removed from typdef
//  Minor Version 94:   ContextInformation added to typdef
//  Minor Version 95:   Restructure of typedefinition inheritance typdef
//  Minor Version 96:   added InternetResult to typdef
//  Minor Version 97:   remove function return type of powerobject
//  Minor Version 98:   scriptdef and classdefinition additions
//  Minor Version 99:   classdef, scriptdef, variabledef, & variablecardinalitydef all "def"s now "definition"
//  Minor Version 100:  Change int argument to long.
//  Minor Version 101:  Remove unnecessary 3rd argument
//  Minor Version 102:  Don't call non-existent super
//  Minor Version 103:  GroupBox event changes, Pointer additions, CreatePage, PageCreated
//  Minor Version 104:  dw internal sizes changed, force migrate to rebuild datawindows
//  Minor Version 105:  updating FontCharSet, SingleLineEdit, EditMask, and MultiLineEdit
//  Minor Version 106:  dw internal sizes changed, force migrate to rebuild datawindows
//  Minor Version 107:  typdef.scr changes, new enum dwConflictResolution
//  Minor Version 108:  Change for Beta4
//  Minor Version 109:  ???
//  Minor Version 110:  Added CharSet and change to Environment
//  Minor Version 111:  Changed FontCharSet defaults, DDE functions added to Window, hwnd changed to __hwnd
//  Minor Version 112:  Added field to ContextKeyword Service Object
//  Minor Version 113:  Added new enumerated type: SizeMode
//  Minor Version 114:  Update Object enumerated type
//  Minor Version 115:  Update ttbl_struct in \dw\dwblk.h
//  Minor Version 116:  Add new display type and sizemode field to omEmbeddedControl class
//  Minor Version 117:  Added new Trackbar class and supporting datatypes
//  Minor Version 118:  Added new VTrackbar class and supporting datatypes
//  Minor Version 119:  Removed obsolete DW functions (changes vtable id's)
//  Minor Version 120:  Restore obsolete DW functions (changes vtable id's)
//  Minor Version 121:  Add ProgressBar class
//  Minor Version 122:  Added new DW DW Sync functions
//  Minor Version 123:  Added new horizontal and vertical progressbar classes
//  Minor Version 124:  Added new horizonHyperLink and PictureHyperLink classes
//  Minor Version 125:  Added CORBAObject and CORBAUnion classes for Jaguar
//  Minor Version 126:  typdef.scr change, new overloads for GetFileOpen/SaveName
//  Minor Version 127:  typdef.scr change, added TransactionServer context service object
//  Minor Version 128:  typdef.scr change, added ErrorLogging service object
//  Minor Version 129:  Redo PictureHyperLink to derive from Picture not PictureButton
//  Minor Version 130:  typdef.scr change, added ResultSet class
//  Minor Version 131:  typdef.scr change, added ResultSets, ADOResultSet and removed DS function
//  Minor Version 132:  typdef.scr change, modified TreeView, ListView, StaticText, Window, DrawObject, and Menu
//  Minor Version 133:  typdef.scr change, added OleTxnObject class derived from OleObject. Added IsAlive() to OleObject
//  Minor Version 134:  dwblk.h change, added storage of HTML generation properties
//  Minor Version 135:  dwblk.h change, changed storage of HTML generation properties
//                      typdef.scr change, added SetHTMLAction() to DataStore and DataWindow
//  Minor Version 136:  Modified Connection & TransactionServer object.
//                      Added ORB, JaguarORB, SSLServiceProvider, and SSLCallback objects
//  Minor Version 137:  Added standard event Help to Window and DragObject
//  Minor Version 138:  dwblk.h change, added new HTML generation properties
//  Minor Version 139:  dwblk.h change, even more HTML generation properties
//  Minor Version 140:  typdef.scr change, added new property to ResultSet class and 7.0 Beta3
//  Minor Version 141:  typdef.scr change, changed events for horizontal and vertical progressbar
//  Minor Version 142:  typdef.scr change, changed pipeline and added GetLibraryList system function
//  Minor Version 143:  dwblk.h change, added ValueIsHtml property to text, column and compute.
//  Minor Version 144:  fix for byte compatibility of the descriptor stuff. Byte swapping was wrong.
//  Minor Version 145:  fix for properties not being deleted on migration
//  Minor Version 146:  fix for result sets not getting destroyed.
//  Minor Version 147:  Added CORBACurrent Object
//  Minor Version 148:  Modified the Service object to support a protected ErrorCode
//  Minor Version 149:  Added CharSetDBCS to CharSet enumerated type in typdef.scr
//  Minor Version 150:  Modified TransactionServer object
//  Minor Version 151:  Added CORBACurrent Object Init functions
//  Minor Version 152:  Added stuff for Maui enhancements
//                       - bunch of new functions, some new properties and new additions to LineStyle
//  Minor Version 153:  Changed dll names from 75 to 80.
//  Minor Version 154:  Bumped due to compiler and runtime enchancements for Exception handling
//  Minor Version 155:  Some cleanup for the new maui properties and functions
//  Minor Version 156:  Added throws data to prototypes for exception handling
//  Minor Version 157:  Added arcTan, arcSin and arcCos functions
//  Minor Version 158:  Added DataWindow properies for HTML Generation HTMLGen.ResourceBase,
//                      HTMLGen.CommonJSFile, HTMLGen.DateJSFile, HTMLGen.NumberJSFile, HTMLGen.StringJSFile
//  Minor Version 159:  dwblk.h change, added AppendedHtml (TeamSybase user exit) property to
//                      bitmap, column, compute, and text.
//  Minor Version 160:  Added HTMLGen.UserJSFile
//  Minor Version 161:  Added Application object FreeDBLibraries
//  Minor Version 162:  Added event "SaveObject()" to omEmbeddedControl
//  Minor Version 163:  Added HTMLGen.NetscapeLayers
//  Minor Version 164:  CR 225107 Force Migration of PB 8.0 Beta 1 apps for Beta 3
//  Minor Version 165:  CR 211239 Fixed / Modified CORBAUnion
//  Minor Version 166:  CR 235330 Added DataWindow.HTMLGen.TabIndexBase & CR 235193 Overload Lookup() on the Connection object
//  Minor Version 167:  dwblk.h change, added storage of XML generation properties
//  Minor Version 168:  dwblk.h change, revamped storage of XML properties using Export Template class hierarchy
//  Minor Version 169:  CR 264301 - Changed PB DLL suffix to 90
//  Minor Version 170:  Added fields to struct_ttbl
//  Minor Version 171:  Added xml! to enum SaveAsType
//  Minor Version 172:  Expanded DW XML Template object w/Comment,PublicId,SystemId,InternalSubset
//  Minor Version 173:  Added MetaDataType and SaveMetaData enumerations
//  Minor Version 174:  Added printername field to dw.print structure
//  Minor Version 175:  Added new powerscript keyword: LONGLONG.
//  Minor Version 176:  Added PBNativeException.
//  Minor Version 177:  Change PBNativeException to PBXRuntimeError.
//  Minor Version 178:  Expanded DW XML Template object w/Encoding
//  Minor Version 179:  Added two new added powerscript function: fnlonglong() & fnlonglong2()
//  Minor Version 180:  Added three prototypes for MessageBox() to deal with longlong type lose data problem.
//  Minor Version 181:  Added DataWindow.Import.XML properties
//  Minor Version 182:  Added DataWindow.Export.XML.HeadGroups property
//  Minor Version 183:  Added DataWindow.Import.XML.Trace and TraceFile properties
//  Minor Version 184:  Expose more options in GetFileOpenName and GetFileSaveName
//  Minor Version 185:  Revert change for 184
//  Minor Version 186:  Expose more options in GetFileOpenName and GetFileSaveName
//  Minor Version 187:  Added DataWindow.Export.XML.IncludeWhitespace property
//  Minor Version 188:  Expanded DW XML Template object w/Options
//  Minor Version 189:  Added system type enum ValSchemeType and Powerscript XMLParseFile() and XMLParseString() functions
//  Minor Version 190:  Added DW Export.PDF.Method property and enum
//  Minor Version 191:  CR293109 Added DW HTMLGen.EncodeSelfLinkArgs property
//  Minor Version 192:  Added DW Export.PDF.Distill.CustomPostScript and Export.PDF.XSLFOP.Print properties
//  Minor Version 193:  Added Active Accessibility objects
//  Minor Version 194:  Added XML Web DataWindow properties
//  Minor Version 195:  Changed PB DLL suffix to 100
//  Minor Version 196:  Adjust datawindow structure and other related data structure to meet the byte alignment request in UNIX.
//  Minor Version 197: CR304251 for isnull and upperbound mem leak. Update op1 or op2 for isnull and upperbound lowerbound.
//  Minor Version 198:  Add Accessibility fields to the DataWindow graphic objects for Section 508 compliance
//  Minor Version 199:  Add New optional parameter (to manipulate Newline character) for dw SaveAsAscii function.
//  Minor Version 200:  Add New property "PlotNullData" for Graph Object type.
//  Minor Version 201:  Added the Encoding enum for string and file operation
//  Minor Version 202:  Changed winGob structure for DataWindow Accessibility
//  Minor Version 203:  Removed several obselete file formats from enumerated SaveAsType
//  Minor Version 204:  Changed DataWindow Accessibility properties to expressions
//  Minor Version 205:  Removed wmf! from the enum SaveAsType
//  Minor Version 206:  Added ARM! to the enum cpuTypes, and WindowsCE! to the enum osTypes
//  Minot Version 207:  Added three new system functions, two overloaded of FileSeek64 and FileLength64.
//  Minot Version 208:  Added FromUTF8/ToUTF8 and String(Blob,encoding)/Blob(string,encoding)
//  Minot Version 209:  Added AscW/CharW
//  Minor Version 210:  Added DataWindow.Export.XHTML template properties for XML Web DW customization
//  Minor Version 211:  Added BlobEdit Encoding parameter
//  Minor Version 212:  Added void accessible pointer to datawindow
//  Minor Version 213:  The struct of typeDW got changed
//  Minor Version 214:  Added functions to the DataWindow and DateStore classes.
//  Minor Version 215:  Changed accessibility properties from class graphic object to drag object
//  Minor Version 216:  Revert major version back from 10 to 3
//  Minor Version 217:  Change AscW/CharW to AscA/CharA, add overload parameter for FileRead
//  Minor Version 218:  Added XML Web DataWindow property CSSGen.SessionSpecific (requested by TeamSybase)
//  Minor Version 219:  MonthCalendar control
//  Minor Version 220:  Animation control
//  Minor Version 221:  Add FileReadEx/FileWriteEx
//  Minor Version 222:  Add some reserved fields to some DataWindow structures
//  Minor Version 223:  InkEdit and InkPicture controls
//  Minor Version 224:  reserve two pcodes for selectclob and updateclob.
//  Minor Version 225:  remove draw function from Animation control.
//  Minor Version 226:  Change Animation function's prototypes
//  Minor Version 227:  Changes to MonthCalendar
//  Minor Version 228:  Added a couple of SaveAsXXX functions to DataWindow and DataStore
//  Minor Version 229:  Change animation control's function prototype just because uint can not take -1.
//  Minor Version 230:  Print enhancement: Add structure PrintDlgInfo, and function PrintDlg()
//  Minor Version 231:  Print enhancement: Enhance PrintOpen(), DW.Print(), DS.Print(), RTE.Print() to consume PrintDlgInfo
//  Minor Version 232:  Added enums for Ink controls, Notify event for TreeView
//  Minor Version 233:  Removed Hittest() from MonthCalendar
//  Minor Version 234:  Remove structure PrintDlgInfo
//  Minor Version 235:  Changed the event types of the Animation control.
//  Minor Version 236:  Restore old enumeration vlaues of SaveAsType.
//  Minor Version 237:  Try to rebuld typdef for PB system global function. In CR356723, it is not correct in release build
//  Minor Version 238:  Added one more overload of the SaveDocument function of the RichTextEdit class
//      PB_DaVinci started here
//  Minor Version 239:  Added one p-code SM_STORE_RETURN_VAL which will replace redundant SM_RETURN in routine
//  Minor Version 240:  Added a new field to DataWindow structure
//  Minor Version 241:  Added a new field to DataWindow column structure
//  Minor Version 242:  Added some reserved PVOIDs to data_table for expansion space.
//  Minor Version 243:  Added DWDataBuffer classes to data_table, the filter expression is in a new location.
//  Minor Version 244:  Added alias property for table column.
//  Minor Version 245:  Change number of color in type Environment from long to longlong.
//  Minor Version 246:  Added a field to DWDataBuffer
//  Minor Version 247:  Added a new object DatePicker
//  Minor Version 248:  For Editmask, Changed DropDownCalendar field, added 2 reserved fields
//  Minor Version 249:  CR381836, added DateSelected event for MonthCalendar
//  Minor Version 250:  Removed some properties, events and functions of DatePicker control
//  Minor Version 251:  Added  methods of TreeView DataWindow
//  Minor Version 252:  Added ink picture control methods to DataWindow/DataStore (required by PSE)
//  Minor Version 253:  Added  method IsExpanded() for TreeView DataWindow
//  Minor Version 254:  Added  method ResetInk() to Datawindow, add several funcs to DWobject
//  Minor Version 255:  Added  private property ValueSet to DatePicker
//  Minor Version 256:  Added Menu property and enum enhancements
//  Minor Version 257:  Add properties to OleRuntimeError
//  Minor Version 258:  Add new data type Byte
//  Minor Version 259:  Add Bitmap Gradient property
//  Minor Version 260:  Adjust MenuLabel to MenuTitleText
//  Minor Version 261:  Add dropdown calendar color properties to editmask, adjust reserved properties
//  Minor Version 262:  Added  method SelectTreeNode() for TreeView DataWindow
//  Minor Version 263:  Modify menu & toolbar enhancement properties to readonly
//  Minor Version 264:  Change the prototypes of global function SetByte()/GetByte()
//  Minor Version 265:  Added XMLGen.Paging property and XMLGenPaging enumerated type
//  Minor Version 266:  Modify menu & toolbar enhancement properties to write in runtime
//  Minor Version 267:  Add ControlCharsVisible property and ShowHeadFoot(boolean, boolean) fucntion to richtext control
//  Minor Version 277:  Skip 10 spaces for PB105 development to make sure PB105 to PB11 mirgation occurs.
//  Minor Version 278:  Add status bar property to RichText control
//  Minor Version 279:  Add font property to RichText control
//  Minor Version 280:  CR410185
//  Minor Version 290:  Leave another 10 rooms for PB105
//  Minor Version 291:  Modify menu & toolbar toplevel enhancement properties to readonly
//  Minor Version 292:  Add 2 new properties SelectStartPos and SelectLength to RichTextEdit control
//  Minor Version 293:  Renamced the properties SelectStartPos and SelectLength of the RichTextEdit control to SelectedStartPos and SelectedTExtLenghth
//  Minor Version 294:  Promoted XMLGen.Paging prop & enum to HTMLGen.PagingMethod prop & enum shared by all RenderFormats
//  Minor Version 295:  Add overloading to SetRemote()/SetRemote()/StartHotlink() to support both UNICODE and ANSI, and add function GetDynamicDecimal() to DynamicDescriptionArea
//  Minor Version 296:  Added a new LPTSTR field in the TBLARGS structure (CL#98759)
//  Minor Version 297:  Added new SyncParm, Synchronization, MlSync, and UlSync objects
//  Minor Version 298:  Add DBNotification event to Transaction
//  Minor Version 299:  Add a create event to Transaction
//  Minor Version 300:  Minor improvements to SyncParm, MLSynchronization, MLSync, and ULSync objects
//  Minor Version 301:  Add new type WSConnection and function DW>SetWSObject() to support Webservices in DataWindow
//  Minor Version 302:  Add new SyncProcessType enumeration and minor improvements to MLSynchronization and MLSync
//  Minor Version 303:  Add new properties to PictureButton
//  Minor Version 304:  Add 2 new type conversion functions
//  Minor Version 305:  Add TreeView DataWindow events Collapsed,Collapsing,Expanded,Expanding,TreeNodeSelected,TreeNodeSelecting, missed in PB105
//  Minor Version 306:  Add new window animation properties
//  Minor Version 307:  Add new event WSConnection.Error, and pending enumerated values of SaveAsType
//  Minor Version 308:  Change WSConnection.Error to DataStore/DataWindow.WSError
//  Minor Version 309:  Change The prototype of event DataStore/DataWindow.WSError
//  Minor Version 310:  Add overloading functions to Trim()/LeftTrim()/RightTrim()
//  Minor Version 311:  Change Trim()/LeftTrim()/RightTrim() from intrinsic functions to real functions
//  Minor Version 312:  Unifiy the overloading of Blob(string) and Blob(byte[]) to a single Blob(any)
//  Minor Version 313:  Removed property RightToLeft from DatePicker, requested by CR451645
//  Minor Version 314:  Add new overloading of InsertPicture (string n, integer i). Requested by CR446513
//  Minor Version 315:  Add RightToLeft Property for DatePicker and MonthCalendar
//  Minor Version 316:  Add 3 orientation related properties to RichTextEdit
//  Minor Version 317:  Properties for Graph(New3DRendering) and DW (RichText column)
//  Minor Version 318:  Add 2 new events DBError and SQLPreview to Transaction
//  Minor Version 319:  DW object properties for gradients/tranparency/tooltips
//  Minor Version 320:  DW Graph Gob New3DRendering property
//  Minor Version 321:  DW Graph Gob Render3D property
//  Minor Version 323:  Add FlowDirection Property
//  Minor Version 324:  Add Clear and ClearAll to RichTextEdit
//  Minor Version 325:  Add dwSetCultureFormat and SetCultureFormat to DW
//      PB_Newton started here
//  Minor Version 326:  GetAdoConnection/SetAdoConnection for Transaction
//  Minor Version 327:  GetAdoConnection/SetAdoConnection support for DW
//  Minor Version 328:  Transparency property for DragObject
//  Minor Version 329:  Expresionable "Enabled" property for DW button
//  Minor Version 330:  Tab sequence and Expresionable "Enabled" property for DW computed field
//  Minor Version 331:  Tab sequence and Expresionable "Enabled" property for DW Graph/Text/Picture
//  Minor Version 332:  Tab sequence and Expresionable "Enabled" property for DW Report/Blob/OLE
//  Minor Version 333:  "IMAction" property for CommandButton  Note:the property has been removed but minor version doesn't need to change back.

#define OB_MAJOR_VERSION                                3
#define OB_MINOR_VERSION                                333

// Minor version number on which to force conversion of specified group.

#define OB_CONVERT_VERSION                              OB_MINOR_VERSION

//****************************************************************************
// Group Version Number access
//****************************************************************************

#define GRP_MAJOR_VERS_MASK     ((ULONG) 0xFFFF0000)
#define GRP_MINOR_VERS_MASK     ((ULONG) 0x0000FFFF)

#define GRP_MAJOR_VERS_SHIFT    16
#define GRP_MINOR_VERS_SHIFT    0

#define ob_get_major_version(vers)                                                                      \
        (((vers) & GRP_MAJOR_VERS_MASK) >> GRP_MAJOR_VERS_SHIFT)

#define ob_get_minor_version(vers)                                                                              \
        (((vers) & GRP_MINOR_VERS_MASK) >> GRP_MINOR_VERS_SHIFT)

#define ob_set_major_version(vers,val)                                                          \
        ((vers) =                                                                                                                               \
            ((ULONG) (val) << GRP_MAJOR_VERS_SHIFT) |                               \
            ((vers) & ~GRP_MAJOR_VERS_MASK))

#define ob_set_minor_version(vers,val)                                                                  \
        ((vers) =                                                                                                                               \
            ((ULONG) (val) << GRP_MINOR_VERS_SHIFT) |                               \
            ((vers) & ~GRP_MINOR_VERS_MASK))

#define ob_build_version_no(major_vers,minor_vers)                                      \
        (  ((ULONG) (major_vers) << GRP_MAJOR_VERS_SHIFT)               |       \
            ((ULONG) (minor_vers) << GRP_MINOR_VERS_SHIFT)  )

#define OB_CURRENT_VERSION                                                                                              \
        (ob_build_version_no(OB_MAJOR_VERSION,OB_MINOR_VERSION))

//****************************************************************************
// Constants defining PowerBuilder Versions
//****************************************************************************

#define OB_PB_VERS_1_0                  ob_build_version_no(0,5)
#define OB_PB_VERS_GRP_HEADER           ob_build_version_no(1,0)
#define OB_PB_VERS_2_0                  ob_build_version_no(1,7)
#define OB_PB_VERS_3_0                  ob_build_version_no(2,17)
#define OB_PB_VERS_CONST_MAP            ob_build_version_no(3,1)
#define OB_PB_VERS_LONG_CONSTREFS       ob_build_version_no(3,3)
#define OB_PB_VERS_PERM_GROUP           ob_build_version_no(3,17)
#define OB_PB_VERS_CONST_MAP_CHG        ob_build_version_no(3,17)
#endif // OBVERS_H


// DOINC popped back into header 'obtypdef.h'
#endif
#ifndef OBCLINST_H
// ***** DOINC including obclinst.h *****
	// DOINC skipping duplicate include
#endif

#ifdef    __cplusplus
	extern "C" {
#endif    /* __cplusplus */

#ifndef OSCALLC_H
		// ***** DOINC including oscallc.h *****
			// DOINC skipping duplicate include
#endif

//****************************************************************************
// Token to VTable ID translation table structure
//****************************************************************************

		typedef struct tag_OB_EVENT_LOOKUP_ITEM
		{
			OB_EVT_TOKEN_ID     token;
			OB_VTABLE_ID        vtable_id;

		} OB_EVENT_LOOKUP_ITEM, FAR* POB_EVENT_LOOKUP_ITEM;

		//****************************************************************************
		// Wrapper macros for POB_PROTOTYPE
		//****************************************************************************

#define ob_get_event_lookup_item_token(obthis,pvt)                          \
    ((OB_EVT_TOKEN_ID) ((POB_EVENT_LOOKUP_ITEM)(pvt))->token)

#define ob_set_event_lookup_item_token(obthis,pvt,tok)                      \
    (((POB_EVENT_LOOKUP_ITEM)(pvt))->token = (OB_EVT_TOKEN_ID)(tok))

#define ob_get_event_lookup_item_id(obthis,pvt)                             \
    ((OB_VTABLE_ID) ((POB_EVENT_LOOKUP_ITEM)(pvt))->vtable_id)

#define ob_set_event_lookup_item_id(obthis,pvt,val)                         \
    (((POB_EVENT_LOOKUP_ITEM)(pvt))->vtable_id = (OB_VTABLE_ID)(val))

//****************************************************************************
// Function prototype style
//****************************************************************************

		typedef enum
		{
			OB_SYS_PROTOTYPE,       // Predefined in system types
			OB_USER_PROTOTYPE,      // User defined in append block.
			OB_FWD_PROTOTYPE        // User defined functions

		} OB_FUNCPROTO_STYLE, FAR* POB_FUNCPROTO_STYLE;

		//****************************************************************************
		// Data flags masks and shifts
		//****************************************************************************

		// info:
#define OB_PROTO_NOARGS_MASK        0x00ff              // 8 bit
#define OB_PROTO_ROUT_TYPE_MASK     0x0100              // 1 bit
#define OB_PROTO_TYPE_MASK          0x0e00              // 3 bits
#define OB_PROTO_ACCESS_MASK        0x3000              // 2 bits
#define OB_PROTO_PROTOSTYLE_MASK    0xc000              // 2 bits

#define OB_PROTO_NOARGS_SHIFT       0
#define OB_PROTO_ROUT_TYPE_SHIFT    8
#define OB_PROTO_TYPE_SHIFT         9
#define OB_PROTO_ACCESS_SHIFT       12
#define OB_PROTO_PROTOSTYLE_SHIFT   14

// info2:
#define OB_PROTO_OBSOLETE_MASK      0x0001              // 1 bit
#define OB_PROTO_DECLARATION_MASK   0x0002              // 1 bit
#define OB_PROTO_VAR_ARGS_MASK      0x0004              // 1 bit
#define OB_PROTO_EXT_EVENT_MASK     0x0008              // 1 bit
#define OB_PROTO_NOTHROWS_MASK      0xff00              // 8 bit

#define OB_PROTO_OBSOLETE_SHIFT     0
#define OB_PROTO_DECLARATION_SHIFT  1
#define OB_PROTO_VAR_ARGS_SHIFT     2
#define OB_PROTO_EXT_EVENT_SHIFT    3
#define OB_PROTO_NOTHROWS_SHIFT     8


//****************************************************************************
// Typedef function and event structure
//****************************************************************************

		typedef struct ob_perm_prototype
		{
			OB_CONST_REF                name;       // Prototype name
			OB_CONST_REF                signature;  // Prototype signature
			OB_CONST_REF                args;       // Prototype argument array
			OB_CONST_REF                aliasname;  // [opt] If set, name to execute
			OB_CONST_REF                dllname;    // If LIBRARY specifiec, name here
			OB_VTABLE_ID                vtable_id;  // Offset to vtable entry
			OB_MODULE_ID                mod_id;     // Offset to mod_symtab node
			OB_ROUT_ID                  rout_id;    // Offset to routine node
			OB_VTABLE_ID                sys_func_id;// If OB_{SYSTEM|SYSDLL}_FUNC_DEF
			OB_CLASS_ID                 type;       // Result value data type
			USHORT                      info;       // Info flags contain:
		//  UCHAR                       no_args         : 8; Up to 255 args.
		//  OB_ROUT_TYPE                rout_type       : 1; OB_EVENT|OB_FUNCTION
		//  OB_FUNC_TYPE                func_type       : 3; How to call this rout
		//  OB_MEMBER_ACCESS            member_access   : 2; What are the access rights
		//  OB_FUNCPROTO_STYLE          proto_style     : 2; Where was this defined
			OB_EVT_TOKEN_ID             token;      // Token id, if an event
			USHORT                      info2;      // Secondary info flag
		//  BOOL                        obsolete        : 1; "PRIOR ALIAS" flag, if func/sub
		//  BOOL                        declaration     : 1; True if this is decl
		//  BOOL                        is_var_args     : 1; True if this func is var_args
		//  BOOL                        is_external_evt : 1; True if this event is external
		//  xxxx                        unused          : 4; unused
		//  UCHAR                       no_throws       : 8; Up to 255 throws
			OB_CONST_REF                descriptor; // Descriptor text
			ULONG                       help_id;
			OB_CONST_REF                throws_ref; // Throws class id array
		} OB_PERM_PROTOTYPE, FAR* POB_PERM_PROTOTYPE;

		typedef struct ob_prototype
		{
			POB_PERM_PROTOTYPE          perm_entry;
			OS_CALLC_FUNC               func_ptr;

		} OB_PROTOTYPE, FAR* POB_PROTOTYPE;


		//****************************************************************************
		// Wrapper macros for POB_PROTOTYPE
		//****************************************************************************

#define ob_get_proto_name(obthis,conpool,proto)                             \
    ((LPTSTR) ob_get_const_data (obthis,                                    \
            conpool, (proto)->perm_entry->name))

#define ob_get_proto_name_ref(obthis,proto)                                 \
    ((OB_CONST_REF) (proto)->perm_entry->name)

#define ob_set_proto_name_ref(obthis,proto,namecr)                          \
    ((proto)->perm_entry->name = (OB_CONST_REF)(namecr))

#define ob_get_proto_signature(obthis,conpool,proto)                    \
    ((LPTSTR) ob_get_const_data (obthis,                                \
        conpool, (proto)->perm_entry->signature))

#define ob_get_proto_signature_ref(obthis,proto)                                \
    ((OB_CONST_REF) (proto)->perm_entry->signature)

#define ob_set_proto_signature_ref(obthis,proto,newSig)                             \
    ((proto)->perm_entry->signature = (OB_CONST_REF)(newSig))

#define ob_get_proto_args(obthis,conpool,proto)                             \
    ((POB_PROTO_ARG) ob_get_const_data (obthis,                             \
        conpool, (proto)->perm_entry->args))

#define ob_get_proto_args_ref(obthis,proto)                                 \
    ((OB_CONST_REF) (proto)->perm_entry->args)

#define ob_set_proto_args_ref(obthis,proto,argscr)                          \
    ((proto)->perm_entry->args = (OB_CONST_REF)(argscr))

#define ob_get_proto_alias_name(obthis,conpool,proto)                       \
    ((LPTSTR) ob_get_const_data (obthis,                                    \
        conpool, (proto)->perm_entry->aliasname))

#define ob_get_proto_alias_name_ref(obthis,proto)                           \
    ((OB_CONST_REF) (proto)->perm_entry->aliasname)

#define ob_set_proto_alias_name_ref(obthis,proto,namecr)                    \
    ((proto)->perm_entry->aliasname = (OB_CONST_REF)(namecr))

#define ob_get_proto_dll_name(obthis,conpool,proto)                         \
    ((LPTSTR) ob_get_const_data (obthis,                                    \
        conpool, (proto)->perm_entry->dllname))

#define ob_get_proto_dll_name_ref(obthis,proto)                             \
    ((OB_CONST_REF) (proto)->perm_entry->dllname)

#define ob_set_proto_dll_name_ref(obthis,proto,namecr)                      \
    ((proto)->perm_entry->dllname = (OB_CONST_REF)(namecr))

#define ob_get_proto_vtable_id(obthis,proto)                                    \
    ((OB_VTABLE_ID) (proto)->perm_entry->vtable_id)

#define ob_set_proto_vtable_id(obthis,proto,vtid)                           \
    ((proto)->perm_entry->vtable_id = (OB_VTABLE_ID)(vtid))

#define ob_get_proto_mod_id(obthis,proto)                                   \
    ((OB_MODULE_ID) (proto)->perm_entry->mod_id)

#define ob_set_proto_mod_id(obthis,proto,modid)                             \
    ((proto)->perm_entry->mod_id = (OB_MODULE_ID)(modid))

#define ob_get_proto_rout_id(obthis,proto)                                  \
    ((OB_ROUT_ID) (proto)->perm_entry->rout_id)

#define ob_set_proto_rout_id(obthis,proto,routid)                           \
    ((proto)->perm_entry->rout_id = (OB_ROUT_ID)(routid))

#define ob_get_proto_sys_func_id(obthis,proto)                              \
    ((OB_VTABLE_ID) (proto)->perm_entry->sys_func_id)

#define ob_set_proto_sys_func_id(obthis,proto,funcid)                       \
    ((proto)->perm_entry->sys_func_id = (OB_VTABLE_ID)(funcid))

#define ob_get_proto_result_type(obthis,proto)                              \
    ((OB_CLASS_ID) (proto)->perm_entry->type)

#define ob_set_proto_result_type(obthis,proto,rtype)                        \
    ((proto)->perm_entry->type = (OB_CLASS_ID)(rtype))

#define ob_get_proto_throws_list(obthis,conpool,proto)                              \
    ((POB_CLASS_ID) ob_get_const_data (obthis,                          \
        conpool, (proto)->perm_entry->throws_ref))

#define ob_get_proto_throws_list_ref(obthis,proto)                              \
    ((OB_CONST_REF) (proto)->perm_entry->throws_ref)

#define ob_set_proto_throws_list_ref(obthis,proto,argscr)                           \
    ((proto)->perm_entry->throws_ref = (OB_CONST_REF)(argscr))

#define ob_get_proto_nothrows(obthis,proto)                                     \
    ((UINT) (((proto)->perm_entry->info2 & OB_PROTO_NOTHROWS_MASK) >>           \
                OB_PROTO_NOTHROWS_SHIFT))

#define ob_set_proto_nothrows(obthis,proto,noargs)                          \
    ((proto)->perm_entry->info2 = (USHORT)(((noargs) << OB_PROTO_NOTHROWS_SHIFT) | \
                ((proto)->perm_entry->info2 & ~OB_PROTO_NOTHROWS_MASK)))

#define ob_get_proto_noargs(obthis,proto)                                   \
    ((UINT) (((proto)->perm_entry->info & OB_PROTO_NOARGS_MASK) >>          \
                OB_PROTO_NOARGS_SHIFT))

#define ob_set_proto_noargs(obthis,proto,noargs)                            \
    ((proto)->perm_entry->info = (USHORT)(((noargs) << OB_PROTO_NOARGS_SHIFT) | \
                ((proto)->perm_entry->info & ~OB_PROTO_NOARGS_MASK)))

#define ob_get_proto_rout_type(obthis,proto)                                \
    ((OB_ROUT_TYPE) (((proto)->perm_entry->info & OB_PROTO_ROUT_TYPE_MASK) >> \
                OB_PROTO_ROUT_TYPE_SHIFT))

#define ob_set_proto_rout_type(obthis,proto,routtype)                       \
    ((proto)->perm_entry->info = (USHORT)(((routtype) << OB_PROTO_ROUT_TYPE_SHIFT) | \
                ((proto)->perm_entry->info & ~OB_PROTO_ROUT_TYPE_MASK)))

#define ob_get_proto_type(obthis,proto)                                     \
    ((OB_FUNC_TYPE) (((proto)->perm_entry->info & OB_PROTO_TYPE_MASK) >>    \
                OB_PROTO_TYPE_SHIFT))

#define ob_set_proto_type(obthis,proto,type)                                \
    ((proto)->perm_entry->info = (USHORT)(((type) << OB_PROTO_TYPE_SHIFT) | \
                ((proto)->perm_entry->info & ~OB_PROTO_TYPE_MASK)))

#define ob_get_proto_member_access(obthis,proto)                            \
    ((OB_MEMBER_ACCESS) (((proto)->perm_entry->info & OB_PROTO_ACCESS_MASK) >> \
                OB_PROTO_ACCESS_SHIFT))

#define ob_set_proto_member_access(obthis,proto,access)                     \
    ((proto)->perm_entry->info = (USHORT)(((access) << OB_PROTO_ACCESS_SHIFT) | \
                ((proto)->perm_entry->info & ~OB_PROTO_ACCESS_MASK)))

#define ob_get_proto_protostyle(obthis,proto)                               \
    ((OB_FUNCPROTO_STYLE)                                                   \
        (((proto)->perm_entry->info & OB_PROTO_PROTOSTYLE_MASK) >>          \
                OB_PROTO_PROTOSTYLE_SHIFT))

#define ob_set_proto_protostyle(obthis,proto,protostyle)                    \
    ((proto)->perm_entry->info = (USHORT)(((protostyle)<<OB_PROTO_PROTOSTYLE_SHIFT) | \
                ((proto)->perm_entry->info & ~OB_PROTO_PROTOSTYLE_MASK)))

#define ob_get_proto_token(obthis,proto)                                    \
    ((OB_EVT_TOKEN_ID) (proto)->perm_entry->token)

#define ob_set_proto_token(obthis,proto,tokn)                               \
    ((proto)->perm_entry->token = (OB_EVT_TOKEN_ID)(tokn))

#define ob_get_proto_obsolete_status(obthis,proto)                          \
    ((BOOL)                                                                 \
        (((proto)->perm_entry->info2 & OB_PROTO_OBSOLETE_MASK) >>           \
                OB_PROTO_OBSOLETE_SHIFT))

#define ob_set_proto_obsolete_status(obthis,proto,status)                   \
    ((proto)->perm_entry->info2 = (USHORT)(((status)<<OB_PROTO_OBSOLETE_SHIFT) | \
                ((proto)->perm_entry->info2 & ~OB_PROTO_OBSOLETE_MASK)))

#define ob_is_proto_obsolete(obthis,proto)                                  \
    ((BOOL) (ob_get_proto_obsolete_status(obthis,proto) == TRUE))

#define ob_get_proto_declaration_status(obthis,proto)                       \
    ((BOOL)                                                                 \
        (((proto)->perm_entry->info2 & OB_PROTO_DECLARATION_MASK) >>        \
                OB_PROTO_DECLARATION_SHIFT))

#define ob_set_proto_declaration_status(obthis,proto,status)                \
    ((proto)->perm_entry->info2 = (USHORT)(((status)<<OB_PROTO_DECLARATION_SHIFT) | \
                ((proto)->perm_entry->info2 & ~OB_PROTO_DECLARATION_MASK)))

#define ob_is_proto_declared_locally(obthis,proto)                          \
    ((BOOL) (ob_get_proto_declaration_status(obthis,proto) == TRUE))

#define ob_get_proto_var_args_status(obthis,proto)                          \
    ((BOOL)                                                                 \
        (((proto)->perm_entry->info2 & OB_PROTO_VAR_ARGS_MASK) >>           \
                OB_PROTO_VAR_ARGS_SHIFT))

#define ob_set_proto_var_args_status(obthis,proto,status)                   \
    ((proto)->perm_entry->info2 = (USHORT)(((status)<<OB_PROTO_VAR_ARGS_SHIFT) | \
                ((proto)->perm_entry->info2 & ~OB_PROTO_VAR_ARGS_MASK)))

#define ob_does_proto_have_var_args(obthis,proto)                           \
    ((BOOL) (ob_get_proto_var_args_status(obthis,proto) == TRUE))

#define ob_get_proto_external_evt_status(obthis,proto)                          \
    ((BOOL)                                                                 \
        (((proto)->perm_entry->info2 & OB_PROTO_EXT_EVENT_MASK) >>          \
                OB_PROTO_EXT_EVENT_SHIFT))

#define ob_set_proto_external_evt_status(obthis,proto,status)                   \
    ((proto)->perm_entry->info2 = (USHORT)(((status)<<OB_PROTO_EXT_EVENT_SHIFT) | \
                ((proto)->perm_entry->info2 & ~OB_PROTO_EXT_EVENT_MASK)))

#define ob_get_proto_func_ptr(obthis,proto)                                 \
    ((BOOL) (proto)->func_ptr)

#define ob_set_proto_func_ptr(obthis,proto,fptr)                            \
    ((proto)->func_ptr = (OS_CALLC_FUNC)(fptr))

#define ob_get_proto_perm_entry(obthis,proto)                               \
    ((BOOL) (proto)->perm_entry)

#define ob_set_proto_perm_entry(obthis,proto,fptr)                          \
    ((proto)->perm_entry = (POB_PERM_PROTOTYPE)(fptr))

#define ob_get_proto_descriptor(obthis,conpool,proto)                       \
    (((proto)->perm_entry->descriptor == OB_CONST_NOT_DEFINED) ? NULL : \
        ((LPTSTR) ob_get_const_data (obthis,                                \
                conpool, (proto)->perm_entry->descriptor)))

#define ob_get_proto_descriptor_ref(obthis,proto)                           \
    ((OB_CONST_REF) (proto)->perm_entry->descriptor)

#define ob_set_proto_descriptor_ref(obthis,proto,descriptorcr)              \
    ((proto)->perm_entry->descriptor = (OB_CONST_REF)(descriptorcr))

#define ob_get_proto_help_id(obthis,proto)                                  \
    ((proto)->perm_entry->help_id)

#define ob_set_proto_help_id(obthis,proto,id)                               \
    ((proto)->perm_entry->help_id = (id))

#define OB_HELP_ID_UNDEFINED    ULONG_MAX

//****************************************************************************
// Indirect attribute function template structures
//****************************************************************************

		typedef enum
		{
			OB_FUNCTMPLT_VAR_ARG,
			OB_FUNCTMPLT_NAME_ARG,
			OB_FUNCTMPLT_ARGS_ARG,
			OB_FUNCTMPLT_NARGS_ARG,
			OB_FUNCTMPLT_VAL_ARG,
			OB_FUNCTMPLT_EOSEQ_ARG,
			OB_FUNCTMPLT_DIMS_ARG

		} OB_FUNCTMPLT_ARG_TYPE, FAR* POB_FUNCTMPLT_ARG_TYPE;


		typedef enum
		{
			OB_INDATTR_GET_FUNC,
			OB_INDATTR_SET_FUNC,
			OB_INDATTR_GETITEM_FUNC,
			OB_INDATTR_SETITEM_FUNC,
			OB_INDATTR_INVMETHOD_FUNC,
			OB_INDATTR_UPPERBOUND_FUNC,
			OB_INDATTR_LOWERBOUND_FUNC,
			OB_INDATTR_UNDEFINED_FUNC

		} OB_INDATTR_FUNC_TYPE, FAR* POB_INDATTR_FUNC_TYPE;


		typedef struct ob_functmplt_argument
		{
			OB_CONST_REF                argname;
			USHORT                      argtype;
			SHORT                       padding;

		} OB_FUNCTMPLT_ARGUMENT, FAR* POB_FUNCTMPLT_ARGUMENT;


		typedef struct ob_indattr_functmplt
		{
			OB_CONST_REF                name;
			OB_CONST_REF                args;
			USHORT                      no_args;
			USHORT                      func_type;
			USHORT                      isDynamic;
			USHORT                      padding;


		} OB_INDATTR_FUNCTMPLT, FAR* POB_INDATTR_FUNCTMPLT;


		//****************************************************************************
		// Wrapper macros for function template stuff
		//****************************************************************************

#define ob_get_functmplt_type(obthis,functmplt)                             \
    ( (OB_INDATTR_FUNC_TYPE) ((functmplt)->func_type) )

#define ob_set_functmplt_type(obthis,functmplt,type)                        \
    ( (functmplt)->func_type = (USHORT) (type) )

#define ob_get_functmplt_arg_type(obthis,functmplt_arg)                     \
    ( (OB_FUNCTMPLT_ARG_TYPE) ((functmplt_arg)->argtype) )

#define ob_set_functmplt_arg_type(obthis,functmplt_arg,type)                \
    ( (functmplt_arg)->argtype = (USHORT) (type) )

#define ob_get_functmplt_is_dynamic(obthis,functmplt)                       \
    ( (USHORT) ((functmplt)->isDynamic) )

#define ob_set_functmplt_is_dynamic(obthis,functmplt,val)                   \
    ( (functmplt)->isDynamic = (USHORT) (val) )

//****************************************************************************
// Enumerated type structures.
//****************************************************************************

		typedef struct ob_enumfield
		{
			OB_CONST_REF                name;
			SHORT                       val;
			SHORT                       padding;

		} OB_ENUMFIELD, FAR* POB_ENUMFIELD;

		//****************************************************************************
		// Virtual routine node on disk
		//****************************************************************************

		typedef struct ob_perm_virtual_node
		{
			OB_VTABLE_ID                vtable_id;
			OB_PROTO_ID                 proto_id;
			OB_CLASS_ID                 class_id;

		} OB_PERM_VIRTUAL_NODE, FAR* POB_PERM_VIRTUAL_NODE;

#define ob_get_perm_vtable_node_vtable_id(obthis,vtnode)                    \
    ((POB_PERM_VIRTUAL_NODE)(vtnode))->vtable_id

#define ob_set_perm_vtable_node_vtable_id(obthis,vtnode,slt)                \
    ( ((POB_PERM_VIRTUAL_NODE)(vtnode))->vtable_id = (USHORT)(slt) )

#define ob_get_perm_vtable_node_proto_id(obthis,vtnode)                     \
    ((POB_PERM_VIRTUAL_NODE)(vtnode))->proto_id

#define ob_set_perm_vtable_node_proto_id(obthis,vtnode,fid)                 \
    ( ((POB_PERM_VIRTUAL_NODE)(vtnode))->proto_id = (OB_PROTO_ID)(fid) )

#define ob_get_perm_vtable_node_class_id(obthis,vtnode)                     \
    ((POB_PERM_VIRTUAL_NODE)(vtnode))->class_id

#define ob_set_perm_vtable_node_class_id(obthis,vtnode,cid)                 \
    ( ((POB_PERM_VIRTUAL_NODE)(vtnode))->class_id = (OB_CLASS_ID)(cid) )

		//****************************************************************************
		// Virtual routine node in memory
		//****************************************************************************

		typedef struct ob_virtual_node
		{
			OB_ROUT_ID                  rout_id;
			OB_PROTO_ID                 proto_id;
			OB_GROUP_ID                 group_id;
			OB_CLASS_ID                 class_id;

		} OB_VIRTUAL_NODE, FAR* POB_VIRTUAL_NODE;

#define ob_get_vtable_node_rout_id(obthis,vtnode)                           \
    (((POB_VIRTUAL_NODE)(vtnode))->rout_id)

#define ob_set_vtable_node_rout_id(obthis,vtnode,fid)                       \
    ( ((POB_VIRTUAL_NODE)(vtnode))->rout_id = (OB_ROUT_ID)(fid) )

#define ob_get_vtable_node_proto_id(obthis,vtnode)                          \
    (((POB_VIRTUAL_NODE)(vtnode))->proto_id)

#define ob_set_vtable_node_proto_id(obthis,vtnode,fid)                      \
    ( ((POB_VIRTUAL_NODE)(vtnode))->proto_id = (OB_PROTO_ID)(fid) )

#define ob_get_vtable_node_group_id(obthis,vtnode)                          \
    (((POB_VIRTUAL_NODE)(vtnode))->group_id)

#define ob_set_vtable_node_group_id(obthis,vtnode,cid)                      \
    ( ((POB_VIRTUAL_NODE)(vtnode))->group_id = (OB_GROUP_ID)(cid) )

#define ob_get_vtable_node_class_id(obthis,vtnode)                          \
    (((POB_VIRTUAL_NODE)(vtnode))->class_id)

#define ob_set_vtable_node_class_id(obthis,vtnode,cid)                      \
    ( ((POB_VIRTUAL_NODE)(vtnode))->class_id = (OB_CLASS_ID)(cid) )

		//****************************************************************************
		//  Type entry styles
		//****************************************************************************

		typedef enum
		{
			TYPE_CLASS,
			TYPE_ENUM,
			TYPE_INIT_SOURCE,
			TYPE_INDIRECT,          // Not used
			TYPE_VAR_BLOCK,
			TYPE_INHERITED

		} OB_CLASS_STYLE, FAR* POB_CLASS_STYLE;

		//****************************************************************************
		// Data flags masks and shifts
		//****************************************************************************

#define OB_PROTOARG_GROUPING_MASK       0x0001              // 1 bit
#define OB_PROTOARG_ARGTYPE_MASK        0x0006              // 2 bits
#define OB_PROTOARG_TYPEARGS_MASK       0x00F8              // 5 bits

#define OB_PROTOARG_GROUPING_SHIFT      0
#define OB_PROTOARG_ARGTYPE_SHIFT       1
#define OB_PROTOARG_TYPEARGS_SHIFT      3

//****************************************************************************
// Prototype argument node
//****************************************************************************

		typedef struct ob_proto_arg
		{
			OB_CONST_REF            name;           // Argument name
			OB_CONST_REF            arrdef;         // If OB_ARRAY, it's definition
			OB_CLASS_ID             datatype;       // Data type of argument
			USHORT                  info;           // Info flags contains:
		//  OB_GROUPTYPE            grouping            : 1; OB_SIMPLE|OB_ARRAY
		//  OB_PROTOARG_TYPE        argtype             : 2; Pass type:val,ref,r/o
		//  INT                     typeargs            : 5; Typeargs for data type

		} OB_PROTO_ARG, FAR* POB_PROTO_ARG;

		//****************************************************************************
		// Wrapper macros for POB_PROTO_ARG
		//****************************************************************************

#define ob_get_proto_arg_name(obthis,conpool,proto)                         \
    ((LPTSTR) ob_get_const_data (obthis,                                    \
        conpool, (proto)->name))

#define ob_get_proto_arg_name_ref(obthis,proto)                             \
    ((OB_CONST_REF) (proto)->name)

#define ob_set_proto_arg_name_ref(obthis,proto,namecr)                      \
    ((proto)->name = (OB_CONST_REF)(namecr))

#define ob_get_proto_arg_array_def(obthis,conpool,proto)                    \
    ((POB_ARRAYDEF) ob_get_const_data (obthis,                              \
        conpool, (proto)->arrdef))

#define ob_get_proto_arg_array_ref(obthis,proto)                            \
    ((OB_CONST_REF) (proto)->arrdef)

#define ob_set_proto_arg_array_ref(obthis,proto,cref)                       \
    ((proto)->arrdef = (OB_CONST_REF)(cref))

#define ob_get_proto_arg_data_type(obthis,proto)                            \
    ((OB_CLASS_ID) (proto)->datatype)

#define ob_set_proto_arg_data_type(obthis,proto,cid)                        \
    ((proto)->datatype = (OB_CLASS_ID)(cid))

#define ob_get_proto_arg_argtype(obthis,protoarg)                           \
    ((OB_PROTOARG_TYPE) (((protoarg)->info & OB_PROTOARG_ARGTYPE_MASK) >>   \
                OB_PROTOARG_ARGTYPE_SHIFT))

#define ob_set_proto_arg_argtype(obthis,protoarg,argtype)                   \
    ((protoarg)->info = (USHORT)(((argtype) << OB_PROTOARG_ARGTYPE_SHIFT) | \
                ((protoarg)->info & ~OB_PROTOARG_ARGTYPE_MASK)))

#define ob_get_proto_arg_grouping(obthis,protoarg)                          \
    ((OB_GROUPTYPE) (((protoarg)->info & OB_PROTOARG_GROUPING_MASK) >>      \
                OB_PROTOARG_GROUPING_SHIFT))

#define ob_set_proto_arg_grouping(obthis,protoarg,grouping)                 \
    ((protoarg)->info = (USHORT)(((grouping) << OB_PROTOARG_GROUPING_SHIFT) | \
                ((protoarg)->info & ~OB_PROTOARG_GROUPING_MASK)))

#define ob_get_proto_arg_typeargs(obthis,protoarg)                          \
    ((INT) (((protoarg)->info & OB_PROTOARG_TYPEARGS_MASK) >>               \
                OB_PROTOARG_TYPEARGS_SHIFT))

#define ob_set_proto_arg_typeargs(obthis,protoarg,typeargs)                 \
    ((protoarg)->info = (USHORT)((((typeargs) << OB_PROTOARG_TYPEARGS_SHIFT) & \
                                  OB_PROTOARG_TYPEARGS_MASK) |              \
                ((protoarg)->info & ~OB_PROTOARG_TYPEARGS_MASK)))

//****************************************************************************
// Module symbol table structure    and associated methods
//****************************************************************************

		typedef OB_LOOK_SYMTAB      OB_MOD_SYMTAB, FAR* POB_MOD_SYMTAB;

#define ob_modsym_init(obthis,mod_symtab,symslots,lkslots,poolslots,subpool)\
            ob_init_look_symtab (obthis, mod_symtab, symslots,              \
                                lkslots, poolslots, subpool)

#define ob_modsym_destroy(obthis,mod_symtab)                                \
            ob_del_look_symtab (obthis, mod_symtab)

#define ob_modsym_write(obthis,mod_symtab)                                  \
            ob_looksym_write (obthis, mod_symtab)

#define ob_modsym_read(obthis,mod_symtab,subpool)                           \
            ob_looksym_read (obthis, mod_symtab, subpool)

		/* ob_modsym_declare: Allows duplicates */
#define ob_modsym_declare(obthis,mod_symtab,name,error)                     \
            ob_dup_looksym_declare (obthis, mod_symtab, name, error)

		/* ob_modsym_reference: Use this to get first symbol */
#define ob_modsym_reference(obthis,mod_symtab,name)                         \
            ob_looksym_reference (obthis, mod_symtab, name)

		/* ob_modsym_next_reference: Use this to get next duplicate symbol */
#define ob_modsym_next_reference(obthis,mod_symtab,name)                    \
            ob_looksym_next_reference (obthis, mod_symtab, name)

#define ob_modsym_entry_delete(obthis,mod_symtab,mod_id)                    \
            ob_looksym_delete (obthis, mod_symtab, mod_id)

#define ob_modsym_entry_delete_dup(obthis,mod_symtab,mod_id)                \
            ob_looksym_delete_dup (obthis, mod_symtab, mod_id)

#define ob_modsym_entry_name(obthis,mod_symtab,mod_id)                      \
            ob_looksym_name (obthis, mod_symtab, mod_id)

		/* Do not use on duplicate symbols */
#define ob_modsym_entry_rename(obthis,mod_symtab,oldname,newname)           \
            ob_looksym_rename (obthis, mod_symtab, oldname, newname)

#define ob_modsym_no_entries(obthis,mod_symtab)                             \
            ob_looksym_no_entries (mod_symtab)

#define ob_modsym_set_proto_id(obthis,mod_symtab,mod_id,id)                 \
            ob_looksym_set_id (mod_symtab, mod_id, id, UNDECLARED_TYPE)

#define ob_modsym_set_globsym_id(obthis,mod_symtab,mod_id,id)               \
            ob_looksym_set_id (mod_symtab, mod_id, id, UNDECLARED_TYPE)

#define ob_modsym_get_proto_id(obthis,mod_symtab,mod_id)                    \
            ob_looksym_get_id (mod_symtab, mod_id)

#define ob_modsym_get_globsym_id(obthis,mod_symtab,mod_id)                  \
            ob_looksym_get_id (mod_symtab, mod_id)

#define ob_modsym_set_functype(obthis,mod_symtab,mod_id,func_type)          \
            ob_looksym_set_typeargs (mod_symtab, mod_id, func_type)

#define ob_modsym_get_functype(obthis,mod_symtab,mod_id)                    \
            ob_looksym_typeargs (mod_symtab, mod_id)

#define ob_is_modsym_entry_used(obthis,mod_symtab,mod_id)                   \
            ob_is_looksym_declared (mod_symtab, mod_id)

#define ob_modsym_get_status(obthis,mod_symtab,mod_id)                      \
            ob_looksym_status (mod_symtab, mod_id)

#define ob_does_modsym_prototype_exist(obthis,mod_symtab,mod_id)            \
            (ob_looksym_no_entries (mod_symtab) > 0 &&                      \
             ob_looksym_status (mod_symtab, mod_id) == USED &&              \
             ob_looksym_get_id(mod_symtab,mod_id) != OB_SYM_NOT_DEFINED)


#define ob_does_routine_exist(obthis,class_entry,mod_id)                    \
            (ob_does_modsym_prototype_exist (obthis,&(class_entry)->mod_symtab,mod_id) && \
             (ob_get_proto_rout_id(obthis,                                  \
                ob_get_class_prototype(obthis,class_entry,                  \
                    ob_modsym_get_proto_id(obthis,                          \
                        &(class_entry)->mod_symtab,mod_id))) != OB_SYM_NOT_DEFINED \
             )                                                              \
            )


//****************************************************************************
// Enum symbol table structure and associated methods
//****************************************************************************

		typedef UINT                OB_ENUM_ID;
		typedef OB_LOOK_SYMTAB      OB_ENUM_SYMTAB, FAR* POB_ENUM_SYMTAB;

#define ob_get_enumsym_conpool(obthis,enum_symtab)                          \
            ob_looksym_conpool (enum_symtab)

		/*
		#define ob_enumsym_init(obthis,enum_symtab,smslots,lkslots,plslots,subpool) \
					ob_init_look_symtab (obthis, enum_symtab, smslots,              \
												lkslots, plslots, subpool)

		#define ob_enumsym_destroy(obthis,enum_symtab)                              \
					ob_del_look_symtab (obthis, enum_symtab)

		#define ob_enumsym_write(obthis,enum_symtab)                                \
					ob_looksym_write (obthis, enum_symtab)

		#define ob_enumsym_read(obthis,enum_symtab,subpool)                         \
					ob_looksym_read (obthis, enum_symtab, subpool)
		*/

#define ob_enumsym_declare(obthis,enum_symtab,name,error)                   \
            ob_looksym_declare (obthis, enum_symtab, name, error)

#define ob_enumsym_reference(obthis,enum_symtab,name)                       \
            ob_looksym_reference (obthis, enum_symtab, name)

		/*
		#define ob_enumsym_entry_delete(obthis,enum_symtab,enum_id)                 \
					ob_looksym_delete (obthis, enum_symtab, enum_id)

		#define ob_enumsym_entry_name(obthis,enum_symtab,enum_id)                   \
					ob_looksym_name (obthis, enum_symtab, enum_id)
		*/

#define ob_enumsym_entry_name_ref(obthis,enum_symtab,enum_id)               \
            ob_looksym_name_ref (enum_symtab, enum_id)

		/*
		#define ob_enumsym_no_entries(obthis,enum_symtab)                           \
					ob_looksym_no_entries (enum_symtab)
		*/

#define ob_enumsym_set_val(obthis,enum_symtab,enum_id,val)                  \
            ob_set_data_int_val (ob_looksym_data (enum_symtab, enum_id), val)

#define ob_enumsym_get_val(obthis,enum_symtab,enum_id)                      \
            ob_get_data_int (ob_looksym_data (enum_symtab, enum_id))

#define ob_enumsym_set_type(obthis,enum_symtab,enum_id,type)                \
            ob_looksym_set_type (enum_symtab, enum_id, type)

#define ob_enumsym_get_type(obthis,enum_symtab,enum_id)                     \
            ob_looksym_type (enum_symtab, enum_id)

		/*
		#define ob_is_enumsym_entry_used(obthis,enum_symtab,enum_id)                \
					ob_is_looksym_declared (enum_symtab, enum_id)

		#define ob_does_enumsym_routine_exist(obthis,enum_symtab,enum_id)           \
					(ob_looksym_no_entries (enum_symtab) > 0 &&                     \
					 ob_looksym_status (enum_symtab, enum_id) == USED)
		*/

		//****************************************************************************
		// Class description structure
		//****************************************************************************

		typedef struct ob_class_def
		{
			OB_CLASS_ID         parent_class;           // Inherited parent type.
			OB_CLASS_ID         nested_class;           // Nested parent type.
			USHORT              no_protos;              // Number of prototypes
			USHORT              no_func_protos;         // Number of functions/subrs.
			USHORT              no_event_protos;        // Number of events
			USHORT              no_local_event_protos;  // Number of events
			USHORT              curr_event;             // Current evt_index entry
			USHORT              curr_func;              // Current func_index entry
			USHORT              no_vtab_lookup;         // Total virt table size
			USHORT              no_vtab_funcs;          // Total funcs in virt table
			USHORT              no_vtab_events;         // Total events in virt table
			USHORT              no_event_lookup;        // No. entries in event lookup
			USHORT              no_perm_vtab_lookup;    // Total used virt table size
			USHORT              no_indattr_functmplt;   // Number of indirect attribute funcs
			USHORT              no_instance_image;      // Number of inst image attrs
			USHORT              no_system_fields;       // Number of fields defined in
														//  system ancestors
		} OB_CLASS_DEF, FAR* POB_CLASS_DEF;

		//****************************************************************************
		// API for OB_CLASS_DEF
		//****************************************************************************

#define ob_get_class_entry_parent(obthis,class_entry)                       \
    ((class_entry)->def_entry->parent_class)

#define ob_get_class_entry_nested(obthis,class_entry)                       \
    ((class_entry)->def_entry->nested_class)

#define ob_get_class_no_instance_image(obthis,class_entry)                  \
    ((class_entry)->def_entry->no_instance_image)

#define ob_set_class_no_instance_image(obthis,class_entry,no_items)         \
    ((class_entry)->def_entry->no_instance_image = (USHORT) (no_items))

#define ob_get_class_no_system_fields(obthis,class_entry)                   \
    ((class_entry)->def_entry->no_system_fields)

#define ob_set_class_no_system_fields(obthis,class_entry,no_items)          \
    ((class_entry)->def_entry->no_system_fields = (USHORT) (no_items))

//****************************************************************************
// Permanent class entry structure
//****************************************************************************

		typedef struct ob_perm_class_entry
		{
			USHORT              info;                    // Info flags contains:
		//  UINT                status              : 1; // Class status
		//  UINT                class_style         : 3; // Class style.
		//  UINT                has_proto_block     : 1; // Has a prototype block?
		//  UINT                has_instvar_block   : 1; // Has a instvar block?
		//  UINT                has_fwdproto_block  : 1; // Has a forward proto block?
		//  UINT                has_typedef_source  : 1; // Has typedef source?
		//  BOOL                is_auto_instantiated: 1; // Is class autoinstantiated

			OB_CLASS_ID         class_id;                // Associated class id.

			struct  struct_inh                                   // If TYPE_INHERITED
			{
				OB_CLASS_ID sec_class;              // Inherited class id.
				OB_CLASS_ID sec_group_class;        // Indirects to inh group.

			};

			union
			{
				USHORT          no_enums;                // If TYPE_ENUM
				USHORT          def_slot;                // If TYPE_CLASS
				struct_inh      inh;
			};
			OB_CONST_REF        descriptor;             // Textual description
			ULONG               help_id;

		} OB_PERM_CLASS_ENTRY, FAR* POB_PERM_CLASS_ENTRY;

		//****************************************************************************
		// API for OB_PERM_CLASS_ENTRY
		//****************************************************************************

#define OB_CLASS_STATUS_MASK            0x0001              // 1 bits
#define OB_CLASS_STYLE_MASK             0x000e              // 3 bits
#define OB_CLASS_PROTOBLOCK_MASK        0x0010              // 1 bits
#define OB_CLASS_INSTVARBLOCK_MASK      0x0020              // 1 bits
#define OB_CLASS_FWDPROTOBLOCK_MASK     0x0040              // 1 bits
#define OB_CLASS_TYPESOURCE_MASK        0x0080              // 1 bits
#define OB_CLASS_AUTOINSTANTIATE_MASK   0x0100              // 1 bits

#define OB_CLASS_STATUS_SHIFT           0
#define OB_CLASS_STYLE_SHIFT            1
#define OB_CLASS_PROTOBLOCK_SHIFT       4
#define OB_CLASS_INSTVARBLOCK_SHIFT     5
#define OB_CLASS_FWDPROTOBLOCK_SHIFT    6
#define OB_CLASS_TYPESOURCE_SHIFT       7
#define OB_CLASS_AUTOINSTANTIATE_SHIFT  8


#define ob_get_class_entry_status(obthis,class_entry)                       \
    ob_get_bitfield ((class_entry)->perm_entry->info, UINT,                 \
        OB_CLASS_STATUS_SHIFT, OB_CLASS_STATUS_MASK)

#define ob_set_class_entry_status(obthis,class_entry,status)                \
    ob_set_bitfield ((class_entry)->perm_entry->info, USHORT, status,       \
        OB_CLASS_STATUS_SHIFT, OB_CLASS_STATUS_MASK)

#define ob_get_class_entry_style(obthis,class_entry)                        \
    ob_get_bitfield ((class_entry)->perm_entry->info, OB_CLASS_STYLE,       \
        OB_CLASS_STYLE_SHIFT, OB_CLASS_STYLE_MASK)

#define ob_set_class_entry_style(obthis,class_entry,style)                  \
    ob_set_bitfield ((class_entry)->perm_entry->info, USHORT, style,        \
        OB_CLASS_STYLE_SHIFT, OB_CLASS_STYLE_MASK)

#define ob_get_class_has_proto_block(obthis,class_entry)                    \
    ob_get_bitfield ((class_entry)->perm_entry->info, BOOL,                 \
        OB_CLASS_PROTOBLOCK_SHIFT, OB_CLASS_PROTOBLOCK_MASK)

#define ob_set_class_has_proto_block(obthis,class_entry,protoblock)         \
    ob_set_bitfield ((class_entry)->perm_entry->info, USHORT, protoblock,   \
        OB_CLASS_PROTOBLOCK_SHIFT, OB_CLASS_PROTOBLOCK_MASK)

#define ob_get_class_has_instvar_block(obthis,class_entry)                  \
    ob_get_bitfield ((class_entry)->perm_entry->info, BOOL,                 \
        OB_CLASS_INSTVARBLOCK_SHIFT, OB_CLASS_INSTVARBLOCK_MASK)

#define ob_set_class_has_instvar_block(obthis,class_entry,instvarblock)     \
    ob_set_bitfield ((class_entry)->perm_entry->info, USHORT, instvarblock, \
        OB_CLASS_INSTVARBLOCK_SHIFT, OB_CLASS_INSTVARBLOCK_MASK)

#define ob_get_class_has_fwdproto_block(obthis,class_entry)                 \
    ob_get_bitfield ((class_entry)->perm_entry->info, BOOL,                 \
        OB_CLASS_FWDPROTOBLOCK_SHIFT, OB_CLASS_FWDPROTOBLOCK_MASK)

#define ob_set_class_has_fwdproto_block(obthis,class_entry,fwdprotoblock)   \
    ob_set_bitfield ((class_entry)->perm_entry->info, USHORT, fwdprotoblock,\
        OB_CLASS_FWDPROTOBLOCK_SHIFT, OB_CLASS_FWDPROTOBLOCK_MASK)

#define ob_get_class_has_type_source(obthis,class_entry)                    \
    ob_get_bitfield ((class_entry)->perm_entry->info, BOOL,                 \
        OB_CLASS_TYPESOURCE_SHIFT, OB_CLASS_TYPESOURCE_MASK)

#define ob_set_class_has_type_source(obthis,class_entry,typesource)         \
    ob_set_bitfield ((class_entry)->perm_entry->info, USHORT, typesource,   \
        OB_CLASS_TYPESOURCE_SHIFT, OB_CLASS_TYPESOURCE_MASK)

#define ob_is_class_autoinstantiate(obthis,class_entry)                     \
    ((class_entry != NULL) ?  ob_get_bitfield ((class_entry)->perm_entry->info, BOOL, \
        OB_CLASS_AUTOINSTANTIATE_SHIFT, OB_CLASS_AUTOINSTANTIATE_MASK) : FALSE)

#define ob_set_class_autoinstantiate(obthis,class_entry,autoinstanced)      \
    ob_set_bitfield ((class_entry)->perm_entry->info, USHORT, autoinstanced,\
        OB_CLASS_AUTOINSTANTIATE_SHIFT, OB_CLASS_AUTOINSTANTIATE_MASK)

#define ob_get_class_entry_id(obthis,class_entry)                           \
    ((class_entry)->perm_entry->class_id)

#define ob_get_class_inh_sec_class(obthis,class_entry)                      \
    ((class_entry)->perm_entry->inh.sec_class)

#define ob_get_class_inh_sec_grp_class(obthis,class_entry)                  \
    ((class_entry)->perm_entry->inh.sec_group_class)

#define ob_set_class_inh_sec_class(obthis,class_entry,class_id)             \
    (class_entry)->perm_entry->inh.sec_class = (class_id)

#define ob_set_class_inh_sec_grp_class(obthis,class_entry,class_id)         \
    (class_entry)->perm_entry->inh.sec_group_class = (class_id)

#define ob_get_class_descriptor(obthis,conpool,class_entry)                     \
    (((class_entry)->perm_entry->descriptor == OB_CONST_NOT_DEFINED) ? NULL :   \
        ((LPTSTR) ob_get_const_data (obthis,                                \
                conpool, (class_entry)->perm_entry->descriptor)))

#define ob_get_class_descriptor_ref(obthis,class_entry)                             \
    ((OB_CONST_REF) (class_entry)->perm_entry->descriptor)

#define ob_set_class_descriptor_ref(obthis,class_entry,descriptorcr)                \
    ((class_entry)->perm_entry->descriptor = (OB_CONST_REF)(descriptorcr))

#define ob_get_class_help_id(obthis,class_entry)                            \
    ((class_entry)->perm_entry->help_id)

#define ob_set_class_help_id(obthis,class_entry,help_id)                    \
    ((class_entry)->perm_entry->help_id) = (help_id)

//****************************************************************************
// Runtime class entry structure
//****************************************************************************

		typedef struct ob_class_entry
		{
			LPTSTR                      source;                 // Object class source.
			UINT                        len;                    // Len of obj class source.
			POB_PERM_CLASS_ENTRY        perm_entry;             // Pointer to parallel perm entry
			POB_CLASS_DEF               def_entry;              // Pointer to class def
			OB_LOOK_SYMTAB              field_symtab;           // Field symbol table.
			POB_PERM_PROTOTYPE          perm_prototypes;        // Permanent prototype list
			POB_PROTOTYPE               prototypes;             // Prototype list
			OB_MOD_SYMTAB               mod_symtab;             // Module symbol table.
			POB_ROUTLIST                routine_list;           // Module routine list.
			POB_VIRTUAL_NODE            rout_vtable;            // Virt routine lookup
			POB_EVENT_LOOKUP_ITEM       event_lookup;           // Token to VTID lookup
			POB_PERM_VIRTUAL_NODE       perm_rout_vtable;       // Disk based rout vtab
			POB_INDATTR_FUNCTMPLT       indattr_functmplt;      // Indirect attr func template
			POB_DATA                    instance_image;         // Image of new class instance
			LPTSTR                      instvar_source;         // Instance variable source.
			UINT                        instvar_source_len;     // Inst source len.
			LPTSTR                      prototype_source;       // Prototype source
			UINT                        prototype_source_len;   // Prototype source len.
			LPTSTR                      fwdproto_source;        // Forward ref prototypes
			UINT                        fwdproto_source_len;    // Forward ref proto lenght
			INT                         field_sum;              // Number of inherited fields
			OB_EVT_TOKEN_ID             cached_event_token1;    // Last event token ref
			UINT                        cached_event_no1;       // Last event ref
			OB_EVT_TOKEN_ID             cached_event_token2;    // Last event token ref
			UINT                        cached_event_no2;       // Last event ref
			OB_EVT_TOKEN_ID             cached_event_token3;    // Last event token ref
			UINT                        cached_event_no3;       // Last event ref
			POB_ENUMFIELD               enumlist;
			POB_RUNTIME_CLASS           runtime_class;
			PVOID                       propertyVariables;      // Cached list of cached variables (a PPBVarDefLocal)
			LONG                        numPropertyVariables;   // How many propertyVariables
			PVOID                       scriptList;             // Cached list of cached scripts (a PPBScriptDefLocal)
			LONG                        numScripts;             // How many scripts
		} OB_CLASS_ENTRY, FAR* POB_CLASS_ENTRY;

		//****************************************************************************
		// API for OB_CLASS_ENTRY
		//****************************************************************************

#define ob_get_class_prototype(obthis,class_entry,proto_id)                 \
    ((POB_PROTOTYPE)((class_entry)->prototypes+proto_id))

#define ob_get_class_vtable_entry(obthis,class_entry,vtable_id)             \
    ((POB_VIRTUAL_NODE)((class_entry)->rout_vtable+vtable_id))

#define ob_get_class_event_lookup_table(obthis,class_entry)                 \
    ((POB_EVENT_LOOKUP_ITEM)((class_entry)->event_lookup))

#define ob_get_class_event_lookup_table_item(obthis,class_entry,pos)        \
    ((POB_EVENT_LOOKUP_ITEM)((class_entry)->event_lookup+pos))

#define ob_get_class_event_lookup_token(obthis,class_entry,pos)             \
    (ob_get_event_lookup_item_token(obthis,                                 \
        ob_get_class_event_lookup_table_item(obthis,class_entry,pos)))

#define ob_set_class_event_lookup_token(obthis,class_entry,pos,val)         \
    (ob_set_event_lookup_item_token(obthis,                                 \
        ob_get_class_event_lookup_table_item(obthis,class_entry,pos),       \
        (val)))

#define ob_get_class_event_lookup_vtable_id(obthis,class_entry,pos)         \
    (ob_get_event_lookup_item_id(obthis,                                    \
        ob_get_class_event_lookup_table_item(obthis,class_entry,pos)))

#define ob_set_class_event_lookup_vtable_id(obthis,class_entry,pos,val)     \
    (ob_set_event_lookup_item_id(obthis,                                    \
        ob_get_class_event_lookup_table_item(obthis,class_entry,pos),       \
        (val)))

// This guy returns the number of fields defined locally in the class
//  use ob_get_class_no_instance_image for the number of fields in an instance
#define ob_get_class_no_fields(obthis,class_entry)                          \
    (ob_looksym_no_entries((class_entry)->field_symtab))

//****************************************************************************
// Typedef description table structure.
//****************************************************************************

		typedef struct perm_type_descript
		{
			USHORT                  no_slots;           // Number of slots in table.
			USHORT                  no_def_slots;       // Number of slots in class def

		} OB_PERM_TYPE_DESCRIPT;

		typedef struct temp_type_descript
		{
			POB_PERM_CLASS_ENTRY    perm_table;         // Pointer to permanent table.
			POB_CLASS_ENTRY         table;              // Pointer to temporary table.
			POB_CLASS_DEF           def_table;          // Pointer to class def table.
			UINT                    perm_alloc_size;    // Current allocation size.
			UINT                    perm_alloc_incr;    // Allocation increment.
			UINT                    alloc_size;         // Current allocation size.
			UINT                    alloc_incr;         // Allocation increment.
			UINT                    def_alloc_size;     // Current allocation size.
			UINT                    def_alloc_incr;     // Allocation increment.
			UINT                    slot_incr;          // No of slots to increment.
			UINT                    next_free;          // Next free slot.
			UINT                    next_free_def;      // Next free slot in class def.

		} OB_TEMP_TYPE_DESCRIPT;

		typedef struct ob_type_descript
		{
			OB_PERM_TYPE_DESCRIPT   ps;
			OB_TEMP_TYPE_DESCRIPT   ts;

		} OB_TYPE_DESCRIPT, FAR* POB_TYPE_DESCRIPT;

		//****************************************************************************
		// Main typedef structure
		//****************************************************************************

		typedef struct ob_typedef
		{
			OB_LOOK_SYMTAB          type_symtab;        // Types lookup symbol table
			OB_ENUM_SYMTAB          enum_symtab;        // Enum lookup symbol table
			POB_CONPOOL             conpool;            // Types constant pool.
			POB_TYPE_DESCRIPT       descript;           // Types description table.
			POB_CONPOOL             arg_conpool;        // Proto arg info

		} OB_TYPEDEF, FAR* POB_TYPEDEF;

		//****************************************************************************
		// Type info structure. Used to pass info about typedefs.
		//****************************************************************************

#define TYPEINFO_CONSTANT_MASK      0x0001              // 1 bit
#define TYPEINFO_INDIRECT_MASK      0x0002              // 1 bit
#define TYPEINFO_ISWRITE_MASK       0x0004              // 1 bit
#define TYPEINFO_ISREAD_MASK        0x0008              // 1 bit
#define TYPEINFO_ISINHERITED_MASK   0x0010              // 1 bit
#define TYPEINFO_ISSYSTEM_MASK      0x0020              // 1 bit

#define TYPEINFO_CONSTANT_SHIFT     0
#define TYPEINFO_INDIRECT_SHIFT     1
#define TYPEINFO_ISWRITE_SHIFT      2
#define TYPEINFO_ISREAD_SHIFT       3
#define TYPEINFO_ISINHERITED_SHIFT  4
#define TYPEINFO_ISSYSTEM_SHIFT     5

		typedef struct ob_typeinfo
		{
			LPTSTR                  name;
			OB_DATA                 data;
			OB_GROUP_ID             source_group_id;// the group id where data came from
			OB_GROUP_ID             group_id;       // the leaf level group id
			OB_CLASS_ID             class_id;       // the leaf level class id
			POB_ARRAYDEF            arrdef;
			OB_MEMBER_ACCESS        scope;          // public, private, protected, system
			OB_MEMBER_ACCESS        read_access;    //private = privateread, etc.
			OB_MEMBER_ACCESS        write_access;   //private = privatewrite, etc.
			UINT                    flags;
			LPTSTR                  set_func;
			LPTSTR                  get_func;
			LPTSTR                  array_set_func;
			LPTSTR                  array_get_func;
			LPTSTR                  array_upper_func;
		} OB_TYPEINFO, FAR* POB_TYPEINFO;

#define ob_get_typeinfo_constant(flags)   \
    ob_get_bitfield(flags,INT,TYPEINFO_CONSTANT_SHIFT,TYPEINFO_CONSTANT_MASK)

#define ob_get_typeinfo_indirect(flags)   \
    ob_get_bitfield(flags,INT,TYPEINFO_INDIRECT_SHIFT,TYPEINFO_INDIRECT_MASK)

#define ob_get_typeinfo_iswrite(flags)   \
    ob_get_bitfield(flags,INT,TYPEINFO_ISWRITE_SHIFT,TYPEINFO_ISWRITE_MASK)

#define ob_get_typeinfo_isread(flags)   \
    ob_get_bitfield(flags,INT,TYPEINFO_ISREAD_SHIFT,TYPEINFO_ISREAD_MASK)

#define ob_get_typeinfo_isinherit(flags)   \
    ob_get_bitfield(flags,INT,TYPEINFO_ISINHERITED_SHIFT,TYPEINFO_ISINHERITED_MASK)

#define ob_get_typeinfo_issystem(flags)   \
    ob_get_bitfield(flags,INT,TYPEINFO_ISSYSTEM_SHIFT,TYPEINFO_ISSYSTEM_MASK)

#define ob_set_typeinfo_constant(flags,cval)   \
    ob_set_bitfield(flags,INT,cval,TYPEINFO_CONSTANT_SHIFT,TYPEINFO_CONSTANT_MASK)

#define ob_set_typeinfo_indirect(flags,ival)   \
    ob_set_bitfield(flags,INT,ival,TYPEINFO_INDIRECT_SHIFT,TYPEINFO_INDIRECT_MASK)

#define ob_set_typeinfo_iswrite(flags,ival)   \
    ob_set_bitfield(flags,INT,ival,TYPEINFO_ISWRITE_SHIFT,TYPEINFO_ISWRITE_MASK)

#define ob_set_typeinfo_isread(flags,ival)   \
    ob_set_bitfield(flags,INT,ival,TYPEINFO_ISREAD_SHIFT,TYPEINFO_ISREAD_MASK)

#define ob_set_typeinfo_isinherit(flags,ival)   \
    ob_set_bitfield(flags,INT,ival,TYPEINFO_ISINHERITED_SHIFT,TYPEINFO_ISINHERITED_MASK)

#define ob_set_typeinfo_issystem(flags,ival)   \
    ob_set_bitfield(flags,INT,ival,TYPEINFO_ISSYSTEM_SHIFT,TYPEINFO_ISSYSTEM_MASK)

		//****************************************************************************
		// Data flags masks and shifts
		//****************************************************************************

#define OB_ACTARG_GROUPING_MASK         0x0001              // 1 bit
#define OB_ACTARG_IS_LVALUE_MASK        0x0002              // 1 bit

#define OB_ACTARG_GROUPING_SHIFT         0
#define OB_ACTARG_IS_LVALUE_SHIFT        1

//****************************************************************************
//  Routine argument structure. Used by type_rout_ref calls.
//****************************************************************************

		typedef struct ob_act_arg
		{
			OB_CLASS_ID             datatype;
			OB_GROUP_ID             group_id;
			USHORT                  info;           // Info flags contains:
		//  OB_GROUPTYPE            grouping;           :1 OB_SIMPLE | OB_ARRAY
		//  BOOL                    is_lvalue;          :1
			ULONG                   num_dims;       // the number of dimensions
			PLONG                   dimensions;
		} OB_ACT_ARG, FAR* POB_ACT_ARG;

		//****************************************************************************
		// Wrapper macros for POB_PROTO_ARG
		//****************************************************************************

#define ob_get_act_arg_data_type(obthis,actarg)                                     \
    ((OB_CLASS_ID) (actarg)->datatype)

#define ob_set_act_arg_data_type(obthis,proto,cid)                              \
    ((proto)->datatype = (OB_CLASS_ID)(cid))

#define ob_get_act_arg_group_id(obthis,actarg)                              \
    ((OB_GROUP_ID) (actarg)->group_id)

#define ob_set_act_arg_group_id(obthis,proto,gid)                           \
    ((proto)->group_id = (OB_GROUP_ID)(gid))

#define ob_get_act_arg_grouping(obthis,actarg)                              \
    ((OB_GROUPTYPE) (((actarg)->info & OB_ACTARG_GROUPING_MASK) >>          \
                OB_PROTOARG_GROUPING_SHIFT))

#define ob_set_act_arg_grouping(obthis,actarg,grouping)                     \
    ((actarg)->info = (USHORT)(((grouping) << OB_ACTARG_GROUPING_SHIFT) |   \
                ((actarg)->info & ~OB_ACTARG_GROUPING_MASK)))

#define ob_get_act_arg_is_lvalue(obthis,actarg)                             \
    ((BOOL) (((actarg)->info & OB_ACTARG_IS_LVALUE_MASK) >>                 \
                OB_ACTARG_IS_LVALUE_SHIFT))

#define ob_set_act_arg_is_lvalue(obthis,actarg,is_lvalue)                   \
    ((actarg)->info = (USHORT)(((is_lvalue) << OB_ACTARG_IS_LVALUE_SHIFT) | \
                ((actarg)->info & ~OB_ACTARG_IS_LVALUE_MASK)))

#define ob_get_act_arg_num_dims(obthis,actarg)                              \
    ((LONG) (((actarg)->num_dims)))

#define ob_set_act_arg_num_dims(obthis,actarg,num)                          \
    ((actarg)->num_dims = (num))

#define ob_get_act_arg_dimensions(obthis,actarg)                            \
    ((PLONG) (((actarg)->dimensions)))

#define ob_set_act_arg_dimensions(obthis,actarg,dims)                       \
    ((actarg)->dimensions = (dims))


//****************************************************************************
//  Prototype namelist structure. Used by type_proto_names calls.
//****************************************************************************

		typedef struct ob_protoname
		{
			OB_GROUP_ID             group_id;
			OB_CLASS_ID             class_id;
			OB_PROTO_ID             proto_id;
			OB_VTABLE_ID            vtable_id;
			OB_ROUT_TYPE            rout_type; // FUNC or EVENT
			LPTSTR                  protoname;
			LPTSTR                  classname;
			BOOL                    is_a_dllfunc;
			BOOL                    is_a_dbrpc;     // Database RPC call (handled like a 'is_a_dllfunc')
			OB_EVT_TOKEN_ID         token;
			OB_CLASS_ID             type;
			POB_PROTO_ARG           args;
			UINT                    no_args;
		} OB_PROTONAME, FAR* POB_PROTONAME;

		//****************************************************************************
		// This structure access
		//****************************************************************************

#define ob_get_sys_typedef_group(obthis)                                    \
            ((POB_GROUP) ((obthis)->sys_typedef_group))

#define ob_get_sys_typedef_group_id(obthis)                                 \
            (ob_get_group_id (obthis, ob_get_sys_typedef_group(obthis)))

#define ob_get_sys_typedef(obthis)                                          \
            ((obthis)->sys_typedef_group == NULL ?                          \
              NULL :                                                        \
              ((POB_GROUP)(obthis)->sys_typedef_group)->typdef              \
            )

#define ob_set_sys_typedef_group(obthis,sys_typdef_group)                   \
            ( (obthis)->sys_typedef_group = (sys_typdef_group),             \
              (obthis)->sys_group_hndl =                                    \
                    ob_get_group_id (obthis, (POB_GROUP) sys_typdef_group)  \
            )

//****************************************************************************
// Reserved event constants
//****************************************************************************

#define OB_ONCREATE_SLOT        0
#define OB_ONDESTROY_SLOT       1
#define OB_EVENT_OFFSET         2

//****************************************************************************
// Class name/id package. For runtime/development time object instantiation
//      execution choice.
//****************************************************************************

		typedef struct ob_class_nameid
		{
			OB_CONST_REF    name;
			OB_CLASS_ID     class_id;
			SHORT           padding;

		} OB_CLASS_NAMEID, FAR* POB_CLASS_NAMEID;

		//****************************************************************************
		// Routine name/id package. For runtime/development time function
		//      execution choice.
		//****************************************************************************

		typedef struct ob_rout_nameid
		{
			USHORT          id;
			OB_CLASS_ID     class_id;
			OB_CONST_REF    name;

		} OB_ROUT_NAMEID, FAR* POB_ROUT_NAMEID;

		//****************************************************************************
		// Field name/id package. For runtime/development time execution choice
		//****************************************************************************

		typedef struct ob_field_nameid
		{
			OB_CONST_REF    name;
			USHORT          id;
			OB_CLASS_ID     type;

		} OB_FIELD_NAMEID, FAR* POB_FIELD_NAMEID;

		//****************************************************************************
		// Macro Definitions:
		//   Use ob_access_class_entry when no error checking is necessary.
		//   Use ob_fetch_class_entry when error check is needed.
		//   Use ob_class_entry when class indirection is needed.
		//****************************************************************************

#define ob_access_class_entry(obthis,group,class_id)                        \
            ob_get_group_typdef (obthis, group)->descript->ts.table +       \
                ob_looksym_get_id (ob_get_group_type_symtab(obthis, group), \
                ob_get_type_id (class_id))

//**************************************************************************
//    Notes:    Differs from ob_get_class_entry in that a class indirection
//              is not done. The class entry returned is the one pointed to
//              by the input parameters. The macro replaces the original
//              function for performance reasons.
//**************************************************************************

#define ob_fetch_class_entry(obthis, group, class_id) \
  ( (UINT)ob_get_type_id (class_id) >= \
      (UINT)ob_looksym_no_entries (ob_get_group_type_symtab(obthis,group)) || \
    ob_looksym_status (ob_get_group_type_symtab (obthis, group), \
                       ob_get_type_id (class_id)) == FREE ? \
    NULL : \
    (ob_access_class_entry(obthis,group,class_id)))

#define ob_class_entry(obthis,group,class_id)                               \
            (                                                               \
            ob_class_indirect (obthis, group, class_id),                    \
            ((*class_id) != UNDECLARED_TYPE ?                               \
                ob_fetch_class_entry (obthis, *(group), *(class_id)) :      \
                NULL)                                                                           \
            )

#define  ob_type_name(obthis,group,class_id)                                \
            (ob_looksym_name (obthis,                                       \
                ob_get_group_type_symtab (obthis, group),                   \
                ob_get_type_id (class_id))                                  \
        )

#define  ob_classhndl_name(obthis,classhndl)                                \
            ob_type_name(obthis,ob_group_data(obthis,classhndl.group_hndl), \
                            classhndl.class_id)

//****************************************************************************
// Function prototypes
//****************************************************************************

#define TYPDEF_NO_ERROR                 0
#define TYPDEF_CONPOOL_FILLED           1
#define TYPDEF_BAD_CLASS                2
#define TYPDEF_BAD_ACCESS_RIGHTS        3

		POB_TYPEDEF                     ob_init_typedef
		(
			POB_THIS                obthis,
			INT                     no_types,
			INT                     no_enums,
			OB_SUBPOOL              subpool
		);

		PBWINAPI(OB_CLASS_ID, ob_type_declare)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				LPTSTR                  type_name,
				OB_TYPE_KIND            type_kind,
				OB_CLASS_STYLE          style,
				OB_CLASS_ID             parent_type,
				OB_CLASS_ID             nested_type,
				BOOL                    autoinstantiate,
				PINT                    error
				);

		PBWINAPI(OB_CLASS_ID, ob_type_declare_class)
			(
				POB_THIS            obthis,
				POB_GROUP           group,
				LPTSTR              type_name,
				OB_TYPE_KIND        type_kind,
				OB_CLASS_STYLE      class_style,
				OB_CLASS_ID         parent_class,
				OB_CLASS_ID         nested_class,
				BOOL                autoinstantiate,
				PINT                error
				);

		PBWINAPI(VOID, ob_type_declare_vtab)
			(
				POB_THIS            obthis,
				POB_GROUP           group,
				OB_CLASS_ID         class_id,
				OB_CLASS_ID         parent_class,
				PINT                error
				);

		OB_CLASS_ID                     ob_inherited_type_declare
		(
			POB_THIS                obthis,
			POB_GROUP               group,
			LPTSTR                  type_name,
			OB_TYPE_KIND            type_kind,
			OB_CLASS_ID             sec_class,
			OB_CLASS_ID             sec_group_class,
			PINT                    error
		);

		OB_CLASS_ID                     ob_indirect_type_declare
		(
			POB_THIS                obthis,
			POB_GROUP               local_group,
			LPTSTR                  type_name,
			UINT                    indirect_slot,
			PINT                    error
		);

		// PB11 language enhancement -- namespace
		LPTSTR ob_get_pure_type_name
		(
			POB_THIS        obthis,
			LPTSTR          type_name,
			BOOL            suffix_appended
		);

		PBWINAPI(OB_CLASS_ID, ob_type_reference)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				LPTSTR                  type_name
				);

		OB_CLASS_ID                     ob_sec_class_ref
		(
			POB_THIS                obthis,
			POB_GROUP FAR* group,
			OB_CLASS_ID             primary_class_id,
			LPTSTR                  name
		);

		OB_CLASS_ID                     ob_set_inherited_class
		(
			POB_THIS                obthis,
			POB_GROUP               target_group,
			LPTSTR                  primary_class_name,
			LPTSTR                  type_name,
			OB_CLASS_ID             target_nested_class_id,
			PINT                    error
		);

		INT                             ob_promote_class_from_parent
		(
			POB_THIS                obthis,
			LPTSTR                  type_name,
			POB_GROUP               target_group,
			OB_CLASS_ID             target_class_id
		);

		VOID                            ob_type_delete
		(
			POB_THIS                obthis,
			POB_GROUP               group,
			OB_CLASS_ID             class_id
		);

		INT                             ob_type_rename
		(
			POB_THIS                obthis,
			POB_GROUP               group,
			OB_CLASS_ID             class_id,
			LPTSTR                  newname
		);

		VOID                            ob_type_set_source
		(
			POB_THIS                obthis,
			POB_GROUP               group,
			OB_CLASS_ID             class_id,
			LPTSTR                  source,
			UINT                    len
		);

		LPTSTR                          ob_type_get_source
		(
			POB_THIS                obthis,
			POB_GROUP               group,
			OB_CLASS_ID             class_id,
			PUINT                   len
		);

		VOID                            ob_del_typdef
		(
			POB_THIS                obthis,
			POB_TYPEDEF             typdef
		);

		OB_ERROR                        ob_typedef_write
		(
			POB_THIS                obthis,
			POB_TYPEDEF             typdef,
			POB_GROUP               pGroup
		);

		POB_TYPEDEF                     ob_typedef_read
		(
			POB_THIS                obthis,
			UINT                    slot_incr,
			POB_GROUP               group,
			OB_SUBPOOL              subpool
		);

		INT                             ob_build_typedef_tables
		(
			POB_THIS                obthis,
			POB_GROUP               group
		);

		PBWINAPI(LPTSTR, ob_get_first_type)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				POB_CLASS_ID            class_id,
				POB_CLASS_STYLE         style
				);

		PBWINAPI(LPTSTR, ob_get_next_type)
			(
				POB_THIS                obthis,
				POB_CLASS_ID            class_id,
				POB_CLASS_STYLE         style
				);

		PBWINAPI(VOID, ob_type_init_process)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id,
				OB_CLASS_STYLE          class_style
				);

		PBWINAPI(VOID, ob_type_decl_process)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id
				);

		PBWINAPI(OB_CLASS_ID, ob_get_nested_class)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id
				);

		PBWINAPI(POB_CLASS_ENTRY, ob_get_class_entry)
			(
				POB_THIS                obthis,
				POB_GROUP FAR* group,
				OB_CLASS_ID             class_id
				);

		PBWINAPI(BOOL, ob_is_class_indirect)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id
				);

		PBWINAPI(POB_ROUTNODE, ob_fetch_routine)
			(
				POB_CLASS_ENTRY         class_entry,
				OB_ROUT_ID              rout_id,
				POB_ROUT_TYPE           type
				);

		POB_CLASS_INFO                  ob_get_group_class_info
		(
			POB_THIS                obthis,
			POB_GROUP               group,
			PUINT                   total_items
		);

		//****************************************************************************
		// Function prototypes in obrouts.c
		//****************************************************************************

#define PROTODECL_NO_ERROR          0
#define PROTODECL_DUP_FUNC          1
#define PROTODECL_CONPOOL_FILLED    2

		PBWINAPI(OB_PROTO_ID, ob_type_proto_decl)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id,
				LPTSTR                  name,
				OB_ROUT_TYPE            rout_type, // FUNC or EVENT
				OB_CLASS_ID             type,
				OB_MODULE_ID            mod_id,
				POB_PROTO_ARG           args,
				UINT                    no_args,
				OB_FUNC_TYPE            func_type,
				LPTSTR                  dllname,
				LPTSTR                  aliasname,
				OB_VTABLE_ID            sys_func_id,
				OB_FUNCPROTO_STYLE      proto_style,
				OB_MEMBER_ACCESS        member_access,
				BOOL                    is_obsolete,
				BOOL                    is_local_decl,
				OB_EVT_TOKEN_ID         token_id,
				BOOL                    is_event_external,
				POB_CLASS_ID            throws_list,
				UINT                    no_throws,
				PINT                    error
				);

		PBWINAPI(OB_MODULE_ID, ob_type_proto_ref)
			(
				POB_THIS                obthis,
				POB_GROUP FAR* group,
				POB_CLASS_ID            class_id,
				LPTSTR                  funcname,
				OB_ROUT_TYPE            rout_type, // FUNC or EVENT
				OB_MEMBER_ACCESS_TYPE   access_type,
				POB_ACT_ARG FAR* funcargs,
				UINT                    no_args,
				POB_CLASS_ID            ret_type,
				POB_FUNC_TYPE           func_type,
				LPTSTR FAR* dllname,
				POB_PROTO_ID            proto_id,
				POB_VTABLE_ID           vtable_id,
				POB_PROTOREF_ERROR      error,
				BOOL                    bound_exact_match = TRUE
				);

		PBWINAPI(PBRESULT, ob_lookup_routine_by_signature)
			(
				POB_THIS                obthis,
				POB_GROUP FAR* pGroup,
				POB_CLASS_ID            classId,
				LPTSTR                  lpstrRoutineName,
				LPTSTR                  lpstrSignature,
				POB_VTABLE_ID           pVtableId,
				POB_GROUP FAR* ppProtoGroup,
				POB_PROTOTYPE FAR* ppPrototype,
				POB_PROTOREF_ERROR      pError,
				BOOL                    bLookupPublicOnly   // Only find routines that are public access
				);

		PBWINAPI(OB_PROTOREF_ERROR, ob_proto_error_upgrade)
			(
				POB_THIS                obthis,
				OB_PROTOREF_ERROR       currerror,
				OB_PROTOREF_ERROR       newerror
				);

		OB_VTABLE_ID                ob_type_nonov_proto_ref
		(
			POB_THIS                obthis,
			POB_GROUP FAR* group,
			POB_CLASS_ID            class_id,
			LPTSTR                  name,
			OB_ROUT_TYPE            rout_type, // FUNC or EVENT
			POB_CLASS_ID            type,
			POB_PROTO_ARG FAR* arglist,
			PUINT                   noargs,
			POB_PROTO_ID            proto_id
		);

		PBWINAPI(OB_MEMBER_ACCESS_TYPE, ob_get_proto_access_type)
			(
				POB_THIS                obthis,
				POB_GROUP               curr_group,
				OB_CLASS_ID             curr_class_id,
				POB_GROUP               formal_arg_group,
				OB_CLASS_ID             formal_arg_class_id
				);

		VOID                            ob_proto_reset
		(
			POB_THIS                obthis
		);

		PBWINAPI(VOID, ob_type_process_protos)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id
				);

		PBWINAPI(INT, ob_type_reprocess_protos)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id,
				LPTSTR                  delete_proto_name,
				OB_ROUT_TYPE            delete_proto_rout_type,
				POB_PROTO_ARG           delete_proto_args,
				UINT                    delete_proto_no_args,
				BOOL                    filter_userprotos
				);

		PBWINAPI(OB_PROTO_ID, ob_type_proto_add)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id,
				LPTSTR                  name,
				OB_ROUT_TYPE            rout_type, // FUNC or EVENT
				OB_CLASS_ID             type,
				OB_MODULE_ID            mod_id,
				UINT                    no_args,
				POB_PROTO_ARG           args,
				OB_FUNC_TYPE            func_type,
				LPTSTR                  dllname,
				LPTSTR                  aliasname,
				OB_VTABLE_ID            sys_func_id,
				OB_FUNCPROTO_STYLE      proto_style,
				OB_MEMBER_ACCESS        member_access,
				BOOL                    is_obsolete,
				BOOL                    is_local_decl,
				OB_EVT_TOKEN_ID         token_id,
				BOOL                    is_external_event,
				POB_CLASS_ID            throws_list,
				UINT                    no_throws,
				PINT                    error
				);

		OB_PROTO_ID ob_type_proto_clone
		(
			POB_THIS                obthis,
			POB_GROUP               source_group,
			OB_CLASS_ID             source_class_id,
			OB_VTABLE_ID            source_vtable_id,
			POB_GROUP               target_group,
			OB_CLASS_ID             target_class_id,
			PINT                    error
		);

		INT                             ob_type_proto_delete
		(
			POB_THIS                obthis,
			POB_GROUP               group,
			OB_CLASS_ID             class_id,
			OB_PROTO_ID             proto_id
		);

		UINT                            ob_get_no_inh_protos
		(
			POB_THIS                obthis,
			POB_GROUP               group,
			OB_CLASS_ID             class_id,
			PBOOL                   error
		);

		PBWINAPI(POB_PROTONAME, ob_get_type_proto_names)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id,
				OB_ROUT_TYPE            rout_type, // FUNC or EVENT
				BOOL                    include_ancestors,
				BOOL                    local_protos_only,
				PUINT                   nprotos,
				PBOOL                   error
				);

		PBWINAPI(VOID, ob_declare_external_event_type)
			(
				POB_THIS            obthis,
				POB_GROUP           group,
				OB_CLASS_ID         class_id,
				OB_CLASS_ID         parent_class,
				PINT                error
				);

		// Only used for Watcom C++ Class Builder
		PBWINAPI(POB_PROTONAME, ob_get_type_proto_names_for_ide)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id,
				OB_ROUT_TYPE            rout_type, // FUNC or EVENT
				BOOL                    include_ancestors,
				BOOL                    local_protos_only,
				PUINT                   nprotos,
				PBOOL                   error
				);

		VOID                        ob_get_ancestor_from_vtable_id
		(
			POB_THIS                obthis,
			POB_GROUP FAR* group,
			POB_CLASS_ENTRY FAR* p_class_entry,
			OB_VTABLE_ID            vtable_id
		);

		PBWINAPI(OB_PROTO_ID, ob_type_vtable_module_srch)
			(
				POB_THIS                obthis,
				POB_GROUP FAR* group,
				POB_CLASS_ID            class_id,
				OB_VTABLE_ID            vtable_id
				);

		PBWINAPI(POB_PROTOTYPE, ob_get_prototype)
			(
				POB_THIS                obthis,
				POB_GROUP FAR* curr_group,
				POB_CLASS_ID            curr_class_id,
				OB_VTABLE_ID            vtable_id
				);

		PBWINAPI(VOID, ob_update_proto_mod_id)
			(
				POB_THIS                obthis,
				OB_PROTO_ID             proto_id,
				OB_MODULE_ID            mod_id
				);

		PBWINAPI(VOID, ob_update_proto_rout_id)
			(
				POB_THIS                obthis,
				OB_PROTO_ID             proto_id,
				OB_ROUT_ID              rout_id
				);

		PBWINAPI(INT, ob_protolist_read)
			(
				POB_THIS                obthis,
				POB_CLASS_ENTRY         class_entry,
				OB_SUBPOOL              subpool
				);

		PBWINAPI(OB_ERROR, ob_protolist_write)
			(
				POB_THIS                obthis,
				POB_CLASS_ENTRY         class_entry
				);

		BOOL ob_prototype_match
		(
			POB_THIS                    obthis,
			POB_GROUP                   group,
			POB_PROTOTYPE               proto,
			LPTSTR                      name,
			POB_GROUP                   proto_group,
			OB_CLASS_ID                 result_type,
			POB_PROTO_ARG               args,
			UINT                        no_args,
			OB_ROUT_TYPE                rout_type,
			POB_PROTO_OVERLOAD_ERROR    error
		);
		//cr463327
		PBWINAPI(BOOL, ob_prototype_match_for_event)
			(
				POB_THIS                    obthis,
				POB_GROUP                   group,
				POB_PROTOTYPE               proto,
				POB_GROUP                   proto_group,
				OB_CLASS_ID                 result_type,
				POB_PROTO_ARG               args,
				UINT                        no_args
				);
		PBWINAPI(OB_PROTO_ID, ob_prototype_search)
			(
				POB_THIS                obthis,
				POB_PROTOTYPE           proto_list,
				UINT                    no_proto_list,
				POB_GROUP               group,
				OB_CLASS_ID             class_id,
				LPTSTR                  name,
				OB_ROUT_TYPE            rout_type, // FUNC or EVENT
				POB_GROUP               proto_group,
				OB_CLASS_ID             result_type,
				POB_PROTO_ARG           args,
				UINT                    no_args,
				POB_PROTO_OVERLOAD_ERROR    error
				);

		PBWINAPI(OB_PROTO_OVERLOAD_ERROR, ob_proto_overload_search)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id,
				LPTSTR                  name,
				OB_ROUT_TYPE            rout_type, // FUNC or EVENT
				OB_CLASS_ID             type,
				POB_PROTO_ARG           args,
				UINT                    no_args
				);

		LPTSTR buildSignature
		(
			POB_THIS        obthis,
			POB_GROUP       pGroup,
			LPTSTR          lpstrScriptName,
			OB_CLASS_ID     returnType,
			POB_PROTO_ARG   args,
			UINT            no_args
		);

		OB_CLASS_ID ob_get_class_id_from_name
		(
			POB_THIS            obthis,
			POB_GROUP           group,
			LPTSTR              name
		);

		PBWINAPI(INT, ob_create_proto_throws_list)
			(
				POB_THIS                    obthis,
				OB_CLASS_HNDL               class_hndl,
				UINT                        no_throws,
				LPTSTR FAR* throws_type_names,
				POB_CLASS_ID FAR* throws_list
				);

		PBWINAPI(INT, ob_create_proto_args)
			(
				POB_THIS                    obthis,
				OB_CLASS_HNDL               class_hndl,
				LPTSTR                      result_name,
				UINT                        no_args,
				POB_PROTOARG_TYPE           arg_pass_style,
				LPTSTR FAR* arg_type_names,
				LPTSTR FAR* arg_names,
				POB_GROUPTYPE               arg_grouping,
				POB_CLASS_ID                result_type,
				POB_PROTO_ARG FAR* args
				);

		PBWINAPI(INT, ob_proto_overload_search_src)
			(
				POB_THIS                    obthis,
				OB_CLASS_HNDL               class_hndl,
				LPTSTR                      name,
				OB_ROUT_TYPE                rout_type,
				LPTSTR                      result_type,
				UINT                        no_args,
				POB_PROTOARG_TYPE           arg_pass_style,
				LPTSTR FAR* arg_type_names,
				POB_GROUPTYPE               arg_grouping,
				POB_PROTO_OVERLOAD_ERROR    error
				);

		OB_VTABLE_ID                    ob_proto_eventtoken_search
		(
			POB_THIS                obthis,
			POB_GROUP               group,
			OB_CLASS_ID             class_id,
			OB_EVT_TOKEN_ID         token
		);

		OB_MODULE_ID                    ob_type_event_module_srch
		(
			POB_THIS                obthis,
			POB_GROUP FAR* group,
			POB_CLASS_ID            class_id,
			OB_VTABLE_ID            event_id,
			OB_EVENT_FUNC FAR* func_ptr,
			PINT                    error
		);

		PBWINAPI(LPTSTR, ob_event_module_name)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				POB_CLASS_ENTRY         class_entry,
				OB_MODULE_ID            mod_id
				);

		OB_MODULE_ID                    ob_event_module_reference
		(
			POB_THIS                obthis,
			POB_GROUP               group,
			POB_CLASS_ENTRY         class_entry,
			LPTSTR                  event_name
		);

		PBWINAPI(OB_VTABLE_ID, ob_find_first_event)
			(
				POB_THIS                obthis,
				POB_CLASS_HNDL          class_hndl,
				LPTSTR                  event_name
				);

		PBWINAPI(OB_MODULE_ID, ob_type_event_script_srch)
			(
				POB_THIS                obthis,
				POB_GROUP FAR* group,
				POB_CLASS_ID            class_id,
				LPTSTR                  name,
				PINT                    error
				);

		VOID obProtoTerminate
		(
			POB_THIS                obThis
		);

		//****************************************************************************
		// Prototypes for obvtlook.c
		//****************************************************************************

		PBWINAPI(INT, ob_build_proto_vtable)
			(
				POB_THIS                    obthis,
				POB_GROUP                   group,
				POB_CLASS_ENTRY             class_entry
				);

		OB_VTABLE_ID                            ob_update_proto_vtable
		(
			POB_THIS                    obthis,
			POB_GROUP                   group,
			POB_CLASS_ENTRY             class_entry,
			LPTSTR                      routname,
			OB_ROUT_TYPE                rout_type, // FUNC or EVENT
			POB_PROTO_ARG               args,
			UINT                        no_args,
			OB_ROUT_ID                  rout_id
		);

		INT                                 ob_input_proto_virtable
		(
			POB_THIS                    obthis,
			POB_GROUP                   group,
			POB_CLASS_ENTRY             class_entry,
			BOOL						free_perm
		);

		POB_PERM_VIRTUAL_NODE               ob_output_proto_virtable
		(
			POB_THIS                    obthis,
			POB_GROUP                   group,
			POB_CLASS_ENTRY             class_entry
		);

		//****************************************************************************
		// Virtual function lookup macros
		//****************************************************************************

#define ob_get_vtable_id(obthis,class_entry,proto_id)                       \
    ((class_entry)->def_entry->no_protos > proto_id ?                       \
     ob_get_proto_vtable_id(obthis,&(class_entry)->prototypes[proto_id]) :                      \
     (OB_VTABLE_ID)OB_SYM_NOT_DEFINED                                       \
    )

#define ob_get_no_prototypes(obthis,class_entry)                            \
    ((class_entry)->def_entry->no_protos)

#define ob_get_proto_id(obthis,class_entry,vtabid)                          \
    (OB_PROTO_ID) ((class_entry)->rout_vtable[vtabid].proto_id)

#define ob_get_total_no_vtab_routs(obthis,class_entry)                      \
    ((class_entry)->def_entry->no_vtab_lookup)

#define ob_get_total_no_vtab_funcs(obthis,class_entry)                      \
    ((class_entry)->def_entry->no_vtab_funcs)

#define ob_get_total_no_vtab_events(obthis,class_entry)                     \
    ((class_entry)->def_entry->no_vtab_events)

#define _is_valid_rout(clsentry,vtabid)                                     \
    ((clsentry)->def_entry->no_protos > 0 &&                                \
     ob_get_total_no_vtab_routs(obthis,clsentry) > vtabid                   \
    )

#define ob_lookup_vtab_proto_id(obthis,clsentry,vtabid)                     \
    (ob_get_total_no_vtab_routs(obthis,clsentry) > vtabid ?                 \
     ob_get_vtable_node_proto_id(obthis,&clsentry->rout_vtable[vtabid]) :   \
     (OB_PROTO_ID)OB_SYM_NOT_DEFINED                                        \
    )

#define ob_lookup_vtab_mod_id(obthis,clsentry,vtabid)                       \
    (ob_get_total_no_vtab_routs(obthis,clsentry) > vtabid ?                 \
     ob_get_proto_mod_id(obthis,&(clsentry)->prototypes[                        \
        ob_lookup_vtab_proto_id(obthis,clsentry,vtabid)]) :                 \
     (OB_MODULE_ID)OB_SYM_NOT_DEFINED                                       \
    )

#define ob_lookup_vtab_rout_id(obthis,clsentry,vtabid)                      \
    (ob_get_total_no_vtab_routs(obthis,clsentry) > vtabid ?                 \
     ob_get_vtable_node_rout_id(obthis,&clsentry->rout_vtable[vtabid]) :        \
     (OB_ROUT_ID)OB_SYM_NOT_DEFINED                                         \
    )

#define ob_lookup_vtab_class_id(obthis,clsentry,vtabid)                     \
    (ob_get_total_no_vtab_routs(obthis,clsentry) > vtabid ?                 \
     ob_get_vtable_node_class_id(obthis,&clsentry->rout_vtable[vtabid]) :       \
     (OB_CLASS_ID)OB_SYM_NOT_DEFINED                                        \
    )

#define ob_lookup_vtab_group_id(obthis,clsentry,vtabid)                     \
    (ob_get_total_no_vtab_routs(obthis,clsentry) > vtabid ?                 \
     ob_get_vtable_node_group_id(obthis,&clsentry->rout_vtable[vtabid]) :       \
     (OB_GROUP_ID)OB_SYM_NOT_DEFINED                                        \
    )

#define ob_lookup_vtab_event_proto_id(obthis,class_entry,event_id,group_id_in,class_id_in) \
            ((OB_PROTO_ID)((class_entry)->def_entry->no_vtab_lookup > event_id &&               \
             (class_entry)->rout_vtable[event_id].group_id == group_id_in &&   \
             (class_entry)->rout_vtable[event_id].class_id == class_id_in ?     \
                ((class_entry)->rout_vtable[event_id].proto_id)      :      \
                OB_SYM_NOT_DEFINED                                      \
                ))

#define ob_lookup_vtab_event_rout_id(obthis,class_entry,event_id,group_id_in,class_id_in) \
            ((OB_ROUT_ID)((class_entry)->def_entry->no_vtab_lookup > event_id &&                \
             (class_entry)->rout_vtable[event_id].group_id == group_id_in &&   \
             (class_entry)->rout_vtable[event_id].class_id == class_id_in ?     \
                ((class_entry)->rout_vtable[event_id].rout_id)   :      \
                OB_SYM_NOT_DEFINED                                      \
                ))

#define ob_lookup_vtab_event_mod_id(obthis,class_entry,event_id,group_id_in,class_id_in) \
            ((OB_MODULE_ID)((class_entry)->def_entry->no_vtab_lookup > event_id &&              \
             (class_entry)->rout_vtable[event_id].group_id == group_id_in &&   \
             (class_entry)->rout_vtable[event_id].class_id == class_id_in ?     \
                (ob_lookup_vtab_mod_id(obthis,class_entry,event_id))     :      \
                OB_SYM_NOT_DEFINED                                      \
                ))

//****************************************************************************
// Function prototypes in obfields.c
//****************************************************************************

		PBWINAPI(OB_SYM_ID, ob_type_field_decl)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             target_class_id,
				LPTSTR                  name,
				OB_INFO_FLAGS           info,
				OB_LOOKUP_INFO          lookup_info,
				OB_CLASS_ID             class_id,
				POB_ARRAYDEF            arrdef,
				POB_FIELD_TYPE          dup_field_type,
				PINT                    error
				);

		VOID                            ob_field_reset
		(
			POB_THIS                obthis,
			POB_GROUP               group,
			OB_CLASS_ID             class_id
		);

		PBWINAPI(OB_SYM_ID, ob_type_field_search)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id,
				LPTSTR                  name,
				POB_CLASS_ID            fieldtype,
				POB_SYM_ID              actual_field_id
				);

		INT                             ob_type_field_add
		(
			POB_THIS                obthis,
			POB_GROUP               group,
			OB_CLASS_ID             class_id,
			LPTSTR                  fieldname,
			OB_CLASS_ID             fieldtype
		);

		VOID                            ob_type_field_delete
		(
			POB_THIS                obthis,
			POB_GROUP               group,
			OB_CLASS_ID             type,
			LPTSTR                  fieldname
		);

		INT                             ob_type_field_rename
		(
			POB_THIS                obthis,
			POB_GROUP               group,
			OB_CLASS_ID             class_id,
			LPTSTR                  old_fieldname,
			LPTSTR                  new_fieldname
		);

		PBWINAPI(OB_SYM_ID, ob_type_field_ref)
			(
				POB_THIS                obthis,
				POB_GROUP FAR* group,
				POB_CLASS_ID            class_id,
				LPTSTR                  name,
				POB_GROUP               curr_group,
				OB_CLASS_ID             curr_class_id,
				POB_CLASS_ID            field_type,
				POB_GROUPTYPE           grouping,
				POB_LOOKUP_INFO         lookup_info,
				POB_DATA FAR* init_value,
				POB_SYM_ID              rel_field_id,
				POB_MEMBER_ACCESS_TYPE  access_check_type,
				PUINT                   level,
				PINT                    error
				);

		PBWINAPI(POB_TYPEINFO, ob_get_type_field_info)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id,
				PUINT                   nfields,
				PINT                    error,
				BOOL                    filter_fields   // TRUE = filter out constants and indirects
				);

		PBWINAPI(VOID, ob_set_field_init_value)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id,
				OB_SYM_ID               field_id,
				OB_CONST_REF            value
				);

		PBWINAPI(POB_DATA, ob_get_field_init_value)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id,
				OB_SYM_ID               field_id
				);

		PBWINAPI(VOID, ob_type_field_clear_instvars)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id
				);

		PBWINAPI(INT, ob_convert_fields_to_const)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id
				);

		PBWINAPI(INT, ob_build_instance_image)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id
				);

		PBWINAPI(VOID, ob_field_decl_indattr_funcs)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id,
				OB_SYM_ID               field_id,
				POB_INDATTR_FUNCTMPLT   func_templates,
				UINT                    no_template_items
				);

		PBWINAPI(POB_INDATTR_FUNCTMPLT, ob_field_get_indattr_funcs)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id,
				OB_SYM_ID               field_id,
				PUINT                   no_tmplts
				);

		PBWINAPI(BOOL, ob_field_requires_update_notification)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id,
				OB_SYM_ID               field_id
				);

		PBWINAPI(POB_LOOK_SYMTAB, ob_get_field_symtab)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id
				);

		//****************************************************************************
		// Function prototypes in obenums.c
		//****************************************************************************


		VOID                            ob_enum_reset
		(
			POB_THIS                obthis
		);

		PBWINAPI(INT, ob_enum_entry_decl)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id,
				LPTSTR                  name,
				BOOL                    has_val,
				INT                     value
				);

		PBWINAPI(VOID, ob_enum_decl_process)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id
				);

		PBWINAPI(INT, ob_enum_reference)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				LPTSTR                  enumname,
				PINT                    enum_val,
				POB_CLASS_ID            class_id,
				POB_GROUP_ID            group_id
				);

		LPTSTR                          ob_enum_name
		(
			POB_THIS                obthis,
			POB_GROUP               group,
			OB_CLASS_ID             class_id,
			INT                     enum_val
		);

		PBWINAPI(POB_ENUM_INFO, ob_get_type_enum_info)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id,
				PUINT                   nenums
				);

		PBWINAPI(BOOL, ob_is_type_enum)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id
				);


		//****************************************************************************
		// Function prototypes in obindatt.cpp
		//****************************************************************************

		PBWINAPI(POB_INDATTR_FUNCTMPLT, ob_type_indattr_search)
			(
				POB_THIS                obthis,
				POB_GROUP FAR* group,
				POB_CLASS_ID            class_id,
				PUINT                   no_tmplts
				);

		PBWINAPI(VOID, ob_type_decl_indattr_funcs)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id,
				POB_INDATTR_FUNCTMPLT   func_templates,
				UINT                    no_func_templates
				);

		//****************************************************************************
		// Function prototypes in obfldsrt.c
		//****************************************************************************


		VOID                            ob_field_sort
		(
			POB_THIS                obthis,
			POB_CONPOOL             conpool,
			POB_CONST_REF FAR* sort_array,
			UINT                    no_array
		);


		//****************************************************************************
		// Function prototypes in obancest.c
		//****************************************************************************

		PBWINAPI(BOOL, ob_is_an_ancestor)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id,
				POB_GROUP               of_group,
				OB_CLASS_ID             of_class_id,
				PINT                    ret
				);

		PBWINAPI(BOOL, ob_is_an_ancestor_excl)
			(
				POB_THIS                obthis,
				POB_GROUP               group,
				OB_CLASS_ID             class_id,
				POB_GROUP               of_group,
				OB_CLASS_ID             of_class_id,
				PINT                    ret
				);

		PBWINAPI(INT, ob_find_type_ancestor)
			(
				POB_THIS                obthis,
				POB_GROUP               group1,
				OB_CLASS_ID             class_id1,
				POB_GROUP               group2,
				OB_CLASS_ID             class_id2
				);

		PBWINAPI(INT, ob_find_type_ancestor_assign)
			(
				POB_THIS                obthis,
				POB_GROUP               group1,
				OB_CLASS_ID             class_id1,
				POB_GROUP               group2,
				OB_CLASS_ID             class_id2
				);


		PBWINAPI(OB_CLASS_ID, ob_find_common_ancestor)
			(
				POB_THIS                obthis,
				POB_GROUP               group1,
				OB_CLASS_ID             class_id1,
				POB_GROUP FAR* group2,
				OB_CLASS_ID             class_id2
				);

		PBWINAPI(OB_CLASS_ID, ob_get_ancestor_system_class)
			(
				POB_THIS                obthis,
				POB_GROUP FAR* group,
				OB_CLASS_ID             class_id
				);

		OB_CLASS_ID                     ob_parent_class_reference
		(
			POB_THIS                obthis,
			POB_GROUP FAR* target_group,
			OB_CLASS_ID             class_id,
			POB_GROUP               prim_group,
			OB_CLASS_ID             prim_class_id
		);

		BOOL                            ob_is_ancestor_modified
		(
			POB_THIS                obthis,
			POB_GROUP               target_group,
			OB_CLASS_ID             class_id
		);

		//****************************************************************************
		// Prototypes from obvalid.c
		//****************************************************************************

		POB_CONFLICT_LIST               ob_validate_class_ancestor
		(
			POB_THIS                obthis,
			POB_GROUP               group,
			OB_CLASS_ID             class_id,
			PUINT                   no_items
		);

		//****************************************************************************
		// Runtime class access functions from obtypdef.cpp
		//****************************************************************************

		PBWINAPI(POB_RUNTIME_CLASS, ob_get_runtime_class)
			(
				POB_THIS                    obthis,
				POB_GROUP                   group,
				OB_CLASS_ID                 class_id
				);

		PBWINAPI(LPCTSTR, ob_get_pspp_class_name)
			(
				POB_THIS                    obthis,
				OB_GROUP_ID                 group_id,
				OB_CLASS_ID                 class_id
				);

		POB_RUNTIME_CLASS ob_init_runtime_class
		(
			POB_THIS                    obthis,
			POB_GROUP                   group,
			OB_CLASS_ID                 class_id,
			OB_CLASS_ID                 parent_class,
			OB_SUBPOOL                  subpool
		);

		INT ob_input_ccode_func_vtable
		(
			POB_THIS                    obthis,
			POB_GROUP                   group,
			POB_CLASS_ENTRY             class_entry,
			VTAB_CLASS_INFO             vtab_class_info,
			PVTAB_INFO                  routine_info,
			HINSTANCE                   hInst,
			OB_SUBPOOL                  subpool
		);

		PBWINAPI(OB_FUNC_FUNC, ob_get_func_vtable_entry)
			(
				OB_INST_ID  obinst,
				ULONG       offset
				);

#define ob_get_class_func_vtable_entry(class_inst,i)        \
    (OB_FUNC_FUNC)(((POB_RUNTIME_CLASS)class_inst)->GetFunctionVtable()[i].func_ptr)

		//
		// Miscellaneous acces functions
		//
		PBWINAPI(PBRESULT, ob_find_method)
			(
				POB_ILOCAL_SESSION  pLocalSession,
				POB_OBJECT          pObject,
				LPTSTR              lpstrMethodName,
				POB_GROUP FAR* ppProtoGroup,
				POB_PROTOTYPE FAR* ppPrototype,
				BOOL                bLookupPublicOnly
				);

		VOID ob_clear_class_entry_cache
		(
			POB_THIS obthis,
			POB_GROUP pGroup
		);

#undef POB_GROUP

#ifdef    __cplusplus
	}   // extern "C" {
#endif    /* __cplusplus */

#endif // OBTYPDEF_H


// DOINC popped back into header 'obcurent.h'
#endif
#ifndef OBALLOC_H
// ***** DOINC including oballoc.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OTPUBLIC_H
// ***** DOINC including otpublic.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBVAR_H
// ***** DOINC including obvar.h *****
// $RCSfile: obvar.h $;$Revision: 4.9 $
//**************************************************************************
//
//                            Copyright 1989 
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :	obvar.h	
//
//    Author   :	Jim Kosko
//
//    Purpose  : 	PB object manager generic variable handling routines.
//
//****************************************************************************

#ifndef OBVAR_H
#define OBVAR_H

//****************************************************************************
// Includes
//****************************************************************************

#ifndef OBTHIS_H
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBARRAY_H
// ***** DOINC including obarray.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBLKSYM_H
// ***** DOINC including oblksym.h *****
	// DOINC skipping duplicate include
#endif

#ifdef    __cplusplus
	extern "C" {
#endif    /* __cplusplus */

		//****************************************************************************
		// Function prototypes
		//****************************************************************************

#define VAR_NO_ERROR	  		0
#define VAR_CONPOOL_FILLED		1
#define VAR_DUP_SYMBOL			2

		OB_SYM_ID						ob_var_declare
		(
			POB_THIS 				obthis,
			POB_LOOK_SYMTAB 		look_symtab,
			LPTSTR 					varname,
			OB_INFO_FLAGS			varinfo,
			OB_LOOKUP_INFO			lookup_info,
			OB_CLASS_ID				type,
			PINT				  	error
		);

		OB_SYM_ID 						ob_array_declare
		(
			POB_THIS 				obthis,
			POB_LOOK_SYMTAB 		look_symtab,
			LPTSTR 					varname,
			OB_INFO_FLAGS			varinfo,
			OB_LOOKUP_INFO			lookup_info,
			OB_CLASS_ID				type,
			POB_ARRAYDEF 			arrdef,
			PINT				  	error
		);

		OB_SYM_ID 						ob_var_reference
		(
			POB_THIS 				obthis,
			POB_LOOK_SYMTAB 		look_symtab,
			LPTSTR 					varname,
			POB_CLASS_ID			type,
			POB_INFO_FLAGS			varinfo
		);

#ifdef    __cplusplus
	}	// extern "C" {
#endif    /* __cplusplus */


#endif // OBVAR_H

// DOINC popped back into header 'obcurent.h'
#endif

#ifdef    __cplusplus
	extern "C" {
#endif    /* __cplusplus */

		//****************************************************************************
		// Macro Definitions
		//****************************************************************************

#define ob_store_routine(obthis,routnode,src,length)						\
	{																					\
	(routnode)->source = src;													\
	(routnode)->len = length;													\
	}

//****************************************************************************
// Function prototypes.
//****************************************************************************

#define ROUTIN_NO_ERROR				0
#define ROUTIN_CONPOOL_FILLED		1

		PBWINAPI(OB_MODULE_ID, ob_rout_declare)
			(
				POB_THIS 				obthis,
				POB_GROUP				group,
				POB_CLASS_ENTRY			class_entry,
				LPTSTR 					routname,
				LPTSTR					qual_routname,
				OB_ROUT_TYPE			rout_type,
				OB_FUNC_TYPE			func_type,
				OB_PROTO_ID				proto_id,
				OB_SYM_ID				glob_id,
				POB_ROUT_ID				rout_id,
				OB_SUBPOOL				subpool,
				BOOL					clear_routine,
				PINT					error
				);

#if 0
		PBWINAPI(OB_MODULE_ID, ob_event_declare)
			(
				POB_THIS 		 		obthis,
				POB_GROUP 		 		group,
				POB_CLASS_ENTRY  		class_entry,
				LPTSTR 			 		routname,
				OB_SUBPOOL 		 		subpool,
				PINT			 		error,
				BOOL					clear_routine
				);
#endif

		PBWINAPI(POB_ROUTNODE, ob_open_routine)
			(
				POB_THIS 		 		obthis,
				POB_CLASS_ENTRY  		class_entry,
				OB_MODULE_ID 	 		module_id
				);

#if 0
		PBWINAPI(POB_ROUTNODE, ob_open_event_routine)
			(
				POB_THIS 		 		obthis,
				POB_CLASS_ENTRY  		class_entry,
				OB_MODULE_ID 	 		module_id
				);
#endif

		PBWINAPI(VOID, ob_close_routine)
			(
				POB_THIS 		 		obthis
				);

		PBWINAPI(INT, ob_func_indirect)
			(
				POB_THIS			 	obthis,
				POB_GROUP FAR* group,
				POB_CLASS_ENTRY FAR* class_entry,
				POB_MODULE_ID		  	mod_id
				);

		INT 					ob_open_routine_inst
		(
			POB_THIS 			  	obthis,
			POB_GROUP 			  	group,
			POB_CLASS_ENTRY 	  	class_entry,
			OB_MODULE_ID 		  	module_id,
			POB_DATA 			  	arglist,
			UINT				  	no_args,
			OB_SCRIPT_TYPE 			script_type
		);

		INT 					ob_open_module_inst
		(
			POB_THIS 		  		obthis,
			POB_GROUP 		  		group,
			POB_CLASS_ENTRY   		class_entry,
			OB_MODULE_ID 	  		mod_id,
			OB_SCRIPT_TYPE 	  		scr_type
		);


		VOID 					ob_close_routine_inst
		(
			POB_THIS 		  		obthis
		);

		LPTSTR					ob_routine_name
		(
			POB_THIS 		  		obthis,
			POB_CLASS_ENTRY   		class_entry,
			OB_MODULE_ID 	  		mod_id
		);

		PBWINAPI(OB_SYM_ID, ob_local_var_declare)
			(
				POB_THIS 		  		obthis,
				POB_GROUP 		  		group,
				LPTSTR 			  		varname,
				OB_INFO_FLAGS	  		varinfo,
				OB_LOOKUP_INFO			lookup_info,
				OB_CLASS_ID		  		type,
				PINT			  		error
				);

		PBWINAPI(OB_SYM_ID, ob_local_array_declare)
			(
				POB_THIS 		  		obthis,
				POB_GROUP 		  		group,
				LPTSTR 			  		varname,
				OB_INFO_FLAGS	  		varinfo,
				OB_LOOKUP_INFO			lookup_info,
				OB_CLASS_ID		  		type,
				POB_ARRAYDEF 	  		arrdef,
				PINT			  		error
				);

		PBWINAPI(OB_SYM_ID, ob_local_var_reference)
			(
				POB_THIS 		  		obthis,
				LPTSTR 			  		varname,
				POB_CLASS_ID	  		type,
				POB_INFO_FLAGS	  		varinfo,
				POB_LOOKUP_INFO			lookup_info,
				POB_DATA FAR* init_value,
				POB_ARRAYDEF FAR* array_def
				);

		PBWINAPI(VOID, ob_local_set_var)
			(
				POB_THIS 		  		obthis,
				POB_GROUP 		  		group,
				OB_SYM_ID 		  		var_id,
				OB_CONST_REF			value
				);

		PBWINAPI(VOID, ob_local_set_id_var)
			(
				POB_THIS 		  		obthis,
				POB_GROUP 		  		group,
				OB_SYM_ID 		  		var_id,
				UINT					value
				);

		PBWINAPI(OB_CONST_REF, ob_set_const)
			(
				POB_THIS 		  		obthis,
				POB_GROUP 		  		group,
				PVOID 					value,
				OB_CONPOOL_ITEM_TYPE	item_type,
				UINT					nitems,
				ULONG 					len
				);

		PBWINAPI(PVOID, ob_get_const)
			(
				POB_THIS 				obthis,
				POB_GROUP 				group,
				OB_CONST_REF 			const_ref
				);

		PVOID		 			ob_get_const_grp
		(
			POB_THIS 				obthis,
			OB_GROUP_ID				group_id,
			OB_CONST_REF 			const_ref
		);

		PVOID		 			ob_extract_const
		(
			POB_THIS 				obthis,
			POB_GROUP 				group,
			OB_CONST_REF 			const_ref
		);

		INT 					ob_convert_var_symtab_to_const
		(
			POB_THIS				obthis,
			POB_GROUP				group,
			POB_LOOK_SYMTAB			symtab
		);

		VOID 					ob_init_var_symtab
		(
			POB_THIS				obthis,
			POB_GROUP				group,
			POB_LOOK_SYMTAB			symtab,
			POB_ROUTNODE			routineContext
		);

		PBWINAPI(INT, ob_convert_vars_to_const)
			(
				POB_THIS 				obthis,
				POB_GROUP 				group
				);

		INT 					ob_get_obj_argument
		(
			POB_THIS 				obthis,
			UINT 					arglist,
			POB_GROUP FAR* obj_group,
			POB_CLASS_ENTRY FAR* obj_class_entry,
			PUINT 					error
		);

		PBWINAPI(BOOL, ob_clear_group_objects)
			(
				POB_THIS 			obthis,
				POB_GROUP			pGroup
				);

		PBWINAPI(VOID, ob_init_group_objects)
			(
				POB_THIS 			obthis,
				POB_GROUP			pGroup
				);

#ifdef    __cplusplus
	}	// extern "C" {
#endif    /* __cplusplus */


#endif // OBCURENT_H
// DOINC popped back into header 'rtccode.h'
// ***** DOINC including shformat.h *****
//**************************************************************************
//
//                            Copyright 1989
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :        shformat.h
//
//    Author   :        Kim Sheffield
//
//    Purpose  :        Formatting and validation routines
//
//****************************************************************************


//****************************************************************************
// Insure file is not included twice
//****************************************************************************

#ifndef SHFORMAT_H
#define SHFORMAT_H

// ***** DOINC including shdt.h *****
	// DOINC skipping duplicate include

#ifdef __cplusplus
	extern "C" {
#endif

		// Lengths do not include required '/0' terminator
		// Mask runtime routines
		PBWINAPI(long, getCultureValueStr)(LPTSTR formatStr, LPTSTR name, LPTSTR defaultValue, LPTSTR outValue, int outSize);
		PBWINAPI(long, getCultureValueInt)(LPTSTR formatStr, LPTSTR name, int defaultValue, int* outValue);

		typedef struct MONTHANDDAYNAMESSTRUCT_TAG
		{
			LPTSTR* monAbbrev;
			LPTSTR* monName;
			LPTSTR* dayAbbrev;
			LPTSTR* dayName;
		} MONTHANDDAYNAMESSTRUCT, * LPMONTHANDDAYNAMESSTRUCT;

		PBWINAPI(long, shformatDateTimeWeb)(LPTSTR pResult, int maxLen, LPTSTR prMask, PSH_TIME value, int flags, LPMONTHANDDAYNAMESSTRUCT cultureInfo);

		PBWINAPI(long, shformatDateTime)(LPTSTR pResult, int maxLen, LPTSTR prMask, PSH_TIME value, int flags);
		PBWINAPI(long, shformatDecimal)(LPTSTR pResult, int maxLen, LPTSTR prFmt, PVOID value, int flags);
		PBWINAPI(long, shformatDecimalWeb)(LPTSTR pResult, int maxLen, LPTSTR prFmt, PVOID value, int flags, LPTSTR dwCultureFormat);
		PBWINAPI(long, shformatDouble)(LPTSTR pResult, int maxLen, LPTSTR prMask, double value, int flags);
		PBWINAPI(long, shformatDoubleWeb)(LPTSTR pResult, int maxLen, LPTSTR prMask, double value, int flags, LPTSTR dwCultureFormat);
		PBWINAPI(long, shformatLonglong)(LPTSTR pResult, int maxLen, LPTSTR prMask, LONGLONG value, int flags);
		PBWINAPI(long, shformatLonglongWeb)(LPTSTR pResult, int maxLen, LPTSTR prMask, LONGLONG value, int flags, LPTSTR dwCultureFormat);
		PBWINAPI(long, shformatReal)(LPTSTR pResult, int maxLen, LPTSTR prMask, float FAR* pValue, int flags);
		PBWINAPI(long, shformatRealWeb)(LPTSTR pResult, int maxLen, LPTSTR prMask, float FAR* pValue, int flags, LPTSTR dwCultureFormat);
		PBWINAPI(long, shformatString)(LPTSTR pResult, int maxLen, LPTSTR prMask, LPTSTR value, int flags);

		// Mask compilation routines
		PBWINAPI(int, shformatCmplDateTimeMask)(LPTSTR prMask, LPTSTR psMask, int maxLen);
		PBWINAPI(int, shformatCmplDateTimeMaskWeb)(LPTSTR prMask, LPTSTR psMask, int maxLen, LPTSTR dwCultureFormat);
		PBWINAPI(int, shformatCmplNumericMask)(LPTSTR prMask, LPTSTR psMask, int maxLen);
		PBWINAPI(int, shformatCmplNumericMaskWeb)(LPTSTR prMask, LPTSTR psMask, int maxLen, LPTSTR dwCultureFormat);
		//CR566072
		PBWINAPI(int, shformatCmplNumericMaskWebCommasPos)(LPTSTR prMask, LPTSTR psMask, int maxLen, LPTSTR dwCultureFormat);
		PBWINAPI(int, shformatCmplStringMask)(LPTSTR prMask, LPTSTR psMask, int maxLen);

		// errMsg should be a 256 byte buffer to hold text string
		PBWINAPI(void, shformatErrorString)(LPTSTR errMsg, int err);

		// Some	formats good for all data types
#define FORMATGENERAL PBTEXT("[GENERAL]")
#define FORMATDATETIME PBTEXT("[SHORTDATE] [TIME]")
#define FORMATDATE PBTEXT("[SHORTDATE]")
#define FORMATTIME PBTEXT("[TIME]")

// Valid values for flags.
#define FORMATVALUEOK       0
#define FORMATVALUENULL     1       // for NULL values
#define FORMATVALUEINVALID  2       // for invalid values
//CR566072
#define FORMATRECORDCOMMASPOS  4       // for recording commas position

// Error return codes for formating
#define FORMATOK            0       // format is valid
#define FORMATERRSIZE       1       // mask length is too small
#define FORMATERRCOLOR      2       // invalid color specified
#define FORMATERRSECTION    3       // too many sections specified
#define FORMATERRCHAR       4       // invalid character in mask
#define FORMATERRKEY        5       // unknown key specified e.g. [xxx] where xxx is unknown
#define FORMATERRPERIOD     6       // Too many periods found
#define FORMATERREOS        7       // Unexpected end of mask string
#define FORMATERRINTERNAL   8       // Internal error: should never happen
#define FORMATERRMONTH      9       // must be m, mm, mmm or mmmm
#define FORMATERRDAY        10      // must be d, dd, ddd or dddd
#define FORMATERRYEAR       11      // must be yy or yyyy
#define FORMATERRHOUR       12      // must be h or hh
#define FORMATERRSECOND     13      // must be s or ss
#define FORMATERRMINUTE     14      // must be m or mm
#define FORMATERRAMPM       15      // must be AM/PM, am/pm, a/p or A/P
#define FORMATERRMSECOND	16		// exceeded maximum size

// Regular expressions routines
		PBWINAPI(int, shregExprCmpl)(LPTSTR pattern, LPTSTR srcPattern, int maxLen);
		PBWINAPI(int, shregExprMatch)(LPTSTR string, LPTSTR pattern);
#ifdef PS_DBCS
		// ADC_DBCS_START_MODIFY cchong Feb 28 2000
		// CR# 206017: "[] ^ $" patterns can't take DBCS characters because orginal data type was signed short
		PBWINAPI(int, shregExprCmplW)(unsigned short* pattern, LPTSTR srcPattern, int maxLen);
		PBWINAPI(int, shregExprMatchW)(unsigned short* string, unsigned short* pattern);
		// ADC_DBCS_END_MODIFY cchong Feb 28 2000
#endif

#define PATTERNOK           0       // pattern is valid
#define PATTERNERRSIZE      1       // pattern length is too small
#define PATTERNERRCLASSEND  2       // unterminated class i.e. [ but no ]
#define PATTERNERRCLASSBIG  3       // class too large > 256
#define PATTERNERRNOCLASS   4       // empty class i.e. []
#define PATTERNERROO        5       // illegal occurence op
#define PATTERNERRBADCOLON  6       // unknown ':' type
#define PATTERNERRNOCOLON   7       // no ':' type

#define PATTERNERRMAX       20      // maximum error

// Validation routines.
		PBWINAPI(BOOL, shIsValidReal)(LPTSTR n);
		PBWINAPI(void, shNormalizeReal)(LPTSTR out, LPTSTR in);
		PBWINAPI(void, shNormalizeRealbyLocale)(LPTSTR out, LPTSTR in);
		PBWINAPI(BOOL, shIsValidRealWeb)(LPTSTR n, TCHAR paramPeriodChar, TCHAR paramCommaChar);
		PBWINAPI(void, shNormalizeRealWeb)(LPTSTR out, LPTSTR in, TCHAR paramPeriodChar, TCHAR paramCommaChar);
		PBWINAPI(void, shNormalizeRealbyLocaleWeb)(LPTSTR out, LPTSTR in, TCHAR paramPeriodChar, TCHAR paramCommaChar);
		PBWINAPI(VOID, pbshr_intl)(void);
		PBWINAPI(BOOL, shIsValidRealNoLocale)(LPTSTR n);

		// -------------------------------------------------------------------------------
		// BLIM\CR201404\9\2000\AUGUST\11TH.
		// Declaration of new exported function shGetRegProfileValue() as well as 
		// structure REGPROFILESTRUCT.
		//
		// BLIM Thursday October 12th 2000 - added #ifndef PS_WINFREE and #endif preprocessor 
		// definitions in order for code to remain compatible in WINFREE environment. 
		// -------------------------------------------------------------------------------
#ifndef PS_WINFREE

		typedef struct REGPROFILESTRUCT_TAG
		{
			// Registry access part.
			HANDLE	hKey;
			LPTSTR	lpszSubKey;
			LPTSTR	lpszValueName;
			long		lRegError;
			// INI file access part.
			LPTSTR	lpszIniFileName;
			LPTSTR	lpszSectionName;
			LPTSTR	lpszKeyName;
			// Common receive value.
			LPTSTR	lpszValueReceiver;
			DWORD		dwValueSize;
			// Common default value.
			LPTSTR	lpszDefaultValue;
		}
		REGPROFILESTRUCT, * LPREGPROFILESTRUCT;

		PBWINAPI(long, shGetRegProfileStringValue)(LPREGPROFILESTRUCT lpRegProfileStruct);

#endif
		// -------------------------------------------------------------------------------

#ifdef __cplusplus
	} // extern "C"
#endif

#endif // SHFORMAT_H
// DOINC popped back into header 'rtccode.h'
// ***** DOINC including obglobal.h *****
// $RCSfile: obglobal.h $;$Revision: 4.21 $
//**************************************************************************
//
//                            Copyright 1989 
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :	obglobal.h	
//
//    Author   :	Jim Kosko
//
//    Purpose  : 	Public definitions and prototypes for PB global objects.
//
//****************************************************************************

#ifndef OBGLOBAL_H
#define OBGLOBAL_H

//****************************************************************************
// Defines
//****************************************************************************

#ifndef OSPASCAL_H
// ***** DOINC including ospascal.h *****
	// DOINC skipping duplicate include
#endif
#ifndef PBSTG_H
// ***** DOINC including pbstg.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBDEFINE_H
// ***** DOINC including obdefine.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBDATA_H
// ***** DOINC including obdata.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBTHIS_H
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBLKSYM_H
// ***** DOINC including oblksym.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBGROUP_H
// ***** DOINC including obgroup.h *****
// $RCSfile: obgroup.h $;$Revision: 4.43 $
//**************************************************************************
//
//                            Copyright 1989 
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :	obgroup.h	
//
//    Author   :	Jim Kosko
//
//    Purpose  : 	Definitions pertaining to object groups.
//
//****************************************************************************

#ifndef OBGROUP_H
#define OBGROUP_H

//****************************************************************************
// Includes
//****************************************************************************

#ifndef OSTIME_H
// ***** DOINC including ostime.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBTHIS_H
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBCONST_H
// ***** DOINC including obconst.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBLKSYM_H
// ***** DOINC including oblksym.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBTYPDEF_H
// ***** DOINC including obtypdef.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBGLBSYM_H
// ***** DOINC including obglbsym.h *****
// $RCSfile: obglbsym.h $;$Revision: 4.12 $
//**************************************************************************
//
//                            Copyright 1989 
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :	obglbsym.h	
//
//    Author   :	Jim Kosko
//
//    Purpose  : 	Definitions for PB object manager global symbol tables.
//
//****************************************************************************

#ifndef OBGLBSYM_H
#define OBGLBSYM_H

//****************************************************************************
//	Includes
//****************************************************************************

#ifndef OBTHIS_H
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBCONST_H
// ***** DOINC including obconst.h *****
	// DOINC skipping duplicate include
#endif

//****************************************************************************
//	Global symbol types
//****************************************************************************

	typedef enum ob_glob_symtype
	{
		OB_GLOB_VAR,
		OB_GLOB_CLASS,
		OB_GLOB_FUNC,
		OB_GLOB_ANY_SYMTYPE

	} OB_GLOB_SYMTYPE, FAR* POB_GLOB_SYMTYPE;

	//****************************************************************************
	//	Global reference types
	//****************************************************************************

	typedef enum ob_glob_reftype
	{
		OB_GLOB_REF,
		OB_GLOB_DECL

	} OB_GLOB_REFTYPE, FAR* POB_GLOB_REFTYPE;

	//****************************************************************************
	// Data flags masks and shifts
	//****************************************************************************

#define OB_GLOBSYM_SYMTYPE_MASK			0x0007				// 3 bits 
#define OB_GLOBSYM_REFTYPE_MASK			0x0018				// 2 bits
#define OB_GLOBSYM_LINKSTATE_MASK		0x0060				// 2 bits
#define OB_GLOBSYM_REFSTYLE_MASK		0x0380				// 3 bits
#define OB_GLOBSYM_PRIMPARENT_MASK		0x0400				// 1 bit
#define OB_GLOBSYM_ISINSTANCED_MASK		0x0800				// 1 bit

#define OB_GLOBSYM_SYMTYPE_SHIFT		0
#define OB_GLOBSYM_REFTYPE_SHIFT		3
#define OB_GLOBSYM_LINKSTATE_SHIFT		5
#define OB_GLOBSYM_REFSTYLE_SHIFT		7
#define OB_GLOBSYM_PRIMPARENT_SHIFT	   10	
#define OB_GLOBSYM_ISINSTANCED_SHIFT   11	 

//****************************************************************************
//	Structure for global symbol table entry.
//****************************************************************************

	typedef struct ob_globsym_entry
	{
		OB_CONST_REF	 name;			  	// Name of global symbol
		OB_GROUP_ID      group_id;        	// Group id of global
		OB_CLASS_ID		 class_id;		  	// Class id of global
		OB_SYM_ID		 id;			  	// Symbol id of variable (OB_GLOB_VAR)
		USHORT			 info;				// Contains:
	//	OB_GLOB_SYMTYPE	 symtype	  : 3;	// Global symbol type
	//  OB_GLOB_REFTYPE	 reftype	  : 2;	// OB_GLOB_REF or OB_GLOB_DECL
	//	UINT             link_state   : 2; 	// Global symbol link state
	//	OB_GLOB_REFSTYLE refstyle	  : 3;	// Style of reference 
	//	UINT			 prim_parent  : 1;	// Primary parent reference flag
											// only valid if refstyle = PARENT
	//	UINT			 is_instanced :	1; 	// TRUE if class is instantiated

	} OB_GLOBSYM_ENTRY, FAR* POB_GLOBSYM_ENTRY;


	//****************************************************************************
	// Wrapper macros for POB_GLOBSYM_ENTRY
	//****************************************************************************

#define ob_get_glbsym_entry_class(obthis,pGlobsymEntry)					\
	((pGlobsymEntry)->class_id)

#define ob_get_glbsym_entry_id(obthis,pGlobsymEntry)					\
	(pGlobsymEntry ? ((pGlobsymEntry)->id) : OB_SYM_NOT_DEFINED)


#define ob_get_glbsym_entry_symtype(obthis,entry) 	  					\
	((OB_GLOB_SYMTYPE) (((entry)->info & OB_GLOBSYM_SYMTYPE_MASK) >> 	\
				OB_GLOBSYM_SYMTYPE_SHIFT))

#define ob_set_glbsym_entry_symtype(obthis,entry,symtype)				\
	((entry)->info = (USHORT)(((symtype) << OB_GLOBSYM_SYMTYPE_SHIFT) | \
					 ((entry)->info & ~OB_GLOBSYM_SYMTYPE_MASK)))

#define ob_get_glbsym_entry_reftype(obthis,entry) 						\
	((OB_GLOB_REFTYPE) (((entry)->info & OB_GLOBSYM_REFTYPE_MASK) >>	\
				OB_GLOBSYM_REFTYPE_SHIFT))

#define ob_set_glbsym_entry_reftype(obthis,entry,reftype)				\
	((entry)->info = (USHORT)(((reftype) << OB_GLOBSYM_REFTYPE_SHIFT) | \
					 ((entry)->info & ~OB_GLOBSYM_REFTYPE_MASK)))

#define ob_get_glbsym_entry_linkstate(obthis,entry) 						\
	((OB_GROUP_LINK_STATE) (((entry)->info & OB_GLOBSYM_LINKSTATE_MASK) >> 	\
				OB_GLOBSYM_LINKSTATE_SHIFT))

#define ob_set_glbsym_entry_linkstate(obthis,entry,linkstate)			\
	((entry)->info = (USHORT)(((linkstate) << OB_GLOBSYM_LINKSTATE_SHIFT) | \
					 ((entry)->info & ~OB_GLOBSYM_LINKSTATE_MASK)))

#define ob_get_glbsym_entry_refstyle(obthis,entry) 						\
	((OB_GLOB_REFSTYLE) (((entry)->info & OB_GLOBSYM_REFSTYLE_MASK) >> 	\
				OB_GLOBSYM_REFSTYLE_SHIFT))

#define ob_set_glbsym_entry_refstyle(obthis,entry,refstyle)				\
	((entry)->info = (USHORT)(((refstyle) << OB_GLOBSYM_REFSTYLE_SHIFT) | \
					 ((entry)->info & ~OB_GLOBSYM_REFSTYLE_MASK)))

#define ob_get_glbsym_entry_primparent(obthis,entry) 					\
	((BOOL) (((entry)->info & OB_GLOBSYM_PRIMPARENT_MASK) >> 			\
				OB_GLOBSYM_PRIMPARENT_SHIFT))

#define ob_set_glbsym_entry_primparent(obthis,entry,primparent)			\
	((entry)->info = (USHORT)(((primparent) << OB_GLOBSYM_PRIMPARENT_SHIFT) | \
					 ((entry)->info & ~OB_GLOBSYM_PRIMPARENT_MASK)))

#define ob_get_glbsym_entry_isinstanced(obthis,entry) 				  	\
	((BOOL) (((entry)->info & OB_GLOBSYM_ISINSTANCED_MASK) >> 		  	\
				OB_GLOBSYM_ISINSTANCED_SHIFT))

#define ob_set_glbsym_entry_isinstanced(obthis,entry,isinstanced)	  	\
	((entry)->info = (USHORT)(((isinstanced) << OB_GLOBSYM_ISINSTANCED_SHIFT) |	\
					 ((entry)->info & ~OB_GLOBSYM_ISINSTANCED_MASK)))

//****************************************************************************
//	Old structure for global symbol table entry. This is maintained for 
//  compatibility with PB libraries older than V4.0. This is necessary since
//  glbsym tables are read before migration.
//****************************************************************************

	typedef struct ob_old_globsym_entry
	{
		USHORT			 name;			  	// Name of global symbol (OB_CONST_REF
		OB_GROUP_ID      group_id;        	// Group id of global
		OB_CLASS_ID		 class_id;		  	// Class id of global
		OB_SYM_ID		 id;			  	// Symbol id of variable (OB_GLOB_VAR)
		USHORT			 info;				// Contains:

	} OB_OLD_GLOBSYM_ENTRY, FAR* POB_OLD_GLOBSYM_ENTRY;


	//****************************************************************************
	// Global symbol table structure.
	//****************************************************************************

	typedef struct ob_perm_globsym
	{
		USHORT					no_slots;			// Number of slots in table.

	} OB_PERM_GLOBSYM;

	typedef struct ob_temp_globsym
	{
		POB_GLOBSYM_ENTRY		table;				// Pointer to actual table.
		UINT					alloc_incr;			// Allocation increment.
		UINT					alloc_size;			// Current allocation size.
		UINT					slot_incr;			// No of slots to increment.
		UINT					next_free;			// Next free slot.

	} OB_TEMP_GLOBSYM;

	typedef struct ob_globsym
	{
		OB_PERM_GLOBSYM		ps;
		OB_TEMP_GLOBSYM		ts;

	} OB_GLOBSYM, FAR* POB_GLOBSYM;

	//****************************************************************************
	// Wrapper API for OB_GLOBSYM
	//****************************************************************************

#define ob_get_globsym_no_slots(obthis,globsym)						\
	((globsym)->ps.no_slots)

#define ob_get_globsym_table(obthis,globsym)						\
	((globsym)->ts.table)

#define ob_set_globsym_table(obthis,globsym,tabl)					\
	((globsym)->ts.table = (tabl))

#define ob_get_globsym_no_used(obthis,globsym)						\
	((globsym)->ts.next_free)

//****************************************************************************
// Function prototypes
//****************************************************************************

#ifdef    __cplusplus
	extern "C" {
#endif    /* __cplusplus */


		POB_GLOBSYM						ob_init_glbsym
		(
			POB_THIS 				obthis,
			UINT 					no_slots,
			OB_SUBPOOL 				subpool
		);

		PBWINAPI(OB_SYM_ID, ob_add_glbsym_var)
			(
				POB_THIS 				obthis,
				POB_GROUP 				group,
				LPTSTR 					name,
				OB_GLOB_REFTYPE 		reftype,
				OB_CLASS_ID 			class_id,
				OB_SYM_ID 				id
				);

		PBWINAPI(OB_SYM_ID, ob_add_glbsym_class)
			(
				POB_THIS 				obthis,
				POB_GROUP 				group,
				LPTSTR 					name,
				OB_GLOB_REFTYPE 		reftype,
				OB_GLOB_REFSTYLE 		refstyle,
				OB_GROUP_ID				group_id,
				OB_CLASS_ID 			class_id,
				OB_CLASS_ID 			sys_class_id
				);

		PBWINAPI(OB_SYM_ID, ob_add_glbsym_func)
			(
				POB_THIS 				obthis,
				POB_GROUP 				group,
				LPTSTR 					name,
				OB_GLOB_REFTYPE 		reftype,
				OB_CLASS_ID 			class_id,
				OB_MODULE_ID 			mod_id
				);

#define	ob_get_glbsym_entry(obthis,glbsym,slot_no)	\
			(((slot_no) < (glbsym)->ts.next_free) ?	\
			((glbsym)->ts.table + (slot_no)) 	  :	\
			NULL)

		VOID			   				ob_del_glbsym
		(
			POB_THIS 				obthis,
			POB_GLOBSYM 			glbsym
		);

		POB_GLOBSYM_ENTRY 				ob_glbsym_decl_search
		(
			POB_THIS 				obthis,
			POB_GROUP				group,
			LPTSTR 					name,
			OB_GLOB_SYMTYPE 		symtype
		);

		POB_GLOBSYM_ENTRY 				ob_next_glbsym_decl
		(
			POB_THIS 				obthis,
			POB_GLOBSYM 			glbsym,
			OB_GLOB_SYMTYPE 		symtype,
			PUINT 					glbpos
		);

		POB_GLOBSYM_ENTRY 				ob_next_glbsym_ref
		(
			POB_THIS 				obthis,
			POB_GLOBSYM 			glbsym,
			PUINT 					glbpos
		);

		OB_ERROR						ob_glbsym_write
		(
			POB_THIS 				obthis,
			POB_GLOBSYM 			glbsym
		);

		POB_GLOBSYM						ob_glbsym_read
		(
			POB_THIS 				obthis,
			UINT 					slot_incr,
			OB_SUBPOOL 				subpool
		);

		POB_GLOBSYM_ENTRY				ob_glbsym_copy
		(
			POB_THIS 				obthis,
			POB_GLOBSYM				glbsym,
			OB_SUBPOOL				subpool
		);

		POB_GLOBSYM 					ob_old_glbsym_read
		(
			POB_THIS 				obthis,
			UINT	   				slot_incr,
			OB_SUBPOOL				subpool
		);

		VOID 							ob_update_glbsym_refstyle
		(
			POB_THIS				obthis,
			POB_GLOBSYM 			glbsym,
			UINT					slot_no,
			OB_GLOB_REFSTYLE		refstyle,
			BOOL					is_prim_parent
		);

#define ob_update_glbsym_instflag(obthis,glbsym,slot_no,instflag)	\
	ob_set_glbsym_entry_isinstanced (obthis,						\
		ob_get_glbsym_entry (obthis, glbsym, slot_no), instflag)

		POB_DATA_INFO 					ob_get_glbsym_vars_of_class
		(
			POB_THIS       			obthis,
			POB_GROUP				group,
			OB_CLASS_ID    			class_id,
			PUINT          			p_no_items
		);

		VOID ob_mark_groups_unlinked
		(
			POB_THIS       obThis
		);

#ifdef    __cplusplus
	}	// extern "C" {
#endif    /* __cplusplus */

#endif // OBGLBSYM_H


// DOINC popped back into header 'obgroup.h'
#endif
#ifndef OBOBJECT_H
// ***** DOINC including obobject.h *****
//**************************************************************************
//
//                            Copyright 1996
//                        Powersoft Corporation
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM POWERSOFT CORPORATION.
//
// ------------------------------------------------------------------------
//
//    Filename :	Obobject.h
//
//    Author   :	Jim Ducharme
//
//    Purpose  : 	Object manager API.
//
//****************************************************************************

#ifndef OBOBJECT_H
#define OBOBJECT_H

//****************************************************************************
// Includes
//****************************************************************************

#ifndef OBTHIS_H
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
#endif

#ifndef OBCLINST_H
// ***** DOINC including obclinst.h *****
	// DOINC skipping duplicate include
#endif

#ifndef OBDATA_H
// ***** DOINC including obdata.h *****
	// DOINC skipping duplicate include
#endif 

#ifndef OBRESULT_H
// ***** DOINC including obresult.h *****
//**************************************************************************
//
//                            Copyright 1997 
//                        		Powersoft Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :	obresult.h	
//
//    Author   :	Jim Ducharme
//
//    Purpose  : 	PBRESULT definitions for PBMODULE_OBJ module
//
//****************************************************************************

#ifndef OBRESULT_H
#define OBRESULT_H

#ifndef PBCOM_H
// ***** DOINC including pbcom.h *****
	// DOINC skipping duplicate include
#endif

// Macro definitions to make this file easier to read.
#define OBRESULT_ERROR(code)		MAKE_PBRESULT(SEVERITY_ERROR, PBMODULE_OBJ, code)
#define OBRESULT_SUCCESS(code)	MAKE_PBRESULT(SEVERITY_SUCCESS, PBMODULE_OBJ, code)


/****************************************************************/
/* General Object Manger codes - Reserved 						*/
/* Range: 0x0000 - 0x003F				  						*/
/****************************************************************/
//Errors
#define OBJ_E_BAD_OBTHIS				OBRESULT_ERROR(0x0000)

/****************************************************************/
/* Object API - for OBOBJECT classes							*/
/* Range: 0x0040 - 0x005F										*/
/****************************************************************/

// Errors
#define OBJ_E_NOT_IMPLEMENTED			OBRESULT_ERROR(0x0040)
#define OBJ_E_INVOKE_FUNCTION_NOT_FOUND OBRESULT_ERROR(0x0041)
#define OBJ_E_INVOKE_IS_SYSTEM_FUNC_DEF OBRESULT_ERROR(0x0042)
#define OBJ_E_INVOKE_WRONG_NUM_ARGS		OBRESULT_ERROR(0x0043)
#define OBJ_E_INVOKE_INVALID_OVERLOAD	OBRESULT_ERROR(0x0044)
#define OBJ_E_INVOKE_INVALID_ARG_CONVERSION	OBRESULT_ERROR(0x0045)
#define OBJ_E_INVOKE_METHOD_INACCESSABLE	OBRESULT_ERROR(0x0046)
#define OBJ_E_INVOKE_REFARG_ERROR		OBRESULT_ERROR(0x0047)
#define OBJ_E_INVOKE_METHOD_AMBIGUOUS	OBRESULT_ERROR(0x0048)
#define OBJ_E_REMOTE_REF_NOT_FOUND		OBRESULT_ERROR(0x0049)
#define OBJ_E_CREATE_CLASS_NOT_FOUND	OBRESULT_ERROR(0x004A)
#define OBJ_E_CREATE_CLASS_ENUM			OBRESULT_ERROR(0x004B)
#define OBJ_E_CREATE_CLASS_AUTOINST		OBRESULT_ERROR(0x004C)
#define OBJ_E_CREATE_FAILURE			OBRESULT_ERROR(0x004D)

// Warnings	
#define	OBJ_W_INVOKE_EVENT_NOT_FOUND	OBRESULT_SUCCESS(0x0051)
#define OBJ_W_INVOKE_WRONG_NUM_ARGS		OBRESULT_SUCCESS(0x0053)
#define OBJ_W_INVOKE_METHOD_INACCESSABLE	OBRESULT_SUCCESS(0x0056)
#define OBJ_W_INVOKE_REFARG_ERROR		OBRESULT_SUCCESS(0x0057)
#define OBJ_W_INVOKE_METHOD_AMBIGUOUS	OBRESULT_SUCCESS(0x0058)

/****************************************************************/
// Remote Procedure calls										*/
// Range: 0x0060 - 0x0064										*/
/****************************************************************/

#define	OBJ_E_RETRY						OBRESULT_ERROR(0x0060)
#define	OBJ_E_EXECUTION_FAILURE			OBRESULT_ERROR(0x0061)
#define	OBJ_E_RT_TERMINATED				OBRESULT_ERROR(0x0062)

/****************************************************************/
// Shared object calls											*/
// Range: 0x0065 - 0x006F										*/
/****************************************************************/
#define OBJ_E_SESSION_CREATE_FAILED		OBRESULT_ERROR(0x0065)
#define OBJ_E_OBJECT_CREATE_FAILED		OBRESULT_ERROR(0x0066)
#define OBJ_E_SHARED_INSTANCE_ERROR		OBRESULT_ERROR(0x0067)

/****************************************************************/
/* Object Request Queue											*/
// Range: 0x0070 - 		  												*/
/****************************************************************/
#define OBJ_E_WAIT_CANCELLED			OBRESULT_ERROR(0x0070)
#define OBJ_E_NO_REPLY					OBRESULT_ERROR(0x0071)
#define OBJ_E_WAITER_NOT_FOUND			OBRESULT_ERROR(0x0072)
#define OBJ_W_QUEUE_EMPTY				OBRESULT_SUCCESS(0x0073)

/****************************************************************/
/* Metaclass Info												*/
// Range: 0x0080 - 0x08F 										*/
/****************************************************************/

#define OBJ_E_MNOT_IMPLEMENTED			OBRESULT_ERROR(0x0080)
#define OBJ_E_MTYPE_NOT_FOUND			OBRESULT_ERROR(0x0081)
#define OBJ_E_MINVALID_OBJECT			OBRESULT_ERROR(0x0082)
#define OBJ_E_MNULL_CLASS_OBJECT		OBRESULT_ERROR(0x0083)
#define OBJ_E_MSESSION_OPEN_ERROR		OBRESULT_ERROR(0x0084)
#define OBJ_E_MSESSION_CLOSE_ERROR		OBRESULT_ERROR(0x0085)
#define OBJ_E_MNULL_ENUM_OBJECT			OBRESULT_ERROR(0x0086)
#define OBJ_E_MNULL_TYPEDEF_OBJECT		OBRESULT_ERROR(0x0087)


#endif

// DOINC popped back into header 'obobject.h'
#endif

#ifndef OBJMGR_H
// ***** DOINC including objmgr.h *****
// $RCSfile: objmgr.h $;$Revision: 4.4 $
//**************************************************************************
//
//                            Copyright 1993 
//                        		Powersoft Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :	objmgr.h	
//
//    Author   :	Jim Kosko
//
//    Purpose  : 	PB Object manager local routines
//
//****************************************************************************

#ifndef OBJMGR_H
#define OBJMGR_H

//****************************************************************************
// Includes
//****************************************************************************

#ifndef OSPASCAL_H
// ***** DOINC including ospascal.h *****
	// DOINC skipping duplicate include
#endif
#ifndef PBSTG_H
// ***** DOINC including pbstg.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBTHIS_H
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
#endif
#ifndef SHDEBUG_H
// ***** DOINC including shdebug.h *****
	// DOINC skipping duplicate include
#endif

//****************************************************************************
// Prototypes
//****************************************************************************
#ifdef    __cplusplus
	extern "C" {
#endif    /* __cplusplus */


		POB_THIS 						ob_init
		(
			PSH_DBG_THIS   					dbgthis,
			ppbstg_anchor  					stgthis
		);

		VOID 							ob_init_run
		(
			POB_THIS						obthis
		);

		VOID 							ob_terminate_run
		(
			POB_THIS						obthis
		);

		VOID 							ob_stop_classdefinition_sessions
		(
			POB_THIS						obthis
		);

#ifdef    __cplusplus
	}	// extern "C" {


#endif // OBJMGR_H
#endif    /* __cplusplus */
// DOINC popped back into header 'obobject.h'
#endif

#ifndef PBCOM_H
// ***** DOINC including pbcom.h *****
	// DOINC skipping duplicate include
#endif

#ifndef PBASSERT_H
// ***** DOINC including pbassert.h *****
	// DOINC skipping duplicate include
#endif

#ifndef RTPUBLIC_H
// ***** DOINC including rtpublic.h *****
//**************************************************************************
//
//                            Copyright 1989
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :    rtpublic.h
//
//    Author   :    Jim Kosko
//
//    Purpose  :    Public definitions for PB runtime executive
//
//****************************************************************************

#ifndef RTPUBLIC_H
#define RTPUBLIC_H


//****************************************************************************
// Includes
//****************************************************************************

// ***** DOINC including ospascal.h *****
	// DOINC skipping duplicate include
// ***** DOINC including pbstg.h *****
	// DOINC skipping duplicate include
// ***** DOINC including obdefine.h *****
	// DOINC skipping duplicate include
// ***** DOINC including rtthis.h *****
	// DOINC skipping duplicate include
// ***** DOINC including objapi.h *****
	// DOINC skipping duplicate include

#ifdef __cplusplus
	extern "C" {
#endif	/* __cplusplus */

		// **************************************************************************
		//   Return values from debug callback function
		// **************************************************************************
#define RT_DEBUG_EXIT       	(-2)	// Terminate run
#define RT_DEBUG_CONTINUE   	(-1)	// Continue run
#define RT_DEBUG_NO_COMMAND		0		// There is no debug command at all
#define RT_DEBUG_STEP_IN    	1		// Step to next instruction
#define RT_DEBUG_STEP_OVER  	2		// Step to next statement in current scope
#define RT_DEBUG_STEP_OUT   	3		// Step to out of the current routine
#define RT_DEBUG_STEP_TO_CURSOR	4		// Step to next instruction

		typedef INT bStepType;

#define ob_IsInStepMode(obthis) ((obthis)->bStep > RT_DEBUG_NO_COMMAND)


		// Id number of temporary breakpoints
#define	RT_DEBUG_TEMP_BP_ID		LONG_MAX
#define	RT_DEBUG_FUNC_BP_ID		(RT_DEBUG_TEMP_BP_ID - 1)
#define	RT_DEBUG_EXCEPTION_BP_ID		(RT_DEBUG_TEMP_BP_ID - 2)

// **************************************************************************
//   Structure for breakpoint
// **************************************************************************

		typedef struct rt_breakpt                       // Breakpoint information
		{
			OB_CLASS_HNDL	obClassHndl;
			OB_VTABLE_ID	obRoutineID;
			UINT			iLineNumber;                 // Script line number
			LPTSTR			boolean_expr;
			UINT			n_times;
			UINT			nth_time;					// Re-init to 0 on each execution
			PVOID			watchPoint;					// Non-null is data watchpoint caused break
			LONG			id;							// unique id for remote debugging
			POB_THIS  		obthis;						// Pointer to the obthis for use by UI

		} RT_BREAKPOINT, FAR* PRT_BREAKPOINT;

		// **************************************************************************
		//   Structure for watchpoint
		// **************************************************************************

		typedef struct rt_watchpt                        // Watchpoint information
		{

			OB_DATA				last_data_node;			// Save the previous state
			POB_DATA			curr_data_node;			// Keep a pointer around
			BOOL				is_object_property;
			OB_INST_ID			rtinst;					// object if this is a property
			BOOL				is_local;				// Local to a function?
			INT					routine_level;			// if local
			LONG				id;						// unique id for remote debugging

		} RT_WATCHPOINT, FAR* PRT_WATCHPOINT;



		//****************************************************************************
		// Execute status enum
		//****************************************************************************

		typedef enum
		{
			RT_EXEC_SUCCESS,
			RT_EXEC_NO_SCRIPT,
			RT_EXEC_FAILURE,
			RT_EXEC_BADTOKEN,
			RT_EXEC_NO_MATCH

		} RT_EXEC_STATUS, FAR* PRT_EXEC_STATUS;

		//****************************************************************************
		// Macro definitions
		//****************************************************************************

#define rt_get_optimize_mode(rtthis)                                            \
							( ((PRT_THIS) (rtthis))->opt_mode )
#define rt_set_optimize_mode(rtthis,omode)                                  \
							( ((PRT_THIS) (rtthis))->opt_mode = omode  )

#define rt_get_app_clshndl(obthis)                                  \
							( ((POB_THIS) (obthis))->appclshndl)

#define rt_get_app_inst(obthis)                                  \
							( ((POB_THIS) (obthis))->appinst)

//****************************************************************************
// Public prototypes
//****************************************************************************

		VOID rt_clear_dlls
		(
			PRT_THIS			rtthis
		);

		PBWINAPI(VOID, rt_set_class_handle)
			(
				PRT_THIS                        rtthis,
				OB_CLASS_HNDL                   appclasshndl,
				OB_INST_ID                      appinst
				);

		PBWINAPI(PRT_THIS, rt_init)
			(
				POB_THIS                        obthis,
				ppbstg_anchor                   stgthis
				);

		PBWINAPI(INT, rt_start_debug)
			(
				PRT_THIS                        rtthis,
				RT_BREAK_PROC                   rtBreakCallback[],
				PVOID                           pUserData
				);

		PBWINAPI(INT, rt_stop_debug)
			(
				PRT_THIS                        rtthis
				);

		PBWINAPI(INT, rt_set_pcode_to_line)
			(
				POB_THIS 		obthis,
				UINT			line_no
				);

		PBWINAPI(PRT_BREAKPOINT, rt_breakpoint)
			(
				PRT_THIS                        rtthis,
				BOOL                            bSet,
				OB_CLASS_HNDL                   obClassHndl,
				OB_VTABLE_ID	   				vtable_id,
				UINT                            iLineNumber,
				UINT							n_times,
				LPTSTR							condition,
				LONG							id
				);

		enum WATCHPOINT_TYPE { LOCAL_WATCH, GLOBAL_WATCH, SHARED_WATCH, INSTANCE_WATCH };
		typedef enum WATCHPOINT_TYPE  WATCHPOINT_TYPE;

		PBWINAPI(PVOID, rt_create_watchpoint)
			(
				PRT_THIS			rtthis,
				POB_DATA_INFO		pdata_info,
				WATCHPOINT_TYPE		watch_type,
				BYTE				item_scope,
				LONG				id
				);

		PBWINAPI(PVOID, rt_find_watchpoint_for_watchid)
			(
				PRT_THIS rtthis,
				LONG	watchId
				);

		PBWINAPI(VOID, rt_delete_watchpoint)
			(
				PRT_THIS			rtthis,
				PVOID		 		watchpt
				);

		PBWINAPI(BOOL, rt_is_line_executable)
			(
				PRT_THIS                    rtthis,
				OB_CLASS_HNDL               class_hndl,
				OB_VTABLE_ID	   			vtable_id,
				UINT                        line_no
				);

		PBWINAPI(UINT, rt_closest_executable_line)
			(
				PRT_THIS                    rtthis,
				OB_CLASS_HNDL               class_hndl,
				OB_VTABLE_ID	   			vtable_id,
				UINT                        line_no
				);

		PBWINAPI(INT, rt_start_run)
			(
				PRT_THIS                        rtthis
				);

		PBWINAPI(INT, rt_stop_run)
			(
				PRT_THIS                        rtthis
				);

		PBWINAPI(INT, rt_create_obinst)
			(
				PRT_THIS 						rtthis,
				LPTSTR							name,
				POB_INST_ID						obinst
				);


		PBWINAPI(POB_DATA, rtReturnValGet)
			(
				PRT_THIS 						rtThis
				);

		PBWINAPI(VOID, rtReturnValFree)
			(
				PRT_THIS 						rtThis
				);

		// **************************************************************************
		//   Error handlers
		// **************************************************************************

		/***************************************************************
		In order not to include an extreme number of PB header files in ocx
		the rt_error_struct structure which is defined here
		is redefined in pbrxctl.h

		IT MUST BE KEPT IN SYNC WITH THE VERSION WITHIN PBRXCTL.H

		***************************************************************/
		typedef struct rt_error_struct
		{
			PRT_THIS			rtthis;
			LPTSTR				message;
			SHORT				error_no;
			USHORT				line_no;
			LPTSTR				group_name;
			LPTSTR				class_name;
			LPTSTR				rout_name;

		} RT_ERROR_STRUCT, FAR* PRT_ERROR_STRUCT;

		// Error callback definitions
#define CONTINUE_RT		1
#define HALT_RT 		2
#define HALT_CLOSE_RT	3

// callback to error handling routine. Make copies of any values in
// error struct, DisplayError = TRUE to display runtime error message,
// Runtime state uses continue, halt, or halt close defined above.
		typedef PBCALLBACK(VOID, *OB_ERROR_FUNC) (PRT_ERROR_STRUCT pErrorStruct,
			BOOL* bDisplayErr, LONG* RuntimeState);
		// end error callback

#ifndef PBOS_WIN
#define rt_formatted_error _rt_formatted_error
#define rt_build_error_struct _rt_build_error_struct
#define rt_get_current_error_struct _rt_get_current_error_struct
#endif

		PBWINAPI(INT, rt_error)
			(
				POB_THIS                        rtthis,
				INT                             iMessageID
				);

		PBCDECLAPI_(INT) rt_formatted_error
		(
			POB_THIS                        rtthis,
			INT                             iMessageID,
			...
		);

		PBCDECLAPI_(PRT_ERROR_STRUCT) rt_build_error_struct
		(
			POB_THIS                        rtthis,
			INT                             iMessageID,
			...
		);


		PBCDECLAPI_(PRT_ERROR_STRUCT) rt_get_current_error_struct
		(
			POB_THIS 			obthisGetErrorFromHere,
			POB_THIS 			obthisAllocateWithThis
		);

		PBWINAPI(VOID, rt_free_error_struct)
			(
				POB_THIS						rtthis,
				PRT_ERROR_STRUCT				error_struct
				);

		PBWINAPI(INT, rt_error_using_struct)
			(
				POB_THIS						rtthis,
				PRT_ERROR_STRUCT				error_struct,
				LPTSTR							exceptionClassName
				);

		PBWINAPI(OB_INST_ID, rt_build_exception_using_error)
			(
				POB_THIS         				obthis,
				PRT_ERROR_STRUCT 				pError,
				LPTSTR			 				className
				);

		PBWINAPI(VOID, rt_handle_uncaught_exception)
			(
				POB_THIS			obthis					// This pointer
				);

		PBWINAPI(VOID, rt_populate_error_struct)
			(
				POB_THIS			obthis,						// This pointer
				PRT_ERROR_STRUCT	error_struct,				// Error structure
				LPTSTR				message,					// Error message
				INT					iMessageID					// Error number
				);

		PBWINAPI(VOID, rt_populate_error_from_stack)
			(
				POB_THIS			obthis,						// This pointer
				PRT_ERROR_STRUCT	error_struct,				// Error structure
				LPTSTR				message,					// Error message
				INT					iMessageID					// Error number
				);

		PBWINAPI(BOOL, rt_call_error_callback)
			(
				POB_THIS						rtthis,
				PRT_ERROR_STRUCT				error_struct,
				BOOL							bAllowHalt
				);

		PBWINAPI(INT, rt_normalize_error_id)
			(
				POB_THIS 						obthis,
				INT    							iMessageID
				);

		PBWINAPI_(INT) rt_user_error
		(
			POB_THIS 			obthis, 					// This pointer
			INT    				iMessageID,					// Message ID
			LPTSTR				pMessageText,				// Message text
			BOOL				bInvokeErr					// Should the error handler be invoked?
		);

		PBWINAPI(INT, ot_handle_exception)
			(
				POB_THIS 			rtthis,
				void* pException_Stack,
				USHORT				currDepth
				);

		PBWINAPI(INT, ob_dbg_pop_call_stack_ntimes)
			(
				POB_THIS 			obthis,
				UINT				n
				);

		PBWINAPI(INT, ob_dbg_push_call_stack_ntimes)
			(
				POB_THIS 			obthis,
				UINT				n
				);

		PBWINAPI(PRT_BREAKPOINT, ob_get_current_stack_location)
			(
				POB_THIS 		obthis
				);

		// **************************************************************************
		//   Structures and enum for external routine callers.
		// **************************************************************************

		typedef enum
		{
			RT_INST_CALL,
			RT_CLASS_CALL,
			RT_CLASS_QUALIFIED_CALL

		} RT_CALL_TYPE, FAR* PRT_CALL_TYPE;

		typedef struct rtClassInfo_tag
		{
			OB_CLASS_HNDL	obClassHndl;
			OB_INST_ID		obInst;
		} RT_CALL_TYPE_INFO;

		typedef struct rtCallInfo
		{
			RT_CALL_TYPE_INFO	rtClassInfo;
			RT_CALL_TYPE		enCallType;
			BOOL				bDontTerminateRuntime; // If TRUE, runtime will NOT shut down or fire system error event

		} RT_CALL_INFO, FAR* PRT_CALL_INFO;

		typedef struct rtRoutineProtoInfo
		{
			OB_GROUP_ID			obGroupId;
			LPTSTR				pchRoutineName;
			LPTSTR				pchAliasName;
			LPTSTR				pchDllName;
			OB_DATA				obdReturnType;
			INT					iNoArgs;
			OB_ROUT_TYPE		obRoutineType;
			OB_MEMBER_ACCESS	obMemberAccess;
			POB_DATA			pobdArgArray;		//caller must free this array
			LPTSTR FAR* ppchArgNameArray;	//caller must free this array
			BOOL				bVarArgs;
			PVOID				ppArrayDefs;	    // pointer to an array of PVOIDs that point to
													// array information
													//caller must free this array
			LPTSTR               pchSystemEventName;	//caller should not free this
		} RT_ROUTINE_PROTO_INFO, FAR* PRT_ROUTINE_PROTO_INFO;

		typedef enum
		{
			RT_SIMPLE,
			RT_NOTIFY
		} RT_REFARG_TYPE, FAR* PRT_REFARG_TYPE;

		typedef struct rtRefArgInfo
		{
			RT_REFARG_TYPE	rtRefType;
			POB_DATA		pobdRefData;

		} RT_REFARG_INFO, FAR* PRT_REFARG_INFO;

		typedef struct rtClassDescrip
		{
			LPTSTR 			pchClassName;
			BOOL 			bIsStruct;
			BOOL			bIsGlobalStruct;

		} RT_CLASS_DESCRIP, FAR* PRT_CLASS_DESCRIP;

		// **************************************************************************
		//   Function prototypes for external routine callers.
		// **************************************************************************

		PBWINAPI(INT, rtRoutineSearch)
			(
				POB_THIS			obThis,
				RT_CALL_INFO		rtCallInfo,
				LPTSTR				pchRoutineName,
				POB_DATA			pobdArgArray,
				UINT				uiNoArgs,
				OB_ROUT_TYPE		obRoutineType,
				POB_VTABLE_ID		pobRoutineId
				);

		PBWINAPI(RT_EXEC_STATUS, rtRoutineExec)
			(
				POB_THIS			obThis,
				RT_CALL_INFO		rtCallInfo,
				POB_DATA			pobdArgArray,
				UINT				uiNoArgs,
				OB_VTABLE_ID		obRoutineId,
				OB_ROUT_TYPE		obRoutineType,
				BOOL				bConvert
				);

		PBWINAPI(RT_EXEC_STATUS, rtRoutineExecByName)
			(
				POB_THIS			obThis,
				LPTSTR				pchRoutineName,
				RT_CALL_INFO		rtCallInfo,
				POB_DATA			pobdArgArray,
				UINT				uiNoArgs,
				OB_ROUT_TYPE		obRoutineType,
				BOOL				bConvert
				);

		PBWINAPI(RT_EXEC_STATUS, rtRoutineExecPosted)
			(
				PVOID	pData
				);

		PBWINAPI(INT, rtRoutineInfo)
			(
				POB_THIS				obThis,
				RT_CALL_INFO			rtCallInfo,
				OB_VTABLE_ID			obRoutineId,
				PRT_ROUTINE_PROTO_INFO	pRoutineProtoInfo
				);

		// Free the ProtoInfo arrays allocated by rtRoutineInfo()
		PBWINAPI(VOID, rtRoutineProtoInfoFree)
			(
				POB_THIS				obThis,
				PRT_ROUTINE_PROTO_INFO	pRoutineProtoInfo
				);

		PBWINAPI(INT, rtInitializeInfoForCall)
			(
				POB_THIS				obThis,
				PRT_ROUTINE_PROTO_INFO	pRoutineProtoInfo
				);

		PBWINAPI(INT, rtCleanupInfoAfterCall)
			(
				POB_THIS				obThis,
				PRT_ROUTINE_PROTO_INFO	pRoutineProtoInfo
				);

		PBWINAPI(INT, rtRoutineCount)
			(
				POB_THIS			obThis,
				RT_CALL_INFO		rtCallInfo,
				PUSHORT				pusRoutineTotal,
				PUSHORT				pusFuncTotal,
				PUSHORT				pusEventTotal
				);

		PBWINAPI(INT, rtReferenceArgCreate)
			(
				POB_THIS 				obThis,
				POB_DATA				pobdRefArg,
				PRT_REFARG_INFO			prtRefArgInfo
				);

		PBWINAPI(INT, rtReferenceArgFree)
			(
				POB_THIS 				obThis,
				POB_DATA				pobdRefArg
				);

		PBWINAPI(INT, rtGetClassDescrip)
			(
				POB_THIS 				obThis,
				OB_CLASS_HNDL			obClassHndl,
				PRT_CLASS_DESCRIP		prtClassDescrip,
				POB_CLASS_ID			pobClassIdSystem
				);

		// Free the contents of an OB_DATA. For return values, use rtReturnValFree
		PBWINAPI(VOID, rtDataFree)
			(
				POB_THIS 				pobThis,
				POB_DATA				pobdVal
				);

#ifdef __cplusplus
		// Make a (deep) copy of an OB_DATA.
		PBWINAPI(VOID, rtDataCopy)
			(
				POB_THIS 				pobThis,
				POB_DATA				pobdDest,
				POB_DATA				pobdSrc,
				BOOL					AddReference = TRUE	// Add a reference to pobdDest if
				);											// the variable contains an object
#endif

		PBWINAPI(VOID, rt_hit_level_0)
			(
				POB_THIS				obthis
				);

		// force garbage collection at level 0
		//#define rtRoutineLevelSet(obthis,level)
			//	(((obthis)->routine_level = level) == 0 ? (ob_run_garbage_collection (obthis, TRUE)) : 0)

		// run garbage collection at level 0
		/* CR294957 zleng Oct/15/2002*/
		/*#define rtRoutineLevelSet(obthis,level)		\
				(((obthis)->routine_level = level) == 0 ? (rt_hit_level_0 (obthis)) : (VOID)0)
		*/
#define rtRoutineLevelIncrement(obthis)			\
	{											\
		(obthis)->routine_level++;				\
	}

#define rtRoutineLevelDecrement(obthis)								\
	{																\
		if ((obthis)->routine_level > 0)							\
		{															\
			(obthis)->routine_level--;								\
			if (obthis->routine_level == 0)							\
			{														\
				rt_hit_level_0(obthis);							\
			}														\
			else if ( (ob_is_response_window_open(obthis)) &&	    \
				( ob_get_top_response_window_routine_level(obthis)  \
					== (UINT) ob_get_routine_level(obthis)			\
				))													\
			{														\
				rt_hit_level_0 (obthis);							\
			}														\
		}															\
	}

		PBWINAPI(HRESULT, rt_StartJaguarDebug)(POB_THIS obthis, HWND hwnd);

		PBWINAPI(HRESULT, rt_StopJaguarDebug)(POB_THIS obthis);

		PBWINAPI(HRESULT, rt_JagBreakpointHit)(POB_THIS obthis, ULONG instance_id, ULONG breakpointID);

		PBWINAPI(HRESULT, rt_JaguarGetCurrentContext)(POB_THIS obthis, ULONG* instance_id, PRT_BREAKPOINT* breakpointID);

#if 0
		PBWINAPI(INT, obPsppCreateBody)
			(
				POB_THIS	obThis,
				UINT		numArgs,
				POB_GROUP	pGroup,
				OB_CLASS_ID	class_id,
				OB_CLASS_ID parent_class_id,
				LPCTSTR		fileName,
				UINT		protId
				);

		PBWINAPI(INT, obPsppDestroyBody)
			(
				POB_THIS	obThis,
				UINT		numArgs,
				POB_GROUP	pGroup,
				OB_CLASS_ID	class_id,
				OB_CLASS_ID parent_class_id,
				LPCTSTR		fileName,
				UINT		protId
				);
#endif

		PBWINAPI(INT, obPsppNormalBody)
			(
				POB_THIS	obThis,
				UINT		numArgs,
				POB_GROUP	pGroup,
				OB_CLASS_ID	class_id,
				OB_CLASS_ID parent_class_id,
				UINT		protId
				);

#ifdef __cplusplus
	}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif // RTPUBLIC_H

// DOINC popped back into header 'obobject.h'
#endif

#define OLDOBTHIS	NULL

//****************************************************************************
// Routine Level management class(Like SmartPointer).
//****************************************************************************
	class routineHelper
	{
		POB_THIS d_obthis;
	public:
		routineHelper(POB_THIS obthis)
			: d_obthis(obthis)
		{
			rtRoutineLevelIncrement(obthis);
		}
		~routineHelper()
		{
			rtRoutineLevelDecrement(d_obthis);
		}
	};

	//****************************************************************************
	// Forward declarations for the pointers to objects
	//****************************************************************************

	typedef class OB_OBJECT FAR* POB_OBJECT;
	typedef class OB_OBJECT FAR* POB_RUNTIME_INST;
	typedef POB_OBJECT FAR* PPOB_OBJECT;

#define UNDEFINED_RTINST NULL

	//****************************************************************************
	// Definitions for runtime reference list
	//****************************************************************************

	typedef struct ob_object_reference
	{
		PPOB_OBJECT			d_backReference;			// a reference to the variable pointing at instance
		BOOL				d_bIsExternal;			// Is this an external reference
#if defined(PSVER_D)
		LPTSTR				d_fileName;				// Filename where reference was added (debugging only)
		UINT				d_lineNo;					// Line number of filename where reference was added
#endif

		VOID Initialize(PPOB_OBJECT backReference, BOOL bIsExternal, LPTSTR fileName, UINT lineNo)
		{
			d_backReference = backReference;
			d_bIsExternal = bIsExternal;
#if defined(PSVER_D)
			d_fileName = fileName;
			d_lineNo = lineNo;
#endif
		};

		VOID ResetReference(POB_OBJECT pActualObject)
		{
			PB_ASSERT(d_backReference != NULL);
			PB_ASSERT(*d_backReference == pActualObject);
			if (*d_backReference == pActualObject)
				*d_backReference = UNDEFINED_RTINST;
			d_backReference = NULL;
		};

		VOID UpdateBackReference(POB_OBJECT pActualObject, PPOB_OBJECT newBackReference)
		{
			if (newBackReference == d_backReference)
				return;

			PB_ASSERT(d_backReference != NULL);
			PB_ASSERT(*d_backReference == pActualObject);
			PB_ASSERT(*newBackReference == pActualObject);
			if (*d_backReference == pActualObject)
				d_backReference = newBackReference;
		}

		PPOB_OBJECT GetBackReference() { return d_backReference; };
		BOOL IsExternal() { return d_bIsExternal; };
		VOID ExchangeWith(POB_OBJECT newObject) { *d_backReference = newObject; };
	} OB_OBJECT_REFERENCE, FAR* POB_OBJECT_REFERENCE;

	// create a dynamic array of reference structures
#define SHDYNARR_TYPE 			OB_OBJECT_REFERENCE
#define SHDYNARR_CLASS_NAME		OB_OBJECT_REF_ARRAY
// ***** DOINC including shdynarr.h *****
//**************************************************************************
//
//                            Copyright 1996
//                        Powersoft Corporation
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM POWERSOFT CORPORATION.
//
// ------------------------------------------------------------------------
//
//    Filename :	shdynarr.h
//
//    Author   :	Jeff Calow
//
//    Purpose  : 	Dynamic array for use in C++. 
//					Pseudo template version for 16 bit support.
//
// 				Code that wants to use this should do the following
//					#define SHDYNARR_TYPE <type of array contents>
//					#define SHDYNARR_CLASS_NAME <name of class to create>
//					#include "shdynarr.h"
//					#undef SHDYNARR_TYPE
//					#undef SHDYNARR_CLASS_NAME
//
//				If not specified, they default to:
//					#define SHDYNARR_TYPE PVOID
//					#define SHDYNARR_CLASS_NAME SH_DYN_PTR_ARRAY
//				and are undeffed automatically.
//****************************************************************************

// NOTE: Only the default case is included guarded
#if ! defined(SHDYNARR_H) || defined(SHDYNARR_TYPE)


// do the default case
#ifndef SHDYNARR_TYPE
#define SHDYNARR_H

#define SHDYNARR_TYPE PVOID
#define SHDYNARR_CLASS_NAME SH_DYN_PTR_ARRAY

#define SHDYNARR_DEFAULT_UNDEF
#endif

// Dynamic pointer array implementation

	class SHDYNARR_CLASS_NAME
	{
	private:
		SHDYNARR_TYPE FAR* block;
		LONG			numEntries;
		LONG			numAlloced;
		LONG			growBy;
		//bluo
		ppbstg_anchor	anchor;

		VOID initialize();
	public:
		// Constructors and Destructors
		// bluo
		// SHDYNARR_CLASS_NAME ();
		SHDYNARR_CLASS_NAME(ppbstg_anchor pAnchor = NULL);
		SHDYNARR_CLASS_NAME(const SHDYNARR_CLASS_NAME& oldOne);
		//~SHDYNARR_CLASS_NAME() { if (anchor != NULL) pbstg_free(anchor, block); else free(block); };
		~SHDYNARR_CLASS_NAME() 
		{
			if (anchor != NULL) 
				pbstg_fee((ppbstg_anchor)anchor, (void *)block);
			else 
				free(block); 
		};

		// access operations
		LONG Size() { return numEntries; };
		// returns the number of elements in the array
		SHDYNARR_TYPE& operator [] (LONG index);
		// indexes into the array.
		// If requested index is past the end of the current array,
		// the array is made bigger and filled with NULL's
		VOID insertBefore(LONG position, SHDYNARR_TYPE entry);
		// inserts the entry before the specified entry.
		// if the position is past the end of the array,
		//    the entry is appended to the array.
		VOID reset();
		// resets the the array to its initial state.
		// NOTE: Assumes that the contents of the array does not 
		// need to be freed.
	// bluo
		VOID setAnchor(ppbstg_anchor pAnchor);

	};

	// all inline functions for SHDYNARR_CLASS_NAME
	inline VOID SHDYNARR_CLASS_NAME::initialize()
	{
		block = NULL;
		numEntries = 0;
		numAlloced = 0;
		growBy = 15;
	}

	// bluo
	// inline SHDYNARR_CLASS_NAME::SHDYNARR_CLASS_NAME()
	inline SHDYNARR_CLASS_NAME::SHDYNARR_CLASS_NAME(ppbstg_anchor pAnchor)
		: anchor(pAnchor)

	{
		initialize();
	}

	inline SHDYNARR_CLASS_NAME::SHDYNARR_CLASS_NAME(const SHDYNARR_CLASS_NAME& oldOne)
	{
		numEntries = oldOne.numEntries;
		numAlloced = oldOne.numAlloced;
		growBy = oldOne.growBy;

		// get a new block
		// bluo
		// block = (SHDYNARR_TYPE FAR *) malloc ((size_t) (oldOne.numAlloced * sizeof (SHDYNARR_TYPE)));
		if (anchor != NULL)
			block = (SHDYNARR_TYPE FAR*) pbstg_alloc(anchor,
			(size_t)(oldOne.numAlloced * sizeof(SHDYNARR_TYPE)), PBSTG_DEFAULT);
		else
			block = (SHDYNARR_TYPE FAR*) malloc((size_t)(oldOne.numAlloced * sizeof(SHDYNARR_TYPE)));

		// copy entries from old block to new one
		pbstg_memcpy(block, oldOne.block, (size_t)(numAlloced * sizeof(SHDYNARR_TYPE)));
	}

	inline SHDYNARR_TYPE& SHDYNARR_CLASS_NAME::operator [] (LONG index)
	{
		// grow it if necessary
		if (index >= Size())
		{
			// check if we need to realloc
			if (index >= numAlloced)
			{
				// calculate the correct size
				LONG newSize = numAlloced + growBy;
				while (newSize <= index)
					newSize += growBy;
				// realloc it
				// bluo
				// block = (SHDYNARR_TYPE FAR *) realloc (block, (size_t) (newSize * sizeof (SHDYNARR_TYPE)));
				if (anchor != NULL)
					block = (SHDYNARR_TYPE FAR*) pbstg_realloc(anchor, block,
					(size_t)(newSize * sizeof(SHDYNARR_TYPE)), PBSTG_DEFAULT);
				else
					block = (SHDYNARR_TYPE FAR*) realloc(block, (size_t)(newSize * sizeof(SHDYNARR_TYPE)));

				// zero init it
				pbstg_memset(block + numAlloced, 0, (size_t)((newSize - numAlloced) * sizeof(SHDYNARR_TYPE)));
				numAlloced = newSize;
			}
			// reset the size
			numEntries = index + 1;
		}
		return block[index];
	}

	inline	VOID SHDYNARR_CLASS_NAME::insertBefore(LONG position, SHDYNARR_TYPE entry)
	{
		LONG	oldSize = Size();
		// if position past end
		if (position >= oldSize)
			// append it
			(*this)[oldSize] = entry;
		// if position before beginning
		else if (position < 0)
			// prepend it
			(*this)[0] = entry;
		// otherwise,
		else
		{
			// add a spot to the end
			(*this)[oldSize];
			// shift everything down by 1, use memmove because source and dest overlap!!
			pbstg_memmove(block + position + 1, block + position, (size_t)((oldSize - position) * sizeof(SHDYNARR_TYPE)));
			// add new element
			(*this)[position] = entry;
		}
	};

	inline	VOID SHDYNARR_CLASS_NAME::reset()
	{
		if (anchor != NULL)
			pbstg_free(anchor, block);
		else
			free(block);
		initialize();
	};

	// bluo
	inline	VOID SHDYNARR_CLASS_NAME::setAnchor(ppbstg_anchor pAnchor)
	{
		// If block is NULL, meaning we have already allocated a block of memory using
		//** malloc or from another pool, we should not replace the anchor, or PB will crash.
		
		if (block == NULL)
			anchor = pAnchor;
	}


	// if we defined them, undef them
#ifdef SHDYNARR_DEFAULT_UNDEF
#undef SHDYNARR_TYPE
#undef SHDYNARR_CLASS_NAME
#endif // SHDYNARR_DEFAULT_UNDEF

#endif // ! defined(SHDYNARR_H) || defined(SHDYNARR_TYPE)

// DOINC popped back into header 'obobject.h'
#undef SHDYNARR_TYPE
#undef SHDYNARR_CLASS_NAME

//***************************************************************************
//    Name:	   	Class OB_OBJECT
//***************************************************************************
	class OB_OBJECT : public IUnknown
	{
	protected:	// Instance variables
		OB_OBJECT_REF_ARRAY		d_reflist;			// List of all references to this object
		UINT					d_refCount;			// Number of references to this object
		UINT					d_externalRefCount;	// Number of those references that are external
		VOID* d_underlying_obj;

	protected:  // Member functions
		PBRESULT initialize()
		{
			d_refCount = 0;
			d_externalRefCount = 0;
			d_underlying_obj = NULL;
			return PB_SUCCESS;
		};

		PBRESULT deinitialize();
		PBRESULT addReferenceImpl(PPOB_OBJECT ppObject, BOOL isInternalRef, LPTSTR fileName,
			UINT lineNo);
		OB_OBJECT() { initialize(); };

		virtual ~OB_OBJECT() { };  // Virtual destructor

	public: // Constructors/Destructors
		OB_OBJECT(OB_OBJECT&); // Copy constructor

		virtual PBRESULT
			destroy
			(
				BOOL garbage_collected = FALSE,
				BOOL force_destruction = FALSE
			)
		{
			return OBJ_E_NOT_IMPLEMENTED;
		};

	public: // Member functions
		virtual PBRESULT getClass(PPOB_RUNTIME_CLASS pClass);
		virtual PBRESULT getClassName(LPTSTR* pname);
		virtual PBRESULT getParent(PPOB_OBJECT pParentObject);

		// Reference tracking information
		PBRESULT 	addExternalReference(PPOB_OBJECT pObject, LPTSTR fileName = NULL,
			UINT lineNo = 0);
		PBRESULT 	removeReference(PPOB_OBJECT pObject);
		PBRESULT	updateReference(PPOB_OBJECT pOldObject, PPOB_OBJECT pNewObject);

		ULONG		getReferenceCount();

		// Short cuts to object class info
		virtual PBRESULT getNumberOfFields(PULONG pNumFields);
		virtual PBRESULT getNumberOfSystemFields(PULONG pNumSystemFields);

		// Runtime instance field access macros
		virtual PBRESULT getField(LPTSTR name, POB_DATA pResult);
		virtual PBRESULT getField(ULONG index, POB_DATA pResult);
		virtual PBRESULT getFieldReference(LPTSTR name, POB_DATA& pResult);
		virtual PBRESULT getFieldReference(ULONG index, POB_DATA& pResult);

		virtual PBRESULT setField(LPTSTR name, POB_DATA pNewValue);
		virtual PBRESULT setField(ULONG index, POB_DATA pNewValue);

		VOID* getUnderlyingObject() const
		{
			return d_underlying_obj;
		}

		VOID	setUnderlyingObject(VOID* obj)
		{
			d_underlying_obj = obj;
		}

		// Method invokation

		virtual PBRESULT invoke(POB_CLASS context, OB_VTABLE_ID vtableId,
			USHORT numArgs, OB_DATA args[], POB_DATA pResult);
		virtual PBRESULT invoke(POB_CLASS context, OB_ROUT_TYPE routType,
			LPTSTR name, USHORT numArgs, OB_DATA args[], POB_DATA pResult);

		virtual PBRESULT invokeAsync(POB_CLASS context, OB_VTABLE_ID vtableId,
			USHORT numArgs, OB_DATA args[]);
		virtual PBRESULT invokeAsync(POB_CLASS context, OB_ROUT_TYPE routType,
			LPTSTR name, USHORT numArgs, OB_DATA args[]);

		virtual BOOL isRemoteObject() { return FALSE; }

		// Overrides from IUnknown
		STDMETHODIMP			QueryInterface(REFIID riid, LPVOID FAR* ppObject)
		{
			*ppObject = NULL; return E_NOINTERFACE;
		};
		STDMETHODIMP_(ULONG)	AddRef(void)
			// This objects are not controlled by this form of reference counting yet
		{
			return 1;
		};
		STDMETHODIMP_(ULONG)	Release(void)
		{
			return 1;
		};
	};

	// Macro to mask code instrumentation
#define addReference(obj)	\
	addExternalReference(obj,PBTEXT(__FILE__),__LINE__)

//****************************************************************************
// Global object utility functions
//****************************************************************************
	extern "C" {

		PBWINAPI(INT, ob_create_object)
			(
				POB_THIS 			obthis,
				POB_DATA 			destination,
				POB_GROUP			p_group,
				OB_CLASS_ID 		class_id
				);

		PBWINAPI(PBRESULT, ob_create_object_using)
			(
				POB_THIS 			obthis,
				POB_DATA 			destination,
				POB_RUNTIME_INST	context,
				LPTSTR		 		class_name
				);

		PBWINAPI(POB_RUNTIME_INST, ob_copy_rtinst)
			(
				POB_THIS                obthis,
				POB_RUNTIME_INST        from_rtinst
				);


		PBWINAPI(INT, ob_destroy_rtinst)
			(
				POB_THIS 			obthis,
				POB_RUNTIME_INST	rtinst
				);

		PBWINAPI(POB_RUNTIME_INST, ob_get_primary_rtinst)
			(
				POB_THIS			obthis,
				POB_RUNTIME_INST	rtinst
				);


		POB_RUNTIME_CLASS ob_get_rtinst_class
		(
			POB_RUNTIME_INST 	rtinst
		);

		OB_CLASS_ID ob_get_rtinst_class_id
		(
			POB_THIS 			obthis,
			POB_RUNTIME_INST	rtinst,
			POB_GROUP FAR* group = NULL
		);

		PBWINAPI(BOOL, ob_is_rtinst_autoinstantiate)
			(
				POB_THIS			obthis,
				POB_RUNTIME_INST	rtinst
				);

		// This comparison tests to see if either object is a structure and
		// if so, does a structure comparison. Otherwise the object references
		// are tested.
		PBWINAPI(BOOL, ob_object_compare)
			(
				POB_THIS			obthis,
				POB_RUNTIME_INST	rtinst1,
				POB_RUNTIME_INST	rtinst2
				);

		PBWINAPI(PBRESULT, ob_invoke_static)
			(
				POB_RUNTIME_INST	rtinst,
				POB_CLASS			context,
				OB_VTABLE_ID		vtableId,
				USHORT				numArgs,
				POB_DATA			args,
				POB_DATA			result
				);

		PBWINAPI(PBRESULT, ob_invoke_dynamic)
			(
				POB_RUNTIME_INST	rtinst,
				POB_CLASS			context,
				OB_ROUT_TYPE		routType,
				LPTSTR				name,
				USHORT				numArgs,
				POB_DATA			args,
				POB_DATA			result
				);

		PBWINAPI(PBRESULT, ob_invoke_staticAsync)
			(
				POB_RUNTIME_INST	rtinst,
				POB_CLASS			context,
				OB_VTABLE_ID		vtableId,
				USHORT				numArgs,
				POB_DATA			args
				);

		PBWINAPI(PBRESULT, ob_invoke_dynamicAsync)
			(
				POB_RUNTIME_INST	rtinst,
				POB_CLASS			context,
				OB_ROUT_TYPE		routType,
				LPTSTR				name,
				USHORT				numArgs,
				POB_DATA			args
				);

		//****************************************************************************
		// The following routines are used by code gen to obtain variable and
		// field lvalues and reference packets. They are defined here instead
		// of in obobjloc.h because they are needed for codegen and codegen
		// cannot see that file.
		// THESE METHODS ARE HACK METHODS. CODE GEN NEEDS TO BE REWORKED SO IT DOESN'T
		// USE THESE OR ANYTHING LIKE THESE.
		//****************************************************************************

		//****************************************************************************
		// Local object utility functions
		//****************************************************************************

		extern "C" {

			PBWINAPI(POB_DATA, ob_instance_lv)
				(
					POB_THIS			obthis,
					POB_RUNTIME_INST	current_inst,
					OB_SYM_ID	 		var_id
					);

			PBWINAPI(VOID, ob_instance_fldupdate_refpkt)
				(
					POB_THIS			obthis,
					POB_DATA 			destination,
					POB_RUNTIME_INST	current_inst,
					OB_SYM_ID	 		var_id
					);

			PBWINAPI(VOID, ob_instance_flditemupdate_refpkt)
				(
					POB_THIS			obthis,
					POB_DATA 			destination,
					POB_RUNTIME_INST	current_inst,
					OB_GROUP_ID			group_id,
					OB_SYM_ID	 		var_id,
					POB_DATA			lvalue,
					ULONG				item_index
					);

			PBWINAPI(VOID, ob_instance_simple_refpkt)
				(
					POB_THIS			obthis,
					POB_DATA 			destination,
					POB_RUNTIME_INST	current_inst,
					OB_SYM_ID	 		var_id
					);

		} // extern "C" {



	} // extern "C" {

#define ob_get_rtinst_group(obthis,rtinst)								\
	(ob_get_classinst_group(NULL,ob_get_rtinst_class(rtinst)))

#define ob_get_rtinst_group_id(obthis,rtinst)							\
	(ob_get_group_id (NULL, ob_get_rtinst_group(obthis,rtinst)))

#define ob_get_rtinst_nested_inst(obthis, rtinst)				\
	((POB_RUNTIME_INST)ob_get_parent_obinst((obthis), (OB_INST_ID)(rtinst)))

#define ob_get_rtinst_class_name(obthis,rtinst)							\
	(ob_get_obinst_class_name(obthis,(OB_INST_ID)(rtinst)))

//****************************************************************************
// Status macros and variables	
//****************************************************************************

#define ob_rtinst_defined(rtinst)          				                \
	OB_INST_DEFINED(rtinst)

#define ob_undefine_rtinst(rtinst)                                      \
	((rtinst) = NULL)

// This comparison operator only compares to see if the two object
// references are equal. Use ob_object_compare if you want the 
// comparison to handle structure contents.
#define ob_rtinst_compare(rtinst1,rtinst2)                              \
	((rtinst1) == (rtinst2))


//***************************************************************************
//
//	 Name:		OB_OBJECT::getClass ()
//
//   Synopsis:	gets the class of the object.
//
//   Returns:	OBJ_E_NOT_IMPLEMENTED
//
//***************************************************************************


	inline PBRESULT OB_OBJECT::getClass(PPOB_RUNTIME_CLASS pClass)
	{
		*pClass = NULL;
		return OBJ_E_NOT_IMPLEMENTED;
	}

	//***************************************************************************
	//
	//	 Name:		OB_OBJECT::getClass ()
	//
	//   Synopsis:	gets the class of the object.
	//
	//   Returns:	OBJ_E_NOT_IMPLEMENTED
	//
	//***************************************************************************

	inline PBRESULT OB_OBJECT::getClassName(LPTSTR* pname)
	{
		return OBJ_E_NOT_IMPLEMENTED;
	}

	//***************************************************************************
	//
	//	 Name:		OB_OBJECT::getClass ()
	//
	//   Synopsis:	gets the class of the object.
	//
	//   Returns:	OBJ_E_NOT_IMPLEMENTED
	//
	//***************************************************************************

	inline PBRESULT OB_OBJECT::getParent(PPOB_OBJECT pParentObject)
	{
		*pParentObject = UNDEFINED_RTINST;
		return OBJ_E_NOT_IMPLEMENTED;
	}

	//***************************************************************************
	//
	//	 Name:		OB_OBJECT::addExternalReference ()
	//
	//   Synopsis:	adds the object to this objects reference list. This is
	//				assumed to be an external reference and not an internal
	//				object manager reference.
	//
	//   Returns:	PB_SUCCESS
	//
	//   Notes:		
	//
	//***************************************************************************


	inline PBRESULT OB_OBJECT::addExternalReference(PPOB_OBJECT pObject, LPTSTR fileName,
		UINT lineNo)
	{
		return addReferenceImpl(pObject, FALSE, fileName, lineNo);
	}


	//***************************************************************************
	//
	//	 Name:		OB_OBJECT::getReferenceCount ()
	//
	//   Synopsis:	returns the number of objects that reference this object.
	//
	//   Returns:	OBJ_E_NOT_IMPLEMENTED
	//
	//***************************************************************************

	inline ULONG OB_OBJECT::getReferenceCount()
	{
		return d_refCount;
	}

	//***************************************************************************
	//
	//	 Name:		OB_OBJECT::getNumberOfFields ()
	//
	//   Synopsis:	returns the number of fields an object has
	//
	//   Returns:	OBJ_E_NOT_IMPLEMENTED
	//
	//***************************************************************************

	inline PBRESULT  OB_OBJECT::getNumberOfFields(PULONG pNumFields)
	{
		return OBJ_E_NOT_IMPLEMENTED;
	}

	//***************************************************************************
	//
	//	 Name:		OB_OBJECT::getNumberOfSystemFields ()
	//
	//   Synopsis:	returns the number of fields an object has
	//
	//   Returns:	OBJ_E_NOT_IMPLEMENTED
	//
	//***************************************************************************

	inline PBRESULT  OB_OBJECT::getNumberOfSystemFields(PULONG pNumSystemFields)
	{
		return OBJ_E_NOT_IMPLEMENTED;
	}

	//***************************************************************************
	//
	//	 Name:		OB_OBJECT::getField ()
	//
	//   Synopsis:	returns a field referenced by name
	//
	//   Returns:	OBJ_E_NOT_IMPLEMENTED
	//
	//***************************************************************************

	inline PBRESULT OB_OBJECT::getField
	(
		LPTSTR name,
		POB_DATA pResult
	)
	{
		return OBJ_E_NOT_IMPLEMENTED;
	}

	//***************************************************************************
	//
	//	 Name:		OB_OBJECT::getField ()
	//
	//   Synopsis:	returns a field referenced by index.
	//
	//   Returns:	OBJ_E_NOT_IMPLEMENTED
	//
	//***************************************************************************

	inline PBRESULT OB_OBJECT::getField
	(
		ULONG index,
		POB_DATA pResult
	)
	{
		return OBJ_E_NOT_IMPLEMENTED;
	}

	//***************************************************************************
	//
	//	 Name:		OB_OBJECT::getFieldReference ()
	//
	//   Synopsis:	returns a refpkt of the field referenced by name
	//
	//   Returns:	OBJ_E_NOT_IMPLEMENTED
	//
	//***************************************************************************


	inline PBRESULT OB_OBJECT::getFieldReference
	(
		LPTSTR name,
		POB_DATA& pResult
	)
	{
		return OBJ_E_NOT_IMPLEMENTED;
	}

	//***************************************************************************
	//
	//	 Name:		OB_OBJECT::getFieldReference ()
	//
	//   Synopsis:	returns a refpkt of the field referenced by index.
	//
	//   Returns:	OBJ_E_NOT_IMPLEMENTED
	//
	//***************************************************************************

	inline PBRESULT OB_OBJECT::getFieldReference
	(
		ULONG index,
		POB_DATA& pResult
	)
	{
		return OBJ_E_NOT_IMPLEMENTED;
	}

	//***************************************************************************
	//
	//	 Name:		OB_OBJECT::setField ()
	//
	//   Synopsis:	sets the value of a field referenced by name.
	//
	//   Returns:	OBJ_E_NOT_IMPLEMENTED
	//
	//***************************************************************************

	inline PBRESULT OB_OBJECT::setField
	(
		LPTSTR name,
		POB_DATA pNewValue
	)
	{
		return OBJ_E_NOT_IMPLEMENTED;
	}

	//***************************************************************************
	//
	//	 Name:		OB_OBJECT::setField ()
	//
	//   Synopsis:	sets the value of a field referenced by index.
	//
	//   Returns:	OBJ_E_NOT_IMPLEMENTED
	//
	//***************************************************************************

	inline PBRESULT OB_OBJECT::setField
	(
		ULONG index,
		POB_DATA pNewValue
	)
	{
		return OBJ_E_NOT_IMPLEMENTED;
	}

	//***************************************************************************
	//
	//	 Name:		OB_OBJECT::invoke ()
	//
	//   Synopsis:	invokes a method of an object referenced by vtable id.
	//
	//   Returns:	OBJ_E_NOT_IMPLEMENTED
	//
	//***************************************************************************

	inline PBRESULT OB_OBJECT::invoke
	(
		POB_CLASS	 context,
		OB_VTABLE_ID vtable_id,
		USHORT numArgs,
		OB_DATA args[],
		POB_DATA pResult
	)
	{
		pResult = NULL;
		return OBJ_E_NOT_IMPLEMENTED;
	}

	//***************************************************************************
	//
	//	 Name:		OB_OBJECT::invoke ()
	//
	//   Synopsis:	invokes a method of an object referenced by name.
	//
	//   Returns:	OBJ_E_NOT_IMPLEMENTED
	//
	//***************************************************************************

	inline PBRESULT OB_OBJECT::invoke
	(
		POB_CLASS context,
		OB_ROUT_TYPE routType,
		LPTSTR name,
		USHORT numArgs,
		OB_DATA args[],
		POB_DATA pResult
	)
	{
		pResult = NULL;
		return OBJ_E_NOT_IMPLEMENTED;
	}

	//***************************************************************************
	//
	//	 Name:		OB_OBJECT::invokeAsync ()
	//
	//   Synopsis:	invokes a method of an object asynchronously 
	//				referenced by vtable id.
	//
	//   Returns:	OBJ_E_NOT_IMPLEMENTED
	//
	//***************************************************************************

	inline PBRESULT OB_OBJECT::invokeAsync
	(
		POB_CLASS context,
		OB_VTABLE_ID vtable_id,
		USHORT numArgs,
		OB_DATA args[]
	)
	{
		return OBJ_E_NOT_IMPLEMENTED;
	}

	//***************************************************************************
	//
	//	 Name:		OB_OBJECT::invokeAsync ()
	//
	//   Synopsis:	invokes a method of an object asynchronously 
	//				referenced by name.
	//
	//***************************************************************************

	inline PBRESULT OB_OBJECT::invokeAsync
	(
		POB_CLASS context,
		OB_ROUT_TYPE routType,
		LPTSTR name,
		USHORT numArgs,
		OB_DATA args[]
	)
	{
		return OBJ_E_NOT_IMPLEMENTED;
	}

#endif // OBOBJECT_H

	// DOINC popped back into header 'obgroup.h'
#endif
#ifndef OBPROPER_H
// ***** DOINC including obproper.h *****
//**************************************************************************
//
//                            Copyright 1996
//                        Powersoft Corporation
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM POWERSOFT CORPORATION.
//
// ------------------------------------------------------------------------
//
//    Filename :	obproper.h
//
//    Author   :	Jim Ducharme
//
//    Purpose  : 	Property API.
//
//****************************************************************************

#ifndef OBPROPER_H
#define OBPROPER_H

#ifndef GENERATED_CODE_BUILD
#ifdef __cplusplus         // Skip over these C++ definitions if we are compiling C code.

#ifndef OBTHIS_H
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
#endif

#ifndef PBCOM_H
// ***** DOINC including pbcom.h *****
	// DOINC skipping duplicate include
#endif

#ifndef __pbprop_h__
// ***** DOINC including pbprop.h *****


/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* at Tue Apr 29 21:01:17 2014
 */
 /* Compiler settings for pbprop.idl:
	 Oicf, W1, Zp8, env=Win32 (32b run)
	 protocol : dce , ms_ext, c_ext, robust
	 error checks: allocation ref bounds_check enum stub_data
	 VC __declspec() decoration level:
		  __declspec(uuid()), __declspec(selectany), __declspec(novtable)
		  DECLSPEC_UUID(), MIDL_INTERFACE()
 */
 //@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

// ***** DOINC including rpc.h *****
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

	rpc.h

Abstract:

	Master include file for RPC applications.

--*/

#if !defined( RPC_NO_WINDOWS_H ) && !defined( MAC ) && !defined( _MAC )
#include <windows.h>
#endif // RPC_NO_WINDOWS_H

#ifndef __RPC_H__
#define __RPC_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
	extern "C" {
#endif

		//-------------------------------------------------------------
		// platform specific defines
		//-------------------------------------------------------------

		//-------------------  MAC ---------------------------
#if defined( MAC ) || defined( _MAC )

#define __RPC_MAC__
// Set the packing level for RPC structures.

#include <pshpack2.h>

//-------------------  WIN32 ---------------------------
#else // win32 platforms

#include <basetsd.h>

#if defined(_M_IA64) || defined(_M_AMD64)
#define __RPC_WIN64__
#else
#define __RPC_WIN32__
#endif

#endif

#if defined(__RPC_WIN64__)
#include <pshpack8.h>
#endif

#ifndef __MIDL_USER_DEFINED
#define midl_user_allocate MIDL_user_allocate
#define midl_user_free     MIDL_user_free
#define __MIDL_USER_DEFINED
#endif

		typedef void* I_RPC_HANDLE;
		typedef long RPC_STATUS;

#if defined(__RPC_WIN32__) || defined(__RPC_WIN64__)
#define RPC_UNICODE_SUPPORTED
#endif

#if !defined(_M_AMD64) && !defined(__RPC_MAC__) && ( (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED) )
#	define __RPC_API  __stdcall
#	define __RPC_USER __stdcall
#	define __RPC_STUB __stdcall
#	define  RPC_ENTRY __stdcall
#else // Not Win32/Win64
#	define __RPC_API
#	define __RPC_USER
#	define __RPC_STUB
#	define RPC_ENTRY
#endif

#define __RPC_FAR

		// Some RPC platforms don't define DECLSPEC_IMPORT
#if !defined(DECLSPEC_IMPORT)
#if (defined(_M_MRX000) || defined(_M_IX86) || defined(_M_IA64) || defined(_M_AMD64)) && !defined(MIDL_PASS)
#define DECLSPEC_IMPORT __declspec(dllimport)
#else
#define DECLSPEC_IMPORT
#endif
#endif

#if !defined(_RPCRT4_)
#define RPCRTAPI DECLSPEC_IMPORT
#else
#define RPCRTAPI
#endif

#if !defined(_RPCNS4_)
#define RPCNSAPI DECLSPEC_IMPORT
#else
#define RPCNSAPI
#endif

#ifdef __RPC_MAC__

#include <setjmp.h>

#define RPCXCWORD (sizeof(jmp_buf)/sizeof(int))

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable: 4005 )
#include <rpcdce.h>
#include <rpcnsi.h>
#include <rpcerr.h>
#include <rpcmac.h>
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default :  4005 )
#endif

		typedef void  (RPC_ENTRY* MACYIELDCALLBACK)(/*OSErr*/ short*);
		RPC_STATUS RPC_ENTRY
			RpcMacSetYieldInfo(
				MACYIELDCALLBACK pfnCallback);

#if !defined(UNALIGNED)
#define UNALIGNED
#endif

#include <poppack.h>

#else // __RPC_MAC__

#include <rpcdce.h>
#include <rpcnsi.h>
#include <rpcnterr.h>
#include <excpt.h>
#include <winerror.h>

#define RpcTryExcept \
    __try \
        {

// trystmts

#define RpcExcept(expr) \
        } \
    __except (expr) \
        {

// exceptstmts

#define RpcEndExcept \
        }

#define RpcTryFinally \
    __try \
        {

// trystmts

#define RpcFinally \
        } \
    __finally \
        {

// finallystmts

#define RpcEndFinally \
        }

#define RpcExceptionCode() GetExceptionCode()
#define RpcAbnormalTermination() AbnormalTermination()

#endif // __RPC_MAC__

// Definitions which depend on windows.h
#if !defined( RPC_NO_WINDOWS_H ) && !defined(__RPC_MAC__)

#include <rpcasync.h>

#endif // RPC_NO_WINDOWS_H

#if defined(__RPC_WIN64__)
#include <poppack.h>
#endif

#ifdef __cplusplus
	}
#endif

#endif // __RPC_H__

	// DOINC popped back into header 'pbprop.h'
	// ***** DOINC including rpcndr.h *****
	/*++

	Copyright (c) Microsoft Corporation. All rights reserved.

	Module Name:

		rpcndr.h

	Abstract:

		Definitions for stub data structures and prototypes of helper functions.

	--*/

	// This version of the rpcndr.h file corresponds to MIDL version 5.0.+
	// used with Windows 2000/XP build 1700+


#ifndef __RPCNDR_H_VERSION__
#define __RPCNDR_H_VERSION__        ( 475 )
#endif // __RPCNDR_H_VERSION__


#ifndef __RPCNDR_H__
#define __RPCNDR_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __REQUIRED_RPCNDR_H_VERSION__
#if ( __RPCNDR_H_VERSION__ < __REQUIRED_RPCNDR_H_VERSION__ )
#error incorrect <rpcndr.h> version. Use the header that matches with the MIDL compiler.
#endif
#endif


#include <pshpack8.h>
#include <basetsd.h>
#include <rpcnsip.h>


#ifdef __cplusplus
	extern "C" {
#endif

		/****************************************************************************

			 Network Computing Architecture (NCA) definition:

			 Network Data Representation: (NDR) Label format:
			 An unsigned long (32 bits) with the following layout:

			 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
			 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
			+---------------+---------------+---------------+-------+-------+
			|   Reserved    |   Reserved    |Floating point | Int   | Char  |
			|               |               |Representation | Rep.  | Rep.  |
			+---------------+---------------+---------------+-------+-------+

			 Where

				 Reserved:

					 Must be zero (0) for NCA 1.5 and NCA 2.0.

				 Floating point Representation is:

					 0 - IEEE
					 1 - VAX
					 2 - Cray
					 3 - IBM

				 Int Rep. is Integer Representation:

					 0 - Big Endian
					 1 - Little Endian

				 Char Rep. is Character Representation:

					 0 - ASCII
					 1 - EBCDIC

			 The Microsoft Local Data Representation (for all platforms which are
			 of interest currently is edefined below:

		 ****************************************************************************/

#define NDR_CHAR_REP_MASK               (unsigned long)0X0000000FL
#define NDR_INT_REP_MASK                (unsigned long)0X000000F0L
#define NDR_FLOAT_REP_MASK              (unsigned long)0X0000FF00L

#define NDR_LITTLE_ENDIAN               (unsigned long)0X00000010L
#define NDR_BIG_ENDIAN                  (unsigned long)0X00000000L

#define NDR_IEEE_FLOAT                  (unsigned long)0X00000000L
#define NDR_VAX_FLOAT                   (unsigned long)0X00000100L
#define NDR_IBM_FLOAT                   (unsigned long)0X00000300L

#define NDR_ASCII_CHAR                  (unsigned long)0X00000000L
#define NDR_EBCDIC_CHAR                 (unsigned long)0X00000001L

#if defined(__RPC_MAC__)
#define NDR_LOCAL_DATA_REPRESENTATION   (unsigned long)0X00000000L
#define NDR_LOCAL_ENDIAN                NDR_BIG_ENDIAN
#else
#define NDR_LOCAL_DATA_REPRESENTATION   (unsigned long)0X00000010L
#define NDR_LOCAL_ENDIAN                NDR_LITTLE_ENDIAN
#endif


		 /****************************************************************************
		  *  Macros for targeted platforms
		  ****************************************************************************/

#if (0x501 <= _WIN32_WINNT)
#define TARGET_IS_NT51_OR_LATER                   1
#else
#define TARGET_IS_NT51_OR_LATER                   0
#endif

#if (0x500 <= _WIN32_WINNT)
#define TARGET_IS_NT50_OR_LATER                   1
#else
#define TARGET_IS_NT50_OR_LATER                   0
#endif

#if (defined(_WIN32_DCOM) || 0x400 <= _WIN32_WINNT)
#define TARGET_IS_NT40_OR_LATER                   1
#else
#define TARGET_IS_NT40_OR_LATER                   0
#endif

#if (0x400 <= WINVER)
#define TARGET_IS_NT351_OR_WIN95_OR_LATER         1
#else
#define TARGET_IS_NT351_OR_WIN95_OR_LATER         0
#endif

		  /****************************************************************************
		   *  Other MIDL base types / predefined types:
		   ****************************************************************************/

#define small char
		typedef unsigned char byte;
		typedef byte cs_byte;
		typedef unsigned char boolean;

#ifndef _HYPER_DEFINED
#define _HYPER_DEFINED

#if (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64))
#define  hyper           __int64
#define MIDL_uhyper  unsigned __int64
#else
		typedef double  hyper;
		typedef double MIDL_uhyper;
#endif

#endif // _HYPER_DEFINED

#ifndef _WCHAR_T_DEFINED
		typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
#ifdef __RPC_WIN64__
		typedef unsigned __int64 size_t;
#else
		typedef unsigned int     size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifdef __RPC_WIN32__
#if   (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#define __RPC_CALLEE       __stdcall
#else
#define __RPC_CALLEE
#endif
#endif

#ifndef __MIDL_USER_DEFINED
#define midl_user_allocate MIDL_user_allocate
#define midl_user_free     MIDL_user_free
#define __MIDL_USER_DEFINED
#endif

		void* __RPC_USER MIDL_user_allocate(size_t);
		void             __RPC_USER MIDL_user_free(void*);

#define RPC_VAR_ENTRY __cdecl


		/* winnt only */
#if defined(_M_IX86) || defined(_M_AMD64) || defined(_M_IA64)
#define __MIDL_DECLSPEC_DLLIMPORT   __declspec(dllimport)
#define __MIDL_DECLSPEC_DLLEXPORT   __declspec(dllexport)
#else
#define __MIDL_DECLSPEC_DLLIMPORT
#define __MIDL_DECLSPEC_DLLEXPORT
#endif




/****************************************************************************
 * Context handle management related definitions:
 *
 * Client and Server Contexts.
 *
 ****************************************************************************/

		typedef void* NDR_CCONTEXT;

		typedef struct
		{
			void* pad[2];
			void* userContext;
		}  *NDR_SCONTEXT;

#define NDRSContextValue(hContext) (&(hContext)->userContext)

#define cbNDRContext 20         /* size of context on WIRE */

		typedef void (__RPC_USER* NDR_RUNDOWN)(void* context);

		typedef void (__RPC_USER* NDR_NOTIFY_ROUTINE)(void);
		typedef void (__RPC_USER* NDR_NOTIFY2_ROUTINE)(boolean flag);

		typedef struct _SCONTEXT_QUEUE {
			unsigned long   NumberOfObjects;
			NDR_SCONTEXT* ArrayOfObjects;
		} SCONTEXT_QUEUE, * PSCONTEXT_QUEUE;

		RPCRTAPI
			RPC_BINDING_HANDLE
			RPC_ENTRY
			NDRCContextBinding(
				IN NDR_CCONTEXT     CContext
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NDRCContextMarshall(
				IN  NDR_CCONTEXT    CContext,
				OUT void* pBuff
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NDRCContextUnmarshall(
				OUT NDR_CCONTEXT* pCContext,
				IN  RPC_BINDING_HANDLE      hBinding,
				IN  void* pBuff,
				IN  unsigned long           DataRepresentation
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NDRSContextMarshall(
				IN  NDR_SCONTEXT    CContext,
				OUT void* pBuff,
				IN  NDR_RUNDOWN     userRunDownIn
			);

		RPCRTAPI
			NDR_SCONTEXT
			RPC_ENTRY
			NDRSContextUnmarshall(
				IN  void* pBuff,
				IN  unsigned long   DataRepresentation
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NDRSContextMarshallEx(
				IN  RPC_BINDING_HANDLE  BindingHandle,
				IN  NDR_SCONTEXT        CContext,
				OUT void* pBuff,
				IN  NDR_RUNDOWN         userRunDownIn
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NDRSContextMarshall2(
				IN  RPC_BINDING_HANDLE  BindingHandle,
				IN  NDR_SCONTEXT        CContext,
				OUT void* pBuff,
				IN  NDR_RUNDOWN         userRunDownIn,
				IN  void* CtxGuard,
				IN unsigned long        Flags
			);

		RPCRTAPI
			NDR_SCONTEXT
			RPC_ENTRY
			NDRSContextUnmarshallEx(
				IN  RPC_BINDING_HANDLE  BindingHandle,
				IN  void* pBuff,
				IN  unsigned long       DataRepresentation
			);

		RPCRTAPI
			NDR_SCONTEXT
			RPC_ENTRY
			NDRSContextUnmarshall2(
				IN  RPC_BINDING_HANDLE  BindingHandle,
				IN  void* pBuff,
				IN  unsigned long       DataRepresentation,
				IN  void* CtxGuard,
				IN unsigned long        Flags
			);

		RPCRTAPI
			void
			RPC_ENTRY
			RpcSsDestroyClientContext(
				IN void** ContextHandle
			);


		/****************************************************************************
			NDR conversion related definitions.
		 ****************************************************************************/

#define byte_from_ndr(source, target) \
    { \
    *(target) = *(*(char  *  *)&(source)->Buffer)++; \
    }

#define byte_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char  *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long  *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

#define boolean_from_ndr(source, target) \
    { \
    *(target) = *(*(char  *  *)&(source)->Buffer)++; \
    }

#define boolean_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char  *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long  *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

#define small_from_ndr(source, target) \
    { \
    *(target) = *(*(char  *  *)&(source)->Buffer)++; \
    }

#define small_from_ndr_temp(source, target, format) \
    { \
    *(target) = *(*(char  *  *)(source))++; \
    }

#define small_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char  *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long  *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

		 /****************************************************************************
			 Platform specific mapping of c-runtime functions.
		  ****************************************************************************/

#if defined(__RPC_WIN32__) || defined(__RPC_WIN64__)
#define MIDL_ascii_strlen(string) \
    strlen(string)
#define MIDL_ascii_strcpy(target,source) \
    strcpy(target,source)
#define MIDL_memset(s,c,n) \
    memset(s,c,n)
#endif

		  /****************************************************************************
			  MIDL 2.0 ndr definitions.
		   ****************************************************************************/

		typedef unsigned long error_status_t;

#define _midl_ma1( p, cast )    *(*( cast **)&p)++
#define _midl_ma2( p, cast )    *(*( cast **)&p)++
#define _midl_ma4( p, cast )    *(*( cast **)&p)++
#define _midl_ma8( p, cast )    *(*( cast **)&p)++

#define _midl_unma1( p, cast )  *(( cast *)p)++
#define _midl_unma2( p, cast )  *(( cast *)p)++
#define _midl_unma3( p, cast )  *(( cast *)p)++
#define _midl_unma4( p, cast )  *(( cast *)p)++

		// Some alignment specific macros.

		// RKK64
		// these appear to be used in fossils inside MIDL
#define _midl_fa2( p )          (p = (RPC_BUFPTR )((ULONG_PTR)(p+1) & ~0x1))
#define _midl_fa4( p )          (p = (RPC_BUFPTR )((ULONG_PTR)(p+3) & ~0x3))
#define _midl_fa8( p )          (p = (RPC_BUFPTR )((ULONG_PTR)(p+7) & ~0x7))

#define _midl_addp( p, n )      (p += n)

// Marshalling macros

#define _midl_marsh_lhs( p, cast )  *(*( cast **)&p)++
#define _midl_marsh_up( mp, p )     *(*(unsigned long **)&mp)++ = (unsigned long)p
#define _midl_advmp( mp )           *(*(unsigned long **)&mp)++
#define _midl_unmarsh_up( p )       (*(*(unsigned long **)&p)++)


////////////////////////////////////////////////////////////////////////////
// Ndr macros.
////////////////////////////////////////////////////////////////////////////

// RKK64
// these appear to be used in fossils inside MIDL
#define NdrMarshConfStringHdr( p, s, l )    (_midl_ma4( p, unsigned long) = s, \
                                            _midl_ma4( p, unsigned long) = 0, \
                                            _midl_ma4( p, unsigned long) = l)

#define NdrUnMarshConfStringHdr(p, s, l)    ((s=_midl_unma4(p,unsigned long),\
                                            (_midl_addp(p,4)),               \
                                            (l=_midl_unma4(p,unsigned long))

#define NdrMarshCCtxtHdl(pc,p)  (NDRCContextMarshall( (NDR_CCONTEXT)pc, p ),p+20)

#define NdrUnMarshCCtxtHdl(pc,p,h,drep) \
        (NDRCContextUnmarshall((NDR_CONTEXT)pc,h,p,drep), p+20)

#define NdrUnMarshSCtxtHdl(pc, p,drep)  (pc = NdrSContextUnMarshall(p,drep ))


#define NdrMarshSCtxtHdl(pc,p,rd)   (NdrSContextMarshall((NDR_SCONTEXT)pc,p, (NDR_RUNDOWN)rd)

// end of unused

#define NdrFieldOffset(s,f)     (LONG_PTR)(& (((s  *)0)->f))
#define NdrFieldPad(s,f,p,t)    ((unsigned long)(NdrFieldOffset(s,f) - NdrFieldOffset(s,p)) - sizeof(t))

#define NdrFcShort(s)   (unsigned char)(s & 0xff), (unsigned char)(s >> 8)
#define NdrFcLong(s)    (unsigned char)(s & 0xff), (unsigned char)((s & 0x0000ff00) >> 8), \
                        (unsigned char)((s & 0x00ff0000) >> 16), (unsigned char)(s >> 24)

//
// On the server side, the following exceptions are mapped to
// the bad stub data exception if -error stub_data is used.
//

#define RPC_BAD_STUB_DATA_EXCEPTION_FILTER  \
                 ( (RpcExceptionCode() == STATUS_ACCESS_VIOLATION)  || \
                   (RpcExceptionCode() == STATUS_DATATYPE_MISALIGNMENT) || \
                   (RpcExceptionCode() == RPC_X_BAD_STUB_DATA) || \
                   (RpcExceptionCode() == RPC_S_INVALID_BOUND) )

/////////////////////////////////////////////////////////////////////////////
// Some stub helper functions.
/////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// Stub helper structures.
////////////////////////////////////////////////////////////////////////////

		struct _MIDL_STUB_MESSAGE;
		struct _MIDL_STUB_DESC;
		struct _FULL_PTR_XLAT_TABLES;

		typedef unsigned char* RPC_BUFPTR;
		typedef unsigned long       RPC_LENGTH;

		// Expression evaluation callback routine prototype.
		typedef void (__RPC_USER* EXPR_EVAL)(struct _MIDL_STUB_MESSAGE*);

		typedef const unsigned char* PFORMAT_STRING;

		/*
		 * Multidimensional conformant/varying array struct.
		 */
		typedef struct
		{
			long              Dimension;

			/* These fields MUST be (unsigned long *) */
			unsigned long* BufferConformanceMark;
			unsigned long* BufferVarianceMark;

			/* Count arrays, used for top level arrays in -Os stubs */
			unsigned long* MaxCountArray;
			unsigned long* OffsetArray;
			unsigned long* ActualCountArray;
		} ARRAY_INFO, * PARRAY_INFO;


		typedef struct _NDR_ASYNC_MESSAGE* PNDR_ASYNC_MESSAGE;
		typedef struct _NDR_CORRELATION_INFO* PNDR_CORRELATION_INFO;

		/*
		 * cs_char info in the stub message
		 */

		typedef struct
		{
			unsigned long   WireCodeset;
			unsigned long   DesiredReceivingCodeset;
			void* CSArrayInfo;
		} CS_STUB_INFO;

		/*
		 * MIDL Stub Message
		 */

		typedef const unsigned char* PFORMAT_STRING;
		typedef struct _MIDL_SYNTAX_INFO MIDL_SYNTAX_INFO, * PMIDL_SYNTAX_INFO;

		struct NDR_ALLOC_ALL_NODES_CONTEXT;
		struct NDR_POINTER_QUEUE_STATE;
		struct _NDR_PROC_CONTEXT;

		typedef struct _MIDL_STUB_MESSAGE
		{
			/* RPC message structure. */
			PRPC_MESSAGE            RpcMsg;

			/* Pointer into RPC message buffer. */
			unsigned char* Buffer;

			/*
			 * These are used internally by the Ndr routines to mark the beginning
			 * and end of an incoming RPC buffer.
			 */
			unsigned char* BufferStart;
			unsigned char* BufferEnd;

			/*
			 * Used internally by the Ndr routines as a place holder in the buffer.
			 * On the marshalling side it's used to mark the location where conformance
			 * size should be marshalled.
			 * On the unmarshalling side it's used to mark the location in the buffer
			 * used during pointer unmarshalling to base pointer offsets off of.
			 */
			unsigned char* BufferMark;

			/* Set by the buffer sizing routines. */
			unsigned long           BufferLength;

			/* Set by the memory sizing routines. */
			unsigned long           MemorySize;

			/* Pointer to user memory. */
			unsigned char* Memory;

			/* Is the Ndr routine begin called from a client side stub. */
			int                     IsClient;

			/* Can the buffer be re-used for memory on unmarshalling. */
			int                     ReuseBuffer;

			/* Hold the context for allocate all nodes */
			struct NDR_ALLOC_ALL_NODES_CONTEXT* pAllocAllNodesContext;
			struct NDR_POINTER_QUEUE_STATE* pPointerQueueState;

			/*
			 * Stuff needed while handling complex structures
			 */

			 /* Ignore imbeded pointers while computing buffer or memory sizes. */
			int                     IgnoreEmbeddedPointers;

			/*
			 * This marks the location in the buffer where pointees of a complex
			 * struct reside.
			 */
			unsigned char* PointerBufferMark;

			/*
			 * Used to catch errors in SendReceive.
			 */
			unsigned char           fBufferValid;

			unsigned char           uFlags;
			unsigned short          UniquePtrCount;

			/*
			 * Used internally by the Ndr routines.  Holds the max counts for
			 * a conformant array.
			 */
			ULONG_PTR               MaxCount;

			/*
			 * Used internally by the Ndr routines.  Holds the offsets for a varying
			 * array.
			 */
			unsigned long           Offset;

			/*
			 * Used internally by the Ndr routines.  Holds the actual counts for
			 * a varying array.
			 */
			unsigned long           ActualCount;

			/* Allocation and Free routine to be used by the Ndr routines. */
			void* (__RPC_API* pfnAllocate)(size_t);
			void                    (__RPC_API* pfnFree)(void*);

			/*
			 * Top of parameter stack.  Used for "single call" stubs during marshalling
			 * to hold the beginning of the parameter list on the stack.  Needed to
			 * extract parameters which hold attribute values for top level arrays and
			 * pointers.
			 */
			unsigned char* StackTop;

			/*
			 *  Fields used for the transmit_as and represent_as objects.
			 *  For represent_as the mapping is: presented=local, transmit=named.
			 */
			unsigned char* pPresentedType;
			unsigned char* pTransmitType;

			/*
			 * When we first construct a binding on the client side, stick it
			 * in the rpcmessage and later call RpcGetBuffer, the handle field
			 * in the rpcmessage is changed. That's fine except that we need to
			 * have that original handle for use in unmarshalling context handles
			 * (the second argument in NDRCContextUnmarshall to be exact). So
			 * stash the contructed handle here and extract it when needed.
			 */
			handle_t                SavedHandle;

			/*
			 * Pointer back to the stub descriptor.  Use this to get all handle info.
			 */
			const struct _MIDL_STUB_DESC* StubDesc;

			/*
			 * Full pointer stuff.
			 */
			struct _FULL_PTR_XLAT_TABLES* FullPtrXlatTables;
			unsigned long                   FullPtrRefId;

			unsigned long                   PointerLength;

			int                             fInDontFree : 1;
			int                             fDontCallFreeInst : 1;
			int                             fInOnlyParam : 1;
			int                             fHasReturn : 1;
			int                             fHasExtensions : 1;
			int                             fHasNewCorrDesc : 1;
			int                             fUnused : 10;
			int                             fUnused2 : 16;


			unsigned long                   dwDestContext;
			void* pvDestContext;

			NDR_SCONTEXT* SavedContextHandles;

			long                            ParamNumber;

			struct IRpcChannelBuffer* pRpcChannelBuffer;

			PARRAY_INFO                     pArrayInfo;
			unsigned long* SizePtrCountArray;
			unsigned long* SizePtrOffsetArray;
			unsigned long* SizePtrLengthArray;

			/*
			 * Interpreter argument queue.  Used on server side only.
			 */
			void* pArgQueue;

			unsigned long                   dwStubPhase;

			void* LowStackMark;

			/*
			 *  Async message pointer, correlation data - NT 5.0 features.
			 */
			PNDR_ASYNC_MESSAGE              pAsyncMsg;
			PNDR_CORRELATION_INFO           pCorrInfo;
			unsigned char* pCorrMemory;

			void* pMemoryList;

			/*
			 *  Reserved fields up to this point present since the 3.50 release.
			 *  Reserved fields below were introduced for Windows 2000 release.
			 *  (but not used).
			 */

			 /*
			  * International character support information - NT 5.1 feature.
			  */

			CS_STUB_INFO* pCSInfo;

			unsigned char* ConformanceMark;
			unsigned char* VarianceMark;

#if defined(IA64)
			void* BackingStoreLowMark;
#else
			INT_PTR                         Unused;
#endif

			struct _NDR_PROC_CONTEXT* pContext;

			/*
			 *  Reserved fields up to this point present since Windows 2000 release.
			 *  Fields added for NT5.1
			 */

			INT_PTR                         Reserved51_1;
			INT_PTR                         Reserved51_2;
			INT_PTR                         Reserved51_3;
			INT_PTR                         Reserved51_4;
			INT_PTR                         Reserved51_5;


			/*
			 *  Reserved fields up to this point present since NT5.1 release.
			 */
		} MIDL_STUB_MESSAGE, * PMIDL_STUB_MESSAGE;


		typedef  struct _MIDL_STUB_MESSAGE MIDL_STUB_MESSAGE, * PMIDL_STUB_MESSAGE;

		/*
		 * Generic handle bind/unbind routine pair.
		 */
		typedef void*
			(__RPC_API* GENERIC_BINDING_ROUTINE)
			(void*);
		typedef void
		(__RPC_API* GENERIC_UNBIND_ROUTINE)
			(void*, unsigned char*);

		typedef struct _GENERIC_BINDING_ROUTINE_PAIR
		{
			GENERIC_BINDING_ROUTINE     pfnBind;
			GENERIC_UNBIND_ROUTINE      pfnUnbind;
		} GENERIC_BINDING_ROUTINE_PAIR, * PGENERIC_BINDING_ROUTINE_PAIR;

		typedef struct __GENERIC_BINDING_INFO
		{
			void* pObj;
			unsigned int                Size;
			GENERIC_BINDING_ROUTINE     pfnBind;
			GENERIC_UNBIND_ROUTINE      pfnUnbind;
		} GENERIC_BINDING_INFO, * PGENERIC_BINDING_INFO;

		// typedef EXPR_EVAL - see above
		// typedefs for xmit_as

#if (defined(_MSC_VER)) && !defined(MIDL_PASS)
// a Microsoft C++ compiler
#define NDR_SHAREABLE __inline
#else
#define NDR_SHAREABLE static
#endif


		typedef void (__RPC_USER* XMIT_HELPER_ROUTINE)
			(PMIDL_STUB_MESSAGE);

		typedef struct _XMIT_ROUTINE_QUINTUPLE
		{
			XMIT_HELPER_ROUTINE     pfnTranslateToXmit;
			XMIT_HELPER_ROUTINE     pfnTranslateFromXmit;
			XMIT_HELPER_ROUTINE     pfnFreeXmit;
			XMIT_HELPER_ROUTINE     pfnFreeInst;
		} XMIT_ROUTINE_QUINTUPLE, * PXMIT_ROUTINE_QUINTUPLE;

		typedef unsigned long
		(__RPC_USER* USER_MARSHAL_SIZING_ROUTINE)
			(unsigned long*,
				unsigned long,
				void*);

		typedef unsigned char*
			(__RPC_USER* USER_MARSHAL_MARSHALLING_ROUTINE)
			(unsigned long*,
				unsigned char*,
				void*);

		typedef unsigned char*
			(__RPC_USER* USER_MARSHAL_UNMARSHALLING_ROUTINE)
			(unsigned long*,
				unsigned char*,
				void*);

		typedef void (__RPC_USER* USER_MARSHAL_FREEING_ROUTINE)
			(unsigned long*,
				void*);

		typedef struct _USER_MARSHAL_ROUTINE_QUADRUPLE
		{
			USER_MARSHAL_SIZING_ROUTINE          pfnBufferSize;
			USER_MARSHAL_MARSHALLING_ROUTINE     pfnMarshall;
			USER_MARSHAL_UNMARSHALLING_ROUTINE   pfnUnmarshall;
			USER_MARSHAL_FREEING_ROUTINE         pfnFree;
		} USER_MARSHAL_ROUTINE_QUADRUPLE;

#define USER_MARSHAL_CB_SIGNATURE 'USRC'

		typedef enum _USER_MARSHAL_CB_TYPE
		{
			USER_MARSHAL_CB_BUFFER_SIZE,
			USER_MARSHAL_CB_MARSHALL,
			USER_MARSHAL_CB_UNMARSHALL,
			USER_MARSHAL_CB_FREE
		} USER_MARSHAL_CB_TYPE;

		typedef struct _USER_MARSHAL_CB
		{
			unsigned long           Flags;
			PMIDL_STUB_MESSAGE      pStubMsg;
			PFORMAT_STRING          pReserve;
			unsigned long           Signature;
			USER_MARSHAL_CB_TYPE    CBType;
			PFORMAT_STRING          pFormat;
			PFORMAT_STRING          pTypeFormat;
		} USER_MARSHAL_CB;


#define USER_CALL_CTXT_MASK(f)  ((f) & 0x00ff)
#define USER_CALL_AUX_MASK(f)   ((f) & 0xff00)
#define GET_USER_DATA_REP(f)    ((f) >> 16)

#define USER_CALL_IS_ASYNC              0x0100  /* aux flag: in an [async] call */
#define USER_CALL_NEW_CORRELATION_DESC  0x0200

		typedef struct _MALLOC_FREE_STRUCT
		{
			void* (__RPC_USER* pfnAllocate)(size_t);
			void        (__RPC_USER* pfnFree)(void*);
		} MALLOC_FREE_STRUCT;

		typedef struct _COMM_FAULT_OFFSETS
		{
			short       CommOffset;
			short       FaultOffset;
		} COMM_FAULT_OFFSETS;

		/*
		 * International character support definitions
		 */

		typedef enum _IDL_CS_CONVERT
		{
			IDL_CS_NO_CONVERT,
			IDL_CS_IN_PLACE_CONVERT,
			IDL_CS_NEW_BUFFER_CONVERT
		} IDL_CS_CONVERT;

		typedef void
		(__RPC_USER* CS_TYPE_NET_SIZE_ROUTINE)
			(RPC_BINDING_HANDLE     hBinding,
				unsigned long          ulNetworkCodeSet,
				unsigned long          ulLocalBufferSize,
				IDL_CS_CONVERT* conversionType,
				unsigned long* pulNetworkBufferSize,
				error_status_t* pStatus);

		typedef void
		(__RPC_USER* CS_TYPE_LOCAL_SIZE_ROUTINE)
			(RPC_BINDING_HANDLE     hBinding,
				unsigned long          ulNetworkCodeSet,
				unsigned long          ulNetworkBufferSize,
				IDL_CS_CONVERT* conversionType,
				unsigned long* pulLocalBufferSize,
				error_status_t* pStatus);

		typedef void
		(__RPC_USER* CS_TYPE_TO_NETCS_ROUTINE)
			(RPC_BINDING_HANDLE     hBinding,
				unsigned long          ulNetworkCodeSet,
				void* pLocalData,
				unsigned long          ulLocalDataLength,
				byte* pNetworkData,
				unsigned long* pulNetworkDataLength,
				error_status_t* pStatus);

		typedef void
		(__RPC_USER* CS_TYPE_FROM_NETCS_ROUTINE)
			(RPC_BINDING_HANDLE     hBinding,
				unsigned long          ulNetworkCodeSet,
				byte* pNetworkData,
				unsigned long          ulNetworkDataLength,
				unsigned long          ulLocalBufferSize,
				void* pLocalData,
				unsigned long* pulLocalDataLength,
				error_status_t* pStatus);

		typedef void
		(__RPC_USER* CS_TAG_GETTING_ROUTINE)
			(RPC_BINDING_HANDLE     hBinding,
				int                    fServerSide,
				unsigned long* pulSendingTag,
				unsigned long* pulDesiredReceivingTag,
				unsigned long* pulReceivingTag,
				error_status_t* pStatus);

		void __RPC_USER
			RpcCsGetTags(
				RPC_BINDING_HANDLE     hBinding,
				int                    fServerSide,
				unsigned long* pulSendingTag,
				unsigned long* pulDesiredReceivingTag,
				unsigned long* pulReceivingTag,
				error_status_t* pStatus);

		typedef struct _NDR_CS_SIZE_CONVERT_ROUTINES
		{
			CS_TYPE_NET_SIZE_ROUTINE    pfnNetSize;
			CS_TYPE_TO_NETCS_ROUTINE    pfnToNetCs;
			CS_TYPE_LOCAL_SIZE_ROUTINE  pfnLocalSize;
			CS_TYPE_FROM_NETCS_ROUTINE  pfnFromNetCs;
		} NDR_CS_SIZE_CONVERT_ROUTINES;

		typedef struct _NDR_CS_ROUTINES
		{
			NDR_CS_SIZE_CONVERT_ROUTINES* pSizeConvertRoutines;
			CS_TAG_GETTING_ROUTINE* pTagGettingRoutines;
		} NDR_CS_ROUTINES;

		/*
		 * MIDL Stub Descriptor
		 */

		typedef struct _MIDL_STUB_DESC
		{
			void* RpcInterfaceInformation;

			void* (__RPC_API* pfnAllocate)(size_t);
			void       (__RPC_API* pfnFree)(void*);

			union
			{
				handle_t* pAutoHandle;
				handle_t* pPrimitiveHandle;
				PGENERIC_BINDING_INFO   pGenericBindingInfo;
			} IMPLICIT_HANDLE_INFO;

			const NDR_RUNDOWN* apfnNdrRundownRoutines;
			const GENERIC_BINDING_ROUTINE_PAIR* aGenericBindingRoutinePairs;
			const EXPR_EVAL* apfnExprEval;
			const XMIT_ROUTINE_QUINTUPLE* aXmitQuintuple;

			const unsigned char* pFormatTypes;

			int                                     fCheckBounds;

			/* Ndr library version. */
			unsigned long                           Version;

			MALLOC_FREE_STRUCT* pMallocFreeStruct;

			long                                    MIDLVersion;

			const COMM_FAULT_OFFSETS* CommFaultOffsets;

			// New fields for version 3.0+
			const USER_MARSHAL_ROUTINE_QUADRUPLE* aUserMarshalQuadruple;

			// Notify routines - added for NT5, MIDL 5.0
			const NDR_NOTIFY_ROUTINE* NotifyRoutineTable;

			/*
			 * Reserved for future use.
			 */

			ULONG_PTR                               mFlags;

			// International support routines - added for 64bit post NT5
			const NDR_CS_ROUTINES* CsRoutineTables;

			void* Reserved4;
			ULONG_PTR                               Reserved5;

			// Fields up to now present in win2000 release.

		} MIDL_STUB_DESC;


		typedef const MIDL_STUB_DESC* PMIDL_STUB_DESC;

		typedef void* PMIDL_XMIT_TYPE;

		/*
		 * MIDL Stub Format String.  This is a const in the stub.
		 */
#if !defined( RC_INVOKED )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable:4200 )
#endif
		typedef struct _MIDL_FORMAT_STRING
		{
			short               Pad;
			unsigned char       Format[];
		} MIDL_FORMAT_STRING;
#if !defined( RC_INVOKED )
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default:4200 )
#endif
#endif

		/*
		 * Stub thunk used for some interpreted server stubs.
		 */
		typedef void (__RPC_API* STUB_THUNK)(PMIDL_STUB_MESSAGE);

		typedef long (__RPC_API* SERVER_ROUTINE)();

		/*
		 * Server Interpreter's information strucuture.
		 */
		typedef struct  _MIDL_SERVER_INFO_
		{
			PMIDL_STUB_DESC                     pStubDesc;
			const SERVER_ROUTINE* DispatchTable;
			PFORMAT_STRING                      Pro_tstring;
			const unsigned short* FmtStringOffset;
			const STUB_THUNK* ThunkTable;
			PRPC_SYNTAX_IDENTIFIER              pTransferSyntax;
			ULONG_PTR                           nCount;
			PMIDL_SYNTAX_INFO                   pSyntaxInfo;
		} MIDL_SERVER_INFO, * PMIDL_SERVER_INFO;

#undef _MIDL_STUBLESS_PROXY_INFO

		/*
		 * Stubless object proxy information structure.
		 */
		typedef struct _MIDL_STUBLESS_PROXY_INFO
		{
			PMIDL_STUB_DESC                     pStubDesc;
			PFORMAT_STRING                      ProcFormatString;
			const unsigned short* FormatStringOffset;
			PRPC_SYNTAX_IDENTIFIER              pTransferSyntax;
			ULONG_PTR                           nCount;
			PMIDL_SYNTAX_INFO                   pSyntaxInfo;
		} MIDL_STUBLESS_PROXY_INFO;

		typedef MIDL_STUBLESS_PROXY_INFO* PMIDL_STUBLESS_PROXY_INFO;

		/*
		 *  Multiple transfer syntax information.
		 */
		typedef struct _MIDL_SYNTAX_INFO
		{
			RPC_SYNTAX_IDENTIFIER               TransferSyntax;
			RPC_DISPATCH_TABLE* DispatchTable;
			PFORMAT_STRING                      Pro_tstring;
			const unsigned short* FmtStringOffset;
			PFORMAT_STRING                      TypeString;
			const void* aUserMarshalQuadruple;
			ULONG_PTR                           pReserved1;
			ULONG_PTR                           pReserved2;
		} MIDL_SYNTAX_INFO, * PMIDL_SYNTAX_INFO;

		typedef unsigned short* PARAM_OFFSETTABLE, * PPARAM_OFFSETTABLE;

		/*
		 * This is the return value from NdrClientCall.
		 */
		typedef union _CLIENT_CALL_RETURN
		{
			void* Pointer;
			LONG_PTR        Simple;
		} CLIENT_CALL_RETURN;

		/*
		 * Full pointer data structures.
		 */

		typedef enum
		{
			XLAT_SERVER = 1,
			XLAT_CLIENT
		} XLAT_SIDE;

		/*
		 * Stores the translation for the conversion from a full pointer into it's
		 * corresponding ref id.
		 */
		typedef struct _FULL_PTR_TO_REFID_ELEMENT
		{
			struct _FULL_PTR_TO_REFID_ELEMENT* Next;

			void* Pointer;
			unsigned long       RefId;
			unsigned char       State;
		} FULL_PTR_TO_REFID_ELEMENT, * PFULL_PTR_TO_REFID_ELEMENT;

		/*
		 * Full pointer translation tables.
		 */
		typedef struct _FULL_PTR_XLAT_TABLES
		{
			/*
			 * Ref id to pointer translation information.
			 */
			struct
			{
				void** XlatTable;
				unsigned char* StateTable;
				unsigned long       NumberOfEntries;
			} RefIdToPointer;

			/*
			 * Pointer to ref id translation information.
			 */
			struct
			{
				PFULL_PTR_TO_REFID_ELEMENT* XlatTable;
				unsigned long                   NumberOfBuckets;
				unsigned long                   HashMask;
			} PointerToRefId;

			/*
			 * Next ref id to use.
			 */
			unsigned long           NextRefId;

			/*
			 * Keep track of the translation size we're handling : server or client.
			 * This tells us when we have to do reverse translations when we insert
			 * new translations.  On the server we must insert a pointer-to-refid
			 * translation whenever we insert a refid-to-pointer translation, and
			 * vica versa for the client.
			 */
			XLAT_SIDE               XlatSide;
		} FULL_PTR_XLAT_TABLES, * PFULL_PTR_XLAT_TABLES;

		/***************************************************************************
		 ** New MIDL 2.0 Ndr routine templates
		 ***************************************************************************/

		RPC_STATUS RPC_ENTRY
			NdrClientGetSupportedSyntaxes(
				IN RPC_CLIENT_INTERFACE* pInf,
				OUT unsigned long* pCount,
				OUT MIDL_SYNTAX_INFO** pArr);


		RPC_STATUS RPC_ENTRY
			NdrServerGetSupportedSyntaxes(
				IN RPC_SERVER_INTERFACE* pInf,
				OUT unsigned long* pCount,
				OUT MIDL_SYNTAX_INFO** pArr,
				OUT unsigned long* pPreferSyntaxIndex);

		/*
		 * Marshall routines
		 */

		RPCRTAPI
			void
			RPC_ENTRY
			NdrSimpleTypeMarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				unsigned char           FormatChar
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrPointerMarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrCsArrayMarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrCsTagMarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		/* Structures */

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrSimpleStructMarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrConformantStructMarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrConformantVaryingStructMarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrComplexStructMarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		/* Arrays */

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrFixedArrayMarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrConformantArrayMarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrConformantVaryingArrayMarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrVaryingArrayMarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrComplexArrayMarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		/* Strings */

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrNonConformantStringMarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrConformantStringMarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		/* Unions */

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrEncapsulatedUnionMarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrNonEncapsulatedUnionMarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		/* Byte count pointer */

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrByteCountPointerMarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		/* Transmit as and represent as*/

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrXmitOrRepAsMarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		/* User_marshal */

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrUserMarshalMarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		/* Interface pointer */

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrInterfacePointerMarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		/* Context handles */

		RPCRTAPI
			void
			RPC_ENTRY
			NdrClientContextMarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				NDR_CCONTEXT            ContextHandle,
				int                     fCheck
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrServerContextMarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				NDR_SCONTEXT            ContextHandle,
				NDR_RUNDOWN             RundownRoutine
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrServerContextNewMarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				NDR_SCONTEXT            ContextHandle,
				NDR_RUNDOWN             RundownRoutine,
				PFORMAT_STRING          pFormat
			);

		/*
		 * Unmarshall routines
		 */

		RPCRTAPI
			void
			RPC_ENTRY
			NdrSimpleTypeUnmarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				unsigned char           FormatChar
			);

		RPCRTAPI
			unsigned char* RPC_ENTRY
			RPC_ENTRY
			NdrCsArrayUnmarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char** ppMemory,
				PFORMAT_STRING          pFormat,
				unsigned char           fMustAlloc
			);

		RPCRTAPI
			unsigned char* RPC_ENTRY
			RPC_ENTRY
			NdrCsTagUnmarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char** ppMemory,
				PFORMAT_STRING          pFormat,
				unsigned char           fMustAlloc
			);

		RPCRTAPI
			unsigned char* RPC_ENTRY
			NdrRangeUnmarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char** ppMemory,
				PFORMAT_STRING          pFormat,
				unsigned char           fMustAlloc
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrCorrelationInitialize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				void* pMemory,
				unsigned long           CacheSize,
				unsigned long           flags
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrCorrelationPass(
				PMIDL_STUB_MESSAGE      pStubMsg
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrCorrelationFree(
				PMIDL_STUB_MESSAGE      pStubMsg
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrPointerUnmarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char** ppMemory,
				PFORMAT_STRING          pFormat,
				unsigned char           fMustAlloc
			);

		/* Structures */

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrSimpleStructUnmarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char** ppMemory,
				PFORMAT_STRING          pFormat,
				unsigned char           fMustAlloc
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrConformantStructUnmarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char** ppMemory,
				PFORMAT_STRING          pFormat,
				unsigned char           fMustAlloc
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrConformantVaryingStructUnmarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char** ppMemory,
				PFORMAT_STRING          pFormat,
				unsigned char           fMustAlloc
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrComplexStructUnmarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char** ppMemory,
				PFORMAT_STRING          pFormat,
				unsigned char           fMustAlloc
			);

		/* Arrays */

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrFixedArrayUnmarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char** ppMemory,
				PFORMAT_STRING          pFormat,
				unsigned char           fMustAlloc
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrConformantArrayUnmarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char** ppMemory,
				PFORMAT_STRING          pFormat,
				unsigned char           fMustAlloc
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrConformantVaryingArrayUnmarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char** ppMemory,
				PFORMAT_STRING          pFormat,
				unsigned char           fMustAlloc
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrVaryingArrayUnmarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char** ppMemory,
				PFORMAT_STRING          pFormat,
				unsigned char           fMustAlloc
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrComplexArrayUnmarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char** ppMemory,
				PFORMAT_STRING          pFormat,
				unsigned char           fMustAlloc
			);

		/* Strings */

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrNonConformantStringUnmarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char** ppMemory,
				PFORMAT_STRING          pFormat,
				unsigned char           fMustAlloc
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrConformantStringUnmarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char** ppMemory,
				PFORMAT_STRING          pFormat,
				unsigned char           fMustAlloc
			);

		/* Unions */

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrEncapsulatedUnionUnmarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char** ppMemory,
				PFORMAT_STRING          pFormat,
				unsigned char           fMustAlloc
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrNonEncapsulatedUnionUnmarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char** ppMemory,
				PFORMAT_STRING          pFormat,
				unsigned char           fMustAlloc
			);

		/* Byte count pointer */

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrByteCountPointerUnmarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char** ppMemory,
				PFORMAT_STRING          pFormat,
				unsigned char           fMustAlloc
			);

		/* Transmit as and represent as*/

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrXmitOrRepAsUnmarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char** ppMemory,
				PFORMAT_STRING          pFormat,
				unsigned char           fMustAlloc
			);

		/* User_marshal */

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrUserMarshalUnmarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char** ppMemory,
				PFORMAT_STRING          pFormat,
				unsigned char           fMustAlloc
			);

		/* Interface pointer */

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrInterfacePointerUnmarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char** ppMemory,
				PFORMAT_STRING          pFormat,
				unsigned char           fMustAlloc
			);

		/* Context handles */

		RPCRTAPI
			void
			RPC_ENTRY
			NdrClientContextUnmarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				NDR_CCONTEXT* pContextHandle,
				RPC_BINDING_HANDLE      BindHandle
			);

		RPCRTAPI
			NDR_SCONTEXT
			RPC_ENTRY
			NdrServerContextUnmarshall(
				PMIDL_STUB_MESSAGE      pStubMsg
			);

		/* New context handle flavors */

		RPCRTAPI
			NDR_SCONTEXT
			RPC_ENTRY
			NdrContextHandleInitialize(
				IN  PMIDL_STUB_MESSAGE  pStubMsg,
				IN  PFORMAT_STRING      pFormat
			);

		RPCRTAPI
			NDR_SCONTEXT
			RPC_ENTRY
			NdrServerContextNewUnmarshall(
				IN  PMIDL_STUB_MESSAGE  pStubMsg,
				IN  PFORMAT_STRING      pFormat
			);

		/*
		 * Buffer sizing routines
		 */

		RPCRTAPI
			void
			RPC_ENTRY
			NdrPointerBufferSize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrCsArrayBufferSize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrCsTagBufferSize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		/* Structures */

		RPCRTAPI
			void
			RPC_ENTRY
			NdrSimpleStructBufferSize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrConformantStructBufferSize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrConformantVaryingStructBufferSize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrComplexStructBufferSize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		/* Arrays */

		RPCRTAPI
			void
			RPC_ENTRY
			NdrFixedArrayBufferSize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrConformantArrayBufferSize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrConformantVaryingArrayBufferSize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrVaryingArrayBufferSize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrComplexArrayBufferSize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		/* Strings */

		RPCRTAPI
			void
			RPC_ENTRY
			NdrConformantStringBufferSize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrNonConformantStringBufferSize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		/* Unions */

		RPCRTAPI
			void
			RPC_ENTRY
			NdrEncapsulatedUnionBufferSize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrNonEncapsulatedUnionBufferSize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		/* Byte count pointer */

		RPCRTAPI
			void
			RPC_ENTRY
			NdrByteCountPointerBufferSize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		/* Transmit as and represent as*/

		RPCRTAPI
			void
			RPC_ENTRY
			NdrXmitOrRepAsBufferSize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		/* User_marshal */

		RPCRTAPI
			void
			RPC_ENTRY
			NdrUserMarshalBufferSize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		/* Interface pointer */

		RPCRTAPI
			void
			RPC_ENTRY
			NdrInterfacePointerBufferSize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		// Context Handle size
		//
		RPCRTAPI
			void
			RPC_ENTRY
			NdrContextHandleSize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		/*
		 * Memory sizing routines
		 */

		RPCRTAPI
			unsigned long
			RPC_ENTRY
			NdrPointerMemorySize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				PFORMAT_STRING          pFormat
			);

		/* cs_char things */

		RPCRTAPI
			unsigned long
			RPC_ENTRY
			NdrCsArrayMemorySize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			unsigned long
			RPC_ENTRY
			NdrCsTagMemorySize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				PFORMAT_STRING          pFormat
			);

		/* Structures */

		RPCRTAPI
			unsigned long
			RPC_ENTRY
			NdrSimpleStructMemorySize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			unsigned long
			RPC_ENTRY
			NdrConformantStructMemorySize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			unsigned long
			RPC_ENTRY
			NdrConformantVaryingStructMemorySize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			unsigned long
			RPC_ENTRY
			NdrComplexStructMemorySize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				PFORMAT_STRING          pFormat
			);

		/* Arrays */

		RPCRTAPI
			unsigned long
			RPC_ENTRY
			NdrFixedArrayMemorySize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			unsigned long
			RPC_ENTRY
			NdrConformantArrayMemorySize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			unsigned long
			RPC_ENTRY
			NdrConformantVaryingArrayMemorySize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			unsigned long
			RPC_ENTRY
			NdrVaryingArrayMemorySize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			unsigned long
			RPC_ENTRY
			NdrComplexArrayMemorySize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				PFORMAT_STRING          pFormat
			);

		/* Strings */

		RPCRTAPI
			unsigned long
			RPC_ENTRY
			NdrConformantStringMemorySize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			unsigned long
			RPC_ENTRY
			NdrNonConformantStringMemorySize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				PFORMAT_STRING          pFormat
			);

		/* Unions */

		RPCRTAPI
			unsigned long
			RPC_ENTRY
			NdrEncapsulatedUnionMemorySize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			unsigned long
			RPC_ENTRY
			NdrNonEncapsulatedUnionMemorySize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				PFORMAT_STRING          pFormat
			);

		/* Transmit as and represent as*/

		RPCRTAPI
			unsigned long
			RPC_ENTRY
			NdrXmitOrRepAsMemorySize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				PFORMAT_STRING          pFormat
			);

		/* User_marshal */

		RPCRTAPI
			unsigned long
			RPC_ENTRY
			NdrUserMarshalMemorySize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				PFORMAT_STRING          pFormat
			);

		/* Interface pointer */

		RPCRTAPI
			unsigned long
			RPC_ENTRY
			NdrInterfacePointerMemorySize(
				PMIDL_STUB_MESSAGE      pStubMsg,
				PFORMAT_STRING          pFormat
			);

		/*
		 * Freeing routines
		 */

		RPCRTAPI
			void
			RPC_ENTRY
			NdrPointerFree(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrCsArrayFree(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		/* Structures */

		RPCRTAPI
			void
			RPC_ENTRY
			NdrSimpleStructFree(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrConformantStructFree(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrConformantVaryingStructFree(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrComplexStructFree(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		/* Arrays */

		RPCRTAPI
			void
			RPC_ENTRY
			NdrFixedArrayFree(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrConformantArrayFree(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrConformantVaryingArrayFree(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrVaryingArrayFree(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrComplexArrayFree(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		/* Unions */

		RPCRTAPI
			void
			RPC_ENTRY
			NdrEncapsulatedUnionFree(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrNonEncapsulatedUnionFree(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		/* Byte count */

		RPCRTAPI
			void
			RPC_ENTRY
			NdrByteCountPointerFree(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		/* Transmit as and represent as*/

		RPCRTAPI
			void
			RPC_ENTRY
			NdrXmitOrRepAsFree(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		/* User_marshal */

		RPCRTAPI
			void
			RPC_ENTRY
			NdrUserMarshalFree(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		/* Interface pointer */

		RPCRTAPI
			void
			RPC_ENTRY
			NdrInterfacePointerFree(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pMemory,
				PFORMAT_STRING          pFormat
			);

		/*
		 * Endian conversion routine.
		 */

		RPCRTAPI
			void
			RPC_ENTRY
			NdrConvert2(
				PMIDL_STUB_MESSAGE      pStubMsg,
				PFORMAT_STRING          pFormat,
				long                    NumberParams
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrConvert(
				PMIDL_STUB_MESSAGE      pStubMsg,
				PFORMAT_STRING          pFormat
			);

#define USER_MARSHAL_FC_BYTE         1
#define USER_MARSHAL_FC_CHAR         2
#define USER_MARSHAL_FC_SMALL        3
#define USER_MARSHAL_FC_USMALL       4
#define USER_MARSHAL_FC_WCHAR        5
#define USER_MARSHAL_FC_SHORT        6
#define USER_MARSHAL_FC_USHORT       7
#define USER_MARSHAL_FC_LONG         8
#define USER_MARSHAL_FC_ULONG        9
#define USER_MARSHAL_FC_FLOAT       10
#define USER_MARSHAL_FC_HYPER       11
#define USER_MARSHAL_FC_DOUBLE      12

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrUserMarshalSimpleTypeConvert(
				unsigned long* pFlags,
				unsigned char* pBuffer,
				unsigned char           FormatChar
			);

		/*
		 * Auxilary routines
		 */

		RPCRTAPI
			void
			RPC_ENTRY
			NdrClientInitializeNew(
				PRPC_MESSAGE            pRpcMsg,
				PMIDL_STUB_MESSAGE      pStubMsg,
				PMIDL_STUB_DESC         pStubDescriptor,
				unsigned int            ProcNum
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrServerInitializeNew(
				PRPC_MESSAGE            pRpcMsg,
				PMIDL_STUB_MESSAGE      pStubMsg,
				PMIDL_STUB_DESC         pStubDescriptor
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrServerInitializePartial(
				PRPC_MESSAGE            pRpcMsg,
				PMIDL_STUB_MESSAGE      pStubMsg,
				PMIDL_STUB_DESC         pStubDescriptor,
				unsigned long           RequestedBufferSize
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrClientInitialize(
				PRPC_MESSAGE            pRpcMsg,
				PMIDL_STUB_MESSAGE      pStubMsg,
				PMIDL_STUB_DESC         pStubDescriptor,
				unsigned int            ProcNum
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrServerInitialize(
				PRPC_MESSAGE            pRpcMsg,
				PMIDL_STUB_MESSAGE      pStubMsg,
				PMIDL_STUB_DESC         pStubDescriptor
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrServerInitializeUnmarshall(
				PMIDL_STUB_MESSAGE      pStubMsg,
				PMIDL_STUB_DESC         pStubDescriptor,
				PRPC_MESSAGE            pRpcMsg
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrServerInitializeMarshall(
				PRPC_MESSAGE            pRpcMsg,
				PMIDL_STUB_MESSAGE      pStubMsg
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrGetBuffer(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned long           BufferLength,
				RPC_BINDING_HANDLE      Handle
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrNsGetBuffer(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned long           BufferLength,
				RPC_BINDING_HANDLE      Handle
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrSendReceive(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pBufferEnd
			);

		RPCRTAPI
			unsigned char*
			RPC_ENTRY
			NdrNsSendReceive(
				PMIDL_STUB_MESSAGE      pStubMsg,
				unsigned char* pBufferEnd,
				RPC_BINDING_HANDLE* pAutoHandle
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrFreeBuffer(
				PMIDL_STUB_MESSAGE      pStubMsg
			);

		RPCRTAPI
			RPC_STATUS
			RPC_ENTRY
			NdrGetDcomProtocolVersion(
				PMIDL_STUB_MESSAGE      pStubMsg,
				RPC_VERSION* pVersion);


		/*
		 * Interpreter calls.
		 */

		 /* client */

		CLIENT_CALL_RETURN RPC_VAR_ENTRY
			NdrClientCall2(
				PMIDL_STUB_DESC         pStubDescriptor,
				PFORMAT_STRING          pFormat,
				...
			);

		CLIENT_CALL_RETURN RPC_VAR_ENTRY
			NdrClientCall(
				PMIDL_STUB_DESC         pStubDescriptor,
				PFORMAT_STRING          pFormat,
				...
			);

		CLIENT_CALL_RETURN RPC_VAR_ENTRY
			NdrAsyncClientCall(
				PMIDL_STUB_DESC         pStubDescriptor,
				PFORMAT_STRING          pFormat,
				...
			);

		CLIENT_CALL_RETURN RPC_VAR_ENTRY
			NdrDcomAsyncClientCall(
				PMIDL_STUB_DESC         pStubDescriptor,
				PFORMAT_STRING          pFormat,
				...
			);

		/* server */
		typedef enum {
			STUB_UNMARSHAL,
			STUB_CALL_SERVER,
			STUB_MARSHAL,
			STUB_CALL_SERVER_NO_HRESULT
		}STUB_PHASE;

		typedef enum {
			PROXY_CALCSIZE,
			PROXY_GETBUFFER,
			PROXY_MARSHAL,
			PROXY_SENDRECEIVE,
			PROXY_UNMARSHAL
		}PROXY_PHASE;

		struct IRpcStubBuffer;      // Forward declaration

		// Raw RPC only
		RPCRTAPI
			void
			RPC_ENTRY
			NdrAsyncServerCall(
				PRPC_MESSAGE                pRpcMsg
			);

		// old dcom async scheme
		RPCRTAPI
			long
			RPC_ENTRY
			NdrAsyncStubCall(
				struct IRpcStubBuffer* pThis,
				struct IRpcChannelBuffer* pChannel,
				PRPC_MESSAGE                pRpcMsg,
				unsigned long* pdwStubPhase
			);

		// async uuid
		RPCRTAPI
			long
			RPC_ENTRY
			NdrDcomAsyncStubCall(
				struct IRpcStubBuffer* pThis,
				struct IRpcChannelBuffer* pChannel,
				PRPC_MESSAGE                pRpcMsg,
				unsigned long* pdwStubPhase
			);

		RPCRTAPI
			long
			RPC_ENTRY
			NdrStubCall2(
				struct IRpcStubBuffer* pThis,
				struct IRpcChannelBuffer* pChannel,
				PRPC_MESSAGE                pRpcMsg,
				unsigned long* pdwStubPhase
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrServerCall2(
				PRPC_MESSAGE                pRpcMsg
			);

		RPCRTAPI
			long
			RPC_ENTRY
			NdrStubCall(
				struct IRpcStubBuffer* pThis,
				struct IRpcChannelBuffer* pChannel,
				PRPC_MESSAGE                pRpcMsg,
				unsigned long* pdwStubPhase
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrServerCall(
				PRPC_MESSAGE                pRpcMsg
			);

		RPCRTAPI
			int
			RPC_ENTRY
			NdrServerUnmarshall(
				struct IRpcChannelBuffer* pChannel,
				PRPC_MESSAGE                pRpcMsg,
				PMIDL_STUB_MESSAGE          pStubMsg,
				PMIDL_STUB_DESC             pStubDescriptor,
				PFORMAT_STRING              pFormat,
				void* pParamList
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrServerMarshall(
				struct IRpcStubBuffer* pThis,
				struct IRpcChannelBuffer* pChannel,
				PMIDL_STUB_MESSAGE          pStubMsg,
				PFORMAT_STRING              pFormat
			);

		/* Comm and Fault status */

		RPCRTAPI
			RPC_STATUS
			RPC_ENTRY
			NdrMapCommAndFaultStatus(
				PMIDL_STUB_MESSAGE          pStubMsg,
				unsigned long* pCommStatus,
				unsigned long* pFaultStatus,
				RPC_STATUS                  Status
			);

		/* Helper routines */

		RPCRTAPI
			int
			RPC_ENTRY
			NdrSH_UPDecision(
				PMIDL_STUB_MESSAGE          pStubMsg,
				unsigned char** pPtrInMem,
				RPC_BUFPTR                  pBuffer
			);

		RPCRTAPI
			int
			RPC_ENTRY
			NdrSH_TLUPDecision(
				PMIDL_STUB_MESSAGE          pStubMsg,
				unsigned char** pPtrInMem
			);

		RPCRTAPI
			int
			RPC_ENTRY
			NdrSH_TLUPDecisionBuffer(
				PMIDL_STUB_MESSAGE          pStubMsg,
				unsigned char** pPtrInMem
			);

		RPCRTAPI
			int
			RPC_ENTRY
			NdrSH_IfAlloc(
				PMIDL_STUB_MESSAGE          pStubMsg,
				unsigned char** pPtrInMem,
				unsigned long               Count
			);

		RPCRTAPI
			int
			RPC_ENTRY
			NdrSH_IfAllocRef(
				PMIDL_STUB_MESSAGE          pStubMsg,
				unsigned char** pPtrInMem,
				unsigned long               Count
			);

		RPCRTAPI
			int
			RPC_ENTRY
			NdrSH_IfAllocSet(
				PMIDL_STUB_MESSAGE          pStubMsg,
				unsigned char** pPtrInMem,
				unsigned long               Count
			);

		RPCRTAPI
			RPC_BUFPTR
			RPC_ENTRY
			NdrSH_IfCopy(
				PMIDL_STUB_MESSAGE          pStubMsg,
				unsigned char** pPtrInMem,
				unsigned long               Count
			);

		RPCRTAPI
			RPC_BUFPTR
			RPC_ENTRY
			NdrSH_IfAllocCopy(
				PMIDL_STUB_MESSAGE          pStubMsg,
				unsigned char** pPtrInMem,
				unsigned long               Count
			);

		RPCRTAPI
			unsigned long
			RPC_ENTRY
			NdrSH_Copy(
				unsigned char* pStubMsg,
				unsigned char* pPtrInMem,
				unsigned long               Count
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrSH_IfFree(
				PMIDL_STUB_MESSAGE          pMessage,
				unsigned char* pPtr);


		RPCRTAPI
			RPC_BUFPTR
			RPC_ENTRY
			NdrSH_StringMarshall(
				PMIDL_STUB_MESSAGE          pMessage,
				unsigned char* pMemory,
				unsigned long               Count,
				int                         Size);

		RPCRTAPI
			RPC_BUFPTR
			RPC_ENTRY
			NdrSH_StringUnMarshall(
				PMIDL_STUB_MESSAGE          pMessage,
				unsigned char** pMemory,
				int                         Size);

		/****************************************************************************
			MIDL 2.0 memory package: rpc_ss_* rpc_sm_*
		 ****************************************************************************/

		typedef void* RPC_SS_THREAD_HANDLE;

		typedef void* __RPC_API
			RPC_CLIENT_ALLOC(
				IN size_t Size
			);

		typedef void __RPC_API
			RPC_CLIENT_FREE(
				IN void* Ptr
			);

		/*++
			 RpcSs* package
		--*/

		RPCRTAPI
			void*
			RPC_ENTRY
			RpcSsAllocate(
				IN size_t Size
			);

		RPCRTAPI
			void
			RPC_ENTRY
			RpcSsDisableAllocate(
				void
			);

		RPCRTAPI
			void
			RPC_ENTRY
			RpcSsEnableAllocate(
				void
			);

		RPCRTAPI
			void
			RPC_ENTRY
			RpcSsFree(
				IN void* NodeToFree
			);

		RPCRTAPI
			RPC_SS_THREAD_HANDLE
			RPC_ENTRY
			RpcSsGetThreadHandle(
				void
			);

		RPCRTAPI
			void
			RPC_ENTRY
			RpcSsSetClientAllocFree(
				IN RPC_CLIENT_ALLOC* ClientAlloc,
				IN RPC_CLIENT_FREE* ClientFree
			);

		RPCRTAPI
			void
			RPC_ENTRY
			RpcSsSetThreadHandle(
				IN RPC_SS_THREAD_HANDLE Id
			);

		RPCRTAPI
			void
			RPC_ENTRY
			RpcSsSwapClientAllocFree(
				IN RPC_CLIENT_ALLOC* ClientAlloc,
				IN RPC_CLIENT_FREE* ClientFree,
				OUT RPC_CLIENT_ALLOC** OldClientAlloc,
				OUT RPC_CLIENT_FREE** OldClientFree
			);

		/*++
			 RpcSm* package
		--*/

		RPCRTAPI
			void*
			RPC_ENTRY
			RpcSmAllocate(
				IN  size_t          Size,
				OUT RPC_STATUS* pStatus
			);

		RPCRTAPI
			RPC_STATUS
			RPC_ENTRY
			RpcSmClientFree(
				IN  void* pNodeToFree
			);

		RPCRTAPI
			RPC_STATUS
			RPC_ENTRY
			RpcSmDestroyClientContext(
				IN void** ContextHandle
			);

		RPCRTAPI
			RPC_STATUS
			RPC_ENTRY
			RpcSmDisableAllocate(
				void
			);

		RPCRTAPI
			RPC_STATUS
			RPC_ENTRY
			RpcSmEnableAllocate(
				void
			);

		RPCRTAPI
			RPC_STATUS
			RPC_ENTRY
			RpcSmFree(
				IN void* NodeToFree
			);

		RPCRTAPI
			RPC_SS_THREAD_HANDLE
			RPC_ENTRY
			RpcSmGetThreadHandle(
				OUT RPC_STATUS* pStatus
			);

		RPCRTAPI
			RPC_STATUS
			RPC_ENTRY
			RpcSmSetClientAllocFree(
				IN RPC_CLIENT_ALLOC* ClientAlloc,
				IN RPC_CLIENT_FREE* ClientFree
			);

		RPCRTAPI
			RPC_STATUS
			RPC_ENTRY
			RpcSmSetThreadHandle(
				IN RPC_SS_THREAD_HANDLE Id
			);

		RPCRTAPI
			RPC_STATUS
			RPC_ENTRY
			RpcSmSwapClientAllocFree(
				IN RPC_CLIENT_ALLOC* ClientAlloc,
				IN RPC_CLIENT_FREE* ClientFree,
				OUT RPC_CLIENT_ALLOC** OldClientAlloc,
				OUT RPC_CLIENT_FREE** OldClientFree
			);

		/*++
			 Ndr stub entry points
		--*/

		RPCRTAPI
			void
			RPC_ENTRY
			NdrRpcSsEnableAllocate(
				PMIDL_STUB_MESSAGE      pMessage);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrRpcSsDisableAllocate(
				PMIDL_STUB_MESSAGE      pMessage);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrRpcSmSetClientToOsf(
				PMIDL_STUB_MESSAGE      pMessage);

		RPCRTAPI
			void*
			RPC_ENTRY
			NdrRpcSmClientAllocate(
				IN size_t Size
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrRpcSmClientFree(
				IN void* NodeToFree
			);

		RPCRTAPI
			void*
			RPC_ENTRY
			NdrRpcSsDefaultAllocate(
				IN size_t Size
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrRpcSsDefaultFree(
				IN void* NodeToFree
			);

		/****************************************************************************
			end of memory package: rpc_ss_* rpc_sm_*
		 ****************************************************************************/

		 /****************************************************************************
		  * Full Pointer APIs
		  ****************************************************************************/

		RPCRTAPI
			PFULL_PTR_XLAT_TABLES
			RPC_ENTRY
			NdrFullPointerXlatInit(
				unsigned long           NumberOfPointers,
				XLAT_SIDE               XlatSide
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrFullPointerXlatFree(
				PFULL_PTR_XLAT_TABLES   pXlatTables
			);

		RPCRTAPI
			int
			RPC_ENTRY
			NdrFullPointerQueryPointer(
				PFULL_PTR_XLAT_TABLES   pXlatTables,
				void* pPointer,
				unsigned char           QueryType,
				unsigned long* pRefId
			);

		RPCRTAPI
			int
			RPC_ENTRY
			NdrFullPointerQueryRefId(
				PFULL_PTR_XLAT_TABLES   pXlatTables,
				unsigned long           RefId,
				unsigned char           QueryType,
				void** ppPointer
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrFullPointerInsertRefId(
				PFULL_PTR_XLAT_TABLES   pXlatTables,
				unsigned long           RefId,
				void* pPointer
			);

		RPCRTAPI
			int
			RPC_ENTRY
			NdrFullPointerFree(
				PFULL_PTR_XLAT_TABLES   pXlatTables,
				void* Pointer
			);

		RPCRTAPI
			void*
			RPC_ENTRY
			NdrAllocate(
				PMIDL_STUB_MESSAGE      pStubMsg,
				size_t                  Len
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrClearOutParameters(
				PMIDL_STUB_MESSAGE      pStubMsg,
				PFORMAT_STRING          pFormat,
				void* ArgAddr
			);


		/****************************************************************************
		 * Proxy APIs
		 ****************************************************************************/

		RPCRTAPI
			void*
			RPC_ENTRY
			NdrOleAllocate(
				IN size_t Size
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrOleFree(
				IN void* NodeToFree
			);

#ifdef CONST_VTABLE
#define CONST_VTBL const
#else
#define CONST_VTBL
#endif

		/****************************************************************************
		 * VC COM support
		 ****************************************************************************/

#ifndef DECLSPEC_SELECTANY
#if (_MSC_VER >= 1100)
#define DECLSPEC_SELECTANY __declspec(selectany)
#else
#define DECLSPEC_SELECTANY
#endif
#endif

#ifndef DECLSPEC_NOVTABLE
#if (_MSC_VER >= 1100) && defined(__cplusplus)
#define DECLSPEC_NOVTABLE __declspec(novtable)
#else
#define DECLSPEC_NOVTABLE
#endif
#endif

#ifndef DECLSPEC_UUID
#if (_MSC_VER >= 1100) && defined(__cplusplus)
#define DECLSPEC_UUID(x) __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif

#define MIDL_INTERFACE(x)   struct DECLSPEC_UUID(x) DECLSPEC_NOVTABLE

#if _MSC_VER >= 1100
#define EXTERN_GUID(itf,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8)  \
  EXTERN_C const IID DECLSPEC_SELECTANY itf = {l1,s1,s2,{c1,c2,c3,c4,c5,c6,c7,c8}}
#else
#define EXTERN_GUID(itf,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8) EXTERN_C const IID itf
#endif

		 /****************************************************************************
		  * UserMarshal information
		  ****************************************************************************/

		typedef struct _NDR_USER_MARSHAL_INFO_LEVEL1
		{
			void* Buffer;
			unsigned long               BufferSize;
			void* (__RPC_API* pfnAllocate)(size_t);
			void (__RPC_API* pfnFree)(void*);
			struct IRpcChannelBuffer* pRpcChannelBuffer;
			ULONG_PTR                   Reserved[5];
		} NDR_USER_MARSHAL_INFO_LEVEL1;

#if !defined( RC_INVOKED )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)
#endif

		typedef struct _NDR_USER_MARSHAL_INFO
		{
			unsigned long InformationLevel;
			union {
				NDR_USER_MARSHAL_INFO_LEVEL1 Level1;
			};
		} NDR_USER_MARSHAL_INFO;

#if !defined( RC_INVOKED )
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif
#endif

		RPC_STATUS
			RPC_ENTRY
			NdrGetUserMarshalInfo(
				IN unsigned long* pFlags,
				IN unsigned long            InformationLevel,
				OUT NDR_USER_MARSHAL_INFO* pMarshalInfo
			);

		/****************************************************************************
		 * 64bit APIs
		 ****************************************************************************/
		RPC_STATUS RPC_ENTRY
			NdrCreateServerInterfaceFromStub(
				IN struct IRpcStubBuffer* pStub,
				IN OUT RPC_SERVER_INTERFACE* pServerIf);

		/*
		 * Interpreter calls
		 */
		CLIENT_CALL_RETURN RPC_VAR_ENTRY
			NdrClientCall3(
				MIDL_STUBLESS_PROXY_INFO* pProxyInfo,
				unsigned long               nProcNum,
				void* pReturnValue,
				...
			);

		CLIENT_CALL_RETURN RPC_VAR_ENTRY
			Ndr64AsyncClientCall(
				MIDL_STUBLESS_PROXY_INFO* pProxyInfo,
				unsigned long               nProcNum,
				void* pReturnValue,
				...
			);

		CLIENT_CALL_RETURN RPC_VAR_ENTRY
			Ndr64DcomAsyncClientCall(
				MIDL_STUBLESS_PROXY_INFO* pProxyInfo,
				unsigned long               nProcNum,
				void* pReturnValue,
				...
			);

		struct IRpcStubBuffer;      // Forward declaration

		RPCRTAPI
			void
			RPC_ENTRY
			Ndr64AsyncServerCall(
				PRPC_MESSAGE                pRpcMsg
			);

		RPCRTAPI
			void
			RPC_ENTRY
			Ndr64AsyncServerCall64(
				PRPC_MESSAGE                pRpcMsg
			);

		RPCRTAPI
			void
			RPC_ENTRY
			Ndr64AsyncServerCallAll(
				PRPC_MESSAGE                pRpcMsg
			);

		RPCRTAPI
			long
			RPC_ENTRY
			Ndr64AsyncStubCall(
				struct IRpcStubBuffer* pThis,
				struct IRpcChannelBuffer* pChannel,
				PRPC_MESSAGE                pRpcMsg,
				unsigned long* pdwStubPhase
			);

		/* async uuid */
		RPCRTAPI
			long
			RPC_ENTRY
			Ndr64DcomAsyncStubCall(
				struct IRpcStubBuffer* pThis,
				struct IRpcChannelBuffer* pChannel,
				PRPC_MESSAGE                pRpcMsg,
				unsigned long* pdwStubPhase
			);

		RPCRTAPI
			long
			RPC_ENTRY
			NdrStubCall3(
				struct IRpcStubBuffer* pThis,
				struct IRpcChannelBuffer* pChannel,
				PRPC_MESSAGE                pRpcMsg,
				unsigned long* pdwStubPhase
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrServerCallAll(
				PRPC_MESSAGE                pRpcMsg
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrServerCallNdr64(
				PRPC_MESSAGE                pRpcMsg
			);


		RPCRTAPI
			void
			RPC_ENTRY
			NdrServerCall3(
				PRPC_MESSAGE                pRpcMsg
			);


		/* [partial_ignore] functions*/
		RPCRTAPI
			void
			RPC_ENTRY
			NdrPartialIgnoreClientMarshall(
				PMIDL_STUB_MESSAGE          pStubMsg,
				void* pMemory
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrPartialIgnoreServerUnmarshall(
				PMIDL_STUB_MESSAGE          pStubMsg,
				void** ppMemory
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrPartialIgnoreClientBufferSize(
				PMIDL_STUB_MESSAGE          pStubMsg,
				void* pMemory
			);

		RPCRTAPI
			void
			RPC_ENTRY
			NdrPartialIgnoreServerInitialize(
				PMIDL_STUB_MESSAGE          pStubMsg,
				void** ppMemory,
				PFORMAT_STRING              pFormat
			);


		void RPC_ENTRY
			RpcUserFree(handle_t AsyncHandle, void* pBuffer);

#ifdef __cplusplus
	}
#endif

#include <poppack.h>

#endif /* __RPCNDR_H__ */

	// DOINC popped back into header 'pbprop.h'

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
// ***** DOINC including windows.h *****

/*++ BUILD Version: 0001    Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:


	windows.h

Abstract:

	Master include file for Windows applications.

--*/

#ifndef _WINDOWS_
#define _WINDOWS_


#ifndef WINVER
#define WINVER 0x0501
#else
#if defined(_WIN32_WINNT) && (WINVER < 0x0400) && (_WIN32_WINNT > 0x0400)
#error WINVER setting conflicts with _WIN32_WINNT setting
#endif
#endif

#ifndef _INC_WINDOWS
#define _INC_WINDOWS

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/*  If defined, the following flags inhibit definition
 *     of the indicated items.
 *
 *  NOGDICAPMASKS     - CC_*, LC_*, PC_*, CP_*, TC_*, RC_
 *  NOVIRTUALKEYCODES - VK_*
 *  NOWINMESSAGES     - WM_*, EM_*, LB_*, CB_*
 *  NOWINSTYLES       - WS_*, CS_*, ES_*, LBS_*, SBS_*, CBS_*
 *  NOSYSMETRICS      - SM_*
 *  NOMENUS           - MF_*
 *  NOICONS           - IDI_*
 *  NOKEYSTATES       - MK_*
 *  NOSYSCOMMANDS     - SC_*
 *  NORASTEROPS       - Binary and Tertiary raster ops
 *  NOSHOWWINDOW      - SW_*
 *  OEMRESOURCE       - OEM Resource values
 *  NOATOM            - Atom Manager routines
 *  NOCLIPBOARD       - Clipboard routines
 *  NOCOLOR           - Screen colors
 *  NOCTLMGR          - Control and Dialog routines
 *  NODRAWTEXT        - DrawText() and DT_*
 *  NOGDI             - All GDI defines and routines
 *  NOKERNEL          - All KERNEL defines and routines
 *  NOUSER            - All USER defines and routines
 *  NONLS             - All NLS defines and routines
 *  NOMB              - MB_* and MessageBox()
 *  NOMEMMGR          - GMEM_*, LMEM_*, GHND, LHND, associated routines
 *  NOMETAFILE        - typedef METAFILEPICT
 *  NOMINMAX          - Macros min(a,b) and max(a,b)
 *  NOMSG             - typedef MSG and associated routines
 *  NOOPENFILE        - OpenFile(), OemToAnsi, AnsiToOem, and OF_*
 *  NOSCROLL          - SB_* and scrolling routines
 *  NOSERVICE         - All Service Controller routines, SERVICE_ equates, etc.
 *  NOSOUND           - Sound driver routines
 *  NOTEXTMETRIC      - typedef TEXTMETRIC and associated routines
 *  NOWH              - SetWindowsHook and WH_*
 *  NOWINOFFSETS      - GWL_*, GCL_*, associated routines
 *  NOCOMM            - COMM driver routines
 *  NOKANJI           - Kanji support stuff.
 *  NOHELP            - Help engine interface.
 *  NOPROFILER        - Profiler interface.
 *  NODEFERWINDOWPOS  - DeferWindowPos routines
 *  NOMCX             - Modem Configuration Extensions
 */

#if defined(RC_INVOKED) && !defined(NOWINRES)

#include <winresrc.h>

#else

#if defined(RC_INVOKED)
 /* Turn off a bunch of stuff to ensure that RC files compile OK. */
#define NOATOM
#define NOGDI
#define NOGDICAPMASKS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NORASTEROPS
#define NOSCROLL
#define NOSOUND
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NOCOMM
#define NOKANJI
#define NOCRYPT
#define NOMCX
#endif

#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_IX86)
#define _X86_
#endif

#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_AMD64)
#define _AMD64_
#endif

#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_M68K)
#define _68K_
#endif

#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_MPPC)
#define _MPPC_
#endif

#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_M_IX86) && !defined(_AMD64_) && defined(_M_IA64)
#if !defined(_IA64_)
#define _IA64_
#endif // !_IA64_
#endif

#ifndef _MAC
#if defined(_68K_) || defined(_MPPC_)
#define _MAC
#endif
#endif

#if defined (_MSC_VER)
#if ( _MSC_VER >= 800 )
#ifndef __cplusplus
#pragma warning(disable:4116)       // TYPE_ALIGNMENT generates this - move it
									// outside the warning push/pop scope.
#endif
#endif
#endif

#ifndef RC_INVOKED
#if     ( _MSC_VER >= 800 )
#pragma warning(disable:4514)
#ifndef __WINDOWS_DONT_DISABLE_PRAGMA_PACK_WARNING__
#pragma warning(disable:4103)
#endif
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4001)
#pragma warning(disable:4201)
#pragma warning(disable:4214)
#endif
#include <excpt.h>
#include <stdarg.h>
#endif /* RC_INVOKED */

#include <windef.h>
#include <winbase.h>
#include <wingdi.h>
#include <winuser.h>
#if !defined(_MAC) || defined(_WIN32NLS)
#include <winnls.h>
#endif
#ifndef _MAC
#include <wincon.h>
#include <winver.h>
#endif
#if !defined(_MAC) || defined(_WIN32REG)
#include <winreg.h>
#endif
#ifndef _MAC
#include <winnetwk.h>
#endif

#ifndef WIN32_LEAN_AND_MEAN
#include <cderr.h>
#include <dde.h>
#include <ddeml.h>
#include <dlgs.h>
#ifndef _MAC
#include <lzexpand.h>
#include <mmsystem.h>
#include <nb30.h>
#include <rpc.h>
#endif
#include <shellapi.h>
#ifndef _MAC
#include <winperf.h>
#include <winsock.h>
#endif
#ifndef NOCRYPT
#include <wincrypt.h>
#include <winefs.h>
#include <winscard.h>
#endif

#ifndef NOGDI
#ifndef _MAC
#include <winspool.h>
#ifdef INC_OLE1
#include <ole.h>
#else
#include <ole2.h>
#endif /* !INC_OLE1 */
#endif /* !MAC */
#include <commdlg.h>
#endif /* !NOGDI */
#endif /* WIN32_LEAN_AND_MEAN */

#include <stralign.h>

#ifdef _MAC
#include <winwlm.h>
#endif


#ifdef INC_OLE2
#include <ole2.h>
#endif /* INC_OLE2 */

#ifndef _MAC
#ifndef NOSERVICE
#include <winsvc.h>
#endif

#if(WINVER >= 0x0400)
#ifndef NOMCX
#include <mcx.h>
#endif /* NOMCX */

#ifndef NOIME
#include <imm.h>
#endif
#endif /* WINVER >= 0x0400 */
#endif

#ifndef RC_INVOKED
#if     ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4001)
#pragma warning(default:4201)
#pragma warning(default:4214)
/* Leave 4514 disabled.  It's an unneeded warning anyway. */
#endif
#endif
#endif /* RC_INVOKED */

#endif /* RC_INVOKED */

#endif /* _INC_WINDOWS */
#endif /* _WINDOWS_ */

// DOINC popped back into header 'pbprop.h'
// ***** DOINC including ole2.h *****
/*#!perl
MapHeaderToDll("ole2.h", "ole32.dll");
ActivateAroundFunctionCall("ole32.dll");
IgnoreFunction("CreateDataAdviseHolder"); # this function occurs in ole2.h and objbase.h
										  # The wrapped one is in objbase.h
IgnoreFunction("OleBuildVersion"); # not documented
DeclareFunctionErrorValue("OleCreateMenuDescriptor", "NULL");
DeclareFunctionErrorValue("OleDuplicateData", "NULL");
DeclareFunctionErrorValue("OleGetIconOfFile", "NULL");
DeclareFunctionErrorValue("OleGetIconOfClass", "NULL");
DeclareFunctionErrorValue("OleMetafilePictFromIconAndLabel", "NULL");
IgnoreFunction("WlmOleCheckoutMacInterface"); # Macintosh stuff
IgnoreFunction("WlmOleCheckinMacInterface"); # Macintosh stuff
IgnoreFunction("WlmOleWrapMacInterface"); # Macintosh stuff
IgnoreFunction("WlmOleUnwrapMacInterface"); # Macintosh stuff
IgnoreFunction("WlmOleCheckoutWinInterface"); # Macintosh stuff
IgnoreFunction("WlmOleCheckinWinInterface"); # Macintosh stuff
IgnoreFunction("WlmOleWrapWinInterface"); # Macintosh stuff
IgnoreFunction("WlmOleUnwrapWinInterface"); # Macintosh stuff
IgnoreFunction("WlmOleVersion"); # Macintosh stuff
IgnoreFunction("WlmOleSetInPlaceWindow"); # Macintosh stuff
IgnoreFunction("WlmOleRegisterUserWrap"); # Macintosh stuff
*/

//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       OLE2.h
//  Contents:   Main OLE2 header; Defines Linking and Emmebbeding interfaces, and API's.
//              Also includes .h files for the compobj, and oleauto  subcomponents.
//
//----------------------------------------------------------------------------
#if !defined( _OLE2_H_ )
#define _OLE2_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _MAC
// Set packing to 8
#include <pshpack8.h>

// Make 100% sure WIN32 is defined
#ifndef WIN32
#define WIN32    100  // 100 == NT version 1.0
#endif
#else //_MAC
#ifdef _WIN32
// ***** DOINC including macname1.h *****
	// DOINC skipping missing include
#endif // _WIN32
#endif //_MAC



// SET to remove _export from interface definitions


#include <winerror.h>

#ifdef _MAC
#if !defined(__MACPUB__)
#include <macpub.h>
#endif
#endif //_MAC

#include <objbase.h>
#include <oleauto.h>

// View OBJECT Error Codes

#define E_DRAW                  VIEW_E_DRAW

// IDataObject Error Codes
#define DATA_E_FORMATETC        DV_E_FORMATETC


#ifdef _MAC
/****** Standard Object Definitions *****************************************/

//#ifndef __COMPOBJ__
//#include <compobj.h>
//#endif



	typedef enum {
		OLE_E_NOEXTENSION = OLE_E_NOSTORAGE + 1,	// no extension at startup
		OLE_E_VERSEXTENSION,						// extension has wrong version #
		OLE_E_IPBUSY,								// cannot get inplace resource
		OLE_E_NOT_FRONT_PROCESS,					// inplace container unexpectedly in background
		OLE_E_WRONG_MENU,							// holemenu != prev holemenu
		OLE_E_MENU_NOT_PATCHED,						// menubar is not hashed
		OLE_E_MENUID_NOT_HASHED,					// id was never hashed
		OLE_E_foo
	} inplace_errors;


	// DoDragDropMac()
	typedef struct tagDRAG_FLAVORINFO {
		unsigned long	cfFormat;
		unsigned long	FlavorFlags;		// Flavor Flags as specified by the DragManager
		OLEBOOL			fAddData;			// If true, the data is added with the flavor
		long			reserved;			// must be NULL
	} DRAG_FLAVORINFO;

#endif //_MAC


	// Common stuff gleamed from OLE.2,

	/* verbs */
#define OLEIVERB_PRIMARY            (0L)
#define OLEIVERB_SHOW               (-1L)
#define OLEIVERB_OPEN               (-2L)
#define OLEIVERB_HIDE               (-3L)
#define OLEIVERB_UIACTIVATE         (-4L)
#define OLEIVERB_INPLACEACTIVATE    (-5L)
#define OLEIVERB_DISCARDUNDOSTATE   (-6L)

// for OleCreateEmbeddingHelper flags; roles in low word; options in high word
#define EMBDHLP_INPROC_HANDLER   0x0000L
#define EMBDHLP_INPROC_SERVER    0x0001L
#define EMBDHLP_CREATENOW    0x00000000L
#define EMBDHLP_DELAYCREATE  0x00010000L

/* extended create function flags */
#define OLECREATE_LEAVERUNNING	0x00000001

/* pull in the MIDL generated header */

#include <oleidl.h>


#ifdef _MAC
	typedef struct tagOleMBarRec
	{
		long reserved;
	} OleMBarRec, * OleMBarPtr, ** OleMBarHandle;

#define noAxis  3               // indicates no grow or size in any direction
	// see mac #defines noConstraint, hAxisOnly, vAxisOnly

#endif //_MAC



/****** DV APIs ***********************************************************/


/* This function is declared in objbase.h and ole2.h.
   IsolationAware support is via objbase.h.
*/
#if    !defined(ISOLATION_AWARE_ENABLED) \
    || !ISOLATION_AWARE_ENABLED \
    || !defined(_OBJBASE_H_) \
    || !defined(CreateDataAdviseHolder)
	WINOLEAPI CreateDataAdviseHolder(OUT LPDATAADVISEHOLDER FAR* ppDAHolder);
#endif


	/****** OLE API Prototypes ************************************************/

	WINOLEAPI_(DWORD) OleBuildVersion(VOID);

	/* helper functions */
	WINOLEAPI ReadClassStg(IN LPSTORAGE pStg, OUT CLSID FAR* pclsid);
	WINOLEAPI WriteClassStg(IN LPSTORAGE pStg, IN REFCLSID rclsid);
	WINOLEAPI ReadClassStm(IN LPSTREAM pStm, OUT CLSID FAR* pclsid);
	WINOLEAPI WriteClassStm(IN LPSTREAM pStm, IN REFCLSID rclsid);
	WINOLEAPI WriteFmtUserTypeStg(IN LPSTORAGE pstg, IN CLIPFORMAT cf, IN LPOLESTR lpszUserType);
	WINOLEAPI ReadFmtUserTypeStg(IN LPSTORAGE pstg, OUT CLIPFORMAT FAR* pcf, OUT LPOLESTR FAR* lplpszUserType);


	/* init/term */

	WINOLEAPI OleInitialize(IN LPVOID pvReserved);
	WINOLEAPI_(void) OleUninitialize(void);


	/* APIs to query whether (Embedded/Linked) object can be created from
	   the data object */

	WINOLEAPI  OleQueryLinkFromData(IN LPDATAOBJECT pSrcDataObject);
	WINOLEAPI  OleQueryCreateFromData(IN LPDATAOBJECT pSrcDataObject);


	/* Object creation APIs */

	WINOLEAPI  OleCreate(IN REFCLSID rclsid, IN REFIID riid, IN DWORD renderopt,
		IN LPFORMATETC pFormatEtc, IN LPOLECLIENTSITE pClientSite,
		IN LPSTORAGE pStg, OUT LPVOID FAR* ppvObj);

	WINOLEAPI  OleCreateEx(IN REFCLSID rclsid, IN REFIID riid, IN DWORD dwFlags,
		IN DWORD renderopt, IN ULONG cFormats, IN DWORD* rgAdvf,
		IN LPFORMATETC rgFormatEtc, IN IAdviseSink FAR* lpAdviseSink,
		OUT DWORD FAR* rgdwConnection, IN LPOLECLIENTSITE pClientSite,
		IN LPSTORAGE pStg, OUT LPVOID FAR* ppvObj);

	WINOLEAPI  OleCreateFromData(IN LPDATAOBJECT pSrcDataObj, IN REFIID riid,
		IN DWORD renderopt, IN LPFORMATETC pFormatEtc,
		IN LPOLECLIENTSITE pClientSite, IN LPSTORAGE pStg,
		OUT LPVOID FAR* ppvObj);

	WINOLEAPI  OleCreateFromDataEx(IN LPDATAOBJECT pSrcDataObj, IN REFIID riid,
		IN DWORD dwFlags, IN DWORD renderopt, IN ULONG cFormats, IN DWORD* rgAdvf,
		IN LPFORMATETC rgFormatEtc, IN IAdviseSink FAR* lpAdviseSink,
		OUT DWORD FAR* rgdwConnection, IN LPOLECLIENTSITE pClientSite,
		IN LPSTORAGE pStg, OUT LPVOID FAR* ppvObj);

	WINOLEAPI  OleCreateLinkFromData(IN LPDATAOBJECT pSrcDataObj, IN REFIID riid,
		IN DWORD renderopt, IN LPFORMATETC pFormatEtc,
		IN LPOLECLIENTSITE pClientSite, IN LPSTORAGE pStg,
		OUT LPVOID FAR* ppvObj);

	WINOLEAPI  OleCreateLinkFromDataEx(IN LPDATAOBJECT pSrcDataObj, IN REFIID riid,
		IN DWORD dwFlags, IN DWORD renderopt, IN ULONG cFormats, IN DWORD* rgAdvf,
		IN LPFORMATETC rgFormatEtc, IN IAdviseSink FAR* lpAdviseSink,
		OUT IN DWORD FAR* rgdwConnection, IN LPOLECLIENTSITE pClientSite,
		IN LPSTORAGE pStg, OUT LPVOID FAR* ppvObj);

	WINOLEAPI  OleCreateStaticFromData(IN LPDATAOBJECT pSrcDataObj, IN REFIID iid,
		IN DWORD renderopt, IN LPFORMATETC pFormatEtc,
		IN LPOLECLIENTSITE pClientSite, IN LPSTORAGE pStg,
		OUT LPVOID FAR* ppvObj);


	WINOLEAPI  OleCreateLink(IN LPMONIKER pmkLinkSrc, IN REFIID riid,
		IN DWORD renderopt, IN LPFORMATETC lpFormatEtc,
		IN LPOLECLIENTSITE pClientSite, IN LPSTORAGE pStg, OUT LPVOID FAR* ppvObj);

	WINOLEAPI  OleCreateLinkEx(IN LPMONIKER pmkLinkSrc, IN REFIID riid,
		IN DWORD dwFlags, IN DWORD renderopt, IN ULONG cFormats, IN DWORD* rgAdvf,
		IN LPFORMATETC rgFormatEtc, IN IAdviseSink FAR* lpAdviseSink,
		OUT DWORD FAR* rgdwConnection, IN LPOLECLIENTSITE pClientSite,
		IN LPSTORAGE pStg, OUT LPVOID FAR* ppvObj);

	WINOLEAPI  OleCreateLinkToFile(IN LPCOLESTR lpszFileName, IN REFIID riid,
		IN DWORD renderopt, IN LPFORMATETC lpFormatEtc,
		IN LPOLECLIENTSITE pClientSite, IN LPSTORAGE pStg, OUT LPVOID FAR* ppvObj);

	WINOLEAPI  OleCreateLinkToFileEx(IN LPCOLESTR lpszFileName, IN REFIID riid,
		IN DWORD dwFlags, IN DWORD renderopt, IN ULONG cFormats, IN DWORD* rgAdvf,
		IN LPFORMATETC rgFormatEtc, IN IAdviseSink FAR* lpAdviseSink,
		OUT DWORD FAR* rgdwConnection, IN LPOLECLIENTSITE pClientSite,
		IN LPSTORAGE pStg, OUT LPVOID FAR* ppvObj);

	WINOLEAPI  OleCreateFromFile(IN REFCLSID rclsid, IN LPCOLESTR lpszFileName, IN REFIID riid,
		IN DWORD renderopt, IN LPFORMATETC lpFormatEtc,
		IN LPOLECLIENTSITE pClientSite, IN LPSTORAGE pStg, OUT LPVOID FAR* ppvObj);

	WINOLEAPI  OleCreateFromFileEx(IN REFCLSID rclsid, IN LPCOLESTR lpszFileName, IN REFIID riid,
		IN DWORD dwFlags, IN DWORD renderopt, IN ULONG cFormats, IN DWORD* rgAdvf,
		IN LPFORMATETC rgFormatEtc, IN IAdviseSink FAR* lpAdviseSink,
		OUT DWORD FAR* rgdwConnection, IN LPOLECLIENTSITE pClientSite,
		IN LPSTORAGE pStg, OUT LPVOID FAR* ppvObj);

	WINOLEAPI  OleLoad(IN LPSTORAGE pStg, IN REFIID riid, IN LPOLECLIENTSITE pClientSite,
		OUT LPVOID FAR* ppvObj);

	WINOLEAPI  OleSave(IN LPPERSISTSTORAGE pPS, IN LPSTORAGE pStg, IN BOOL fSameAsLoad);

	WINOLEAPI  OleLoadFromStream(IN LPSTREAM pStm, IN REFIID iidInterface, OUT LPVOID FAR* ppvObj);
	WINOLEAPI  OleSaveToStream(IN LPPERSISTSTREAM pPStm, IN LPSTREAM pStm);


	WINOLEAPI  OleSetContainedObject(IN LPUNKNOWN pUnknown, IN BOOL fContained);
	WINOLEAPI  OleNoteObjectVisible(IN LPUNKNOWN pUnknown, IN BOOL fVisible);


	/* Drag/Drop APIs */

	WINOLEAPI  RegisterDragDrop(IN HWND hwnd, IN LPDROPTARGET pDropTarget);
	WINOLEAPI  RevokeDragDrop(IN HWND hwnd);
	WINOLEAPI  DoDragDrop(IN LPDATAOBJECT pDataObj, IN LPDROPSOURCE pDropSource,
		IN DWORD dwOKEffects, OUT LPDWORD pdwEffect);

	/* Clipboard APIs */

	WINOLEAPI  OleSetClipboard(IN LPDATAOBJECT pDataObj);
	WINOLEAPI  OleGetClipboard(OUT LPDATAOBJECT FAR* ppDataObj);
	WINOLEAPI  OleFlushClipboard(void);
	WINOLEAPI  OleIsCurrentClipboard(IN LPDATAOBJECT pDataObj);


	/* InPlace Editing APIs */

	WINOLEAPI_(HOLEMENU)   OleCreateMenuDescriptor(IN HMENU hmenuCombined,
		IN LPOLEMENUGROUPWIDTHS lpMenuWidths);
	WINOLEAPI              OleSetMenuDescriptor(IN HOLEMENU holemenu, IN HWND hwndFrame,
		IN HWND hwndActiveObject,
		IN LPOLEINPLACEFRAME lpFrame,
		IN LPOLEINPLACEACTIVEOBJECT lpActiveObj);
	WINOLEAPI              OleDestroyMenuDescriptor(IN HOLEMENU holemenu);

	WINOLEAPI              OleTranslateAccelerator(IN LPOLEINPLACEFRAME lpFrame,
		IN LPOLEINPLACEFRAMEINFO lpFrameInfo, IN LPMSG lpmsg);


	/* Helper APIs */
	WINOLEAPI_(HANDLE) OleDuplicateData(IN HANDLE hSrc, IN CLIPFORMAT cfFormat,
		IN UINT uiFlags);

	WINOLEAPI          OleDraw(IN LPUNKNOWN pUnknown, IN DWORD dwAspect, IN HDC hdcDraw,
		IN LPCRECT lprcBounds);

	WINOLEAPI          OleRun(IN LPUNKNOWN pUnknown);
	WINOLEAPI_(BOOL)   OleIsRunning(IN LPOLEOBJECT pObject);
	WINOLEAPI          OleLockRunning(IN LPUNKNOWN pUnknown, IN BOOL fLock, IN BOOL fLastUnlockCloses);
	WINOLEAPI_(void)   ReleaseStgMedium(IN LPSTGMEDIUM);
	WINOLEAPI          CreateOleAdviseHolder(OUT LPOLEADVISEHOLDER FAR* ppOAHolder);

	WINOLEAPI          OleCreateDefaultHandler(IN REFCLSID clsid, IN LPUNKNOWN pUnkOuter,
		IN REFIID riid, OUT LPVOID FAR* lplpObj);

	WINOLEAPI          OleCreateEmbeddingHelper(IN REFCLSID clsid, IN LPUNKNOWN pUnkOuter,
		IN DWORD flags, IN LPCLASSFACTORY pCF,
		IN REFIID riid, OUT LPVOID FAR* lplpObj);

	WINOLEAPI_(BOOL)   IsAccelerator(IN HACCEL hAccel, IN int cAccelEntries, IN LPMSG lpMsg,
		OUT WORD FAR* lpwCmd);
	/* Icon extraction Helper APIs */

	WINOLEAPI_(HGLOBAL) OleGetIconOfFile(IN LPOLESTR lpszPath, IN BOOL fUseFileAsLabel);

	WINOLEAPI_(HGLOBAL) OleGetIconOfClass(IN REFCLSID rclsid, IN LPOLESTR lpszLabel,
		IN BOOL fUseTypeAsLabel);

	WINOLEAPI_(HGLOBAL) OleMetafilePictFromIconAndLabel(IN HICON hIcon, IN LPOLESTR lpszLabel,
		IN LPOLESTR lpszSourceFile, IN UINT iIconIndex);



	/* Registration Database Helper APIs */

	WINOLEAPI                  OleRegGetUserType(IN REFCLSID clsid, IN DWORD dwFormOfType,
		OUT LPOLESTR FAR* pszUserType);

	WINOLEAPI                  OleRegGetMiscStatus(IN REFCLSID clsid, IN DWORD dwAspect,
		OUT DWORD FAR* pdwStatus);

	WINOLEAPI                  OleRegEnumFormatEtc(IN REFCLSID clsid, IN DWORD dwDirection,
		OUT LPENUMFORMATETC FAR* ppenum);

	WINOLEAPI                  OleRegEnumVerbs(IN REFCLSID clsid, OUT LPENUMOLEVERB FAR* ppenum);

#ifdef _MAC
	/* WlmOLE helper APIs */

	WINOLEAPI WlmOleCheckoutMacInterface(LPUNKNOWN pUnk, LPVOID* ppv);
	WINOLEAPI WlmOleCheckinMacInterface(LPUNKNOWN pUnk);
	WINOLEAPI WlmOleWrapMacInterface(LPUNKNOWN pUnk, REFIID riid, LPVOID* ppv);
	WINOLEAPI WlmOleUnwrapMacInterface(LPVOID pv);

	WINOLEAPI WlmOleCheckoutWinInterface(LPVOID pUnk, LPUNKNOWN* ppv);
	WINOLEAPI WlmOleCheckinWinInterface(LPVOID pUnk);
	WINOLEAPI WlmOleWrapWinInterface(LPVOID pUnk, REFIID riid, LPUNKNOWN* ppv);
	WINOLEAPI WlmOleUnwrapWinInterface(LPVOID pv);

	WINOLEAPI_(void) WlmOleVersion(void);
	WINOLEAPI_(void) WlmOleSetInPlaceWindow(HWND hwnd);

	typedef HRESULT(STDAPICALLTYPE* OLEWRAPPROC) (REFIID riid, LPVOID* ppvWin, LPVOID* ppvMac);
	WINOLEAPI WlmOleRegisterUserWrap(OLEWRAPPROC procNew, OLEWRAPPROC* pprocOld);
#endif


	/* OLE 1.0 conversion APIS */

	/***** OLE 1.0 OLESTREAM declarations *************************************/

	typedef struct _OLESTREAM FAR* LPOLESTREAM;

	typedef struct _OLESTREAMVTBL
	{
		DWORD(CALLBACK* Get)(LPOLESTREAM, void FAR*, DWORD);
		DWORD(CALLBACK* Put)(LPOLESTREAM, const void FAR*, DWORD);
	} OLESTREAMVTBL;
	typedef  OLESTREAMVTBL FAR* LPOLESTREAMVTBL;

	typedef struct _OLESTREAM
	{
		LPOLESTREAMVTBL lpstbl;
	} OLESTREAM;


	WINOLEAPI OleConvertOLESTREAMToIStorage
	(IN LPOLESTREAM                lpolestream,
		OUT LPSTORAGE                   pstg,
		IN const DVTARGETDEVICE FAR* ptd);

	WINOLEAPI OleConvertIStorageToOLESTREAM
	(IN LPSTORAGE      pstg,
		OUT LPOLESTREAM     lpolestream);


	/* Storage Utility APIs */
	WINOLEAPI GetHGlobalFromILockBytes(IN LPLOCKBYTES plkbyt, OUT HGLOBAL FAR* phglobal);
	WINOLEAPI CreateILockBytesOnHGlobal(IN HGLOBAL hGlobal, IN BOOL fDeleteOnRelease,
		OUT LPLOCKBYTES FAR* pplkbyt);

	WINOLEAPI GetHGlobalFromStream(IN LPSTREAM pstm, OUT HGLOBAL FAR* phglobal);
	WINOLEAPI CreateStreamOnHGlobal(IN HGLOBAL hGlobal, IN BOOL fDeleteOnRelease,
		OUT LPSTREAM FAR* ppstm);


	/* ConvertTo APIS */

	WINOLEAPI OleDoAutoConvert(IN LPSTORAGE pStg, OUT LPCLSID pClsidNew);
	WINOLEAPI OleGetAutoConvert(IN REFCLSID clsidOld, OUT LPCLSID pClsidNew);
	WINOLEAPI OleSetAutoConvert(IN REFCLSID clsidOld, IN REFCLSID clsidNew);
	WINOLEAPI GetConvertStg(IN LPSTORAGE pStg);
	WINOLEAPI SetConvertStg(IN LPSTORAGE pStg, IN BOOL fConvert);


	WINOLEAPI OleConvertIStorageToOLESTREAMEx
	(IN LPSTORAGE          pstg,
		// Presentation data to OLESTREAM
		IN CLIPFORMAT         cfFormat,   //      format
		IN LONG               lWidth,     //      width
		IN LONG               lHeight,    //      height
		IN DWORD              dwSize,     //      size in bytes
		IN LPSTGMEDIUM        pmedium,    //      bits
		OUT LPOLESTREAM        polestm);

	WINOLEAPI OleConvertOLESTREAMToIStorageEx
	(IN LPOLESTREAM        polestm,
		OUT LPSTORAGE          pstg,
		// Presentation data from OLESTREAM
		OUT CLIPFORMAT FAR* pcfFormat,  //      format
		OUT LONG FAR* plwWidth,   //      width
		OUT LONG FAR* plHeight,   //      height
		OUT DWORD FAR* pdwSize,    //      size in bytes
		OUT LPSTGMEDIUM        pmedium);   //      bits

#ifndef _MAC
#ifndef RC_INVOKED
#include <poppack.h>
#endif // RC_INVOKED

#else // _MAC

#ifndef __MACAPI__
#include <macapi.h>
#endif

#ifdef _WIN32
// ***** DOINC including macname2.h *****
	// DOINC skipping missing include
#endif // _WIN32

#endif // _MAC

//d308927f-ca94-4c96-8d87-2692a3dadff6
/*#!perl
SetInsertionPoint("ole2.h", "d308927f-ca94-4c96-8d87-2692a3dadff6");
*/

#endif     // __OLE2_H__
// DOINC popped back into header 'pbprop.h'
#endif /*COM_NO_WINDOWS_H*/

#ifndef __pbprop_h__
#define __pbprop_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */

#ifndef __IPB_PropertySet_FWD_DEFINED__
#define __IPB_PropertySet_FWD_DEFINED__
	typedef interface IPB_PropertySet IPB_PropertySet;
#endif 	/* __IPB_PropertySet_FWD_DEFINED__ */


	/* header files for imported files */
	// ***** DOINC including unknwn.h *****


	/* this ALWAYS GENERATED file contains the definitions for the interfaces */


	 /* File created by MIDL compiler version 6.00.0361 */
	/* Compiler settings for unknwn.idl:
		Oicf, W1, Zp8, env=Win32 (32b run)
		protocol : dce , ms_ext, c_ext, robust
		error checks: allocation ref bounds_check enum stub_data
		VC __declspec() decoration level:
			 __declspec(uuid()), __declspec(selectany), __declspec(novtable)
			 DECLSPEC_UUID(), MIDL_INTERFACE()
	*/
	//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

// ***** DOINC including rpc.h *****
	// DOINC skipping duplicate include
// ***** DOINC including rpcndr.h *****
	// DOINC skipping duplicate include

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
// ***** DOINC including windows.h *****
	// DOINC skipping duplicate include
// ***** DOINC including ole2.h *****
	// DOINC skipping duplicate include
#endif /*COM_NO_WINDOWS_H*/

#ifndef __unknwn_h__
#define __unknwn_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */

#ifndef __IUnknown_FWD_DEFINED__
#define __IUnknown_FWD_DEFINED__
	typedef interface IUnknown IUnknown;
#endif 	/* __IUnknown_FWD_DEFINED__ */


#ifndef __AsyncIUnknown_FWD_DEFINED__
#define __AsyncIUnknown_FWD_DEFINED__
	typedef interface AsyncIUnknown AsyncIUnknown;
#endif 	/* __AsyncIUnknown_FWD_DEFINED__ */


#ifndef __IClassFactory_FWD_DEFINED__
#define __IClassFactory_FWD_DEFINED__
	typedef interface IClassFactory IClassFactory;
#endif 	/* __IClassFactory_FWD_DEFINED__ */


	/* header files for imported files */
	// ***** DOINC including wtypes.h *****


	/* this ALWAYS GENERATED file contains the definitions for the interfaces */


	 /* File created by MIDL compiler version 6.00.0361 */
	/* Compiler settings for wtypes.idl:
		Oicf, W1, Zp8, env=Win32 (32b run)
		protocol : dce , ms_ext, c_ext, robust
		error checks: allocation ref bounds_check enum stub_data
		VC __declspec() decoration level:
			 __declspec(uuid()), __declspec(selectany), __declspec(novtable)
			 DECLSPEC_UUID(), MIDL_INTERFACE()
	*/
	//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

// ***** DOINC including rpc.h *****
	// DOINC skipping duplicate include
// ***** DOINC including rpcndr.h *****
	// DOINC skipping duplicate include

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __wtypes_h__
#define __wtypes_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */

/* header files for imported files */
// ***** DOINC including basetsd.h *****
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

	basetsd.h

Abstract:

	Type definitions for the basic sized types.

Author:

Revision History:

--*/

#ifndef _BASETSD_H_
#define _BASETSD_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
	extern "C" {
#endif

		typedef signed char         INT8, * PINT8;
		typedef signed short        INT16, * PINT16;
		typedef signed int          INT32, * PINT32;
		typedef signed __int64      INT64, * PINT64;
		typedef unsigned char       UINT8, * PUINT8;
		typedef unsigned short      UINT16, * PUINT16;
		typedef unsigned int        UINT32, * PUINT32;
		typedef unsigned __int64    UINT64, * PUINT64;

		//
		// The following types are guaranteed to be signed and 32 bits wide.
		//

		typedef signed int LONG32, * PLONG32;

		//
		// The following types are guaranteed to be unsigned and 32 bits wide.
		//

		typedef unsigned int ULONG32, * PULONG32;
		typedef unsigned int DWORD32, * PDWORD32;

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

		//
		// The INT_PTR is guaranteed to be the same size as a pointer.  Its
		// size with change with pointer size (32/64).  It should be used
		// anywhere that a pointer is cast to an integer type. UINT_PTR is
		// the unsigned variation.
		//
		// __int3264 is intrinsic to 64b MIDL but not to old MIDL or to C compiler.
		//
#if ( 501 < __midl )

		typedef [public] __int3264 INT_PTR, * PINT_PTR;
		typedef [public] unsigned __int3264 UINT_PTR, * PUINT_PTR;

		typedef [public] __int3264 LONG_PTR, * PLONG_PTR;
		typedef [public] unsigned __int3264 ULONG_PTR, * PULONG_PTR;

#else  // midl64
// old midl and C++ compiler

#if defined(_WIN64)
		typedef __int64 INT_PTR, * PINT_PTR;
		typedef unsigned __int64 UINT_PTR, * PUINT_PTR;

		typedef __int64 LONG_PTR, * PLONG_PTR;
		typedef unsigned __int64 ULONG_PTR, * PULONG_PTR;

#define __int3264   __int64

#else
		typedef _W64 int INT_PTR, * PINT_PTR;
		typedef _W64 unsigned int UINT_PTR, * PUINT_PTR;

		typedef _W64 long LONG_PTR, * PLONG_PTR;
		typedef _W64 unsigned long ULONG_PTR, * PULONG_PTR;

#define __int3264   __int32

#endif
#endif // midl64

		//
		// HALF_PTR is half the size of a pointer it intended for use with
		// within structures which contain a pointer and two small fields.
		// UHALF_PTR is the unsigned variation.
		//

#ifdef _WIN64

#define ADDRESS_TAG_BIT 0x40000000000UI64

		typedef __int64 SHANDLE_PTR;
		typedef unsigned __int64 HANDLE_PTR;
		typedef unsigned int UHALF_PTR, * PUHALF_PTR;
		typedef int HALF_PTR, * PHALF_PTR;

#if !defined(__midl)
		__inline
			unsigned long
			HandleToULong(
				const void* h
			)
		{
			return((unsigned long)(ULONG_PTR)h);
		}

		__inline
			long
			HandleToLong(
				const void* h
			)
		{
			return((long)(LONG_PTR)h);
		}

		__inline
			void*
			ULongToHandle(
				const unsigned long h
			)
		{
			return((void*)(UINT_PTR)h);
		}


		__inline
			void*
			LongToHandle(
				const long h
			)
		{
			return((void*)(INT_PTR)h);
		}


		__inline
			unsigned long
			PtrToUlong(
				const void* p
			)
		{
			return((unsigned long)(ULONG_PTR)p);
		}

		__inline
			unsigned int
			PtrToUint(
				const void* p
			)
		{
			return((unsigned int)(UINT_PTR)p);
		}

		__inline
			unsigned short
			PtrToUshort(
				const void* p
			)
		{
			return((unsigned short)(unsigned long)(ULONG_PTR)p);
		}

		__inline
			long
			PtrToLong(
				const void* p
			)
		{
			return((long)(LONG_PTR)p);
		}

		__inline
			int
			PtrToInt(
				const void* p
			)
		{
			return((int)(INT_PTR)p);
		}

		__inline
			short
			PtrToShort(
				const void* p
			)
		{
			return((short)(long)(LONG_PTR)p);
		}

		__inline
			void*
			IntToPtr(
				const int i
			)
			// Caution: IntToPtr() sign-extends the int value.
		{
			return((void*)(INT_PTR)i);
		}

		__inline
			void*
			UIntToPtr(
				const unsigned int ui
			)
			// Caution: UIntToPtr() zero-extends the unsigned int value.
		{
			return((void*)(UINT_PTR)ui);
		}

		__inline
			void*
			LongToPtr(
				const long l
			)
			// Caution: LongToPtr() sign-extends the long value.
		{
			return((void*)(LONG_PTR)l);
		}

		__inline
			void*
			ULongToPtr(
				const unsigned long ul
			)
			// Caution: ULongToPtr() zero-extends the unsigned long value.
		{
			return((void*)(ULONG_PTR)ul);
		}

#endif // !_midl

#else  // !_WIN64

#define ADDRESS_TAG_BIT 0x80000000UL

		typedef unsigned short UHALF_PTR, * PUHALF_PTR;
		typedef short HALF_PTR, * PHALF_PTR;
		typedef _W64 long SHANDLE_PTR;
		typedef _W64 unsigned long HANDLE_PTR;

#define HandleToULong( h ) ((ULONG)(ULONG_PTR)(h) )
#define HandleToLong( h )  ((LONG)(LONG_PTR) (h) )
#define ULongToHandle( ul ) ((HANDLE)(ULONG_PTR) (ul) )
#define LongToHandle( h )   ((HANDLE)(LONG_PTR) (h) )
#define PtrToUlong( p ) ((ULONG)(ULONG_PTR) (p) )
#define PtrToLong( p )  ((LONG)(LONG_PTR) (p) )
#define PtrToUint( p ) ((UINT)(UINT_PTR) (p) )
#define PtrToInt( p )  ((INT)(INT_PTR) (p) )
#define PtrToUshort( p ) ((unsigned short)(ULONG_PTR)(p) )
#define PtrToShort( p )  ((short)(LONG_PTR)(p) )
#define IntToPtr( i )    ((VOID *)(INT_PTR)((int)i))
#define UIntToPtr( ui )  ((VOID *)(UINT_PTR)((unsigned int)ui))
#define LongToPtr( l )   ((VOID *)(LONG_PTR)((long)l))
#define ULongToPtr( ul ) ((VOID *)(ULONG_PTR)((unsigned long)ul))

#endif // !_WIN64

#define HandleToUlong(h)  HandleToULong(h)
#define UlongToHandle(ul) ULongToHandle(ul)
#define UlongToPtr(ul) ULongToPtr(ul)
#define UintToPtr(ui)  UIntToPtr(ui)

#define MAXUINT_PTR  (~((UINT_PTR)0))
#define MAXINT_PTR   ((INT_PTR)(MAXUINT_PTR >> 1))
#define MININT_PTR   (~MAXINT_PTR)

#define MAXULONG_PTR (~((ULONG_PTR)0))
#define MAXLONG_PTR  ((LONG_PTR)(MAXULONG_PTR >> 1))
#define MINLONG_PTR  (~MAXLONG_PTR)

#define MAXUHALF_PTR ((UHALF_PTR)~0)
#define MAXHALF_PTR  ((HALF_PTR)(MAXUHALF_PTR >> 1))
#define MINHALF_PTR  (~MAXHALF_PTR)

		//
		// SIZE_T used for counts or ranges which need to span the range of
		// of a pointer.  SSIZE_T is the signed variation.
		//

		typedef ULONG_PTR SIZE_T, * PSIZE_T;
		typedef LONG_PTR SSIZE_T, * PSSIZE_T;

		//
		// Add Windows flavor DWORD_PTR types
		//

		typedef ULONG_PTR DWORD_PTR, * PDWORD_PTR;

		//
		// The following types are guaranteed to be signed and 64 bits wide.
		//

		typedef __int64 LONG64, * PLONG64;


		//
		// The following types are guaranteed to be unsigned and 64 bits wide.
		//

		typedef unsigned __int64 ULONG64, * PULONG64;
		typedef unsigned __int64 DWORD64, * PDWORD64;

		//
		// Thread affinity.
		//

		typedef ULONG_PTR KAFFINITY;
		typedef KAFFINITY* PKAFFINITY;

#ifdef __cplusplus
	}
#endif

#endif // _BASETSD_H_
	// DOINC popped back into header 'wtypes.h'
	// ***** DOINC including guiddef.h *****
	//+---------------------------------------------------------------------------
	//
	//  Microsoft Windows
	//  Copyright (c) Microsoft Corporation.  All rights reserved.
	//
	//  File:       guiddef.h
	//
	//  Contents:   GUID definition
	//
	//----------------------------------------------------------------------------

#ifndef GUID_DEFINED
#define GUID_DEFINED
#if defined(__midl)
	typedef struct {
		unsigned long  Data1;
		unsigned short Data2;
		unsigned short Data3;
		byte           Data4[8];
	} GUID;
#else
	typedef struct _GUID {
		unsigned long  Data1;
		unsigned short Data2;
		unsigned short Data3;
		unsigned char  Data4[8];
	} GUID;
#endif
#endif

#ifndef FAR
#ifdef _WIN32
#define FAR
#else
#define FAR _far
#endif
#endif

#ifndef DECLSPEC_SELECTANY
#if (_MSC_VER >= 1100)
#define DECLSPEC_SELECTANY  __declspec(selectany)
#else
#define DECLSPEC_SELECTANY
#endif
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
#define EXTERN_C    extern "C"
#else
#define EXTERN_C    extern
#endif
#endif

#ifdef DEFINE_GUID
#undef DEFINE_GUID
#endif

#ifdef INITGUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID DECLSPEC_SELECTANY name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#else
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID FAR name
#endif // INITGUID

#define DEFINE_OLEGUID(name, l, w1, w2) DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

#ifndef _GUIDDEF_H_
#define _GUIDDEF_H_

#ifndef __LPGUID_DEFINED__
#define __LPGUID_DEFINED__
	typedef GUID* LPGUID;
#endif

#ifndef __LPCGUID_DEFINED__
#define __LPCGUID_DEFINED__
	typedef const GUID* LPCGUID;
#endif

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

	typedef GUID IID;
	typedef IID* LPIID;
#define IID_NULL            GUID_NULL
#define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)
	typedef GUID CLSID;
	typedef CLSID* LPCLSID;
#define CLSID_NULL          GUID_NULL
#define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)
	typedef GUID FMTID;
	typedef FMTID* LPFMTID;
#define FMTID_NULL          GUID_NULL
#define IsEqualFMTID(rfmtid1, rfmtid2) IsEqualGUID(rfmtid1, rfmtid2)

#ifdef __midl_proxy
#define __MIDL_CONST
#else
#define __MIDL_CONST const
#endif

#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#ifdef __cplusplus
#define REFGUID const GUID &
#else
#define REFGUID const GUID * __MIDL_CONST
#endif
#endif

#ifndef _REFIID_DEFINED
#define _REFIID_DEFINED
#ifdef __cplusplus
#define REFIID const IID &
#else
#define REFIID const IID * __MIDL_CONST
#endif
#endif

#ifndef _REFCLSID_DEFINED
#define _REFCLSID_DEFINED
#ifdef __cplusplus
#define REFCLSID const IID &
#else
#define REFCLSID const IID * __MIDL_CONST
#endif
#endif

#ifndef _REFFMTID_DEFINED
#define _REFFMTID_DEFINED
#ifdef __cplusplus
#define REFFMTID const IID &
#else
#define REFFMTID const IID * __MIDL_CONST
#endif
#endif

#endif // !__IID_DEFINED__

#if !defined (__midl)
#if !defined (_SYS_GUID_OPERATORS_)
#define _SYS_GUID_OPERATORS_
#include <string.h>

	// Faster (but makes code fatter) inline version...use sparingly
#ifdef __cplusplus
	__inline int InlineIsEqualGUID(REFGUID rguid1, REFGUID rguid2)
	{
		return (
			((unsigned long*)&rguid1)[0] == ((unsigned long*)&rguid2)[0] &&
			((unsigned long*)&rguid1)[1] == ((unsigned long*)&rguid2)[1] &&
			((unsigned long*)&rguid1)[2] == ((unsigned long*)&rguid2)[2] &&
			((unsigned long*)&rguid1)[3] == ((unsigned long*)&rguid2)[3]);
	}

	__inline int IsEqualGUID(REFGUID rguid1, REFGUID rguid2)
	{
		return !memcmp(&rguid1, &rguid2, sizeof(GUID));
	}

#else   // ! __cplusplus

#define InlineIsEqualGUID(rguid1, rguid2)  \
        (((unsigned long *) rguid1)[0] == ((unsigned long *) rguid2)[0] &&   \
        ((unsigned long *) rguid1)[1] == ((unsigned long *) rguid2)[1] &&    \
        ((unsigned long *) rguid1)[2] == ((unsigned long *) rguid2)[2] &&    \
        ((unsigned long *) rguid1)[3] == ((unsigned long *) rguid2)[3])

#define IsEqualGUID(rguid1, rguid2) (!memcmp(rguid1, rguid2, sizeof(GUID)))

#endif  // __cplusplus

#ifdef __INLINE_ISEQUAL_GUID
#undef IsEqualGUID
#define IsEqualGUID(rguid1, rguid2) InlineIsEqualGUID(rguid1, rguid2)
#endif

// Same type, different name

#define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)
#define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)


#if !defined _SYS_GUID_OPERATOR_EQ_ && !defined _NO_SYS_GUID_OPERATOR_EQ_
#define _SYS_GUID_OPERATOR_EQ_
// A couple of C++ helpers

#ifdef __cplusplus
	__inline int operator==(REFGUID guidOne, REFGUID guidOther)
	{
		return IsEqualGUID(guidOne, guidOther);
	}

	__inline int operator!=(REFGUID guidOne, REFGUID guidOther)
	{
		return !(guidOne == guidOther);
	}
#endif
#endif  // _SYS_GUID_OPERATOR_EQ_
#endif  // _SYS_GUID_OPERATORS_
#endif  // __midl
#endif  // _GUIDDEF_H_
	// DOINC popped back into header 'wtypes.h'

#ifdef __cplusplus
	extern "C" {
#endif 

		void* __RPC_USER MIDL_user_allocate(size_t);
		void __RPC_USER MIDL_user_free(void*);

		/* interface __MIDL_itf_wtypes_0000 */
		/* [local] */

		//+-------------------------------------------------------------------------
		//
		//  Microsoft Windows
		//  Copyright (c) Microsoft Corporation. All rights reserved.
		//
		//--------------------------------------------------------------------------
#if ( _MSC_VER >= 1020 )
#pragma once
#endif


		extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_v0_0_c_ifspec;
		extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_v0_0_s_ifspec;

#ifndef __IWinTypes_INTERFACE_DEFINED__
#define __IWinTypes_INTERFACE_DEFINED__

		/* interface IWinTypes */
		/* [auto_handle][unique][version][uuid] */

		typedef struct tagRemHGLOBAL
		{
			long fNullHGlobal;
			unsigned long cbData;
			/* [size_is] */ byte data[1];
		} 	RemHGLOBAL;

		typedef struct tagRemHMETAFILEPICT
		{
			long mm;
			long xExt;
			long yExt;
			unsigned long cbData;
			/* [size_is] */ byte data[1];
		} 	RemHMETAFILEPICT;

		typedef struct tagRemHENHMETAFILE
		{
			unsigned long cbData;
			/* [size_is] */ byte data[1];
		} 	RemHENHMETAFILE;

		typedef struct tagRemHBITMAP
		{
			unsigned long cbData;
			/* [size_is] */ byte data[1];
		} 	RemHBITMAP;

		typedef struct tagRemHPALETTE
		{
			unsigned long cbData;
			/* [size_is] */ byte data[1];
		} 	RemHPALETTE;

		typedef struct tagRemBRUSH
		{
			unsigned long cbData;
			/* [size_is] */ byte data[1];
		} 	RemHBRUSH;

#if !defined(_WIN32) && !defined(_MPPC_)
		// The following code is for Win16 only
#ifndef WINAPI          // If not included with 3.1 headers...
#define FAR             _far
#define PASCAL          _pascal
#define CDECL           _cdecl
#define VOID            void
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#ifndef FALSE
#define FALSE 0
#define TRUE 1
#endif // !FALSE
#ifndef _BYTE_DEFINED
#define _BYTE_DEFINED
		typedef byte BYTE;

#endif // !_BYTE_DEFINED
#ifndef _WORD_DEFINED
#define _WORD_DEFINED
		typedef unsigned short WORD;

#endif // !_WORD_DEFINED
		typedef unsigned int UINT;

		typedef int INT;

		typedef long BOOL;

#ifndef _LONG_DEFINED
#define _LONG_DEFINED
		typedef long LONG;

#endif // !_LONG_DEFINED
#ifndef _WPARAM_DEFINED
#define _WPARAM_DEFINED
		typedef UINT_PTR WPARAM;

#endif // _WPARAM_DEFINED
#ifndef _DWORD_DEFINED
#define _DWORD_DEFINED
		typedef unsigned long DWORD;

#endif // !_DWORD_DEFINED
#ifndef _LPARAM_DEFINED
#define _LPARAM_DEFINED
		typedef LONG_PTR LPARAM;

#endif // !_LPARAM_DEFINED
#ifndef _LRESULT_DEFINED
#define _LRESULT_DEFINED
		typedef LONG_PTR LRESULT;

#endif // !_LRESULT_DEFINED
		typedef void* HANDLE;

		typedef void* HMODULE;

		typedef void* HINSTANCE;

		typedef void* HRGN;

		typedef void* HTASK;

		typedef void* HKEY;

		typedef void* HDESK;

		typedef void* HMF;

		typedef void* HEMF;

		typedef void* HPEN;

		typedef void* HRSRC;

		typedef void* HSTR;

		typedef void* HWINSTA;

		typedef void* HKL;

		typedef void* HGDIOBJ;

		typedef HANDLE HDWP;

#ifndef _HFILE_DEFINED
#define _HFILE_DEFINED
		typedef INT HFILE;

#endif // !_HFILE_DEFINED
#ifndef _LPWORD_DEFINED
#define _LPWORD_DEFINED
		typedef WORD* LPWORD;

#endif // !_LPWORD_DEFINED
#ifndef _LPDWORD_DEFINED
#define _LPDWORD_DEFINED
		typedef DWORD* LPDWORD;

#endif // !_LPDWORD_DEFINED
		typedef char CHAR;

		typedef /* [string] */ CHAR* LPSTR;

		typedef /* [string] */ const CHAR* LPCSTR;

#ifndef _WCHAR_DEFINED
#define _WCHAR_DEFINED
		typedef wchar_t WCHAR;

		typedef WCHAR TCHAR;

#endif // !_WCHAR_DEFINED
		typedef /* [string] */ WCHAR* LPWSTR;

		typedef /* [string] */ TCHAR* LPTSTR;

		typedef /* [string] */ const WCHAR* LPCWSTR;

		typedef /* [string] */ const TCHAR* LPCTSTR;

#ifndef _COLORREF_DEFINED
#define _COLORREF_DEFINED
		typedef DWORD COLORREF;

#endif // !_COLORREF_DEFINED
#ifndef _LPCOLORREF_DEFINED
#define _LPCOLORREF_DEFINED
		typedef DWORD* LPCOLORREF;

#endif // !_LPCOLORREF_DEFINED
		typedef HANDLE* LPHANDLE;

		typedef struct _RECTL
		{
			LONG left;
			LONG top;
			LONG right;
			LONG bottom;
		} 	RECTL;

		typedef struct _RECTL* PRECTL;

		typedef struct _RECTL* LPRECTL;

		typedef struct tagPOINT
		{
			LONG x;
			LONG y;
		} 	POINT;

		typedef struct tagPOINT* PPOINT;

		typedef struct tagPOINT* LPPOINT;

		typedef struct _POINTL
		{
			LONG x;
			LONG y;
		} 	POINTL;

		typedef struct _POINTL* PPOINTL;

#ifndef WIN16
		typedef struct tagSIZE
		{
			LONG cx;
			LONG cy;
		} 	SIZE;

		typedef struct tagSIZE* PSIZE;

		typedef struct tagSIZE* LPSIZE;

#else // WIN16
		typedef struct tagSIZE
		{
			INT cx;
			INT cy;
		} SIZE, * PSIZE, * LPSIZE;
#endif // WIN16
		typedef struct tagSIZEL
		{
			LONG cx;
			LONG cy;
		} 	SIZEL;

		typedef struct tagSIZEL* PSIZEL;

		typedef struct tagSIZEL* LPSIZEL;

#endif  //WINAPI
#endif  //!WIN32 && !MPPC
#ifndef _PALETTEENTRY_DEFINED
#define _PALETTEENTRY_DEFINED
		typedef struct tagPALETTEENTRY
		{
			BYTE peRed;
			BYTE peGreen;
			BYTE peBlue;
			BYTE peFlags;
		} 	PALETTEENTRY;

		typedef struct tagPALETTEENTRY* PPALETTEENTRY;

		typedef struct tagPALETTEENTRY* LPPALETTEENTRY;

#endif // !_PALETTEENTRY_DEFINED
#ifndef _LOGPALETTE_DEFINED
#define _LOGPALETTE_DEFINED
		typedef struct tagLOGPALETTE
		{
			WORD palVersion;
			WORD palNumEntries;
			/* [size_is] */ PALETTEENTRY palPalEntry[1];
		} 	LOGPALETTE;

		typedef struct tagLOGPALETTE* PLOGPALETTE;

		typedef struct tagLOGPALETTE* LPLOGPALETTE;

#endif // !_LOGPALETTE_DEFINED
#if defined(_WIN32) && !defined(OLE2ANSI)
		typedef WCHAR OLECHAR;

		typedef /* [string] */ OLECHAR* LPOLESTR;

		typedef /* [string] */ const OLECHAR* LPCOLESTR;

#define OLESTR(str) L##str

#else

		typedef char      OLECHAR;
		typedef LPSTR     LPOLESTR;
		typedef LPCSTR    LPCOLESTR;
#define OLESTR(str) str
#endif
#ifndef _WINDEF_
		typedef const RECTL* LPCRECTL;

		typedef void* PVOID;

		typedef void* LPVOID;

		typedef float FLOAT;

		typedef struct tagRECT
		{
			LONG left;
			LONG top;
			LONG right;
			LONG bottom;
		} 	RECT;

		typedef struct tagRECT* PRECT;

		typedef struct tagRECT* LPRECT;

		typedef const RECT* LPCRECT;

#endif  //_WINDEF_
		typedef unsigned char UCHAR;

		typedef short SHORT;

		typedef unsigned short USHORT;

		typedef DWORD ULONG;

		typedef double DOUBLE;

#ifndef _DWORDLONG_
		typedef unsigned __int64 DWORDLONG;

		typedef DWORDLONG* PDWORDLONG;

#endif // !_DWORDLONG_
#ifndef _ULONGLONG_
		typedef __int64 LONGLONG;

		typedef unsigned __int64 ULONGLONG;

		typedef LONGLONG* PLONGLONG;

		typedef ULONGLONG* PULONGLONG;

#endif // _ULONGLONG_
#if 0
		typedef struct _LARGE_INTEGER
		{
			LONGLONG QuadPart;
		} 	LARGE_INTEGER;

		typedef LARGE_INTEGER* PLARGE_INTEGER;

		typedef struct _ULARGE_INTEGER
		{
			ULONGLONG QuadPart;
		} 	ULARGE_INTEGER;

#endif // 0
#ifndef _WINBASE_
#ifndef _FILETIME_
#define _FILETIME_
		typedef struct _FILETIME
		{
			DWORD dwLowDateTime;
			DWORD dwHighDateTime;
		} 	FILETIME;

		typedef struct _FILETIME* PFILETIME;

		typedef struct _FILETIME* LPFILETIME;

#endif // !_FILETIME
#ifndef _SYSTEMTIME_
#define _SYSTEMTIME_
		typedef struct _SYSTEMTIME
		{
			WORD wYear;
			WORD wMonth;
			WORD wDayOfWeek;
			WORD wDay;
			WORD wHour;
			WORD wMinute;
			WORD wSecond;
			WORD wMilliseconds;
		} 	SYSTEMTIME;

		typedef struct _SYSTEMTIME* PSYSTEMTIME;

		typedef struct _SYSTEMTIME* LPSYSTEMTIME;

#endif // !_SYSTEMTIME
#ifndef _SECURITY_ATTRIBUTES_
#define _SECURITY_ATTRIBUTES_
		typedef struct _SECURITY_ATTRIBUTES
		{
			DWORD nLength;
			/* [size_is] */ LPVOID lpSecurityDescriptor;
			BOOL bInheritHandle;
		} 	SECURITY_ATTRIBUTES;

		typedef struct _SECURITY_ATTRIBUTES* PSECURITY_ATTRIBUTES;

		typedef struct _SECURITY_ATTRIBUTES* LPSECURITY_ATTRIBUTES;

#endif // !_SECURITY_ATTRIBUTES_
#ifndef SECURITY_DESCRIPTOR_REVISION
		typedef USHORT SECURITY_DESCRIPTOR_CONTROL;

		typedef USHORT* PSECURITY_DESCRIPTOR_CONTROL;

		typedef PVOID PSID;

		typedef struct _ACL
		{
			UCHAR AclRevision;
			UCHAR Sbz1;
			USHORT AclSize;
			USHORT AceCount;
			USHORT Sbz2;
		} 	ACL;

		typedef ACL* PACL;

		typedef struct _SECURITY_DESCRIPTOR
		{
			UCHAR Revision;
			UCHAR Sbz1;
			SECURITY_DESCRIPTOR_CONTROL Control;
			PSID Owner;
			PSID Group;
			PACL Sacl;
			PACL Dacl;
		} 	SECURITY_DESCRIPTOR;

		typedef struct _SECURITY_DESCRIPTOR* PISECURITY_DESCRIPTOR;

#endif // !SECURITY_DESCRIPTOR_REVISION
#endif //_WINBASE_
		typedef struct _COAUTHIDENTITY
		{
			/* [size_is] */ USHORT* User;
			ULONG UserLength;
			/* [size_is] */ USHORT* Domain;
			ULONG DomainLength;
			/* [size_is] */ USHORT* Password;
			ULONG PasswordLength;
			ULONG Flags;
		} 	COAUTHIDENTITY;

		typedef struct _COAUTHINFO
		{
			DWORD dwAuthnSvc;
			DWORD dwAuthzSvc;
			LPWSTR pwszServerPrincName;
			DWORD dwAuthnLevel;
			DWORD dwImpersonationLevel;
			COAUTHIDENTITY* pAuthIdentityData;
			DWORD dwCapabilities;
		} 	COAUTHINFO;

		typedef LONG SCODE;

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
		typedef LONG HRESULT;

#endif // !_HRESULT_DEFINED
		typedef SCODE* PSCODE;

#ifndef __OBJECTID_DEFINED
#define __OBJECTID_DEFINED
#define _OBJECTID_DEFINED
		typedef struct _OBJECTID
		{
			GUID Lineage;
			unsigned long Uniquifier;
		} 	OBJECTID;

#endif // !_OBJECTID_DEFINED
#if 0
		typedef GUID* REFGUID;

		typedef IID* REFIID;

		typedef CLSID* REFCLSID;

		typedef FMTID* REFFMTID;

#endif // 0
		typedef
			enum tagMEMCTX
		{
			MEMCTX_TASK = 1,
			MEMCTX_SHARED = 2,
			MEMCTX_MACSYSTEM = 3,
			MEMCTX_UNKNOWN = -1,
			MEMCTX_SAME = -2
		} 	MEMCTX;

#ifndef _ROTFLAGS_DEFINED
#define _ROTFLAGS_DEFINED
#define ROTFLAGS_REGISTRATIONKEEPSALIVE 0x1
#define ROTFLAGS_ALLOWANYCLIENT 0x2
#endif // !_ROTFLAGS_DEFINED
#ifndef _ROT_COMPARE_MAX_DEFINED
#define _ROT_COMPARE_MAX_DEFINED
#define ROT_COMPARE_MAX 2048
#endif // !_ROT_COMPARE_MAX_DEFINED
		typedef
			enum tagCLSCTX
		{
			CLSCTX_INPROC_SERVER = 0x1,
			CLSCTX_INPROC_HANDLER = 0x2,
			CLSCTX_LOCAL_SERVER = 0x4,
			CLSCTX_INPROC_SERVER16 = 0x8,
			CLSCTX_REMOTE_SERVER = 0x10,
			CLSCTX_INPROC_HANDLER16 = 0x20,
			CLSCTX_RESERVED1 = 0x40,
			CLSCTX_RESERVED2 = 0x80,
			CLSCTX_RESERVED3 = 0x100,
			CLSCTX_RESERVED4 = 0x200,
			CLSCTX_NO_CODE_DOWNLOAD = 0x400,
			CLSCTX_RESERVED5 = 0x800,
			CLSCTX_NO_CUSTOM_MARSHAL = 0x1000,
			CLSCTX_ENABLE_CODE_DOWNLOAD = 0x2000,
			CLSCTX_NO_FAILURE_LOG = 0x4000,
			CLSCTX_DISABLE_AAA = 0x8000,
			CLSCTX_ENABLE_AAA = 0x10000,
			CLSCTX_FROM_DEFAULT_CONTEXT = 0x20000
		} 	CLSCTX;

		typedef
			enum tagMSHLFLAGS
		{
			MSHLFLAGS_NORMAL = 0,
			MSHLFLAGS_TABLESTRONG = 1,
			MSHLFLAGS_TABLEWEAK = 2,
			MSHLFLAGS_NOPING = 4,
			MSHLFLAGS_RESERVED1 = 8,
			MSHLFLAGS_RESERVED2 = 16,
			MSHLFLAGS_RESERVED3 = 32,
			MSHLFLAGS_RESERVED4 = 64
		} 	MSHLFLAGS;

		typedef
			enum tagMSHCTX
		{
			MSHCTX_LOCAL = 0,
			MSHCTX_NOSHAREDMEM = 1,
			MSHCTX_DIFFERENTMACHINE = 2,
			MSHCTX_INPROC = 3,
			MSHCTX_CROSSCTX = 4
		} 	MSHCTX;

		typedef
			enum tagDVASPECT
		{
			DVASPECT_CONTENT = 1,
			DVASPECT_THUMBNAIL = 2,
			DVASPECT_ICON = 4,
			DVASPECT_DOCPRINT = 8
		} 	DVASPECT;

		typedef
			enum tagSTGC
		{
			STGC_DEFAULT = 0,
			STGC_OVERWRITE = 1,
			STGC_ONLYIFCURRENT = 2,
			STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = 4,
			STGC_CONSOLIDATE = 8
		} 	STGC;

		typedef
			enum tagSTGMOVE
		{
			STGMOVE_MOVE = 0,
			STGMOVE_COPY = 1,
			STGMOVE_SHALLOWCOPY = 2
		} 	STGMOVE;

		typedef
			enum tagSTATFLAG
		{
			STATFLAG_DEFAULT = 0,
			STATFLAG_NONAME = 1,
			STATFLAG_NOOPEN = 2
		} 	STATFLAG;

		typedef /* [context_handle] */ void* HCONTEXT;

#ifndef _LCID_DEFINED
#define _LCID_DEFINED
		typedef DWORD LCID;

#endif // !_LCID_DEFINED
#ifndef _LANGID_DEFINED
#define _LANGID_DEFINED
		typedef USHORT LANGID;

#endif // !_LANGID_DEFINED
		typedef struct _BYTE_BLOB
		{
			unsigned long clSize;
			/* [size_is] */ byte abData[1];
		} 	BYTE_BLOB;

		typedef /* [unique] */ BYTE_BLOB* UP_BYTE_BLOB;

		typedef struct _WORD_BLOB
		{
			unsigned long clSize;
			/* [size_is] */ unsigned short asData[1];
		} 	WORD_BLOB;

		typedef /* [unique] */ WORD_BLOB* UP_WORD_BLOB;

		typedef struct _DWORD_BLOB
		{
			unsigned long clSize;
			/* [size_is] */ unsigned long alData[1];
		} 	DWORD_BLOB;

		typedef /* [unique] */ DWORD_BLOB* UP_DWORD_BLOB;

		typedef struct _FLAGGED_BYTE_BLOB
		{
			unsigned long fFlags;
			unsigned long clSize;
			/* [size_is] */ byte abData[1];
		} 	FLAGGED_BYTE_BLOB;

		typedef /* [unique] */ FLAGGED_BYTE_BLOB* UP_FLAGGED_BYTE_BLOB;

		typedef struct _FLAGGED_WORD_BLOB
		{
			unsigned long fFlags;
			unsigned long clSize;
			/* [size_is] */ unsigned short asData[1];
		} 	FLAGGED_WORD_BLOB;

		typedef /* [unique] */ FLAGGED_WORD_BLOB* UP_FLAGGED_WORD_BLOB;

		typedef struct _BYTE_SIZEDARR
		{
			unsigned long clSize;
			/* [size_is] */ byte* pData;
		} 	BYTE_SIZEDARR;

		typedef struct _SHORT_SIZEDARR
		{
			unsigned long clSize;
			/* [size_is] */ unsigned short* pData;
		} 	WORD_SIZEDARR;

		typedef struct _LONG_SIZEDARR
		{
			unsigned long clSize;
			/* [size_is] */ unsigned long* pData;
		} 	DWORD_SIZEDARR;

		typedef struct _HYPER_SIZEDARR
		{
			unsigned long clSize;
			/* [size_is] */ hyper* pData;
		} 	HYPER_SIZEDARR;

#define	WDT_INPROC_CALL	( 0x48746457 )

#define	WDT_REMOTE_CALL	( 0x52746457 )

#define	WDT_INPROC64_CALL	( 0x50746457 )

		typedef struct _userCLIPFORMAT
		{
			long fContext;
			/* [switch_is] */ /* [switch_type] */ union __MIDL_IWinTypes_0001
			{
				/* [case()] */ DWORD dwValue;
				/* [case()][string] */ wchar_t* pwszName;
			} 	u;
		} 	userCLIPFORMAT;

		typedef /* [unique] */ userCLIPFORMAT* wireCLIPFORMAT;

		typedef /* [wire_marshal] */ WORD CLIPFORMAT;

		typedef struct _GDI_NONREMOTE
		{
			long fContext;
			/* [switch_is] */ /* [switch_type] */ union __MIDL_IWinTypes_0002
			{
				/* [case()] */ long hInproc;
				/* [case()] */ DWORD_BLOB* hRemote;
			} 	u;
		} 	GDI_NONREMOTE;

		typedef struct _userHGLOBAL
		{
			long fContext;
			/* [switch_is] */ /* [switch_type] */ union __MIDL_IWinTypes_0003
			{
				/* [case()] */ long hInproc;
				/* [case()] */ FLAGGED_BYTE_BLOB* hRemote;
				/* [case()] */ __int64 hInproc64;
			} 	u;
		} 	userHGLOBAL;

		typedef /* [unique] */ userHGLOBAL* wireHGLOBAL;

		typedef struct _userHMETAFILE
		{
			long fContext;
			/* [switch_is] */ /* [switch_type] */ union __MIDL_IWinTypes_0004
			{
				/* [case()] */ long hInproc;
				/* [case()] */ BYTE_BLOB* hRemote;
				/* [case()] */ __int64 hInproc64;
			} 	u;
		} 	userHMETAFILE;

		typedef struct _remoteMETAFILEPICT
		{
			long mm;
			long xExt;
			long yExt;
			userHMETAFILE* hMF;
		} 	remoteMETAFILEPICT;

		typedef struct _userHMETAFILEPICT
		{
			long fContext;
			/* [switch_is] */ /* [switch_type] */ union __MIDL_IWinTypes_0005
			{
				/* [case()] */ long hInproc;
				/* [case()] */ remoteMETAFILEPICT* hRemote;
				/* [case()] */ __int64 hInproc64;
			} 	u;
		} 	userHMETAFILEPICT;

		typedef struct _userHENHMETAFILE
		{
			long fContext;
			/* [switch_is] */ /* [switch_type] */ union __MIDL_IWinTypes_0006
			{
				/* [case()] */ long hInproc;
				/* [case()] */ BYTE_BLOB* hRemote;
				/* [case()] */ __int64 hInproc64;
			} 	u;
		} 	userHENHMETAFILE;

		typedef struct _userBITMAP
		{
			LONG bmType;
			LONG bmWidth;
			LONG bmHeight;
			LONG bmWidthBytes;
			WORD bmPlanes;
			WORD bmBitsPixel;
			ULONG cbSize;
			/* [size_is] */ byte pBuffer[1];
		} 	userBITMAP;

		typedef struct _userHBITMAP
		{
			long fContext;
			/* [switch_is] */ /* [switch_type] */ union __MIDL_IWinTypes_0007
			{
				/* [case()] */ long hInproc;
				/* [case()] */ userBITMAP* hRemote;
				/* [case()] */ __int64 hInproc64;
			} 	u;
		} 	userHBITMAP;

		typedef struct _userHPALETTE
		{
			long fContext;
			/* [switch_is] */ /* [switch_type] */ union __MIDL_IWinTypes_0008
			{
				/* [case()] */ long hInproc;
				/* [case()] */ LOGPALETTE* hRemote;
				/* [case()] */ __int64 hInproc64;
			} 	u;
		} 	userHPALETTE;

		typedef struct _RemotableHandle
		{
			long fContext;
			/* [switch_is] */ /* [switch_type] */ union __MIDL_IWinTypes_0009
			{
				/* [case()] */ long hInproc;
				/* [case()] */ long hRemote;
			} 	u;
		} 	RemotableHandle;

		typedef /* [unique] */ RemotableHandle* wireHWND;

		typedef /* [unique] */ RemotableHandle* wireHMENU;

		typedef /* [unique] */ RemotableHandle* wireHACCEL;

		typedef /* [unique] */ RemotableHandle* wireHBRUSH;

		typedef /* [unique] */ RemotableHandle* wireHFONT;

		typedef /* [unique] */ RemotableHandle* wireHDC;

		typedef /* [unique] */ RemotableHandle* wireHICON;

#if 0
		typedef /* [wire_marshal] */ void* HWND;

		typedef /* [wire_marshal] */ void* HMENU;

		typedef /* [wire_marshal] */ void* HACCEL;

		typedef /* [wire_marshal] */ void* HBRUSH;

		typedef /* [wire_marshal] */ void* HFONT;

		typedef /* [wire_marshal] */ void* HDC;

		typedef /* [wire_marshal] */ void* HICON;

#ifndef _HCURSOR_DEFINED
#define _HCURSOR_DEFINED
		typedef HICON HCURSOR;

#endif // !_HCURSOR_DEFINED
#endif //0
#ifndef _TEXTMETRIC_DEFINED
#define _TEXTMETRIC_DEFINED
		typedef struct tagTEXTMETRICW
		{
			LONG tmHeight;
			LONG tmAscent;
			LONG tmDescent;
			LONG tmInternalLeading;
			LONG tmExternalLeading;
			LONG tmAveCharWidth;
			LONG tmMaxCharWidth;
			LONG tmWeight;
			LONG tmOverhang;
			LONG tmDigitizedAspectX;
			LONG tmDigitizedAspectY;
			WCHAR tmFirstChar;
			WCHAR tmLastChar;
			WCHAR tmDefaultChar;
			WCHAR tmBreakChar;
			BYTE tmItalic;
			BYTE tmUnderlined;
			BYTE tmStruckOut;
			BYTE tmPitchAndFamily;
			BYTE tmCharSet;
		} 	TEXTMETRICW;

		typedef struct tagTEXTMETRICW* PTEXTMETRICW;

		typedef struct tagTEXTMETRICW* LPTEXTMETRICW;

#endif // !_TEXTMETRIC_DEFINED
#ifndef _WIN32           // The following code is for Win16 only
#ifndef WINAPI          // If not included with 3.1 headers...
		typedef struct tagMSG
		{
			HWND hwnd;
			UINT message;
			WPARAM wParam;
			LPARAM lParam;
			DWORD time;
			POINT pt;
		} 	MSG;

		typedef struct tagMSG* PMSG;

		typedef struct tagMSG* NPMSG;

		typedef struct tagMSG* LPMSG;

#endif // _WIN32
#endif // WINAPI
		typedef /* [unique] */ userHBITMAP* wireHBITMAP;

		typedef /* [unique] */ userHPALETTE* wireHPALETTE;

		typedef /* [unique] */ userHENHMETAFILE* wireHENHMETAFILE;

		typedef /* [unique] */ userHMETAFILE* wireHMETAFILE;

		typedef /* [unique] */ userHMETAFILEPICT* wireHMETAFILEPICT;

#if 0
		typedef /* [wire_marshal] */ void* HGLOBAL;

		typedef HGLOBAL HLOCAL;

		typedef /* [wire_marshal] */ void* HBITMAP;

		typedef /* [wire_marshal] */ void* HPALETTE;

		typedef /* [wire_marshal] */ void* HENHMETAFILE;

		typedef /* [wire_marshal] */ void* HMETAFILE;

#endif //0
		typedef /* [wire_marshal] */ void* HMETAFILEPICT;



		extern RPC_IF_HANDLE IWinTypes_v0_1_c_ifspec;
		extern RPC_IF_HANDLE IWinTypes_v0_1_s_ifspec;
#endif /* __IWinTypes_INTERFACE_DEFINED__ */

		/* interface __MIDL_itf_wtypes_0003 */
		/* [local] */

#if ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)
#endif
		typedef double DATE;

#ifndef _tagCY_DEFINED
#define _tagCY_DEFINED
#define _CY_DEFINED
#if 0
		/* the following isn't the real definition of CY, but it is */
		/* what RPC knows how to remote */
		typedef struct tagCY
		{
			LONGLONG int64;
		} 	CY;

#else /* 0 */
		/* real definition that makes the C++ compiler happy */
		typedef union tagCY {
			struct {
#ifdef _MAC
				long      Hi;
				long Lo;
#else
				unsigned long Lo;
				long      Hi;
#endif
			};
			LONGLONG int64;
		} CY;
#endif /* 0 */
#endif /* _tagCY_DEFINED */
		typedef CY* LPCY;

#if 0 /* _tagDEC_DEFINED */
		/* The following isn't the real definition of Decimal type, */
		/* but it is what RPC knows how to remote */
		typedef struct tagDEC
		{
			USHORT wReserved;
			BYTE scale;
			BYTE sign;
			ULONG Hi32;
			ULONGLONG Lo64;
		} 	DECIMAL;

#else /* _tagDEC_DEFINED */
		/* real definition that makes the C++ compiler happy */
		typedef struct tagDEC {
			USHORT wReserved;
			union {
				struct {
					BYTE scale;
					BYTE sign;
				};
				USHORT signscale;
			};
			ULONG Hi32;
			union {
				struct {
#ifdef _MAC
					ULONG Mid32;
					ULONG Lo32;
#else
					ULONG Lo32;
					ULONG Mid32;
#endif
				};
				ULONGLONG Lo64;
			};
		} DECIMAL;
#define DECIMAL_NEG ((BYTE)0x80)
#define DECIMAL_SETZERO(dec) \
        {(dec).Lo64 = 0; (dec).Hi32 = 0; (dec).signscale = 0;}
#endif /* _tagDEC_DEFINED */
		typedef DECIMAL* LPDECIMAL;

#if ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif
#endif
		typedef /* [unique] */ FLAGGED_WORD_BLOB* wireBSTR;

		typedef /* [wire_marshal] */ OLECHAR* BSTR;

		typedef BSTR* LPBSTR;

		/* 0 == FALSE, -1 == TRUE */
		typedef short VARIANT_BOOL;

#if !__STDC__ && (_MSC_VER <= 1000)
		/* For backward compatibility */
		typedef VARIANT_BOOL _VARIANT_BOOL;

#else
		/* ANSI C/C++ reserve bool as keyword */
#define _VARIANT_BOOL    /##/
#endif
		typedef boolean BOOLEAN;

		/* The BSTRBLOB structure is used by some implementations */
		/* of the IPropertyStorage interface when marshaling BSTRs */
		/* on systems which don't support BSTR marshaling. */
#ifndef _tagBSTRBLOB_DEFINED
#define _tagBSTRBLOB_DEFINED
		typedef struct tagBSTRBLOB
		{
			ULONG cbSize;
			/* [size_is] */ BYTE* pData;
		} 	BSTRBLOB;

		typedef struct tagBSTRBLOB* LPBSTRBLOB;

#endif
#define VARIANT_TRUE ((VARIANT_BOOL)-1)
#define VARIANT_FALSE ((VARIANT_BOOL)0)
#ifndef _tagBLOB_DEFINED
#define _tagBLOB_DEFINED
#define _BLOB_DEFINED
#define _LPBLOB_DEFINED
		typedef struct tagBLOB
		{
			ULONG cbSize;
			/* [size_is] */ BYTE* pBlobData;
		} 	BLOB;

		typedef struct tagBLOB* LPBLOB;

#endif
		typedef struct tagCLIPDATA
		{
			ULONG cbSize;
			long ulClipFmt;
			/* [size_is] */ BYTE* pClipData;
		} 	CLIPDATA;

		// Macro to calculate the size of the above pClipData
#define CBPCLIPDATA(clipdata)    ( (clipdata).cbSize - sizeof((clipdata).ulClipFmt) )
		typedef unsigned short VARTYPE;

		/*
		 * VARENUM usage key,
		 *
		 * * [V] - may appear in a VARIANT
		 * * [T] - may appear in a TYPEDESC
		 * * [P] - may appear in an OLE property set
		 * * [S] - may appear in a Safe Array
		 *
		 *
		 *  VT_EMPTY            [V]   [P]     nothing
		 *  VT_NULL             [V]   [P]     SQL style Null
		 *  VT_I2               [V][T][P][S]  2 byte signed int
		 *  VT_I4               [V][T][P][S]  4 byte signed int
		 *  VT_R4               [V][T][P][S]  4 byte real
		 *  VT_R8               [V][T][P][S]  8 byte real
		 *  VT_CY               [V][T][P][S]  currency
		 *  VT_DATE             [V][T][P][S]  date
		 *  VT_BSTR             [V][T][P][S]  OLE Automation string
		 *  VT_DISPATCH         [V][T]   [S]  IDispatch *
		 *  VT_ERROR            [V][T][P][S]  SCODE
		 *  VT_BOOL             [V][T][P][S]  True=-1, False=0
		 *  VT_VARIANT          [V][T][P][S]  VARIANT *
		 *  VT_UNKNOWN          [V][T]   [S]  IUnknown *
		 *  VT_DECIMAL          [V][T]   [S]  16 byte fixed point
		 *  VT_RECORD           [V]   [P][S]  user defined type
		 *  VT_I1               [V][T][P][s]  signed char
		 *  VT_UI1              [V][T][P][S]  unsigned char
		 *  VT_UI2              [V][T][P][S]  unsigned short
		 *  VT_UI4              [V][T][P][S]  unsigned long
		 *  VT_I8                  [T][P]     signed 64-bit int
		 *  VT_UI8                 [T][P]     unsigned 64-bit int
		 *  VT_INT              [V][T][P][S]  signed machine int
		 *  VT_UINT             [V][T]   [S]  unsigned machine int
		 *  VT_INT_PTR             [T]        signed machine register size width
		 *  VT_UINT_PTR            [T]        unsigned machine register size width
		 *  VT_VOID                [T]        C style void
		 *  VT_HRESULT             [T]        Standard return type
		 *  VT_PTR                 [T]        pointer type
		 *  VT_SAFEARRAY           [T]        (use VT_ARRAY in VARIANT)
		 *  VT_CARRAY              [T]        C style array
		 *  VT_USERDEFINED         [T]        user defined type
		 *  VT_LPSTR               [T][P]     null terminated string
		 *  VT_LPWSTR              [T][P]     wide null terminated string
		 *  VT_FILETIME               [P]     FILETIME
		 *  VT_BLOB                   [P]     Length prefixed bytes
		 *  VT_STREAM                 [P]     Name of the stream follows
		 *  VT_STORAGE                [P]     Name of the storage follows
		 *  VT_STREAMED_OBJECT        [P]     Stream contains an object
		 *  VT_STORED_OBJECT          [P]     Storage contains an object
		 *  VT_VERSIONED_STREAM       [P]     Stream with a GUID version
		 *  VT_BLOB_OBJECT            [P]     Blob contains an object
		 *  VT_CF                     [P]     Clipboard format
		 *  VT_CLSID                  [P]     A Class ID
		 *  VT_VECTOR                 [P]     simple counted array
		 *  VT_ARRAY            [V]           SAFEARRAY*
		 *  VT_BYREF            [V]           void* for local use
		 *  VT_BSTR_BLOB                      Reserved for system use
		 */

		enum VARENUM
		{
			VT_EMPTY = 0,
			VT_NULL = 1,
			VT_I2 = 2,
			VT_I4 = 3,
			VT_R4 = 4,
			VT_R8 = 5,
			VT_CY = 6,
			VT_DATE = 7,
			VT_BSTR = 8,
			VT_DISPATCH = 9,
			VT_ERROR = 10,
			VT_BOOL = 11,
			VT_VARIANT = 12,
			VT_UNKNOWN = 13,
			VT_DECIMAL = 14,
			VT_I1 = 16,
			VT_UI1 = 17,
			VT_UI2 = 18,
			VT_UI4 = 19,
			VT_I8 = 20,
			VT_UI8 = 21,
			VT_INT = 22,
			VT_UINT = 23,
			VT_VOID = 24,
			VT_HRESULT = 25,
			VT_PTR = 26,
			VT_SAFEARRAY = 27,
			VT_CARRAY = 28,
			VT_USERDEFINED = 29,
			VT_LPSTR = 30,
			VT_LPWSTR = 31,
			VT_RECORD = 36,
			VT_INT_PTR = 37,
			VT_UINT_PTR = 38,
			VT_FILETIME = 64,
			VT_BLOB = 65,
			VT_STREAM = 66,
			VT_STORAGE = 67,
			VT_STREAMED_OBJECT = 68,
			VT_STORED_OBJECT = 69,
			VT_BLOB_OBJECT = 70,
			VT_CF = 71,
			VT_CLSID = 72,
			VT_VERSIONED_STREAM = 73,
			VT_BSTR_BLOB = 0xfff,
			VT_VECTOR = 0x1000,
			VT_ARRAY = 0x2000,
			VT_BYREF = 0x4000,
			VT_RESERVED = 0x8000,
			VT_ILLEGAL = 0xffff,
			VT_ILLEGALMASKED = 0xfff,
			VT_TYPEMASK = 0xfff
		};
		typedef ULONG PROPID;

#ifndef SID_IDENTIFIER_AUTHORITY_DEFINED
#define SID_IDENTIFIER_AUTHORITY_DEFINED
		typedef struct _SID_IDENTIFIER_AUTHORITY
		{
			UCHAR Value[6];
		} 	SID_IDENTIFIER_AUTHORITY;

		typedef struct _SID_IDENTIFIER_AUTHORITY* PSID_IDENTIFIER_AUTHORITY;

#endif
#ifndef SID_DEFINED
#define SID_DEFINED
		typedef struct _SID
		{
			BYTE Revision;
			BYTE SubAuthorityCount;
			SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
			/* [size_is] */ ULONG SubAuthority[1];
		} 	SID;

		typedef struct _SID* PISID;

		typedef struct _SID_AND_ATTRIBUTES
		{
			SID* Sid;
			DWORD Attributes;
		} 	SID_AND_ATTRIBUTES;

		typedef struct _SID_AND_ATTRIBUTES* PSID_AND_ATTRIBUTES;

#endif
		typedef struct tagCSPLATFORM
		{
			DWORD dwPlatformId;
			DWORD dwVersionHi;
			DWORD dwVersionLo;
			DWORD dwProcessorArch;
		} 	CSPLATFORM;

		typedef struct tagQUERYCONTEXT
		{
			DWORD dwContext;
			CSPLATFORM Platform;
			LCID Locale;
			DWORD dwVersionHi;
			DWORD dwVersionLo;
		} 	QUERYCONTEXT;

		typedef /* [v1_enum] */
			enum tagTYSPEC
		{
			TYSPEC_CLSID = 0,
			TYSPEC_FILEEXT = TYSPEC_CLSID + 1,
			TYSPEC_MIMETYPE = TYSPEC_FILEEXT + 1,
			TYSPEC_FILENAME = TYSPEC_MIMETYPE + 1,
			TYSPEC_PROGID = TYSPEC_FILENAME + 1,
			TYSPEC_PACKAGENAME = TYSPEC_PROGID + 1,
			TYSPEC_OBJECTID = TYSPEC_PACKAGENAME + 1
		} 	TYSPEC;

		typedef /* [public] */ struct __MIDL___MIDL_itf_wtypes_0003_0001
		{
			DWORD tyspec;
			/* [switch_is] */ /* [switch_type] */ union __MIDL___MIDL_itf_wtypes_0003_0005
			{
				/* [case()] */ CLSID clsid;
				/* [case()] */ LPOLESTR pFileExt;
				/* [case()] */ LPOLESTR pMimeType;
				/* [case()] */ LPOLESTR pProgId;
				/* [case()] */ LPOLESTR pFileName;
				/* [case()] */ struct
				{
					LPOLESTR pPackageName;
					GUID PolicyId;
				} 	ByName;
				/* [case()] */ struct
				{
					GUID ObjectId;
					GUID PolicyId;
				} 	ByObjectId;
			} 	tagged_union;
		} 	uCLSSPEC;



		extern RPC_IF_HANDLE __MIDL_itf_wtypes_0003_v0_0_c_ifspec;
		extern RPC_IF_HANDLE __MIDL_itf_wtypes_0003_v0_0_s_ifspec;

		/* Additional Prototypes for ALL interfaces */

		/* end of Additional Prototypes */

#ifdef __cplusplus
	}
#endif

#endif


	// DOINC popped back into header 'unknwn.h'

#ifdef __cplusplus
	extern "C" {
#endif 

		void* __RPC_USER MIDL_user_allocate(size_t);
		void __RPC_USER MIDL_user_free(void*);

		/* interface __MIDL_itf_unknwn_0000 */
		/* [local] */

		//+-------------------------------------------------------------------------
		//
		//  Microsoft Windows
		//  Copyright (c) Microsoft Corporation. All rights reserved.
		//
		//--------------------------------------------------------------------------
#if ( _MSC_VER >= 1020 )
#pragma once
#endif


		extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_v0_0_c_ifspec;
		extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_v0_0_s_ifspec;

#ifndef __IUnknown_INTERFACE_DEFINED__
#define __IUnknown_INTERFACE_DEFINED__

		/* interface IUnknown */
		/* [unique][uuid][object][local] */

		typedef /* [unique] */ IUnknown* LPUNKNOWN;

		//////////////////////////////////////////////////////////////////
		// IID_IUnknown and all other system IIDs are provided in UUID.LIB
		// Link that library in with your proxies, clients and servers
		//////////////////////////////////////////////////////////////////

#if (_MSC_VER >= 1100) && defined(__cplusplus) && !defined(CINTERFACE)
		EXTERN_C const IID IID_IUnknown;
		extern "C++"
		{
			MIDL_INTERFACE("00000000-0000-0000-C000-000000000046")
				IUnknown
			{
			public:
				BEGIN_INTERFACE
					virtual HRESULT STDMETHODCALLTYPE QueryInterface(
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void __RPC_FAR * __RPC_FAR * ppvObject) = 0;

				virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;

				virtual ULONG STDMETHODCALLTYPE Release(void) = 0;

				template<class Q>
				HRESULT STDMETHODCALLTYPE QueryInterface(Q * *pp)
				{
					return QueryInterface(__uuidof(Q), (void**)pp);
				}

				END_INTERFACE
			};
		} // extern C++
		HRESULT STDMETHODCALLTYPE IUnknown_QueryInterface_Proxy(
			IUnknown __RPC_FAR* This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void __RPC_FAR* __RPC_FAR* ppvObject);

		void __RPC_STUB IUnknown_QueryInterface_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);

		ULONG STDMETHODCALLTYPE IUnknown_AddRef_Proxy(
			IUnknown __RPC_FAR* This);

		void __RPC_STUB IUnknown_AddRef_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);

		ULONG STDMETHODCALLTYPE IUnknown_Release_Proxy(
			IUnknown __RPC_FAR* This);

		void __RPC_STUB IUnknown_Release_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);
#else

		EXTERN_C const IID IID_IUnknown;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000000-0000-0000-C000-000000000046")
			IUnknown
		{
		public:
			BEGIN_INTERFACE
				virtual HRESULT STDMETHODCALLTYPE QueryInterface(
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject) = 0;

			virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;

			virtual ULONG STDMETHODCALLTYPE Release(void) = 0;

			END_INTERFACE
		};

#else 	/* C style interface */

		typedef struct IUnknownVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IUnknown* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IUnknown* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IUnknown* This);

			END_INTERFACE
		} IUnknownVtbl;

		interface IUnknown
		{
			CONST_VTBL struct IUnknownVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IUnknown_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUnknown_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUnknown_Release(This)	\
    (This)->lpVtbl -> Release(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IUnknown_QueryInterface_Proxy(
			IUnknown* This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void** ppvObject);


		void __RPC_STUB IUnknown_QueryInterface_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		ULONG STDMETHODCALLTYPE IUnknown_AddRef_Proxy(
			IUnknown* This);


		void __RPC_STUB IUnknown_AddRef_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		ULONG STDMETHODCALLTYPE IUnknown_Release_Proxy(
			IUnknown* This);


		void __RPC_STUB IUnknown_Release_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IUnknown_INTERFACE_DEFINED__ */


		/* interface __MIDL_itf_unknwn_0005 */
		/* [local] */

#endif


		extern RPC_IF_HANDLE __MIDL_itf_unknwn_0005_v0_0_c_ifspec;
		extern RPC_IF_HANDLE __MIDL_itf_unknwn_0005_v0_0_s_ifspec;

#ifndef __AsyncIUnknown_INTERFACE_DEFINED__
#define __AsyncIUnknown_INTERFACE_DEFINED__

		/* interface AsyncIUnknown */
		/* [unique][uuid][object][local] */


		EXTERN_C const IID IID_AsyncIUnknown;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("000e0000-0000-0000-C000-000000000046")
			AsyncIUnknown : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE Begin_QueryInterface(
				/* [in] */ REFIID riid) = 0;

			virtual HRESULT STDMETHODCALLTYPE Finish_QueryInterface(
				/* [out] */ void** ppvObject) = 0;

			virtual HRESULT STDMETHODCALLTYPE Begin_AddRef(void) = 0;

			virtual ULONG STDMETHODCALLTYPE Finish_AddRef(void) = 0;

			virtual HRESULT STDMETHODCALLTYPE Begin_Release(void) = 0;

			virtual ULONG STDMETHODCALLTYPE Finish_Release(void) = 0;

		};

#else 	/* C style interface */

		typedef struct AsyncIUnknownVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					AsyncIUnknown* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				AsyncIUnknown* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				AsyncIUnknown* This);

			HRESULT(STDMETHODCALLTYPE* Begin_QueryInterface)(
				AsyncIUnknown* This,
				/* [in] */ REFIID riid);

			HRESULT(STDMETHODCALLTYPE* Finish_QueryInterface)(
				AsyncIUnknown* This,
				/* [out] */ void** ppvObject);

			HRESULT(STDMETHODCALLTYPE* Begin_AddRef)(
				AsyncIUnknown* This);

			ULONG(STDMETHODCALLTYPE* Finish_AddRef)(
				AsyncIUnknown* This);

			HRESULT(STDMETHODCALLTYPE* Begin_Release)(
				AsyncIUnknown* This);

			ULONG(STDMETHODCALLTYPE* Finish_Release)(
				AsyncIUnknown* This);

			END_INTERFACE
		} AsyncIUnknownVtbl;

		interface AsyncIUnknown
		{
			CONST_VTBL struct AsyncIUnknownVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define AsyncIUnknown_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define AsyncIUnknown_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define AsyncIUnknown_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define AsyncIUnknown_Begin_QueryInterface(This,riid)	\
    (This)->lpVtbl -> Begin_QueryInterface(This,riid)

#define AsyncIUnknown_Finish_QueryInterface(This,ppvObject)	\
    (This)->lpVtbl -> Finish_QueryInterface(This,ppvObject)

#define AsyncIUnknown_Begin_AddRef(This)	\
    (This)->lpVtbl -> Begin_AddRef(This)

#define AsyncIUnknown_Finish_AddRef(This)	\
    (This)->lpVtbl -> Finish_AddRef(This)

#define AsyncIUnknown_Begin_Release(This)	\
    (This)->lpVtbl -> Begin_Release(This)

#define AsyncIUnknown_Finish_Release(This)	\
    (This)->lpVtbl -> Finish_Release(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE AsyncIUnknown_Begin_QueryInterface_Proxy(
			AsyncIUnknown* This,
			/* [in] */ REFIID riid);


		void __RPC_STUB AsyncIUnknown_Begin_QueryInterface_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE AsyncIUnknown_Finish_QueryInterface_Proxy(
			AsyncIUnknown* This,
			/* [out] */ void** ppvObject);


		void __RPC_STUB AsyncIUnknown_Finish_QueryInterface_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE AsyncIUnknown_Begin_AddRef_Proxy(
			AsyncIUnknown* This);


		void __RPC_STUB AsyncIUnknown_Begin_AddRef_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		ULONG STDMETHODCALLTYPE AsyncIUnknown_Finish_AddRef_Proxy(
			AsyncIUnknown* This);


		void __RPC_STUB AsyncIUnknown_Finish_AddRef_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE AsyncIUnknown_Begin_Release_Proxy(
			AsyncIUnknown* This);


		void __RPC_STUB AsyncIUnknown_Begin_Release_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		ULONG STDMETHODCALLTYPE AsyncIUnknown_Finish_Release_Proxy(
			AsyncIUnknown* This);


		void __RPC_STUB AsyncIUnknown_Finish_Release_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __AsyncIUnknown_INTERFACE_DEFINED__ */


#ifndef __IClassFactory_INTERFACE_DEFINED__
#define __IClassFactory_INTERFACE_DEFINED__

		/* interface IClassFactory */
		/* [unique][uuid][object] */

		typedef /* [unique] */ IClassFactory* LPCLASSFACTORY;


		EXTERN_C const IID IID_IClassFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000001-0000-0000-C000-000000000046")
			IClassFactory : public IUnknown
		{
		public:
			virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateInstance(
				/* [unique][in] */ IUnknown * pUnkOuter,
				/* [in] */ REFIID riid,
				/* [iid_is][out] */ void** ppvObject) = 0;

			virtual /* [local] */ HRESULT STDMETHODCALLTYPE LockServer(
				/* [in] */ BOOL fLock) = 0;

		};

#else 	/* C style interface */

		typedef struct IClassFactoryVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IClassFactory* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IClassFactory* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IClassFactory* This);

			/* [local] */ HRESULT(STDMETHODCALLTYPE* CreateInstance)(
				IClassFactory* This,
				/* [unique][in] */ IUnknown* pUnkOuter,
				/* [in] */ REFIID riid,
				/* [iid_is][out] */ void** ppvObject);

			/* [local] */ HRESULT(STDMETHODCALLTYPE* LockServer)(
				IClassFactory* This,
				/* [in] */ BOOL fLock);

			END_INTERFACE
		} IClassFactoryVtbl;

		interface IClassFactory
		{
			CONST_VTBL struct IClassFactoryVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IClassFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IClassFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IClassFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IClassFactory_CreateInstance(This,pUnkOuter,riid,ppvObject)	\
    (This)->lpVtbl -> CreateInstance(This,pUnkOuter,riid,ppvObject)

#define IClassFactory_LockServer(This,fLock)	\
    (This)->lpVtbl -> LockServer(This,fLock)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		/* [call_as] */ HRESULT STDMETHODCALLTYPE IClassFactory_RemoteCreateInstance_Proxy(
			IClassFactory* This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ IUnknown** ppvObject);


		void __RPC_STUB IClassFactory_RemoteCreateInstance_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		/* [call_as] */ HRESULT __stdcall IClassFactory_RemoteLockServer_Proxy(
			IClassFactory* This,
			/* [in] */ BOOL fLock);


		void __RPC_STUB IClassFactory_RemoteLockServer_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IClassFactory_INTERFACE_DEFINED__ */


		/* Additional Prototypes for ALL interfaces */

		/* [local] */ HRESULT STDMETHODCALLTYPE IClassFactory_CreateInstance_Proxy(
			IClassFactory* This,
			/* [unique][in] */ IUnknown* pUnkOuter,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void** ppvObject);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IClassFactory_CreateInstance_Stub(
			IClassFactory* This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ IUnknown** ppvObject);

		/* [local] */ HRESULT STDMETHODCALLTYPE IClassFactory_LockServer_Proxy(
			IClassFactory* This,
			/* [in] */ BOOL fLock);


		/* [call_as] */ HRESULT __stdcall IClassFactory_LockServer_Stub(
			IClassFactory* This,
			/* [in] */ BOOL fLock);



		/* end of Additional Prototypes */

#ifdef __cplusplus
	}
#endif

#endif


	// DOINC popped back into header 'pbprop.h'
	// ***** DOINC including objidl.h *****


	/* this ALWAYS GENERATED file contains the definitions for the interfaces */


	 /* File created by MIDL compiler version 6.00.0361 */
	/* Compiler settings for objidl.idl:
		Oicf, W1, Zp8, env=Win32 (32b run)
		protocol : dce , ms_ext, c_ext, robust
		error checks: allocation ref bounds_check enum stub_data
		VC __declspec() decoration level:
			 __declspec(uuid()), __declspec(selectany), __declspec(novtable)
			 DECLSPEC_UUID(), MIDL_INTERFACE()
	*/
	//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

// ***** DOINC including rpc.h *****
	// DOINC skipping duplicate include
// ***** DOINC including rpcndr.h *****
	// DOINC skipping duplicate include

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
// ***** DOINC including windows.h *****
	// DOINC skipping duplicate include
// ***** DOINC including ole2.h *****
	// DOINC skipping duplicate include
#endif /*COM_NO_WINDOWS_H*/

#ifndef __objidl_h__
#define __objidl_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */

#ifndef __IMarshal_FWD_DEFINED__
#define __IMarshal_FWD_DEFINED__
	typedef interface IMarshal IMarshal;
#endif 	/* __IMarshal_FWD_DEFINED__ */


#ifndef __IMarshal2_FWD_DEFINED__
#define __IMarshal2_FWD_DEFINED__
	typedef interface IMarshal2 IMarshal2;
#endif 	/* __IMarshal2_FWD_DEFINED__ */


#ifndef __IMalloc_FWD_DEFINED__
#define __IMalloc_FWD_DEFINED__
	typedef interface IMalloc IMalloc;
#endif 	/* __IMalloc_FWD_DEFINED__ */


#ifndef __IMallocSpy_FWD_DEFINED__
#define __IMallocSpy_FWD_DEFINED__
	typedef interface IMallocSpy IMallocSpy;
#endif 	/* __IMallocSpy_FWD_DEFINED__ */


#ifndef __IStdMarshalInfo_FWD_DEFINED__
#define __IStdMarshalInfo_FWD_DEFINED__
	typedef interface IStdMarshalInfo IStdMarshalInfo;
#endif 	/* __IStdMarshalInfo_FWD_DEFINED__ */


#ifndef __IExternalConnection_FWD_DEFINED__
#define __IExternalConnection_FWD_DEFINED__
	typedef interface IExternalConnection IExternalConnection;
#endif 	/* __IExternalConnection_FWD_DEFINED__ */


#ifndef __IMultiQI_FWD_DEFINED__
#define __IMultiQI_FWD_DEFINED__
	typedef interface IMultiQI IMultiQI;
#endif 	/* __IMultiQI_FWD_DEFINED__ */


#ifndef __AsyncIMultiQI_FWD_DEFINED__
#define __AsyncIMultiQI_FWD_DEFINED__
	typedef interface AsyncIMultiQI AsyncIMultiQI;
#endif 	/* __AsyncIMultiQI_FWD_DEFINED__ */


#ifndef __IInternalUnknown_FWD_DEFINED__
#define __IInternalUnknown_FWD_DEFINED__
	typedef interface IInternalUnknown IInternalUnknown;
#endif 	/* __IInternalUnknown_FWD_DEFINED__ */


#ifndef __IEnumUnknown_FWD_DEFINED__
#define __IEnumUnknown_FWD_DEFINED__
	typedef interface IEnumUnknown IEnumUnknown;
#endif 	/* __IEnumUnknown_FWD_DEFINED__ */


#ifndef __IBindCtx_FWD_DEFINED__
#define __IBindCtx_FWD_DEFINED__
	typedef interface IBindCtx IBindCtx;
#endif 	/* __IBindCtx_FWD_DEFINED__ */


#ifndef __IEnumMoniker_FWD_DEFINED__
#define __IEnumMoniker_FWD_DEFINED__
	typedef interface IEnumMoniker IEnumMoniker;
#endif 	/* __IEnumMoniker_FWD_DEFINED__ */


#ifndef __IRunnableObject_FWD_DEFINED__
#define __IRunnableObject_FWD_DEFINED__
	typedef interface IRunnableObject IRunnableObject;
#endif 	/* __IRunnableObject_FWD_DEFINED__ */


#ifndef __IRunningObjectTable_FWD_DEFINED__
#define __IRunningObjectTable_FWD_DEFINED__
	typedef interface IRunningObjectTable IRunningObjectTable;
#endif 	/* __IRunningObjectTable_FWD_DEFINED__ */


#ifndef __IPersist_FWD_DEFINED__
#define __IPersist_FWD_DEFINED__
	typedef interface IPersist IPersist;
#endif 	/* __IPersist_FWD_DEFINED__ */


#ifndef __IPersistStream_FWD_DEFINED__
#define __IPersistStream_FWD_DEFINED__
	typedef interface IPersistStream IPersistStream;
#endif 	/* __IPersistStream_FWD_DEFINED__ */


#ifndef __IMoniker_FWD_DEFINED__
#define __IMoniker_FWD_DEFINED__
	typedef interface IMoniker IMoniker;
#endif 	/* __IMoniker_FWD_DEFINED__ */


#ifndef __IROTData_FWD_DEFINED__
#define __IROTData_FWD_DEFINED__
	typedef interface IROTData IROTData;
#endif 	/* __IROTData_FWD_DEFINED__ */


#ifndef __IEnumString_FWD_DEFINED__
#define __IEnumString_FWD_DEFINED__
	typedef interface IEnumString IEnumString;
#endif 	/* __IEnumString_FWD_DEFINED__ */


#ifndef __ISequentialStream_FWD_DEFINED__
#define __ISequentialStream_FWD_DEFINED__
	typedef interface ISequentialStream ISequentialStream;
#endif 	/* __ISequentialStream_FWD_DEFINED__ */


#ifndef __IStream_FWD_DEFINED__
#define __IStream_FWD_DEFINED__
	typedef interface IStream IStream;
#endif 	/* __IStream_FWD_DEFINED__ */


#ifndef __IEnumSTATSTG_FWD_DEFINED__
#define __IEnumSTATSTG_FWD_DEFINED__
	typedef interface IEnumSTATSTG IEnumSTATSTG;
#endif 	/* __IEnumSTATSTG_FWD_DEFINED__ */


#ifndef __IStorage_FWD_DEFINED__
#define __IStorage_FWD_DEFINED__
	typedef interface IStorage IStorage;
#endif 	/* __IStorage_FWD_DEFINED__ */


#ifndef __IPersistFile_FWD_DEFINED__
#define __IPersistFile_FWD_DEFINED__
	typedef interface IPersistFile IPersistFile;
#endif 	/* __IPersistFile_FWD_DEFINED__ */


#ifndef __IPersistStorage_FWD_DEFINED__
#define __IPersistStorage_FWD_DEFINED__
	typedef interface IPersistStorage IPersistStorage;
#endif 	/* __IPersistStorage_FWD_DEFINED__ */


#ifndef __ILockBytes_FWD_DEFINED__
#define __ILockBytes_FWD_DEFINED__
	typedef interface ILockBytes ILockBytes;
#endif 	/* __ILockBytes_FWD_DEFINED__ */


#ifndef __IEnumFORMATETC_FWD_DEFINED__
#define __IEnumFORMATETC_FWD_DEFINED__
	typedef interface IEnumFORMATETC IEnumFORMATETC;
#endif 	/* __IEnumFORMATETC_FWD_DEFINED__ */


#ifndef __IEnumSTATDATA_FWD_DEFINED__
#define __IEnumSTATDATA_FWD_DEFINED__
	typedef interface IEnumSTATDATA IEnumSTATDATA;
#endif 	/* __IEnumSTATDATA_FWD_DEFINED__ */


#ifndef __IRootStorage_FWD_DEFINED__
#define __IRootStorage_FWD_DEFINED__
	typedef interface IRootStorage IRootStorage;
#endif 	/* __IRootStorage_FWD_DEFINED__ */


#ifndef __IAdviseSink_FWD_DEFINED__
#define __IAdviseSink_FWD_DEFINED__
	typedef interface IAdviseSink IAdviseSink;
#endif 	/* __IAdviseSink_FWD_DEFINED__ */


#ifndef __AsyncIAdviseSink_FWD_DEFINED__
#define __AsyncIAdviseSink_FWD_DEFINED__
	typedef interface AsyncIAdviseSink AsyncIAdviseSink;
#endif 	/* __AsyncIAdviseSink_FWD_DEFINED__ */


#ifndef __IAdviseSink2_FWD_DEFINED__
#define __IAdviseSink2_FWD_DEFINED__
	typedef interface IAdviseSink2 IAdviseSink2;
#endif 	/* __IAdviseSink2_FWD_DEFINED__ */


#ifndef __AsyncIAdviseSink2_FWD_DEFINED__
#define __AsyncIAdviseSink2_FWD_DEFINED__
	typedef interface AsyncIAdviseSink2 AsyncIAdviseSink2;
#endif 	/* __AsyncIAdviseSink2_FWD_DEFINED__ */


#ifndef __IDataObject_FWD_DEFINED__
#define __IDataObject_FWD_DEFINED__
	typedef interface IDataObject IDataObject;
#endif 	/* __IDataObject_FWD_DEFINED__ */


#ifndef __IDataAdviseHolder_FWD_DEFINED__
#define __IDataAdviseHolder_FWD_DEFINED__
	typedef interface IDataAdviseHolder IDataAdviseHolder;
#endif 	/* __IDataAdviseHolder_FWD_DEFINED__ */


#ifndef __IMessageFilter_FWD_DEFINED__
#define __IMessageFilter_FWD_DEFINED__
	typedef interface IMessageFilter IMessageFilter;
#endif 	/* __IMessageFilter_FWD_DEFINED__ */


#ifndef __IRpcChannelBuffer_FWD_DEFINED__
#define __IRpcChannelBuffer_FWD_DEFINED__
	typedef interface IRpcChannelBuffer IRpcChannelBuffer;
#endif 	/* __IRpcChannelBuffer_FWD_DEFINED__ */


#ifndef __IRpcChannelBuffer2_FWD_DEFINED__
#define __IRpcChannelBuffer2_FWD_DEFINED__
	typedef interface IRpcChannelBuffer2 IRpcChannelBuffer2;
#endif 	/* __IRpcChannelBuffer2_FWD_DEFINED__ */


#ifndef __IAsyncRpcChannelBuffer_FWD_DEFINED__
#define __IAsyncRpcChannelBuffer_FWD_DEFINED__
	typedef interface IAsyncRpcChannelBuffer IAsyncRpcChannelBuffer;
#endif 	/* __IAsyncRpcChannelBuffer_FWD_DEFINED__ */


#ifndef __IRpcChannelBuffer3_FWD_DEFINED__
#define __IRpcChannelBuffer3_FWD_DEFINED__
	typedef interface IRpcChannelBuffer3 IRpcChannelBuffer3;
#endif 	/* __IRpcChannelBuffer3_FWD_DEFINED__ */


#ifndef __IRpcSyntaxNegotiate_FWD_DEFINED__
#define __IRpcSyntaxNegotiate_FWD_DEFINED__
	typedef interface IRpcSyntaxNegotiate IRpcSyntaxNegotiate;
#endif 	/* __IRpcSyntaxNegotiate_FWD_DEFINED__ */


#ifndef __IRpcProxyBuffer_FWD_DEFINED__
#define __IRpcProxyBuffer_FWD_DEFINED__
	typedef interface IRpcProxyBuffer IRpcProxyBuffer;
#endif 	/* __IRpcProxyBuffer_FWD_DEFINED__ */


#ifndef __IRpcStubBuffer_FWD_DEFINED__
#define __IRpcStubBuffer_FWD_DEFINED__
	typedef interface IRpcStubBuffer IRpcStubBuffer;
#endif 	/* __IRpcStubBuffer_FWD_DEFINED__ */


#ifndef __IPSFactoryBuffer_FWD_DEFINED__
#define __IPSFactoryBuffer_FWD_DEFINED__
	typedef interface IPSFactoryBuffer IPSFactoryBuffer;
#endif 	/* __IPSFactoryBuffer_FWD_DEFINED__ */


#ifndef __IChannelHook_FWD_DEFINED__
#define __IChannelHook_FWD_DEFINED__
	typedef interface IChannelHook IChannelHook;
#endif 	/* __IChannelHook_FWD_DEFINED__ */


#ifndef __IClientSecurity_FWD_DEFINED__
#define __IClientSecurity_FWD_DEFINED__
	typedef interface IClientSecurity IClientSecurity;
#endif 	/* __IClientSecurity_FWD_DEFINED__ */


#ifndef __IServerSecurity_FWD_DEFINED__
#define __IServerSecurity_FWD_DEFINED__
	typedef interface IServerSecurity IServerSecurity;
#endif 	/* __IServerSecurity_FWD_DEFINED__ */


#ifndef __IClassActivator_FWD_DEFINED__
#define __IClassActivator_FWD_DEFINED__
	typedef interface IClassActivator IClassActivator;
#endif 	/* __IClassActivator_FWD_DEFINED__ */


#ifndef __IRpcOptions_FWD_DEFINED__
#define __IRpcOptions_FWD_DEFINED__
	typedef interface IRpcOptions IRpcOptions;
#endif 	/* __IRpcOptions_FWD_DEFINED__ */


#ifndef __IFillLockBytes_FWD_DEFINED__
#define __IFillLockBytes_FWD_DEFINED__
	typedef interface IFillLockBytes IFillLockBytes;
#endif 	/* __IFillLockBytes_FWD_DEFINED__ */


#ifndef __IProgressNotify_FWD_DEFINED__
#define __IProgressNotify_FWD_DEFINED__
	typedef interface IProgressNotify IProgressNotify;
#endif 	/* __IProgressNotify_FWD_DEFINED__ */


#ifndef __ILayoutStorage_FWD_DEFINED__
#define __ILayoutStorage_FWD_DEFINED__
	typedef interface ILayoutStorage ILayoutStorage;
#endif 	/* __ILayoutStorage_FWD_DEFINED__ */


#ifndef __IBlockingLock_FWD_DEFINED__
#define __IBlockingLock_FWD_DEFINED__
	typedef interface IBlockingLock IBlockingLock;
#endif 	/* __IBlockingLock_FWD_DEFINED__ */


#ifndef __ITimeAndNoticeControl_FWD_DEFINED__
#define __ITimeAndNoticeControl_FWD_DEFINED__
	typedef interface ITimeAndNoticeControl ITimeAndNoticeControl;
#endif 	/* __ITimeAndNoticeControl_FWD_DEFINED__ */


#ifndef __IOplockStorage_FWD_DEFINED__
#define __IOplockStorage_FWD_DEFINED__
	typedef interface IOplockStorage IOplockStorage;
#endif 	/* __IOplockStorage_FWD_DEFINED__ */


#ifndef __ISurrogate_FWD_DEFINED__
#define __ISurrogate_FWD_DEFINED__
	typedef interface ISurrogate ISurrogate;
#endif 	/* __ISurrogate_FWD_DEFINED__ */


#ifndef __IGlobalInterfaceTable_FWD_DEFINED__
#define __IGlobalInterfaceTable_FWD_DEFINED__
	typedef interface IGlobalInterfaceTable IGlobalInterfaceTable;
#endif 	/* __IGlobalInterfaceTable_FWD_DEFINED__ */


#ifndef __IDirectWriterLock_FWD_DEFINED__
#define __IDirectWriterLock_FWD_DEFINED__
	typedef interface IDirectWriterLock IDirectWriterLock;
#endif 	/* __IDirectWriterLock_FWD_DEFINED__ */


#ifndef __ISynchronize_FWD_DEFINED__
#define __ISynchronize_FWD_DEFINED__
	typedef interface ISynchronize ISynchronize;
#endif 	/* __ISynchronize_FWD_DEFINED__ */


#ifndef __ISynchronizeHandle_FWD_DEFINED__
#define __ISynchronizeHandle_FWD_DEFINED__
	typedef interface ISynchronizeHandle ISynchronizeHandle;
#endif 	/* __ISynchronizeHandle_FWD_DEFINED__ */


#ifndef __ISynchronizeEvent_FWD_DEFINED__
#define __ISynchronizeEvent_FWD_DEFINED__
	typedef interface ISynchronizeEvent ISynchronizeEvent;
#endif 	/* __ISynchronizeEvent_FWD_DEFINED__ */


#ifndef __ISynchronizeContainer_FWD_DEFINED__
#define __ISynchronizeContainer_FWD_DEFINED__
	typedef interface ISynchronizeContainer ISynchronizeContainer;
#endif 	/* __ISynchronizeContainer_FWD_DEFINED__ */


#ifndef __ISynchronizeMutex_FWD_DEFINED__
#define __ISynchronizeMutex_FWD_DEFINED__
	typedef interface ISynchronizeMutex ISynchronizeMutex;
#endif 	/* __ISynchronizeMutex_FWD_DEFINED__ */


#ifndef __ICancelMethodCalls_FWD_DEFINED__
#define __ICancelMethodCalls_FWD_DEFINED__
	typedef interface ICancelMethodCalls ICancelMethodCalls;
#endif 	/* __ICancelMethodCalls_FWD_DEFINED__ */


#ifndef __IAsyncManager_FWD_DEFINED__
#define __IAsyncManager_FWD_DEFINED__
	typedef interface IAsyncManager IAsyncManager;
#endif 	/* __IAsyncManager_FWD_DEFINED__ */


#ifndef __ICallFactory_FWD_DEFINED__
#define __ICallFactory_FWD_DEFINED__
	typedef interface ICallFactory ICallFactory;
#endif 	/* __ICallFactory_FWD_DEFINED__ */


#ifndef __IRpcHelper_FWD_DEFINED__
#define __IRpcHelper_FWD_DEFINED__
	typedef interface IRpcHelper IRpcHelper;
#endif 	/* __IRpcHelper_FWD_DEFINED__ */


#ifndef __IReleaseMarshalBuffers_FWD_DEFINED__
#define __IReleaseMarshalBuffers_FWD_DEFINED__
	typedef interface IReleaseMarshalBuffers IReleaseMarshalBuffers;
#endif 	/* __IReleaseMarshalBuffers_FWD_DEFINED__ */


#ifndef __IWaitMultiple_FWD_DEFINED__
#define __IWaitMultiple_FWD_DEFINED__
	typedef interface IWaitMultiple IWaitMultiple;
#endif 	/* __IWaitMultiple_FWD_DEFINED__ */


#ifndef __IUrlMon_FWD_DEFINED__
#define __IUrlMon_FWD_DEFINED__
	typedef interface IUrlMon IUrlMon;
#endif 	/* __IUrlMon_FWD_DEFINED__ */


#ifndef __IForegroundTransfer_FWD_DEFINED__
#define __IForegroundTransfer_FWD_DEFINED__
	typedef interface IForegroundTransfer IForegroundTransfer;
#endif 	/* __IForegroundTransfer_FWD_DEFINED__ */


#ifndef __IAddrTrackingControl_FWD_DEFINED__
#define __IAddrTrackingControl_FWD_DEFINED__
	typedef interface IAddrTrackingControl IAddrTrackingControl;
#endif 	/* __IAddrTrackingControl_FWD_DEFINED__ */


#ifndef __IAddrExclusionControl_FWD_DEFINED__
#define __IAddrExclusionControl_FWD_DEFINED__
	typedef interface IAddrExclusionControl IAddrExclusionControl;
#endif 	/* __IAddrExclusionControl_FWD_DEFINED__ */


#ifndef __IPipeByte_FWD_DEFINED__
#define __IPipeByte_FWD_DEFINED__
	typedef interface IPipeByte IPipeByte;
#endif 	/* __IPipeByte_FWD_DEFINED__ */


#ifndef __AsyncIPipeByte_FWD_DEFINED__
#define __AsyncIPipeByte_FWD_DEFINED__
	typedef interface AsyncIPipeByte AsyncIPipeByte;
#endif 	/* __AsyncIPipeByte_FWD_DEFINED__ */


#ifndef __IPipeLong_FWD_DEFINED__
#define __IPipeLong_FWD_DEFINED__
	typedef interface IPipeLong IPipeLong;
#endif 	/* __IPipeLong_FWD_DEFINED__ */


#ifndef __AsyncIPipeLong_FWD_DEFINED__
#define __AsyncIPipeLong_FWD_DEFINED__
	typedef interface AsyncIPipeLong AsyncIPipeLong;
#endif 	/* __AsyncIPipeLong_FWD_DEFINED__ */


#ifndef __IPipeDouble_FWD_DEFINED__
#define __IPipeDouble_FWD_DEFINED__
	typedef interface IPipeDouble IPipeDouble;
#endif 	/* __IPipeDouble_FWD_DEFINED__ */


#ifndef __AsyncIPipeDouble_FWD_DEFINED__
#define __AsyncIPipeDouble_FWD_DEFINED__
	typedef interface AsyncIPipeDouble AsyncIPipeDouble;
#endif 	/* __AsyncIPipeDouble_FWD_DEFINED__ */


#ifndef __IThumbnailExtractor_FWD_DEFINED__
#define __IThumbnailExtractor_FWD_DEFINED__
	typedef interface IThumbnailExtractor IThumbnailExtractor;
#endif 	/* __IThumbnailExtractor_FWD_DEFINED__ */


#ifndef __IDummyHICONIncluder_FWD_DEFINED__
#define __IDummyHICONIncluder_FWD_DEFINED__
	typedef interface IDummyHICONIncluder IDummyHICONIncluder;
#endif 	/* __IDummyHICONIncluder_FWD_DEFINED__ */


#ifndef __IEnumContextProps_FWD_DEFINED__
#define __IEnumContextProps_FWD_DEFINED__
	typedef interface IEnumContextProps IEnumContextProps;
#endif 	/* __IEnumContextProps_FWD_DEFINED__ */


#ifndef __IContext_FWD_DEFINED__
#define __IContext_FWD_DEFINED__
	typedef interface IContext IContext;
#endif 	/* __IContext_FWD_DEFINED__ */


#ifndef __IObjContext_FWD_DEFINED__
#define __IObjContext_FWD_DEFINED__
	typedef interface IObjContext IObjContext;
#endif 	/* __IObjContext_FWD_DEFINED__ */


#ifndef __IProcessLock_FWD_DEFINED__
#define __IProcessLock_FWD_DEFINED__
	typedef interface IProcessLock IProcessLock;
#endif 	/* __IProcessLock_FWD_DEFINED__ */


#ifndef __ISurrogateService_FWD_DEFINED__
#define __ISurrogateService_FWD_DEFINED__
	typedef interface ISurrogateService ISurrogateService;
#endif 	/* __ISurrogateService_FWD_DEFINED__ */


#ifndef __IComThreadingInfo_FWD_DEFINED__
#define __IComThreadingInfo_FWD_DEFINED__
	typedef interface IComThreadingInfo IComThreadingInfo;
#endif 	/* __IComThreadingInfo_FWD_DEFINED__ */


#ifndef __IProcessInitControl_FWD_DEFINED__
#define __IProcessInitControl_FWD_DEFINED__
	typedef interface IProcessInitControl IProcessInitControl;
#endif 	/* __IProcessInitControl_FWD_DEFINED__ */


#ifndef __IInitializeSpy_FWD_DEFINED__
#define __IInitializeSpy_FWD_DEFINED__
	typedef interface IInitializeSpy IInitializeSpy;
#endif 	/* __IInitializeSpy_FWD_DEFINED__ */


	/* header files for imported files */
	// ***** DOINC including unknwn.h *****
		// DOINC skipping duplicate include

#ifdef __cplusplus
	extern "C" {
#endif 

		void* __RPC_USER MIDL_user_allocate(size_t);
		void __RPC_USER MIDL_user_free(void*);

		/* interface __MIDL_itf_objidl_0000 */
		/* [local] */

		//+-------------------------------------------------------------------------
		//+-------------------------------------------------------------------------
		//
		//  Microsoft Windows
		//  Copyright (c) Microsoft Corporation. All rights reserved.
		//
		//--------------------------------------------------------------------------



#if ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)
#endif
#if ( _MSC_VER >= 1020 )
#pragma once
#endif













		typedef struct _COSERVERINFO
		{
			DWORD dwReserved1;
			LPWSTR pwszName;
			COAUTHINFO* pAuthInfo;
			DWORD dwReserved2;
		} 	COSERVERINFO;



		extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_v0_0_c_ifspec;
		extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_v0_0_s_ifspec;

#ifndef __IMarshal_INTERFACE_DEFINED__
#define __IMarshal_INTERFACE_DEFINED__

		/* interface IMarshal */
		/* [uuid][object][local] */

		typedef /* [unique] */ IMarshal* LPMARSHAL;


		EXTERN_C const IID IID_IMarshal;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000003-0000-0000-C000-000000000046")
			IMarshal : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE GetUnmarshalClass(
				/* [in] */ REFIID riid,
				/* [unique][in] */ void* pv,
				/* [in] */ DWORD dwDestContext,
				/* [unique][in] */ void* pvDestContext,
				/* [in] */ DWORD mshlflags,
				/* [out] */ CLSID * pCid) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetMarshalSizeMax(
				/* [in] */ REFIID riid,
				/* [unique][in] */ void* pv,
				/* [in] */ DWORD dwDestContext,
				/* [unique][in] */ void* pvDestContext,
				/* [in] */ DWORD mshlflags,
				/* [out] */ DWORD* pSize) = 0;

			virtual HRESULT STDMETHODCALLTYPE MarshalInterface(
				/* [unique][in] */ IStream* pStm,
				/* [in] */ REFIID riid,
				/* [unique][in] */ void* pv,
				/* [in] */ DWORD dwDestContext,
				/* [unique][in] */ void* pvDestContext,
				/* [in] */ DWORD mshlflags) = 0;

			virtual HRESULT STDMETHODCALLTYPE UnmarshalInterface(
				/* [unique][in] */ IStream* pStm,
				/* [in] */ REFIID riid,
				/* [out] */ void** ppv) = 0;

			virtual HRESULT STDMETHODCALLTYPE ReleaseMarshalData(
				/* [unique][in] */ IStream* pStm) = 0;

			virtual HRESULT STDMETHODCALLTYPE DisconnectObject(
				/* [in] */ DWORD dwReserved) = 0;

		};

#else 	/* C style interface */

		typedef struct IMarshalVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IMarshal* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IMarshal* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IMarshal* This);

			HRESULT(STDMETHODCALLTYPE* GetUnmarshalClass)(
				IMarshal* This,
				/* [in] */ REFIID riid,
				/* [unique][in] */ void* pv,
				/* [in] */ DWORD dwDestContext,
				/* [unique][in] */ void* pvDestContext,
				/* [in] */ DWORD mshlflags,
				/* [out] */ CLSID* pCid);

			HRESULT(STDMETHODCALLTYPE* GetMarshalSizeMax)(
				IMarshal* This,
				/* [in] */ REFIID riid,
				/* [unique][in] */ void* pv,
				/* [in] */ DWORD dwDestContext,
				/* [unique][in] */ void* pvDestContext,
				/* [in] */ DWORD mshlflags,
				/* [out] */ DWORD* pSize);

			HRESULT(STDMETHODCALLTYPE* MarshalInterface)(
				IMarshal* This,
				/* [unique][in] */ IStream* pStm,
				/* [in] */ REFIID riid,
				/* [unique][in] */ void* pv,
				/* [in] */ DWORD dwDestContext,
				/* [unique][in] */ void* pvDestContext,
				/* [in] */ DWORD mshlflags);

			HRESULT(STDMETHODCALLTYPE* UnmarshalInterface)(
				IMarshal* This,
				/* [unique][in] */ IStream* pStm,
				/* [in] */ REFIID riid,
				/* [out] */ void** ppv);

			HRESULT(STDMETHODCALLTYPE* ReleaseMarshalData)(
				IMarshal* This,
				/* [unique][in] */ IStream* pStm);

			HRESULT(STDMETHODCALLTYPE* DisconnectObject)(
				IMarshal* This,
				/* [in] */ DWORD dwReserved);

			END_INTERFACE
		} IMarshalVtbl;

		interface IMarshal
		{
			CONST_VTBL struct IMarshalVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IMarshal_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMarshal_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMarshal_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMarshal_GetUnmarshalClass(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pCid)	\
    (This)->lpVtbl -> GetUnmarshalClass(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pCid)

#define IMarshal_GetMarshalSizeMax(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pSize)	\
    (This)->lpVtbl -> GetMarshalSizeMax(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pSize)

#define IMarshal_MarshalInterface(This,pStm,riid,pv,dwDestContext,pvDestContext,mshlflags)	\
    (This)->lpVtbl -> MarshalInterface(This,pStm,riid,pv,dwDestContext,pvDestContext,mshlflags)

#define IMarshal_UnmarshalInterface(This,pStm,riid,ppv)	\
    (This)->lpVtbl -> UnmarshalInterface(This,pStm,riid,ppv)

#define IMarshal_ReleaseMarshalData(This,pStm)	\
    (This)->lpVtbl -> ReleaseMarshalData(This,pStm)

#define IMarshal_DisconnectObject(This,dwReserved)	\
    (This)->lpVtbl -> DisconnectObject(This,dwReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IMarshal_GetUnmarshalClass_Proxy(
			IMarshal* This,
			/* [in] */ REFIID riid,
			/* [unique][in] */ void* pv,
			/* [in] */ DWORD dwDestContext,
			/* [unique][in] */ void* pvDestContext,
			/* [in] */ DWORD mshlflags,
			/* [out] */ CLSID* pCid);


		void __RPC_STUB IMarshal_GetUnmarshalClass_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IMarshal_GetMarshalSizeMax_Proxy(
			IMarshal* This,
			/* [in] */ REFIID riid,
			/* [unique][in] */ void* pv,
			/* [in] */ DWORD dwDestContext,
			/* [unique][in] */ void* pvDestContext,
			/* [in] */ DWORD mshlflags,
			/* [out] */ DWORD* pSize);


		void __RPC_STUB IMarshal_GetMarshalSizeMax_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IMarshal_MarshalInterface_Proxy(
			IMarshal* This,
			/* [unique][in] */ IStream* pStm,
			/* [in] */ REFIID riid,
			/* [unique][in] */ void* pv,
			/* [in] */ DWORD dwDestContext,
			/* [unique][in] */ void* pvDestContext,
			/* [in] */ DWORD mshlflags);


		void __RPC_STUB IMarshal_MarshalInterface_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IMarshal_UnmarshalInterface_Proxy(
			IMarshal* This,
			/* [unique][in] */ IStream* pStm,
			/* [in] */ REFIID riid,
			/* [out] */ void** ppv);


		void __RPC_STUB IMarshal_UnmarshalInterface_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IMarshal_ReleaseMarshalData_Proxy(
			IMarshal* This,
			/* [unique][in] */ IStream* pStm);


		void __RPC_STUB IMarshal_ReleaseMarshalData_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IMarshal_DisconnectObject_Proxy(
			IMarshal* This,
			/* [in] */ DWORD dwReserved);


		void __RPC_STUB IMarshal_DisconnectObject_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IMarshal_INTERFACE_DEFINED__ */


#ifndef __IMarshal2_INTERFACE_DEFINED__
#define __IMarshal2_INTERFACE_DEFINED__

		/* interface IMarshal2 */
		/* [uuid][object][local] */

		typedef /* [unique] */ IMarshal2* LPMARSHAL2;


		EXTERN_C const IID IID_IMarshal2;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("000001cf-0000-0000-C000-000000000046")
			IMarshal2 : public IMarshal
		{
		public:
		};

#else 	/* C style interface */

		typedef struct IMarshal2Vtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IMarshal2* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IMarshal2* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IMarshal2* This);

			HRESULT(STDMETHODCALLTYPE* GetUnmarshalClass)(
				IMarshal2* This,
				/* [in] */ REFIID riid,
				/* [unique][in] */ void* pv,
				/* [in] */ DWORD dwDestContext,
				/* [unique][in] */ void* pvDestContext,
				/* [in] */ DWORD mshlflags,
				/* [out] */ CLSID* pCid);

			HRESULT(STDMETHODCALLTYPE* GetMarshalSizeMax)(
				IMarshal2* This,
				/* [in] */ REFIID riid,
				/* [unique][in] */ void* pv,
				/* [in] */ DWORD dwDestContext,
				/* [unique][in] */ void* pvDestContext,
				/* [in] */ DWORD mshlflags,
				/* [out] */ DWORD* pSize);

			HRESULT(STDMETHODCALLTYPE* MarshalInterface)(
				IMarshal2* This,
				/* [unique][in] */ IStream* pStm,
				/* [in] */ REFIID riid,
				/* [unique][in] */ void* pv,
				/* [in] */ DWORD dwDestContext,
				/* [unique][in] */ void* pvDestContext,
				/* [in] */ DWORD mshlflags);

			HRESULT(STDMETHODCALLTYPE* UnmarshalInterface)(
				IMarshal2* This,
				/* [unique][in] */ IStream* pStm,
				/* [in] */ REFIID riid,
				/* [out] */ void** ppv);

			HRESULT(STDMETHODCALLTYPE* ReleaseMarshalData)(
				IMarshal2* This,
				/* [unique][in] */ IStream* pStm);

			HRESULT(STDMETHODCALLTYPE* DisconnectObject)(
				IMarshal2* This,
				/* [in] */ DWORD dwReserved);

			END_INTERFACE
		} IMarshal2Vtbl;

		interface IMarshal2
		{
			CONST_VTBL struct IMarshal2Vtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IMarshal2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMarshal2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMarshal2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMarshal2_GetUnmarshalClass(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pCid)	\
    (This)->lpVtbl -> GetUnmarshalClass(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pCid)

#define IMarshal2_GetMarshalSizeMax(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pSize)	\
    (This)->lpVtbl -> GetMarshalSizeMax(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pSize)

#define IMarshal2_MarshalInterface(This,pStm,riid,pv,dwDestContext,pvDestContext,mshlflags)	\
    (This)->lpVtbl -> MarshalInterface(This,pStm,riid,pv,dwDestContext,pvDestContext,mshlflags)

#define IMarshal2_UnmarshalInterface(This,pStm,riid,ppv)	\
    (This)->lpVtbl -> UnmarshalInterface(This,pStm,riid,ppv)

#define IMarshal2_ReleaseMarshalData(This,pStm)	\
    (This)->lpVtbl -> ReleaseMarshalData(This,pStm)

#define IMarshal2_DisconnectObject(This,dwReserved)	\
    (This)->lpVtbl -> DisconnectObject(This,dwReserved)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMarshal2_INTERFACE_DEFINED__ */


#ifndef __IMalloc_INTERFACE_DEFINED__
#define __IMalloc_INTERFACE_DEFINED__

		/* interface IMalloc */
		/* [uuid][object][local] */

		typedef /* [unique] */ IMalloc* LPMALLOC;


		EXTERN_C const IID IID_IMalloc;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000002-0000-0000-C000-000000000046")
			IMalloc : public IUnknown
		{
		public:
			virtual void* STDMETHODCALLTYPE Alloc(
				/* [in] */ SIZE_T cb) = 0;

			virtual void* STDMETHODCALLTYPE Realloc(
				/* [in] */ void* pv,
				/* [in] */ SIZE_T cb) = 0;

			virtual void STDMETHODCALLTYPE Free(
				/* [in] */ void* pv) = 0;

			virtual SIZE_T STDMETHODCALLTYPE GetSize(
				/* [in] */ void* pv) = 0;

			virtual int STDMETHODCALLTYPE DidAlloc(
				void* pv) = 0;

			virtual void STDMETHODCALLTYPE HeapMinimize(void) = 0;

		};

#else 	/* C style interface */

		typedef struct IMallocVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IMalloc* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IMalloc* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IMalloc* This);

			void* (STDMETHODCALLTYPE* Alloc)(
				IMalloc* This,
				/* [in] */ SIZE_T cb);

			void* (STDMETHODCALLTYPE* Realloc)(
				IMalloc* This,
				/* [in] */ void* pv,
				/* [in] */ SIZE_T cb);

			void (STDMETHODCALLTYPE* Free)(
				IMalloc* This,
				/* [in] */ void* pv);

			SIZE_T(STDMETHODCALLTYPE* GetSize)(
				IMalloc* This,
				/* [in] */ void* pv);

			int (STDMETHODCALLTYPE* DidAlloc)(
				IMalloc* This,
				void* pv);

			void (STDMETHODCALLTYPE* HeapMinimize)(
				IMalloc* This);

			END_INTERFACE
		} IMallocVtbl;

		interface IMalloc
		{
			CONST_VTBL struct IMallocVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IMalloc_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMalloc_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMalloc_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMalloc_Alloc(This,cb)	\
    (This)->lpVtbl -> Alloc(This,cb)

#define IMalloc_Realloc(This,pv,cb)	\
    (This)->lpVtbl -> Realloc(This,pv,cb)

#define IMalloc_Free(This,pv)	\
    (This)->lpVtbl -> Free(This,pv)

#define IMalloc_GetSize(This,pv)	\
    (This)->lpVtbl -> GetSize(This,pv)

#define IMalloc_DidAlloc(This,pv)	\
    (This)->lpVtbl -> DidAlloc(This,pv)

#define IMalloc_HeapMinimize(This)	\
    (This)->lpVtbl -> HeapMinimize(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		void* STDMETHODCALLTYPE IMalloc_Alloc_Proxy(
			IMalloc* This,
			/* [in] */ SIZE_T cb);


		void __RPC_STUB IMalloc_Alloc_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		void* STDMETHODCALLTYPE IMalloc_Realloc_Proxy(
			IMalloc* This,
			/* [in] */ void* pv,
			/* [in] */ SIZE_T cb);


		void __RPC_STUB IMalloc_Realloc_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		void STDMETHODCALLTYPE IMalloc_Free_Proxy(
			IMalloc* This,
			/* [in] */ void* pv);


		void __RPC_STUB IMalloc_Free_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		SIZE_T STDMETHODCALLTYPE IMalloc_GetSize_Proxy(
			IMalloc* This,
			/* [in] */ void* pv);


		void __RPC_STUB IMalloc_GetSize_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		int STDMETHODCALLTYPE IMalloc_DidAlloc_Proxy(
			IMalloc* This,
			void* pv);


		void __RPC_STUB IMalloc_DidAlloc_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		void STDMETHODCALLTYPE IMalloc_HeapMinimize_Proxy(
			IMalloc* This);


		void __RPC_STUB IMalloc_HeapMinimize_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IMalloc_INTERFACE_DEFINED__ */


#ifndef __IMallocSpy_INTERFACE_DEFINED__
#define __IMallocSpy_INTERFACE_DEFINED__

		/* interface IMallocSpy */
		/* [uuid][object][local] */

		typedef /* [unique] */ IMallocSpy* LPMALLOCSPY;


		EXTERN_C const IID IID_IMallocSpy;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("0000001d-0000-0000-C000-000000000046")
			IMallocSpy : public IUnknown
		{
		public:
			virtual SIZE_T STDMETHODCALLTYPE PreAlloc(
				/* [in] */ SIZE_T cbRequest) = 0;

			virtual void* STDMETHODCALLTYPE PostAlloc(
				/* [in] */ void* pActual) = 0;

			virtual void* STDMETHODCALLTYPE PreFree(
				/* [in] */ void* pRequest,
				/* [in] */ BOOL fSpyed) = 0;

			virtual void STDMETHODCALLTYPE PostFree(
				/* [in] */ BOOL fSpyed) = 0;

			virtual SIZE_T STDMETHODCALLTYPE PreRealloc(
				/* [in] */ void* pRequest,
				/* [in] */ SIZE_T cbRequest,
				/* [out] */ void** ppNewRequest,
				/* [in] */ BOOL fSpyed) = 0;

			virtual void* STDMETHODCALLTYPE PostRealloc(
				/* [in] */ void* pActual,
				/* [in] */ BOOL fSpyed) = 0;

			virtual void* STDMETHODCALLTYPE PreGetSize(
				/* [in] */ void* pRequest,
				/* [in] */ BOOL fSpyed) = 0;

			virtual SIZE_T STDMETHODCALLTYPE PostGetSize(
				/* [in] */ SIZE_T cbActual,
				/* [in] */ BOOL fSpyed) = 0;

			virtual void* STDMETHODCALLTYPE PreDidAlloc(
				/* [in] */ void* pRequest,
				/* [in] */ BOOL fSpyed) = 0;

			virtual int STDMETHODCALLTYPE PostDidAlloc(
				/* [in] */ void* pRequest,
				/* [in] */ BOOL fSpyed,
				/* [in] */ int fActual) = 0;

			virtual void STDMETHODCALLTYPE PreHeapMinimize(void) = 0;

			virtual void STDMETHODCALLTYPE PostHeapMinimize(void) = 0;

		};

#else 	/* C style interface */

		typedef struct IMallocSpyVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IMallocSpy* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IMallocSpy* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IMallocSpy* This);

			SIZE_T(STDMETHODCALLTYPE* PreAlloc)(
				IMallocSpy* This,
				/* [in] */ SIZE_T cbRequest);

			void* (STDMETHODCALLTYPE* PostAlloc)(
				IMallocSpy* This,
				/* [in] */ void* pActual);

			void* (STDMETHODCALLTYPE* PreFree)(
				IMallocSpy* This,
				/* [in] */ void* pRequest,
				/* [in] */ BOOL fSpyed);

			void (STDMETHODCALLTYPE* PostFree)(
				IMallocSpy* This,
				/* [in] */ BOOL fSpyed);

			SIZE_T(STDMETHODCALLTYPE* PreRealloc)(
				IMallocSpy* This,
				/* [in] */ void* pRequest,
				/* [in] */ SIZE_T cbRequest,
				/* [out] */ void** ppNewRequest,
				/* [in] */ BOOL fSpyed);

			void* (STDMETHODCALLTYPE* PostRealloc)(
				IMallocSpy* This,
				/* [in] */ void* pActual,
				/* [in] */ BOOL fSpyed);

			void* (STDMETHODCALLTYPE* PreGetSize)(
				IMallocSpy* This,
				/* [in] */ void* pRequest,
				/* [in] */ BOOL fSpyed);

			SIZE_T(STDMETHODCALLTYPE* PostGetSize)(
				IMallocSpy* This,
				/* [in] */ SIZE_T cbActual,
				/* [in] */ BOOL fSpyed);

			void* (STDMETHODCALLTYPE* PreDidAlloc)(
				IMallocSpy* This,
				/* [in] */ void* pRequest,
				/* [in] */ BOOL fSpyed);

			int (STDMETHODCALLTYPE* PostDidAlloc)(
				IMallocSpy* This,
				/* [in] */ void* pRequest,
				/* [in] */ BOOL fSpyed,
				/* [in] */ int fActual);

			void (STDMETHODCALLTYPE* PreHeapMinimize)(
				IMallocSpy* This);

			void (STDMETHODCALLTYPE* PostHeapMinimize)(
				IMallocSpy* This);

			END_INTERFACE
		} IMallocSpyVtbl;

		interface IMallocSpy
		{
			CONST_VTBL struct IMallocSpyVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IMallocSpy_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMallocSpy_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMallocSpy_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMallocSpy_PreAlloc(This,cbRequest)	\
    (This)->lpVtbl -> PreAlloc(This,cbRequest)

#define IMallocSpy_PostAlloc(This,pActual)	\
    (This)->lpVtbl -> PostAlloc(This,pActual)

#define IMallocSpy_PreFree(This,pRequest,fSpyed)	\
    (This)->lpVtbl -> PreFree(This,pRequest,fSpyed)

#define IMallocSpy_PostFree(This,fSpyed)	\
    (This)->lpVtbl -> PostFree(This,fSpyed)

#define IMallocSpy_PreRealloc(This,pRequest,cbRequest,ppNewRequest,fSpyed)	\
    (This)->lpVtbl -> PreRealloc(This,pRequest,cbRequest,ppNewRequest,fSpyed)

#define IMallocSpy_PostRealloc(This,pActual,fSpyed)	\
    (This)->lpVtbl -> PostRealloc(This,pActual,fSpyed)

#define IMallocSpy_PreGetSize(This,pRequest,fSpyed)	\
    (This)->lpVtbl -> PreGetSize(This,pRequest,fSpyed)

#define IMallocSpy_PostGetSize(This,cbActual,fSpyed)	\
    (This)->lpVtbl -> PostGetSize(This,cbActual,fSpyed)

#define IMallocSpy_PreDidAlloc(This,pRequest,fSpyed)	\
    (This)->lpVtbl -> PreDidAlloc(This,pRequest,fSpyed)

#define IMallocSpy_PostDidAlloc(This,pRequest,fSpyed,fActual)	\
    (This)->lpVtbl -> PostDidAlloc(This,pRequest,fSpyed,fActual)

#define IMallocSpy_PreHeapMinimize(This)	\
    (This)->lpVtbl -> PreHeapMinimize(This)

#define IMallocSpy_PostHeapMinimize(This)	\
    (This)->lpVtbl -> PostHeapMinimize(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		SIZE_T STDMETHODCALLTYPE IMallocSpy_PreAlloc_Proxy(
			IMallocSpy* This,
			/* [in] */ SIZE_T cbRequest);


		void __RPC_STUB IMallocSpy_PreAlloc_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		void* STDMETHODCALLTYPE IMallocSpy_PostAlloc_Proxy(
			IMallocSpy* This,
			/* [in] */ void* pActual);


		void __RPC_STUB IMallocSpy_PostAlloc_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		void* STDMETHODCALLTYPE IMallocSpy_PreFree_Proxy(
			IMallocSpy* This,
			/* [in] */ void* pRequest,
			/* [in] */ BOOL fSpyed);


		void __RPC_STUB IMallocSpy_PreFree_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		void STDMETHODCALLTYPE IMallocSpy_PostFree_Proxy(
			IMallocSpy* This,
			/* [in] */ BOOL fSpyed);


		void __RPC_STUB IMallocSpy_PostFree_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		SIZE_T STDMETHODCALLTYPE IMallocSpy_PreRealloc_Proxy(
			IMallocSpy* This,
			/* [in] */ void* pRequest,
			/* [in] */ SIZE_T cbRequest,
			/* [out] */ void** ppNewRequest,
			/* [in] */ BOOL fSpyed);


		void __RPC_STUB IMallocSpy_PreRealloc_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		void* STDMETHODCALLTYPE IMallocSpy_PostRealloc_Proxy(
			IMallocSpy* This,
			/* [in] */ void* pActual,
			/* [in] */ BOOL fSpyed);


		void __RPC_STUB IMallocSpy_PostRealloc_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		void* STDMETHODCALLTYPE IMallocSpy_PreGetSize_Proxy(
			IMallocSpy* This,
			/* [in] */ void* pRequest,
			/* [in] */ BOOL fSpyed);


		void __RPC_STUB IMallocSpy_PreGetSize_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		SIZE_T STDMETHODCALLTYPE IMallocSpy_PostGetSize_Proxy(
			IMallocSpy* This,
			/* [in] */ SIZE_T cbActual,
			/* [in] */ BOOL fSpyed);


		void __RPC_STUB IMallocSpy_PostGetSize_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		void* STDMETHODCALLTYPE IMallocSpy_PreDidAlloc_Proxy(
			IMallocSpy* This,
			/* [in] */ void* pRequest,
			/* [in] */ BOOL fSpyed);


		void __RPC_STUB IMallocSpy_PreDidAlloc_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		int STDMETHODCALLTYPE IMallocSpy_PostDidAlloc_Proxy(
			IMallocSpy* This,
			/* [in] */ void* pRequest,
			/* [in] */ BOOL fSpyed,
			/* [in] */ int fActual);


		void __RPC_STUB IMallocSpy_PostDidAlloc_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		void STDMETHODCALLTYPE IMallocSpy_PreHeapMinimize_Proxy(
			IMallocSpy* This);


		void __RPC_STUB IMallocSpy_PreHeapMinimize_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		void STDMETHODCALLTYPE IMallocSpy_PostHeapMinimize_Proxy(
			IMallocSpy* This);


		void __RPC_STUB IMallocSpy_PostHeapMinimize_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IMallocSpy_INTERFACE_DEFINED__ */


#ifndef __IStdMarshalInfo_INTERFACE_DEFINED__
#define __IStdMarshalInfo_INTERFACE_DEFINED__

		/* interface IStdMarshalInfo */
		/* [uuid][object][local] */

		typedef /* [unique] */ IStdMarshalInfo* LPSTDMARSHALINFO;


		EXTERN_C const IID IID_IStdMarshalInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000018-0000-0000-C000-000000000046")
			IStdMarshalInfo : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE GetClassForHandler(
				/* [in] */ DWORD dwDestContext,
				/* [unique][in] */ void* pvDestContext,
				/* [out] */ CLSID * pClsid) = 0;

		};

#else 	/* C style interface */

		typedef struct IStdMarshalInfoVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IStdMarshalInfo* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IStdMarshalInfo* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IStdMarshalInfo* This);

			HRESULT(STDMETHODCALLTYPE* GetClassForHandler)(
				IStdMarshalInfo* This,
				/* [in] */ DWORD dwDestContext,
				/* [unique][in] */ void* pvDestContext,
				/* [out] */ CLSID* pClsid);

			END_INTERFACE
		} IStdMarshalInfoVtbl;

		interface IStdMarshalInfo
		{
			CONST_VTBL struct IStdMarshalInfoVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IStdMarshalInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStdMarshalInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStdMarshalInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStdMarshalInfo_GetClassForHandler(This,dwDestContext,pvDestContext,pClsid)	\
    (This)->lpVtbl -> GetClassForHandler(This,dwDestContext,pvDestContext,pClsid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IStdMarshalInfo_GetClassForHandler_Proxy(
			IStdMarshalInfo* This,
			/* [in] */ DWORD dwDestContext,
			/* [unique][in] */ void* pvDestContext,
			/* [out] */ CLSID* pClsid);


		void __RPC_STUB IStdMarshalInfo_GetClassForHandler_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IStdMarshalInfo_INTERFACE_DEFINED__ */


#ifndef __IExternalConnection_INTERFACE_DEFINED__
#define __IExternalConnection_INTERFACE_DEFINED__

		/* interface IExternalConnection */
		/* [uuid][local][object] */

		typedef /* [unique] */ IExternalConnection* LPEXTERNALCONNECTION;

		typedef
			enum tagEXTCONN
		{
			EXTCONN_STRONG = 0x1,
			EXTCONN_WEAK = 0x2,
			EXTCONN_CALLABLE = 0x4
		} 	EXTCONN;


		EXTERN_C const IID IID_IExternalConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000019-0000-0000-C000-000000000046")
			IExternalConnection : public IUnknown
		{
		public:
			virtual DWORD STDMETHODCALLTYPE AddConnection(
				/* [in] */ DWORD extconn,
				/* [in] */ DWORD reserved) = 0;

			virtual DWORD STDMETHODCALLTYPE ReleaseConnection(
				/* [in] */ DWORD extconn,
				/* [in] */ DWORD reserved,
				/* [in] */ BOOL fLastReleaseCloses) = 0;

		};

#else 	/* C style interface */

		typedef struct IExternalConnectionVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IExternalConnection* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IExternalConnection* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IExternalConnection* This);

			DWORD(STDMETHODCALLTYPE* AddConnection)(
				IExternalConnection* This,
				/* [in] */ DWORD extconn,
				/* [in] */ DWORD reserved);

			DWORD(STDMETHODCALLTYPE* ReleaseConnection)(
				IExternalConnection* This,
				/* [in] */ DWORD extconn,
				/* [in] */ DWORD reserved,
				/* [in] */ BOOL fLastReleaseCloses);

			END_INTERFACE
		} IExternalConnectionVtbl;

		interface IExternalConnection
		{
			CONST_VTBL struct IExternalConnectionVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IExternalConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExternalConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExternalConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExternalConnection_AddConnection(This,extconn,reserved)	\
    (This)->lpVtbl -> AddConnection(This,extconn,reserved)

#define IExternalConnection_ReleaseConnection(This,extconn,reserved,fLastReleaseCloses)	\
    (This)->lpVtbl -> ReleaseConnection(This,extconn,reserved,fLastReleaseCloses)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		DWORD STDMETHODCALLTYPE IExternalConnection_AddConnection_Proxy(
			IExternalConnection* This,
			/* [in] */ DWORD extconn,
			/* [in] */ DWORD reserved);


		void __RPC_STUB IExternalConnection_AddConnection_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		DWORD STDMETHODCALLTYPE IExternalConnection_ReleaseConnection_Proxy(
			IExternalConnection* This,
			/* [in] */ DWORD extconn,
			/* [in] */ DWORD reserved,
			/* [in] */ BOOL fLastReleaseCloses);


		void __RPC_STUB IExternalConnection_ReleaseConnection_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IExternalConnection_INTERFACE_DEFINED__ */


		/* interface __MIDL_itf_objidl_0015 */
		/* [local] */

		typedef /* [unique] */ IMultiQI* LPMULTIQI;

		typedef struct tagMULTI_QI
		{
			const IID* pIID;
			IUnknown* pItf;
			HRESULT hr;
		} 	MULTI_QI;



		extern RPC_IF_HANDLE __MIDL_itf_objidl_0015_v0_0_c_ifspec;
		extern RPC_IF_HANDLE __MIDL_itf_objidl_0015_v0_0_s_ifspec;

#ifndef __IMultiQI_INTERFACE_DEFINED__
#define __IMultiQI_INTERFACE_DEFINED__

		/* interface IMultiQI */
		/* [async_uuid][uuid][local][object] */


		EXTERN_C const IID IID_IMultiQI;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000020-0000-0000-C000-000000000046")
			IMultiQI : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE QueryMultipleInterfaces(
				/* [in] */ ULONG cMQIs,
				/* [out][in] */ MULTI_QI * pMQIs) = 0;

		};

#else 	/* C style interface */

		typedef struct IMultiQIVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IMultiQI* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IMultiQI* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IMultiQI* This);

			HRESULT(STDMETHODCALLTYPE* QueryMultipleInterfaces)(
				IMultiQI* This,
				/* [in] */ ULONG cMQIs,
				/* [out][in] */ MULTI_QI* pMQIs);

			END_INTERFACE
		} IMultiQIVtbl;

		interface IMultiQI
		{
			CONST_VTBL struct IMultiQIVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IMultiQI_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMultiQI_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMultiQI_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMultiQI_QueryMultipleInterfaces(This,cMQIs,pMQIs)	\
    (This)->lpVtbl -> QueryMultipleInterfaces(This,cMQIs,pMQIs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IMultiQI_QueryMultipleInterfaces_Proxy(
			IMultiQI* This,
			/* [in] */ ULONG cMQIs,
			/* [out][in] */ MULTI_QI* pMQIs);


		void __RPC_STUB IMultiQI_QueryMultipleInterfaces_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IMultiQI_INTERFACE_DEFINED__ */


#ifndef __AsyncIMultiQI_INTERFACE_DEFINED__
#define __AsyncIMultiQI_INTERFACE_DEFINED__

		/* interface AsyncIMultiQI */
		/* [uuid][local][object] */


		EXTERN_C const IID IID_AsyncIMultiQI;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("000e0020-0000-0000-C000-000000000046")
			AsyncIMultiQI : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE Begin_QueryMultipleInterfaces(
				/* [in] */ ULONG cMQIs,
				/* [out][in] */ MULTI_QI * pMQIs) = 0;

			virtual HRESULT STDMETHODCALLTYPE Finish_QueryMultipleInterfaces(
				/* [out][in] */ MULTI_QI* pMQIs) = 0;

		};

#else 	/* C style interface */

		typedef struct AsyncIMultiQIVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					AsyncIMultiQI* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				AsyncIMultiQI* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				AsyncIMultiQI* This);

			HRESULT(STDMETHODCALLTYPE* Begin_QueryMultipleInterfaces)(
				AsyncIMultiQI* This,
				/* [in] */ ULONG cMQIs,
				/* [out][in] */ MULTI_QI* pMQIs);

			HRESULT(STDMETHODCALLTYPE* Finish_QueryMultipleInterfaces)(
				AsyncIMultiQI* This,
				/* [out][in] */ MULTI_QI* pMQIs);

			END_INTERFACE
		} AsyncIMultiQIVtbl;

		interface AsyncIMultiQI
		{
			CONST_VTBL struct AsyncIMultiQIVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define AsyncIMultiQI_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define AsyncIMultiQI_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define AsyncIMultiQI_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define AsyncIMultiQI_Begin_QueryMultipleInterfaces(This,cMQIs,pMQIs)	\
    (This)->lpVtbl -> Begin_QueryMultipleInterfaces(This,cMQIs,pMQIs)

#define AsyncIMultiQI_Finish_QueryMultipleInterfaces(This,pMQIs)	\
    (This)->lpVtbl -> Finish_QueryMultipleInterfaces(This,pMQIs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE AsyncIMultiQI_Begin_QueryMultipleInterfaces_Proxy(
			AsyncIMultiQI* This,
			/* [in] */ ULONG cMQIs,
			/* [out][in] */ MULTI_QI* pMQIs);


		void __RPC_STUB AsyncIMultiQI_Begin_QueryMultipleInterfaces_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE AsyncIMultiQI_Finish_QueryMultipleInterfaces_Proxy(
			AsyncIMultiQI* This,
			/* [out][in] */ MULTI_QI* pMQIs);


		void __RPC_STUB AsyncIMultiQI_Finish_QueryMultipleInterfaces_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __AsyncIMultiQI_INTERFACE_DEFINED__ */


#ifndef __IInternalUnknown_INTERFACE_DEFINED__
#define __IInternalUnknown_INTERFACE_DEFINED__

		/* interface IInternalUnknown */
		/* [uuid][local][object] */


		EXTERN_C const IID IID_IInternalUnknown;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000021-0000-0000-C000-000000000046")
			IInternalUnknown : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE QueryInternalInterface(
				/* [in] */ REFIID riid,
				/* [out] */ void** ppv) = 0;

		};

#else 	/* C style interface */

		typedef struct IInternalUnknownVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IInternalUnknown* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IInternalUnknown* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IInternalUnknown* This);

			HRESULT(STDMETHODCALLTYPE* QueryInternalInterface)(
				IInternalUnknown* This,
				/* [in] */ REFIID riid,
				/* [out] */ void** ppv);

			END_INTERFACE
		} IInternalUnknownVtbl;

		interface IInternalUnknown
		{
			CONST_VTBL struct IInternalUnknownVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IInternalUnknown_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternalUnknown_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInternalUnknown_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInternalUnknown_QueryInternalInterface(This,riid,ppv)	\
    (This)->lpVtbl -> QueryInternalInterface(This,riid,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IInternalUnknown_QueryInternalInterface_Proxy(
			IInternalUnknown* This,
			/* [in] */ REFIID riid,
			/* [out] */ void** ppv);


		void __RPC_STUB IInternalUnknown_QueryInternalInterface_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IInternalUnknown_INTERFACE_DEFINED__ */


#ifndef __IEnumUnknown_INTERFACE_DEFINED__
#define __IEnumUnknown_INTERFACE_DEFINED__

		/* interface IEnumUnknown */
		/* [unique][uuid][object] */

		typedef /* [unique] */ IEnumUnknown* LPENUMUNKNOWN;


		EXTERN_C const IID IID_IEnumUnknown;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000100-0000-0000-C000-000000000046")
			IEnumUnknown : public IUnknown
		{
		public:
			virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next(
				/* [in] */ ULONG celt,
				/* [out] */ IUnknown * *rgelt,
				/* [out] */ ULONG * pceltFetched) = 0;

			virtual HRESULT STDMETHODCALLTYPE Skip(
				/* [in] */ ULONG celt) = 0;

			virtual HRESULT STDMETHODCALLTYPE Reset(void) = 0;

			virtual HRESULT STDMETHODCALLTYPE Clone(
				/* [out] */ IEnumUnknown** ppenum) = 0;

		};

#else 	/* C style interface */

		typedef struct IEnumUnknownVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IEnumUnknown* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IEnumUnknown* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IEnumUnknown* This);

			/* [local] */ HRESULT(STDMETHODCALLTYPE* Next)(
				IEnumUnknown* This,
				/* [in] */ ULONG celt,
				/* [out] */ IUnknown** rgelt,
				/* [out] */ ULONG* pceltFetched);

			HRESULT(STDMETHODCALLTYPE* Skip)(
				IEnumUnknown* This,
				/* [in] */ ULONG celt);

			HRESULT(STDMETHODCALLTYPE* Reset)(
				IEnumUnknown* This);

			HRESULT(STDMETHODCALLTYPE* Clone)(
				IEnumUnknown* This,
				/* [out] */ IEnumUnknown** ppenum);

			END_INTERFACE
		} IEnumUnknownVtbl;

		interface IEnumUnknown
		{
			CONST_VTBL struct IEnumUnknownVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IEnumUnknown_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumUnknown_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumUnknown_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumUnknown_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumUnknown_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumUnknown_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumUnknown_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumUnknown_RemoteNext_Proxy(
			IEnumUnknown* This,
			/* [in] */ ULONG celt,
			/* [length_is][size_is][out] */ IUnknown** rgelt,
			/* [out] */ ULONG* pceltFetched);


		void __RPC_STUB IEnumUnknown_RemoteNext_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IEnumUnknown_Skip_Proxy(
			IEnumUnknown* This,
			/* [in] */ ULONG celt);


		void __RPC_STUB IEnumUnknown_Skip_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IEnumUnknown_Reset_Proxy(
			IEnumUnknown* This);


		void __RPC_STUB IEnumUnknown_Reset_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IEnumUnknown_Clone_Proxy(
			IEnumUnknown* This,
			/* [out] */ IEnumUnknown** ppenum);


		void __RPC_STUB IEnumUnknown_Clone_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IEnumUnknown_INTERFACE_DEFINED__ */


#ifndef __IBindCtx_INTERFACE_DEFINED__
#define __IBindCtx_INTERFACE_DEFINED__

		/* interface IBindCtx */
		/* [unique][uuid][object] */

		typedef /* [unique] */ IBindCtx* LPBC;

		typedef /* [unique] */ IBindCtx* LPBINDCTX;

		typedef struct tagBIND_OPTS
		{
			DWORD cbStruct;
			DWORD grfFlags;
			DWORD grfMode;
			DWORD dwTickCountDeadline;
		} 	BIND_OPTS;

		typedef struct tagBIND_OPTS* LPBIND_OPTS;

#if defined(__cplusplus)
		typedef struct tagBIND_OPTS2 : tagBIND_OPTS {
			DWORD           dwTrackFlags;
			DWORD           dwClassContext;
			LCID            locale;
			COSERVERINFO* pServerInfo;
		} BIND_OPTS2, * LPBIND_OPTS2;
#else
		typedef struct tagBIND_OPTS2
		{
			DWORD cbStruct;
			DWORD grfFlags;
			DWORD grfMode;
			DWORD dwTickCountDeadline;
			DWORD dwTrackFlags;
			DWORD dwClassContext;
			LCID locale;
			COSERVERINFO* pServerInfo;
		} 	BIND_OPTS2;

		typedef struct tagBIND_OPTS2* LPBIND_OPTS2;

#endif
		typedef
			enum tagBIND_FLAGS
		{
			BIND_MAYBOTHERUSER = 1,
			BIND_JUSTTESTEXISTENCE = 2
		} 	BIND_FLAGS;


		EXTERN_C const IID IID_IBindCtx;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("0000000e-0000-0000-C000-000000000046")
			IBindCtx : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE RegisterObjectBound(
				/* [unique][in] */ IUnknown * punk) = 0;

			virtual HRESULT STDMETHODCALLTYPE RevokeObjectBound(
				/* [unique][in] */ IUnknown* punk) = 0;

			virtual HRESULT STDMETHODCALLTYPE ReleaseBoundObjects(void) = 0;

			virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetBindOptions(
				/* [in] */ BIND_OPTS* pbindopts) = 0;

			virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetBindOptions(
				/* [out][in] */ BIND_OPTS* pbindopts) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetRunningObjectTable(
				/* [out] */ IRunningObjectTable** pprot) = 0;

			virtual HRESULT STDMETHODCALLTYPE RegisterObjectParam(
				/* [in] */ LPOLESTR pszKey,
				/* [unique][in] */ IUnknown* punk) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetObjectParam(
				/* [in] */ LPOLESTR pszKey,
				/* [out] */ IUnknown** ppunk) = 0;

			virtual HRESULT STDMETHODCALLTYPE EnumObjectParam(
				/* [out] */ IEnumString** ppenum) = 0;

			virtual HRESULT STDMETHODCALLTYPE RevokeObjectParam(
				/* [in] */ LPOLESTR pszKey) = 0;

		};

#else 	/* C style interface */

		typedef struct IBindCtxVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IBindCtx* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IBindCtx* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IBindCtx* This);

			HRESULT(STDMETHODCALLTYPE* RegisterObjectBound)(
				IBindCtx* This,
				/* [unique][in] */ IUnknown* punk);

			HRESULT(STDMETHODCALLTYPE* RevokeObjectBound)(
				IBindCtx* This,
				/* [unique][in] */ IUnknown* punk);

			HRESULT(STDMETHODCALLTYPE* ReleaseBoundObjects)(
				IBindCtx* This);

			/* [local] */ HRESULT(STDMETHODCALLTYPE* SetBindOptions)(
				IBindCtx* This,
				/* [in] */ BIND_OPTS* pbindopts);

			/* [local] */ HRESULT(STDMETHODCALLTYPE* GetBindOptions)(
				IBindCtx* This,
				/* [out][in] */ BIND_OPTS* pbindopts);

			HRESULT(STDMETHODCALLTYPE* GetRunningObjectTable)(
				IBindCtx* This,
				/* [out] */ IRunningObjectTable** pprot);

			HRESULT(STDMETHODCALLTYPE* RegisterObjectParam)(
				IBindCtx* This,
				/* [in] */ LPOLESTR pszKey,
				/* [unique][in] */ IUnknown* punk);

			HRESULT(STDMETHODCALLTYPE* GetObjectParam)(
				IBindCtx* This,
				/* [in] */ LPOLESTR pszKey,
				/* [out] */ IUnknown** ppunk);

			HRESULT(STDMETHODCALLTYPE* EnumObjectParam)(
				IBindCtx* This,
				/* [out] */ IEnumString** ppenum);

			HRESULT(STDMETHODCALLTYPE* RevokeObjectParam)(
				IBindCtx* This,
				/* [in] */ LPOLESTR pszKey);

			END_INTERFACE
		} IBindCtxVtbl;

		interface IBindCtx
		{
			CONST_VTBL struct IBindCtxVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IBindCtx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBindCtx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBindCtx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBindCtx_RegisterObjectBound(This,punk)	\
    (This)->lpVtbl -> RegisterObjectBound(This,punk)

#define IBindCtx_RevokeObjectBound(This,punk)	\
    (This)->lpVtbl -> RevokeObjectBound(This,punk)

#define IBindCtx_ReleaseBoundObjects(This)	\
    (This)->lpVtbl -> ReleaseBoundObjects(This)

#define IBindCtx_SetBindOptions(This,pbindopts)	\
    (This)->lpVtbl -> SetBindOptions(This,pbindopts)

#define IBindCtx_GetBindOptions(This,pbindopts)	\
    (This)->lpVtbl -> GetBindOptions(This,pbindopts)

#define IBindCtx_GetRunningObjectTable(This,pprot)	\
    (This)->lpVtbl -> GetRunningObjectTable(This,pprot)

#define IBindCtx_RegisterObjectParam(This,pszKey,punk)	\
    (This)->lpVtbl -> RegisterObjectParam(This,pszKey,punk)

#define IBindCtx_GetObjectParam(This,pszKey,ppunk)	\
    (This)->lpVtbl -> GetObjectParam(This,pszKey,ppunk)

#define IBindCtx_EnumObjectParam(This,ppenum)	\
    (This)->lpVtbl -> EnumObjectParam(This,ppenum)

#define IBindCtx_RevokeObjectParam(This,pszKey)	\
    (This)->lpVtbl -> RevokeObjectParam(This,pszKey)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IBindCtx_RegisterObjectBound_Proxy(
			IBindCtx* This,
			/* [unique][in] */ IUnknown* punk);


		void __RPC_STUB IBindCtx_RegisterObjectBound_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IBindCtx_RevokeObjectBound_Proxy(
			IBindCtx* This,
			/* [unique][in] */ IUnknown* punk);


		void __RPC_STUB IBindCtx_RevokeObjectBound_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IBindCtx_ReleaseBoundObjects_Proxy(
			IBindCtx* This);


		void __RPC_STUB IBindCtx_ReleaseBoundObjects_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindCtx_RemoteSetBindOptions_Proxy(
			IBindCtx* This,
			/* [in] */ BIND_OPTS2* pbindopts);


		void __RPC_STUB IBindCtx_RemoteSetBindOptions_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindCtx_RemoteGetBindOptions_Proxy(
			IBindCtx* This,
			/* [out][in] */ BIND_OPTS2* pbindopts);


		void __RPC_STUB IBindCtx_RemoteGetBindOptions_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IBindCtx_GetRunningObjectTable_Proxy(
			IBindCtx* This,
			/* [out] */ IRunningObjectTable** pprot);


		void __RPC_STUB IBindCtx_GetRunningObjectTable_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IBindCtx_RegisterObjectParam_Proxy(
			IBindCtx* This,
			/* [in] */ LPOLESTR pszKey,
			/* [unique][in] */ IUnknown* punk);


		void __RPC_STUB IBindCtx_RegisterObjectParam_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IBindCtx_GetObjectParam_Proxy(
			IBindCtx* This,
			/* [in] */ LPOLESTR pszKey,
			/* [out] */ IUnknown** ppunk);


		void __RPC_STUB IBindCtx_GetObjectParam_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IBindCtx_EnumObjectParam_Proxy(
			IBindCtx* This,
			/* [out] */ IEnumString** ppenum);


		void __RPC_STUB IBindCtx_EnumObjectParam_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IBindCtx_RevokeObjectParam_Proxy(
			IBindCtx* This,
			/* [in] */ LPOLESTR pszKey);


		void __RPC_STUB IBindCtx_RevokeObjectParam_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IBindCtx_INTERFACE_DEFINED__ */


#ifndef __IEnumMoniker_INTERFACE_DEFINED__
#define __IEnumMoniker_INTERFACE_DEFINED__

		/* interface IEnumMoniker */
		/* [unique][uuid][object] */

		typedef /* [unique] */ IEnumMoniker* LPENUMMONIKER;


		EXTERN_C const IID IID_IEnumMoniker;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000102-0000-0000-C000-000000000046")
			IEnumMoniker : public IUnknown
		{
		public:
			virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next(
				/* [in] */ ULONG celt,
				/* [length_is][size_is][out] */ IMoniker * *rgelt,
				/* [out] */ ULONG * pceltFetched) = 0;

			virtual HRESULT STDMETHODCALLTYPE Skip(
				/* [in] */ ULONG celt) = 0;

			virtual HRESULT STDMETHODCALLTYPE Reset(void) = 0;

			virtual HRESULT STDMETHODCALLTYPE Clone(
				/* [out] */ IEnumMoniker** ppenum) = 0;

		};

#else 	/* C style interface */

		typedef struct IEnumMonikerVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IEnumMoniker* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IEnumMoniker* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IEnumMoniker* This);

			/* [local] */ HRESULT(STDMETHODCALLTYPE* Next)(
				IEnumMoniker* This,
				/* [in] */ ULONG celt,
				/* [length_is][size_is][out] */ IMoniker** rgelt,
				/* [out] */ ULONG* pceltFetched);

			HRESULT(STDMETHODCALLTYPE* Skip)(
				IEnumMoniker* This,
				/* [in] */ ULONG celt);

			HRESULT(STDMETHODCALLTYPE* Reset)(
				IEnumMoniker* This);

			HRESULT(STDMETHODCALLTYPE* Clone)(
				IEnumMoniker* This,
				/* [out] */ IEnumMoniker** ppenum);

			END_INTERFACE
		} IEnumMonikerVtbl;

		interface IEnumMoniker
		{
			CONST_VTBL struct IEnumMonikerVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IEnumMoniker_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumMoniker_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumMoniker_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumMoniker_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumMoniker_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumMoniker_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumMoniker_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumMoniker_RemoteNext_Proxy(
			IEnumMoniker* This,
			/* [in] */ ULONG celt,
			/* [length_is][size_is][out] */ IMoniker** rgelt,
			/* [out] */ ULONG* pceltFetched);


		void __RPC_STUB IEnumMoniker_RemoteNext_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IEnumMoniker_Skip_Proxy(
			IEnumMoniker* This,
			/* [in] */ ULONG celt);


		void __RPC_STUB IEnumMoniker_Skip_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IEnumMoniker_Reset_Proxy(
			IEnumMoniker* This);


		void __RPC_STUB IEnumMoniker_Reset_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IEnumMoniker_Clone_Proxy(
			IEnumMoniker* This,
			/* [out] */ IEnumMoniker** ppenum);


		void __RPC_STUB IEnumMoniker_Clone_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IEnumMoniker_INTERFACE_DEFINED__ */


#ifndef __IRunnableObject_INTERFACE_DEFINED__
#define __IRunnableObject_INTERFACE_DEFINED__

		/* interface IRunnableObject */
		/* [uuid][object] */

		typedef /* [unique] */ IRunnableObject* LPRUNNABLEOBJECT;


		EXTERN_C const IID IID_IRunnableObject;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000126-0000-0000-C000-000000000046")
			IRunnableObject : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE GetRunningClass(
				/* [out] */ LPCLSID lpClsid) = 0;

			virtual HRESULT STDMETHODCALLTYPE Run(
				/* [in] */ LPBINDCTX pbc) = 0;

			virtual /* [local] */ BOOL STDMETHODCALLTYPE IsRunning(void) = 0;

			virtual HRESULT STDMETHODCALLTYPE LockRunning(
				/* [in] */ BOOL fLock,
				/* [in] */ BOOL fLastUnlockCloses) = 0;

			virtual HRESULT STDMETHODCALLTYPE SetContainedObject(
				/* [in] */ BOOL fContained) = 0;

		};

#else 	/* C style interface */

		typedef struct IRunnableObjectVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IRunnableObject* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IRunnableObject* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IRunnableObject* This);

			HRESULT(STDMETHODCALLTYPE* GetRunningClass)(
				IRunnableObject* This,
				/* [out] */ LPCLSID lpClsid);

			HRESULT(STDMETHODCALLTYPE* Run)(
				IRunnableObject* This,
				/* [in] */ LPBINDCTX pbc);

			/* [local] */ BOOL(STDMETHODCALLTYPE* IsRunning)(
				IRunnableObject* This);

			HRESULT(STDMETHODCALLTYPE* LockRunning)(
				IRunnableObject* This,
				/* [in] */ BOOL fLock,
				/* [in] */ BOOL fLastUnlockCloses);

			HRESULT(STDMETHODCALLTYPE* SetContainedObject)(
				IRunnableObject* This,
				/* [in] */ BOOL fContained);

			END_INTERFACE
		} IRunnableObjectVtbl;

		interface IRunnableObject
		{
			CONST_VTBL struct IRunnableObjectVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IRunnableObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRunnableObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRunnableObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRunnableObject_GetRunningClass(This,lpClsid)	\
    (This)->lpVtbl -> GetRunningClass(This,lpClsid)

#define IRunnableObject_Run(This,pbc)	\
    (This)->lpVtbl -> Run(This,pbc)

#define IRunnableObject_IsRunning(This)	\
    (This)->lpVtbl -> IsRunning(This)

#define IRunnableObject_LockRunning(This,fLock,fLastUnlockCloses)	\
    (This)->lpVtbl -> LockRunning(This,fLock,fLastUnlockCloses)

#define IRunnableObject_SetContainedObject(This,fContained)	\
    (This)->lpVtbl -> SetContainedObject(This,fContained)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IRunnableObject_GetRunningClass_Proxy(
			IRunnableObject* This,
			/* [out] */ LPCLSID lpClsid);


		void __RPC_STUB IRunnableObject_GetRunningClass_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IRunnableObject_Run_Proxy(
			IRunnableObject* This,
			/* [in] */ LPBINDCTX pbc);


		void __RPC_STUB IRunnableObject_Run_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IRunnableObject_RemoteIsRunning_Proxy(
			IRunnableObject* This);


		void __RPC_STUB IRunnableObject_RemoteIsRunning_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IRunnableObject_LockRunning_Proxy(
			IRunnableObject* This,
			/* [in] */ BOOL fLock,
			/* [in] */ BOOL fLastUnlockCloses);


		void __RPC_STUB IRunnableObject_LockRunning_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IRunnableObject_SetContainedObject_Proxy(
			IRunnableObject* This,
			/* [in] */ BOOL fContained);


		void __RPC_STUB IRunnableObject_SetContainedObject_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IRunnableObject_INTERFACE_DEFINED__ */


#ifndef __IRunningObjectTable_INTERFACE_DEFINED__
#define __IRunningObjectTable_INTERFACE_DEFINED__

		/* interface IRunningObjectTable */
		/* [uuid][object] */

		typedef /* [unique] */ IRunningObjectTable* LPRUNNINGOBJECTTABLE;


		EXTERN_C const IID IID_IRunningObjectTable;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000010-0000-0000-C000-000000000046")
			IRunningObjectTable : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE Register(
				/* [in] */ DWORD grfFlags,
				/* [unique][in] */ IUnknown * punkObject,
				/* [unique][in] */ IMoniker * pmkObjectName,
				/* [out] */ DWORD * pdwRegister) = 0;

			virtual HRESULT STDMETHODCALLTYPE Revoke(
				/* [in] */ DWORD dwRegister) = 0;

			virtual HRESULT STDMETHODCALLTYPE IsRunning(
				/* [unique][in] */ IMoniker* pmkObjectName) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetObject(
				/* [unique][in] */ IMoniker* pmkObjectName,
				/* [out] */ IUnknown** ppunkObject) = 0;

			virtual HRESULT STDMETHODCALLTYPE NoteChangeTime(
				/* [in] */ DWORD dwRegister,
				/* [in] */ FILETIME* pfiletime) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetTimeOfLastChange(
				/* [unique][in] */ IMoniker* pmkObjectName,
				/* [out] */ FILETIME* pfiletime) = 0;

			virtual HRESULT STDMETHODCALLTYPE EnumRunning(
				/* [out] */ IEnumMoniker** ppenumMoniker) = 0;

		};

#else 	/* C style interface */

		typedef struct IRunningObjectTableVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IRunningObjectTable* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IRunningObjectTable* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IRunningObjectTable* This);

			HRESULT(STDMETHODCALLTYPE* Register)(
				IRunningObjectTable* This,
				/* [in] */ DWORD grfFlags,
				/* [unique][in] */ IUnknown* punkObject,
				/* [unique][in] */ IMoniker* pmkObjectName,
				/* [out] */ DWORD* pdwRegister);

			HRESULT(STDMETHODCALLTYPE* Revoke)(
				IRunningObjectTable* This,
				/* [in] */ DWORD dwRegister);

			HRESULT(STDMETHODCALLTYPE* IsRunning)(
				IRunningObjectTable* This,
				/* [unique][in] */ IMoniker* pmkObjectName);

			HRESULT(STDMETHODCALLTYPE* GetObject)(
				IRunningObjectTable* This,
				/* [unique][in] */ IMoniker* pmkObjectName,
				/* [out] */ IUnknown** ppunkObject);

			HRESULT(STDMETHODCALLTYPE* NoteChangeTime)(
				IRunningObjectTable* This,
				/* [in] */ DWORD dwRegister,
				/* [in] */ FILETIME* pfiletime);

			HRESULT(STDMETHODCALLTYPE* GetTimeOfLastChange)(
				IRunningObjectTable* This,
				/* [unique][in] */ IMoniker* pmkObjectName,
				/* [out] */ FILETIME* pfiletime);

			HRESULT(STDMETHODCALLTYPE* EnumRunning)(
				IRunningObjectTable* This,
				/* [out] */ IEnumMoniker** ppenumMoniker);

			END_INTERFACE
		} IRunningObjectTableVtbl;

		interface IRunningObjectTable
		{
			CONST_VTBL struct IRunningObjectTableVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IRunningObjectTable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRunningObjectTable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRunningObjectTable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRunningObjectTable_Register(This,grfFlags,punkObject,pmkObjectName,pdwRegister)	\
    (This)->lpVtbl -> Register(This,grfFlags,punkObject,pmkObjectName,pdwRegister)

#define IRunningObjectTable_Revoke(This,dwRegister)	\
    (This)->lpVtbl -> Revoke(This,dwRegister)

#define IRunningObjectTable_IsRunning(This,pmkObjectName)	\
    (This)->lpVtbl -> IsRunning(This,pmkObjectName)

#define IRunningObjectTable_GetObject(This,pmkObjectName,ppunkObject)	\
    (This)->lpVtbl -> GetObject(This,pmkObjectName,ppunkObject)

#define IRunningObjectTable_NoteChangeTime(This,dwRegister,pfiletime)	\
    (This)->lpVtbl -> NoteChangeTime(This,dwRegister,pfiletime)

#define IRunningObjectTable_GetTimeOfLastChange(This,pmkObjectName,pfiletime)	\
    (This)->lpVtbl -> GetTimeOfLastChange(This,pmkObjectName,pfiletime)

#define IRunningObjectTable_EnumRunning(This,ppenumMoniker)	\
    (This)->lpVtbl -> EnumRunning(This,ppenumMoniker)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IRunningObjectTable_Register_Proxy(
			IRunningObjectTable* This,
			/* [in] */ DWORD grfFlags,
			/* [unique][in] */ IUnknown* punkObject,
			/* [unique][in] */ IMoniker* pmkObjectName,
			/* [out] */ DWORD* pdwRegister);


		void __RPC_STUB IRunningObjectTable_Register_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IRunningObjectTable_Revoke_Proxy(
			IRunningObjectTable* This,
			/* [in] */ DWORD dwRegister);


		void __RPC_STUB IRunningObjectTable_Revoke_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IRunningObjectTable_IsRunning_Proxy(
			IRunningObjectTable* This,
			/* [unique][in] */ IMoniker* pmkObjectName);


		void __RPC_STUB IRunningObjectTable_IsRunning_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IRunningObjectTable_GetObject_Proxy(
			IRunningObjectTable* This,
			/* [unique][in] */ IMoniker* pmkObjectName,
			/* [out] */ IUnknown** ppunkObject);


		void __RPC_STUB IRunningObjectTable_GetObject_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IRunningObjectTable_NoteChangeTime_Proxy(
			IRunningObjectTable* This,
			/* [in] */ DWORD dwRegister,
			/* [in] */ FILETIME* pfiletime);


		void __RPC_STUB IRunningObjectTable_NoteChangeTime_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IRunningObjectTable_GetTimeOfLastChange_Proxy(
			IRunningObjectTable* This,
			/* [unique][in] */ IMoniker* pmkObjectName,
			/* [out] */ FILETIME* pfiletime);


		void __RPC_STUB IRunningObjectTable_GetTimeOfLastChange_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IRunningObjectTable_EnumRunning_Proxy(
			IRunningObjectTable* This,
			/* [out] */ IEnumMoniker** ppenumMoniker);


		void __RPC_STUB IRunningObjectTable_EnumRunning_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IRunningObjectTable_INTERFACE_DEFINED__ */


#ifndef __IPersist_INTERFACE_DEFINED__
#define __IPersist_INTERFACE_DEFINED__

		/* interface IPersist */
		/* [uuid][object] */

		typedef /* [unique] */ IPersist* LPPERSIST;


		EXTERN_C const IID IID_IPersist;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("0000010c-0000-0000-C000-000000000046")
			IPersist : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE GetClassID(
				/* [out] */ CLSID * pClassID) = 0;

		};

#else 	/* C style interface */

		typedef struct IPersistVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IPersist* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IPersist* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IPersist* This);

			HRESULT(STDMETHODCALLTYPE* GetClassID)(
				IPersist* This,
				/* [out] */ CLSID* pClassID);

			END_INTERFACE
		} IPersistVtbl;

		interface IPersist
		{
			CONST_VTBL struct IPersistVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IPersist_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPersist_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPersist_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPersist_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IPersist_GetClassID_Proxy(
			IPersist* This,
			/* [out] */ CLSID* pClassID);


		void __RPC_STUB IPersist_GetClassID_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IPersist_INTERFACE_DEFINED__ */


#ifndef __IPersistStream_INTERFACE_DEFINED__
#define __IPersistStream_INTERFACE_DEFINED__

		/* interface IPersistStream */
		/* [unique][uuid][object] */

		typedef /* [unique] */ IPersistStream* LPPERSISTSTREAM;


		EXTERN_C const IID IID_IPersistStream;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000109-0000-0000-C000-000000000046")
			IPersistStream : public IPersist
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE IsDirty(void) = 0;

			virtual HRESULT STDMETHODCALLTYPE Load(
				/* [unique][in] */ IStream* pStm) = 0;

			virtual HRESULT STDMETHODCALLTYPE Save(
				/* [unique][in] */ IStream* pStm,
				/* [in] */ BOOL fClearDirty) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetSizeMax(
				/* [out] */ ULARGE_INTEGER* pcbSize) = 0;

		};

#else 	/* C style interface */

		typedef struct IPersistStreamVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IPersistStream* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IPersistStream* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IPersistStream* This);

			HRESULT(STDMETHODCALLTYPE* GetClassID)(
				IPersistStream* This,
				/* [out] */ CLSID* pClassID);

			HRESULT(STDMETHODCALLTYPE* IsDirty)(
				IPersistStream* This);

			HRESULT(STDMETHODCALLTYPE* Load)(
				IPersistStream* This,
				/* [unique][in] */ IStream* pStm);

			HRESULT(STDMETHODCALLTYPE* Save)(
				IPersistStream* This,
				/* [unique][in] */ IStream* pStm,
				/* [in] */ BOOL fClearDirty);

			HRESULT(STDMETHODCALLTYPE* GetSizeMax)(
				IPersistStream* This,
				/* [out] */ ULARGE_INTEGER* pcbSize);

			END_INTERFACE
		} IPersistStreamVtbl;

		interface IPersistStream
		{
			CONST_VTBL struct IPersistStreamVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IPersistStream_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPersistStream_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPersistStream_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPersistStream_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IPersistStream_IsDirty(This)	\
    (This)->lpVtbl -> IsDirty(This)

#define IPersistStream_Load(This,pStm)	\
    (This)->lpVtbl -> Load(This,pStm)

#define IPersistStream_Save(This,pStm,fClearDirty)	\
    (This)->lpVtbl -> Save(This,pStm,fClearDirty)

#define IPersistStream_GetSizeMax(This,pcbSize)	\
    (This)->lpVtbl -> GetSizeMax(This,pcbSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IPersistStream_IsDirty_Proxy(
			IPersistStream* This);


		void __RPC_STUB IPersistStream_IsDirty_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPersistStream_Load_Proxy(
			IPersistStream* This,
			/* [unique][in] */ IStream* pStm);


		void __RPC_STUB IPersistStream_Load_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPersistStream_Save_Proxy(
			IPersistStream* This,
			/* [unique][in] */ IStream* pStm,
			/* [in] */ BOOL fClearDirty);


		void __RPC_STUB IPersistStream_Save_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPersistStream_GetSizeMax_Proxy(
			IPersistStream* This,
			/* [out] */ ULARGE_INTEGER* pcbSize);


		void __RPC_STUB IPersistStream_GetSizeMax_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IPersistStream_INTERFACE_DEFINED__ */


#ifndef __IMoniker_INTERFACE_DEFINED__
#define __IMoniker_INTERFACE_DEFINED__

		/* interface IMoniker */
		/* [unique][uuid][object] */

		typedef /* [unique] */ IMoniker* LPMONIKER;

		typedef
			enum tagMKSYS
		{
			MKSYS_NONE = 0,
			MKSYS_GENERICCOMPOSITE = 1,
			MKSYS_FILEMONIKER = 2,
			MKSYS_ANTIMONIKER = 3,
			MKSYS_ITEMMONIKER = 4,
			MKSYS_POINTERMONIKER = 5,
			MKSYS_CLASSMONIKER = 7,
			MKSYS_OBJREFMONIKER = 8,
			MKSYS_SESSIONMONIKER = 9
		} 	MKSYS;

		typedef /* [v1_enum] */
			enum tagMKREDUCE
		{
			MKRREDUCE_ONE = 3 << 16,
			MKRREDUCE_TOUSER = 2 << 16,
			MKRREDUCE_THROUGHUSER = 1 << 16,
			MKRREDUCE_ALL = 0
		} 	MKRREDUCE;


		EXTERN_C const IID IID_IMoniker;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("0000000f-0000-0000-C000-000000000046")
			IMoniker : public IPersistStream
		{
		public:
			virtual /* [local] */ HRESULT STDMETHODCALLTYPE BindToObject(
				/* [unique][in] */ IBindCtx * pbc,
				/* [unique][in] */ IMoniker * pmkToLeft,
				/* [in] */ REFIID riidResult,
				/* [iid_is][out] */ void** ppvResult) = 0;

			virtual /* [local] */ HRESULT STDMETHODCALLTYPE BindToStorage(
				/* [unique][in] */ IBindCtx* pbc,
				/* [unique][in] */ IMoniker* pmkToLeft,
				/* [in] */ REFIID riid,
				/* [iid_is][out] */ void** ppvObj) = 0;

			virtual HRESULT STDMETHODCALLTYPE Reduce(
				/* [unique][in] */ IBindCtx* pbc,
				/* [in] */ DWORD dwReduceHowFar,
				/* [unique][out][in] */ IMoniker** ppmkToLeft,
				/* [out] */ IMoniker** ppmkReduced) = 0;

			virtual HRESULT STDMETHODCALLTYPE ComposeWith(
				/* [unique][in] */ IMoniker* pmkRight,
				/* [in] */ BOOL fOnlyIfNotGeneric,
				/* [out] */ IMoniker** ppmkComposite) = 0;

			virtual HRESULT STDMETHODCALLTYPE Enum(
				/* [in] */ BOOL fForward,
				/* [out] */ IEnumMoniker** ppenumMoniker) = 0;

			virtual HRESULT STDMETHODCALLTYPE IsEqual(
				/* [unique][in] */ IMoniker* pmkOtherMoniker) = 0;

			virtual HRESULT STDMETHODCALLTYPE Hash(
				/* [out] */ DWORD* pdwHash) = 0;

			virtual HRESULT STDMETHODCALLTYPE IsRunning(
				/* [unique][in] */ IBindCtx* pbc,
				/* [unique][in] */ IMoniker* pmkToLeft,
				/* [unique][in] */ IMoniker* pmkNewlyRunning) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetTimeOfLastChange(
				/* [unique][in] */ IBindCtx* pbc,
				/* [unique][in] */ IMoniker* pmkToLeft,
				/* [out] */ FILETIME* pFileTime) = 0;

			virtual HRESULT STDMETHODCALLTYPE Inverse(
				/* [out] */ IMoniker** ppmk) = 0;

			virtual HRESULT STDMETHODCALLTYPE CommonPrefixWith(
				/* [unique][in] */ IMoniker* pmkOther,
				/* [out] */ IMoniker** ppmkPrefix) = 0;

			virtual HRESULT STDMETHODCALLTYPE RelativePathTo(
				/* [unique][in] */ IMoniker* pmkOther,
				/* [out] */ IMoniker** ppmkRelPath) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetDisplayName(
				/* [unique][in] */ IBindCtx* pbc,
				/* [unique][in] */ IMoniker* pmkToLeft,
				/* [out] */ LPOLESTR* ppszDisplayName) = 0;

			virtual HRESULT STDMETHODCALLTYPE ParseDisplayName(
				/* [unique][in] */ IBindCtx* pbc,
				/* [unique][in] */ IMoniker* pmkToLeft,
				/* [in] */ LPOLESTR pszDisplayName,
				/* [out] */ ULONG* pchEaten,
				/* [out] */ IMoniker** ppmkOut) = 0;

			virtual HRESULT STDMETHODCALLTYPE IsSystemMoniker(
				/* [out] */ DWORD* pdwMksys) = 0;

		};

#else 	/* C style interface */

		typedef struct IMonikerVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IMoniker* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IMoniker* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IMoniker* This);

			HRESULT(STDMETHODCALLTYPE* GetClassID)(
				IMoniker* This,
				/* [out] */ CLSID* pClassID);

			HRESULT(STDMETHODCALLTYPE* IsDirty)(
				IMoniker* This);

			HRESULT(STDMETHODCALLTYPE* Load)(
				IMoniker* This,
				/* [unique][in] */ IStream* pStm);

			HRESULT(STDMETHODCALLTYPE* Save)(
				IMoniker* This,
				/* [unique][in] */ IStream* pStm,
				/* [in] */ BOOL fClearDirty);

			HRESULT(STDMETHODCALLTYPE* GetSizeMax)(
				IMoniker* This,
				/* [out] */ ULARGE_INTEGER* pcbSize);

			/* [local] */ HRESULT(STDMETHODCALLTYPE* BindToObject)(
				IMoniker* This,
				/* [unique][in] */ IBindCtx* pbc,
				/* [unique][in] */ IMoniker* pmkToLeft,
				/* [in] */ REFIID riidResult,
				/* [iid_is][out] */ void** ppvResult);

			/* [local] */ HRESULT(STDMETHODCALLTYPE* BindToStorage)(
				IMoniker* This,
				/* [unique][in] */ IBindCtx* pbc,
				/* [unique][in] */ IMoniker* pmkToLeft,
				/* [in] */ REFIID riid,
				/* [iid_is][out] */ void** ppvObj);

			HRESULT(STDMETHODCALLTYPE* Reduce)(
				IMoniker* This,
				/* [unique][in] */ IBindCtx* pbc,
				/* [in] */ DWORD dwReduceHowFar,
				/* [unique][out][in] */ IMoniker** ppmkToLeft,
				/* [out] */ IMoniker** ppmkReduced);

			HRESULT(STDMETHODCALLTYPE* ComposeWith)(
				IMoniker* This,
				/* [unique][in] */ IMoniker* pmkRight,
				/* [in] */ BOOL fOnlyIfNotGeneric,
				/* [out] */ IMoniker** ppmkComposite);

			HRESULT(STDMETHODCALLTYPE* Enum)(
				IMoniker* This,
				/* [in] */ BOOL fForward,
				/* [out] */ IEnumMoniker** ppenumMoniker);

			HRESULT(STDMETHODCALLTYPE* IsEqual)(
				IMoniker* This,
				/* [unique][in] */ IMoniker* pmkOtherMoniker);

			HRESULT(STDMETHODCALLTYPE* Hash)(
				IMoniker* This,
				/* [out] */ DWORD* pdwHash);

			HRESULT(STDMETHODCALLTYPE* IsRunning)(
				IMoniker* This,
				/* [unique][in] */ IBindCtx* pbc,
				/* [unique][in] */ IMoniker* pmkToLeft,
				/* [unique][in] */ IMoniker* pmkNewlyRunning);

			HRESULT(STDMETHODCALLTYPE* GetTimeOfLastChange)(
				IMoniker* This,
				/* [unique][in] */ IBindCtx* pbc,
				/* [unique][in] */ IMoniker* pmkToLeft,
				/* [out] */ FILETIME* pFileTime);

			HRESULT(STDMETHODCALLTYPE* Inverse)(
				IMoniker* This,
				/* [out] */ IMoniker** ppmk);

			HRESULT(STDMETHODCALLTYPE* CommonPrefixWith)(
				IMoniker* This,
				/* [unique][in] */ IMoniker* pmkOther,
				/* [out] */ IMoniker** ppmkPrefix);

			HRESULT(STDMETHODCALLTYPE* RelativePathTo)(
				IMoniker* This,
				/* [unique][in] */ IMoniker* pmkOther,
				/* [out] */ IMoniker** ppmkRelPath);

			HRESULT(STDMETHODCALLTYPE* GetDisplayName)(
				IMoniker* This,
				/* [unique][in] */ IBindCtx* pbc,
				/* [unique][in] */ IMoniker* pmkToLeft,
				/* [out] */ LPOLESTR* ppszDisplayName);

			HRESULT(STDMETHODCALLTYPE* ParseDisplayName)(
				IMoniker* This,
				/* [unique][in] */ IBindCtx* pbc,
				/* [unique][in] */ IMoniker* pmkToLeft,
				/* [in] */ LPOLESTR pszDisplayName,
				/* [out] */ ULONG* pchEaten,
				/* [out] */ IMoniker** ppmkOut);

			HRESULT(STDMETHODCALLTYPE* IsSystemMoniker)(
				IMoniker* This,
				/* [out] */ DWORD* pdwMksys);

			END_INTERFACE
		} IMonikerVtbl;

		interface IMoniker
		{
			CONST_VTBL struct IMonikerVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IMoniker_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMoniker_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMoniker_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMoniker_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IMoniker_IsDirty(This)	\
    (This)->lpVtbl -> IsDirty(This)

#define IMoniker_Load(This,pStm)	\
    (This)->lpVtbl -> Load(This,pStm)

#define IMoniker_Save(This,pStm,fClearDirty)	\
    (This)->lpVtbl -> Save(This,pStm,fClearDirty)

#define IMoniker_GetSizeMax(This,pcbSize)	\
    (This)->lpVtbl -> GetSizeMax(This,pcbSize)


#define IMoniker_BindToObject(This,pbc,pmkToLeft,riidResult,ppvResult)	\
    (This)->lpVtbl -> BindToObject(This,pbc,pmkToLeft,riidResult,ppvResult)

#define IMoniker_BindToStorage(This,pbc,pmkToLeft,riid,ppvObj)	\
    (This)->lpVtbl -> BindToStorage(This,pbc,pmkToLeft,riid,ppvObj)

#define IMoniker_Reduce(This,pbc,dwReduceHowFar,ppmkToLeft,ppmkReduced)	\
    (This)->lpVtbl -> Reduce(This,pbc,dwReduceHowFar,ppmkToLeft,ppmkReduced)

#define IMoniker_ComposeWith(This,pmkRight,fOnlyIfNotGeneric,ppmkComposite)	\
    (This)->lpVtbl -> ComposeWith(This,pmkRight,fOnlyIfNotGeneric,ppmkComposite)

#define IMoniker_Enum(This,fForward,ppenumMoniker)	\
    (This)->lpVtbl -> Enum(This,fForward,ppenumMoniker)

#define IMoniker_IsEqual(This,pmkOtherMoniker)	\
    (This)->lpVtbl -> IsEqual(This,pmkOtherMoniker)

#define IMoniker_Hash(This,pdwHash)	\
    (This)->lpVtbl -> Hash(This,pdwHash)

#define IMoniker_IsRunning(This,pbc,pmkToLeft,pmkNewlyRunning)	\
    (This)->lpVtbl -> IsRunning(This,pbc,pmkToLeft,pmkNewlyRunning)

#define IMoniker_GetTimeOfLastChange(This,pbc,pmkToLeft,pFileTime)	\
    (This)->lpVtbl -> GetTimeOfLastChange(This,pbc,pmkToLeft,pFileTime)

#define IMoniker_Inverse(This,ppmk)	\
    (This)->lpVtbl -> Inverse(This,ppmk)

#define IMoniker_CommonPrefixWith(This,pmkOther,ppmkPrefix)	\
    (This)->lpVtbl -> CommonPrefixWith(This,pmkOther,ppmkPrefix)

#define IMoniker_RelativePathTo(This,pmkOther,ppmkRelPath)	\
    (This)->lpVtbl -> RelativePathTo(This,pmkOther,ppmkRelPath)

#define IMoniker_GetDisplayName(This,pbc,pmkToLeft,ppszDisplayName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbc,pmkToLeft,ppszDisplayName)

#define IMoniker_ParseDisplayName(This,pbc,pmkToLeft,pszDisplayName,pchEaten,ppmkOut)	\
    (This)->lpVtbl -> ParseDisplayName(This,pbc,pmkToLeft,pszDisplayName,pchEaten,ppmkOut)

#define IMoniker_IsSystemMoniker(This,pdwMksys)	\
    (This)->lpVtbl -> IsSystemMoniker(This,pdwMksys)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		/* [call_as] */ HRESULT STDMETHODCALLTYPE IMoniker_RemoteBindToObject_Proxy(
			IMoniker* This,
			/* [unique][in] */ IBindCtx* pbc,
			/* [unique][in] */ IMoniker* pmkToLeft,
			/* [in] */ REFIID riidResult,
			/* [iid_is][out] */ IUnknown** ppvResult);


		void __RPC_STUB IMoniker_RemoteBindToObject_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IMoniker_RemoteBindToStorage_Proxy(
			IMoniker* This,
			/* [unique][in] */ IBindCtx* pbc,
			/* [unique][in] */ IMoniker* pmkToLeft,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ IUnknown** ppvObj);


		void __RPC_STUB IMoniker_RemoteBindToStorage_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IMoniker_Reduce_Proxy(
			IMoniker* This,
			/* [unique][in] */ IBindCtx* pbc,
			/* [in] */ DWORD dwReduceHowFar,
			/* [unique][out][in] */ IMoniker** ppmkToLeft,
			/* [out] */ IMoniker** ppmkReduced);


		void __RPC_STUB IMoniker_Reduce_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IMoniker_ComposeWith_Proxy(
			IMoniker* This,
			/* [unique][in] */ IMoniker* pmkRight,
			/* [in] */ BOOL fOnlyIfNotGeneric,
			/* [out] */ IMoniker** ppmkComposite);


		void __RPC_STUB IMoniker_ComposeWith_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IMoniker_Enum_Proxy(
			IMoniker* This,
			/* [in] */ BOOL fForward,
			/* [out] */ IEnumMoniker** ppenumMoniker);


		void __RPC_STUB IMoniker_Enum_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IMoniker_IsEqual_Proxy(
			IMoniker* This,
			/* [unique][in] */ IMoniker* pmkOtherMoniker);


		void __RPC_STUB IMoniker_IsEqual_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IMoniker_Hash_Proxy(
			IMoniker* This,
			/* [out] */ DWORD* pdwHash);


		void __RPC_STUB IMoniker_Hash_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IMoniker_IsRunning_Proxy(
			IMoniker* This,
			/* [unique][in] */ IBindCtx* pbc,
			/* [unique][in] */ IMoniker* pmkToLeft,
			/* [unique][in] */ IMoniker* pmkNewlyRunning);


		void __RPC_STUB IMoniker_IsRunning_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IMoniker_GetTimeOfLastChange_Proxy(
			IMoniker* This,
			/* [unique][in] */ IBindCtx* pbc,
			/* [unique][in] */ IMoniker* pmkToLeft,
			/* [out] */ FILETIME* pFileTime);


		void __RPC_STUB IMoniker_GetTimeOfLastChange_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IMoniker_Inverse_Proxy(
			IMoniker* This,
			/* [out] */ IMoniker** ppmk);


		void __RPC_STUB IMoniker_Inverse_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IMoniker_CommonPrefixWith_Proxy(
			IMoniker* This,
			/* [unique][in] */ IMoniker* pmkOther,
			/* [out] */ IMoniker** ppmkPrefix);


		void __RPC_STUB IMoniker_CommonPrefixWith_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IMoniker_RelativePathTo_Proxy(
			IMoniker* This,
			/* [unique][in] */ IMoniker* pmkOther,
			/* [out] */ IMoniker** ppmkRelPath);


		void __RPC_STUB IMoniker_RelativePathTo_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IMoniker_GetDisplayName_Proxy(
			IMoniker* This,
			/* [unique][in] */ IBindCtx* pbc,
			/* [unique][in] */ IMoniker* pmkToLeft,
			/* [out] */ LPOLESTR* ppszDisplayName);


		void __RPC_STUB IMoniker_GetDisplayName_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IMoniker_ParseDisplayName_Proxy(
			IMoniker* This,
			/* [unique][in] */ IBindCtx* pbc,
			/* [unique][in] */ IMoniker* pmkToLeft,
			/* [in] */ LPOLESTR pszDisplayName,
			/* [out] */ ULONG* pchEaten,
			/* [out] */ IMoniker** ppmkOut);


		void __RPC_STUB IMoniker_ParseDisplayName_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IMoniker_IsSystemMoniker_Proxy(
			IMoniker* This,
			/* [out] */ DWORD* pdwMksys);


		void __RPC_STUB IMoniker_IsSystemMoniker_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IMoniker_INTERFACE_DEFINED__ */


#ifndef __IROTData_INTERFACE_DEFINED__
#define __IROTData_INTERFACE_DEFINED__

		/* interface IROTData */
		/* [unique][uuid][object] */


		EXTERN_C const IID IID_IROTData;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("f29f6bc0-5021-11ce-aa15-00006901293f")
			IROTData : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE GetComparisonData(
				/* [size_is][out] */ byte * pbData,
				/* [in] */ ULONG cbMax,
				/* [out] */ ULONG * pcbData) = 0;

		};

#else 	/* C style interface */

		typedef struct IROTDataVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IROTData* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IROTData* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IROTData* This);

			HRESULT(STDMETHODCALLTYPE* GetComparisonData)(
				IROTData* This,
				/* [size_is][out] */ byte* pbData,
				/* [in] */ ULONG cbMax,
				/* [out] */ ULONG* pcbData);

			END_INTERFACE
		} IROTDataVtbl;

		interface IROTData
		{
			CONST_VTBL struct IROTDataVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IROTData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IROTData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IROTData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IROTData_GetComparisonData(This,pbData,cbMax,pcbData)	\
    (This)->lpVtbl -> GetComparisonData(This,pbData,cbMax,pcbData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IROTData_GetComparisonData_Proxy(
			IROTData* This,
			/* [size_is][out] */ byte* pbData,
			/* [in] */ ULONG cbMax,
			/* [out] */ ULONG* pcbData);


		void __RPC_STUB IROTData_GetComparisonData_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IROTData_INTERFACE_DEFINED__ */


#ifndef __IEnumString_INTERFACE_DEFINED__
#define __IEnumString_INTERFACE_DEFINED__

		/* interface IEnumString */
		/* [unique][uuid][object] */

		typedef /* [unique] */ IEnumString* LPENUMSTRING;


		EXTERN_C const IID IID_IEnumString;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000101-0000-0000-C000-000000000046")
			IEnumString : public IUnknown
		{
		public:
			virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next(
				/* [in] */ ULONG celt,
				/* [length_is][size_is][out] */ LPOLESTR * rgelt,
				/* [out] */ ULONG * pceltFetched) = 0;

			virtual HRESULT STDMETHODCALLTYPE Skip(
				/* [in] */ ULONG celt) = 0;

			virtual HRESULT STDMETHODCALLTYPE Reset(void) = 0;

			virtual HRESULT STDMETHODCALLTYPE Clone(
				/* [out] */ IEnumString** ppenum) = 0;

		};

#else 	/* C style interface */

		typedef struct IEnumStringVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IEnumString* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IEnumString* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IEnumString* This);

			/* [local] */ HRESULT(STDMETHODCALLTYPE* Next)(
				IEnumString* This,
				/* [in] */ ULONG celt,
				/* [length_is][size_is][out] */ LPOLESTR* rgelt,
				/* [out] */ ULONG* pceltFetched);

			HRESULT(STDMETHODCALLTYPE* Skip)(
				IEnumString* This,
				/* [in] */ ULONG celt);

			HRESULT(STDMETHODCALLTYPE* Reset)(
				IEnumString* This);

			HRESULT(STDMETHODCALLTYPE* Clone)(
				IEnumString* This,
				/* [out] */ IEnumString** ppenum);

			END_INTERFACE
		} IEnumStringVtbl;

		interface IEnumString
		{
			CONST_VTBL struct IEnumStringVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IEnumString_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumString_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumString_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumString_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumString_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumString_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumString_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumString_RemoteNext_Proxy(
			IEnumString* This,
			/* [in] */ ULONG celt,
			/* [length_is][size_is][out] */ LPOLESTR* rgelt,
			/* [out] */ ULONG* pceltFetched);


		void __RPC_STUB IEnumString_RemoteNext_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IEnumString_Skip_Proxy(
			IEnumString* This,
			/* [in] */ ULONG celt);


		void __RPC_STUB IEnumString_Skip_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IEnumString_Reset_Proxy(
			IEnumString* This);


		void __RPC_STUB IEnumString_Reset_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IEnumString_Clone_Proxy(
			IEnumString* This,
			/* [out] */ IEnumString** ppenum);


		void __RPC_STUB IEnumString_Clone_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IEnumString_INTERFACE_DEFINED__ */


#ifndef __ISequentialStream_INTERFACE_DEFINED__
#define __ISequentialStream_INTERFACE_DEFINED__

		/* interface ISequentialStream */
		/* [unique][uuid][object] */


		EXTERN_C const IID IID_ISequentialStream;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("0c733a30-2a1c-11ce-ade5-00aa0044773d")
			ISequentialStream : public IUnknown
		{
		public:
			virtual /* [local] */ HRESULT STDMETHODCALLTYPE Read(
				/* [length_is][size_is][out] */ void* pv,
				/* [in] */ ULONG cb,
				/* [out] */ ULONG * pcbRead) = 0;

			virtual /* [local] */ HRESULT STDMETHODCALLTYPE Write(
				/* [size_is][in] */ const void* pv,
				/* [in] */ ULONG cb,
				/* [out] */ ULONG* pcbWritten) = 0;

		};

#else 	/* C style interface */

		typedef struct ISequentialStreamVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					ISequentialStream* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				ISequentialStream* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				ISequentialStream* This);

			/* [local] */ HRESULT(STDMETHODCALLTYPE* Read)(
				ISequentialStream* This,
				/* [length_is][size_is][out] */ void* pv,
				/* [in] */ ULONG cb,
				/* [out] */ ULONG* pcbRead);

			/* [local] */ HRESULT(STDMETHODCALLTYPE* Write)(
				ISequentialStream* This,
				/* [size_is][in] */ const void* pv,
				/* [in] */ ULONG cb,
				/* [out] */ ULONG* pcbWritten);

			END_INTERFACE
		} ISequentialStreamVtbl;

		interface ISequentialStream
		{
			CONST_VTBL struct ISequentialStreamVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define ISequentialStream_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISequentialStream_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISequentialStream_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISequentialStream_Read(This,pv,cb,pcbRead)	\
    (This)->lpVtbl -> Read(This,pv,cb,pcbRead)

#define ISequentialStream_Write(This,pv,cb,pcbWritten)	\
    (This)->lpVtbl -> Write(This,pv,cb,pcbWritten)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		/* [call_as] */ HRESULT STDMETHODCALLTYPE ISequentialStream_RemoteRead_Proxy(
			ISequentialStream* This,
			/* [length_is][size_is][out] */ byte* pv,
			/* [in] */ ULONG cb,
			/* [out] */ ULONG* pcbRead);


		void __RPC_STUB ISequentialStream_RemoteRead_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE ISequentialStream_RemoteWrite_Proxy(
			ISequentialStream* This,
			/* [size_is][in] */ const byte* pv,
			/* [in] */ ULONG cb,
			/* [out] */ ULONG* pcbWritten);


		void __RPC_STUB ISequentialStream_RemoteWrite_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __ISequentialStream_INTERFACE_DEFINED__ */


#ifndef __IStream_INTERFACE_DEFINED__
#define __IStream_INTERFACE_DEFINED__

		/* interface IStream */
		/* [unique][uuid][object] */

		typedef /* [unique] */ IStream* LPSTREAM;

		//FSSpec is Macintosh only, defined in macos\files.h
#ifdef _MAC
		typedef struct tagSTATSTG
		{
			LPOLESTR pwcsName;
			FSSpec* pspec;
			DWORD type;
			ULARGE_INTEGER cbSize;
			FILETIME mtime;
			FILETIME ctime;
			FILETIME atime;
			DWORD grfMode;
			DWORD grfLocksSupported;
			CLSID clsid;
			DWORD grfStateBits;
			DWORD reserved;
		} STATSTG;
#else //_MAC
		typedef struct tagSTATSTG
		{
			LPOLESTR pwcsName;
			DWORD type;
			ULARGE_INTEGER cbSize;
			FILETIME mtime;
			FILETIME ctime;
			FILETIME atime;
			DWORD grfMode;
			DWORD grfLocksSupported;
			CLSID clsid;
			DWORD grfStateBits;
			DWORD reserved;
		} 	STATSTG;

#endif //_MAC
		typedef
			enum tagSTGTY
		{
			STGTY_STORAGE = 1,
			STGTY_STREAM = 2,
			STGTY_LOCKBYTES = 3,
			STGTY_PROPERTY = 4
		} 	STGTY;

		typedef
			enum tagSTREAM_SEEK
		{
			STREAM_SEEK_SET = 0,
			STREAM_SEEK_CUR = 1,
			STREAM_SEEK_END = 2
		} 	STREAM_SEEK;

		typedef
			enum tagLOCKTYPE
		{
			LOCK_WRITE = 1,
			LOCK_EXCLUSIVE = 2,
			LOCK_ONLYONCE = 4
		} 	LOCKTYPE;


		EXTERN_C const IID IID_IStream;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("0000000c-0000-0000-C000-000000000046")
			IStream : public ISequentialStream
		{
		public:
			virtual /* [local] */ HRESULT STDMETHODCALLTYPE Seek(
				/* [in] */ LARGE_INTEGER dlibMove,
				/* [in] */ DWORD dwOrigin,
				/* [out] */ ULARGE_INTEGER * plibNewPosition) = 0;

			virtual HRESULT STDMETHODCALLTYPE SetSize(
				/* [in] */ ULARGE_INTEGER libNewSize) = 0;

			virtual /* [local] */ HRESULT STDMETHODCALLTYPE CopyTo(
				/* [unique][in] */ IStream* pstm,
				/* [in] */ ULARGE_INTEGER cb,
				/* [out] */ ULARGE_INTEGER* pcbRead,
				/* [out] */ ULARGE_INTEGER* pcbWritten) = 0;

			virtual HRESULT STDMETHODCALLTYPE Commit(
				/* [in] */ DWORD grfCommitFlags) = 0;

			virtual HRESULT STDMETHODCALLTYPE Revert(void) = 0;

			virtual HRESULT STDMETHODCALLTYPE LockRegion(
				/* [in] */ ULARGE_INTEGER libOffset,
				/* [in] */ ULARGE_INTEGER cb,
				/* [in] */ DWORD dwLockType) = 0;

			virtual HRESULT STDMETHODCALLTYPE UnlockRegion(
				/* [in] */ ULARGE_INTEGER libOffset,
				/* [in] */ ULARGE_INTEGER cb,
				/* [in] */ DWORD dwLockType) = 0;

			virtual HRESULT STDMETHODCALLTYPE Stat(
				/* [out] */ STATSTG* pstatstg,
				/* [in] */ DWORD grfStatFlag) = 0;

			virtual HRESULT STDMETHODCALLTYPE Clone(
				/* [out] */ IStream** ppstm) = 0;

		};

#else 	/* C style interface */

		typedef struct IStreamVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IStream* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IStream* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IStream* This);

			/* [local] */ HRESULT(STDMETHODCALLTYPE* Read)(
				IStream* This,
				/* [length_is][size_is][out] */ void* pv,
				/* [in] */ ULONG cb,
				/* [out] */ ULONG* pcbRead);

			/* [local] */ HRESULT(STDMETHODCALLTYPE* Write)(
				IStream* This,
				/* [size_is][in] */ const void* pv,
				/* [in] */ ULONG cb,
				/* [out] */ ULONG* pcbWritten);

			/* [local] */ HRESULT(STDMETHODCALLTYPE* Seek)(
				IStream* This,
				/* [in] */ LARGE_INTEGER dlibMove,
				/* [in] */ DWORD dwOrigin,
				/* [out] */ ULARGE_INTEGER* plibNewPosition);

			HRESULT(STDMETHODCALLTYPE* SetSize)(
				IStream* This,
				/* [in] */ ULARGE_INTEGER libNewSize);

			/* [local] */ HRESULT(STDMETHODCALLTYPE* CopyTo)(
				IStream* This,
				/* [unique][in] */ IStream* pstm,
				/* [in] */ ULARGE_INTEGER cb,
				/* [out] */ ULARGE_INTEGER* pcbRead,
				/* [out] */ ULARGE_INTEGER* pcbWritten);

			HRESULT(STDMETHODCALLTYPE* Commit)(
				IStream* This,
				/* [in] */ DWORD grfCommitFlags);

			HRESULT(STDMETHODCALLTYPE* Revert)(
				IStream* This);

			HRESULT(STDMETHODCALLTYPE* LockRegion)(
				IStream* This,
				/* [in] */ ULARGE_INTEGER libOffset,
				/* [in] */ ULARGE_INTEGER cb,
				/* [in] */ DWORD dwLockType);

			HRESULT(STDMETHODCALLTYPE* UnlockRegion)(
				IStream* This,
				/* [in] */ ULARGE_INTEGER libOffset,
				/* [in] */ ULARGE_INTEGER cb,
				/* [in] */ DWORD dwLockType);

			HRESULT(STDMETHODCALLTYPE* Stat)(
				IStream* This,
				/* [out] */ STATSTG* pstatstg,
				/* [in] */ DWORD grfStatFlag);

			HRESULT(STDMETHODCALLTYPE* Clone)(
				IStream* This,
				/* [out] */ IStream** ppstm);

			END_INTERFACE
		} IStreamVtbl;

		interface IStream
		{
			CONST_VTBL struct IStreamVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IStream_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStream_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStream_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStream_Read(This,pv,cb,pcbRead)	\
    (This)->lpVtbl -> Read(This,pv,cb,pcbRead)

#define IStream_Write(This,pv,cb,pcbWritten)	\
    (This)->lpVtbl -> Write(This,pv,cb,pcbWritten)


#define IStream_Seek(This,dlibMove,dwOrigin,plibNewPosition)	\
    (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition)

#define IStream_SetSize(This,libNewSize)	\
    (This)->lpVtbl -> SetSize(This,libNewSize)

#define IStream_CopyTo(This,pstm,cb,pcbRead,pcbWritten)	\
    (This)->lpVtbl -> CopyTo(This,pstm,cb,pcbRead,pcbWritten)

#define IStream_Commit(This,grfCommitFlags)	\
    (This)->lpVtbl -> Commit(This,grfCommitFlags)

#define IStream_Revert(This)	\
    (This)->lpVtbl -> Revert(This)

#define IStream_LockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> LockRegion(This,libOffset,cb,dwLockType)

#define IStream_UnlockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> UnlockRegion(This,libOffset,cb,dwLockType)

#define IStream_Stat(This,pstatstg,grfStatFlag)	\
    (This)->lpVtbl -> Stat(This,pstatstg,grfStatFlag)

#define IStream_Clone(This,ppstm)	\
    (This)->lpVtbl -> Clone(This,ppstm)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		/* [call_as] */ HRESULT STDMETHODCALLTYPE IStream_RemoteSeek_Proxy(
			IStream* This,
			/* [in] */ LARGE_INTEGER dlibMove,
			/* [in] */ DWORD dwOrigin,
			/* [out] */ ULARGE_INTEGER* plibNewPosition);


		void __RPC_STUB IStream_RemoteSeek_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IStream_SetSize_Proxy(
			IStream* This,
			/* [in] */ ULARGE_INTEGER libNewSize);


		void __RPC_STUB IStream_SetSize_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IStream_RemoteCopyTo_Proxy(
			IStream* This,
			/* [unique][in] */ IStream* pstm,
			/* [in] */ ULARGE_INTEGER cb,
			/* [out] */ ULARGE_INTEGER* pcbRead,
			/* [out] */ ULARGE_INTEGER* pcbWritten);


		void __RPC_STUB IStream_RemoteCopyTo_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IStream_Commit_Proxy(
			IStream* This,
			/* [in] */ DWORD grfCommitFlags);


		void __RPC_STUB IStream_Commit_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IStream_Revert_Proxy(
			IStream* This);


		void __RPC_STUB IStream_Revert_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IStream_LockRegion_Proxy(
			IStream* This,
			/* [in] */ ULARGE_INTEGER libOffset,
			/* [in] */ ULARGE_INTEGER cb,
			/* [in] */ DWORD dwLockType);


		void __RPC_STUB IStream_LockRegion_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IStream_UnlockRegion_Proxy(
			IStream* This,
			/* [in] */ ULARGE_INTEGER libOffset,
			/* [in] */ ULARGE_INTEGER cb,
			/* [in] */ DWORD dwLockType);


		void __RPC_STUB IStream_UnlockRegion_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IStream_Stat_Proxy(
			IStream* This,
			/* [out] */ STATSTG* pstatstg,
			/* [in] */ DWORD grfStatFlag);


		void __RPC_STUB IStream_Stat_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IStream_Clone_Proxy(
			IStream* This,
			/* [out] */ IStream** ppstm);


		void __RPC_STUB IStream_Clone_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IStream_INTERFACE_DEFINED__ */


#ifndef __IEnumSTATSTG_INTERFACE_DEFINED__
#define __IEnumSTATSTG_INTERFACE_DEFINED__

		/* interface IEnumSTATSTG */
		/* [unique][uuid][object] */

		typedef /* [unique] */ IEnumSTATSTG* LPENUMSTATSTG;


		EXTERN_C const IID IID_IEnumSTATSTG;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("0000000d-0000-0000-C000-000000000046")
			IEnumSTATSTG : public IUnknown
		{
		public:
			virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next(
				/* [in] */ ULONG celt,
				/* [length_is][size_is][out] */ STATSTG * rgelt,
				/* [out] */ ULONG * pceltFetched) = 0;

			virtual HRESULT STDMETHODCALLTYPE Skip(
				/* [in] */ ULONG celt) = 0;

			virtual HRESULT STDMETHODCALLTYPE Reset(void) = 0;

			virtual HRESULT STDMETHODCALLTYPE Clone(
				/* [out] */ IEnumSTATSTG** ppenum) = 0;

		};

#else 	/* C style interface */

		typedef struct IEnumSTATSTGVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IEnumSTATSTG* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IEnumSTATSTG* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IEnumSTATSTG* This);

			/* [local] */ HRESULT(STDMETHODCALLTYPE* Next)(
				IEnumSTATSTG* This,
				/* [in] */ ULONG celt,
				/* [length_is][size_is][out] */ STATSTG* rgelt,
				/* [out] */ ULONG* pceltFetched);

			HRESULT(STDMETHODCALLTYPE* Skip)(
				IEnumSTATSTG* This,
				/* [in] */ ULONG celt);

			HRESULT(STDMETHODCALLTYPE* Reset)(
				IEnumSTATSTG* This);

			HRESULT(STDMETHODCALLTYPE* Clone)(
				IEnumSTATSTG* This,
				/* [out] */ IEnumSTATSTG** ppenum);

			END_INTERFACE
		} IEnumSTATSTGVtbl;

		interface IEnumSTATSTG
		{
			CONST_VTBL struct IEnumSTATSTGVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IEnumSTATSTG_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumSTATSTG_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumSTATSTG_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumSTATSTG_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumSTATSTG_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumSTATSTG_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumSTATSTG_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumSTATSTG_RemoteNext_Proxy(
			IEnumSTATSTG* This,
			/* [in] */ ULONG celt,
			/* [length_is][size_is][out] */ STATSTG* rgelt,
			/* [out] */ ULONG* pceltFetched);


		void __RPC_STUB IEnumSTATSTG_RemoteNext_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IEnumSTATSTG_Skip_Proxy(
			IEnumSTATSTG* This,
			/* [in] */ ULONG celt);


		void __RPC_STUB IEnumSTATSTG_Skip_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IEnumSTATSTG_Reset_Proxy(
			IEnumSTATSTG* This);


		void __RPC_STUB IEnumSTATSTG_Reset_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IEnumSTATSTG_Clone_Proxy(
			IEnumSTATSTG* This,
			/* [out] */ IEnumSTATSTG** ppenum);


		void __RPC_STUB IEnumSTATSTG_Clone_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IEnumSTATSTG_INTERFACE_DEFINED__ */


#ifndef __IStorage_INTERFACE_DEFINED__
#define __IStorage_INTERFACE_DEFINED__

		/* interface IStorage */
		/* [unique][uuid][object] */

		typedef /* [unique] */ IStorage* LPSTORAGE;

		typedef struct tagRemSNB
		{
			unsigned long ulCntStr;
			unsigned long ulCntChar;
			/* [size_is] */ OLECHAR rgString[1];
		} 	RemSNB;

		typedef /* [unique] */ RemSNB* wireSNB;

		typedef /* [wire_marshal] */ OLECHAR** SNB;


		EXTERN_C const IID IID_IStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("0000000b-0000-0000-C000-000000000046")
			IStorage : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE CreateStream(
				/* [string][in] */ const OLECHAR * pwcsName,
				/* [in] */ DWORD grfMode,
				/* [in] */ DWORD reserved1,
				/* [in] */ DWORD reserved2,
				/* [out] */ IStream * *ppstm) = 0;

			virtual /* [local] */ HRESULT STDMETHODCALLTYPE OpenStream(
				/* [string][in] */ const OLECHAR* pwcsName,
				/* [unique][in] */ void* reserved1,
				/* [in] */ DWORD grfMode,
				/* [in] */ DWORD reserved2,
				/* [out] */ IStream** ppstm) = 0;

			virtual HRESULT STDMETHODCALLTYPE CreateStorage(
				/* [string][in] */ const OLECHAR* pwcsName,
				/* [in] */ DWORD grfMode,
				/* [in] */ DWORD reserved1,
				/* [in] */ DWORD reserved2,
				/* [out] */ IStorage** ppstg) = 0;

			virtual HRESULT STDMETHODCALLTYPE OpenStorage(
				/* [string][unique][in] */ const OLECHAR* pwcsName,
				/* [unique][in] */ IStorage* pstgPriority,
				/* [in] */ DWORD grfMode,
				/* [unique][in] */ SNB snbExclude,
				/* [in] */ DWORD reserved,
				/* [out] */ IStorage** ppstg) = 0;

			virtual HRESULT STDMETHODCALLTYPE CopyTo(
				/* [in] */ DWORD ciidExclude,
				/* [size_is][unique][in] */ const IID* rgiidExclude,
				/* [unique][in] */ SNB snbExclude,
				/* [unique][in] */ IStorage* pstgDest) = 0;

			virtual HRESULT STDMETHODCALLTYPE MoveElementTo(
				/* [string][in] */ const OLECHAR* pwcsName,
				/* [unique][in] */ IStorage* pstgDest,
				/* [string][in] */ const OLECHAR* pwcsNewName,
				/* [in] */ DWORD grfFlags) = 0;

			virtual HRESULT STDMETHODCALLTYPE Commit(
				/* [in] */ DWORD grfCommitFlags) = 0;

			virtual HRESULT STDMETHODCALLTYPE Revert(void) = 0;

			virtual /* [local] */ HRESULT STDMETHODCALLTYPE EnumElements(
				/* [in] */ DWORD reserved1,
				/* [size_is][unique][in] */ void* reserved2,
				/* [in] */ DWORD reserved3,
				/* [out] */ IEnumSTATSTG** ppenum) = 0;

			virtual HRESULT STDMETHODCALLTYPE DestroyElement(
				/* [string][in] */ const OLECHAR* pwcsName) = 0;

			virtual HRESULT STDMETHODCALLTYPE RenameElement(
				/* [string][in] */ const OLECHAR* pwcsOldName,
				/* [string][in] */ const OLECHAR* pwcsNewName) = 0;

			virtual HRESULT STDMETHODCALLTYPE SetElementTimes(
				/* [string][unique][in] */ const OLECHAR* pwcsName,
				/* [unique][in] */ const FILETIME* pctime,
				/* [unique][in] */ const FILETIME* patime,
				/* [unique][in] */ const FILETIME* pmtime) = 0;

			virtual HRESULT STDMETHODCALLTYPE SetClass(
				/* [in] */ REFCLSID clsid) = 0;

			virtual HRESULT STDMETHODCALLTYPE SetStateBits(
				/* [in] */ DWORD grfStateBits,
				/* [in] */ DWORD grfMask) = 0;

			virtual HRESULT STDMETHODCALLTYPE Stat(
				/* [out] */ STATSTG* pstatstg,
				/* [in] */ DWORD grfStatFlag) = 0;

		};

#else 	/* C style interface */

		typedef struct IStorageVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IStorage* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IStorage* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IStorage* This);

			HRESULT(STDMETHODCALLTYPE* CreateStream)(
				IStorage* This,
				/* [string][in] */ const OLECHAR* pwcsName,
				/* [in] */ DWORD grfMode,
				/* [in] */ DWORD reserved1,
				/* [in] */ DWORD reserved2,
				/* [out] */ IStream** ppstm);

			/* [local] */ HRESULT(STDMETHODCALLTYPE* OpenStream)(
				IStorage* This,
				/* [string][in] */ const OLECHAR* pwcsName,
				/* [unique][in] */ void* reserved1,
				/* [in] */ DWORD grfMode,
				/* [in] */ DWORD reserved2,
				/* [out] */ IStream** ppstm);

			HRESULT(STDMETHODCALLTYPE* CreateStorage)(
				IStorage* This,
				/* [string][in] */ const OLECHAR* pwcsName,
				/* [in] */ DWORD grfMode,
				/* [in] */ DWORD reserved1,
				/* [in] */ DWORD reserved2,
				/* [out] */ IStorage** ppstg);

			HRESULT(STDMETHODCALLTYPE* OpenStorage)(
				IStorage* This,
				/* [string][unique][in] */ const OLECHAR* pwcsName,
				/* [unique][in] */ IStorage* pstgPriority,
				/* [in] */ DWORD grfMode,
				/* [unique][in] */ SNB snbExclude,
				/* [in] */ DWORD reserved,
				/* [out] */ IStorage** ppstg);

			HRESULT(STDMETHODCALLTYPE* CopyTo)(
				IStorage* This,
				/* [in] */ DWORD ciidExclude,
				/* [size_is][unique][in] */ const IID* rgiidExclude,
				/* [unique][in] */ SNB snbExclude,
				/* [unique][in] */ IStorage* pstgDest);

			HRESULT(STDMETHODCALLTYPE* MoveElementTo)(
				IStorage* This,
				/* [string][in] */ const OLECHAR* pwcsName,
				/* [unique][in] */ IStorage* pstgDest,
				/* [string][in] */ const OLECHAR* pwcsNewName,
				/* [in] */ DWORD grfFlags);

			HRESULT(STDMETHODCALLTYPE* Commit)(
				IStorage* This,
				/* [in] */ DWORD grfCommitFlags);

			HRESULT(STDMETHODCALLTYPE* Revert)(
				IStorage* This);

			/* [local] */ HRESULT(STDMETHODCALLTYPE* EnumElements)(
				IStorage* This,
				/* [in] */ DWORD reserved1,
				/* [size_is][unique][in] */ void* reserved2,
				/* [in] */ DWORD reserved3,
				/* [out] */ IEnumSTATSTG** ppenum);

			HRESULT(STDMETHODCALLTYPE* DestroyElement)(
				IStorage* This,
				/* [string][in] */ const OLECHAR* pwcsName);

			HRESULT(STDMETHODCALLTYPE* RenameElement)(
				IStorage* This,
				/* [string][in] */ const OLECHAR* pwcsOldName,
				/* [string][in] */ const OLECHAR* pwcsNewName);

			HRESULT(STDMETHODCALLTYPE* SetElementTimes)(
				IStorage* This,
				/* [string][unique][in] */ const OLECHAR* pwcsName,
				/* [unique][in] */ const FILETIME* pctime,
				/* [unique][in] */ const FILETIME* patime,
				/* [unique][in] */ const FILETIME* pmtime);

			HRESULT(STDMETHODCALLTYPE* SetClass)(
				IStorage* This,
				/* [in] */ REFCLSID clsid);

			HRESULT(STDMETHODCALLTYPE* SetStateBits)(
				IStorage* This,
				/* [in] */ DWORD grfStateBits,
				/* [in] */ DWORD grfMask);

			HRESULT(STDMETHODCALLTYPE* Stat)(
				IStorage* This,
				/* [out] */ STATSTG* pstatstg,
				/* [in] */ DWORD grfStatFlag);

			END_INTERFACE
		} IStorageVtbl;

		interface IStorage
		{
			CONST_VTBL struct IStorageVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStorage_CreateStream(This,pwcsName,grfMode,reserved1,reserved2,ppstm)	\
    (This)->lpVtbl -> CreateStream(This,pwcsName,grfMode,reserved1,reserved2,ppstm)

#define IStorage_OpenStream(This,pwcsName,reserved1,grfMode,reserved2,ppstm)	\
    (This)->lpVtbl -> OpenStream(This,pwcsName,reserved1,grfMode,reserved2,ppstm)

#define IStorage_CreateStorage(This,pwcsName,grfMode,reserved1,reserved2,ppstg)	\
    (This)->lpVtbl -> CreateStorage(This,pwcsName,grfMode,reserved1,reserved2,ppstg)

#define IStorage_OpenStorage(This,pwcsName,pstgPriority,grfMode,snbExclude,reserved,ppstg)	\
    (This)->lpVtbl -> OpenStorage(This,pwcsName,pstgPriority,grfMode,snbExclude,reserved,ppstg)

#define IStorage_CopyTo(This,ciidExclude,rgiidExclude,snbExclude,pstgDest)	\
    (This)->lpVtbl -> CopyTo(This,ciidExclude,rgiidExclude,snbExclude,pstgDest)

#define IStorage_MoveElementTo(This,pwcsName,pstgDest,pwcsNewName,grfFlags)	\
    (This)->lpVtbl -> MoveElementTo(This,pwcsName,pstgDest,pwcsNewName,grfFlags)

#define IStorage_Commit(This,grfCommitFlags)	\
    (This)->lpVtbl -> Commit(This,grfCommitFlags)

#define IStorage_Revert(This)	\
    (This)->lpVtbl -> Revert(This)

#define IStorage_EnumElements(This,reserved1,reserved2,reserved3,ppenum)	\
    (This)->lpVtbl -> EnumElements(This,reserved1,reserved2,reserved3,ppenum)

#define IStorage_DestroyElement(This,pwcsName)	\
    (This)->lpVtbl -> DestroyElement(This,pwcsName)

#define IStorage_RenameElement(This,pwcsOldName,pwcsNewName)	\
    (This)->lpVtbl -> RenameElement(This,pwcsOldName,pwcsNewName)

#define IStorage_SetElementTimes(This,pwcsName,pctime,patime,pmtime)	\
    (This)->lpVtbl -> SetElementTimes(This,pwcsName,pctime,patime,pmtime)

#define IStorage_SetClass(This,clsid)	\
    (This)->lpVtbl -> SetClass(This,clsid)

#define IStorage_SetStateBits(This,grfStateBits,grfMask)	\
    (This)->lpVtbl -> SetStateBits(This,grfStateBits,grfMask)

#define IStorage_Stat(This,pstatstg,grfStatFlag)	\
    (This)->lpVtbl -> Stat(This,pstatstg,grfStatFlag)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IStorage_CreateStream_Proxy(
			IStorage* This,
			/* [string][in] */ const OLECHAR* pwcsName,
			/* [in] */ DWORD grfMode,
			/* [in] */ DWORD reserved1,
			/* [in] */ DWORD reserved2,
			/* [out] */ IStream** ppstm);


		void __RPC_STUB IStorage_CreateStream_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IStorage_RemoteOpenStream_Proxy(
			IStorage* This,
			/* [string][in] */ const OLECHAR* pwcsName,
			/* [in] */ unsigned long cbReserved1,
			/* [size_is][unique][in] */ byte* reserved1,
			/* [in] */ DWORD grfMode,
			/* [in] */ DWORD reserved2,
			/* [out] */ IStream** ppstm);


		void __RPC_STUB IStorage_RemoteOpenStream_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IStorage_CreateStorage_Proxy(
			IStorage* This,
			/* [string][in] */ const OLECHAR* pwcsName,
			/* [in] */ DWORD grfMode,
			/* [in] */ DWORD reserved1,
			/* [in] */ DWORD reserved2,
			/* [out] */ IStorage** ppstg);


		void __RPC_STUB IStorage_CreateStorage_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IStorage_OpenStorage_Proxy(
			IStorage* This,
			/* [string][unique][in] */ const OLECHAR* pwcsName,
			/* [unique][in] */ IStorage* pstgPriority,
			/* [in] */ DWORD grfMode,
			/* [unique][in] */ SNB snbExclude,
			/* [in] */ DWORD reserved,
			/* [out] */ IStorage** ppstg);


		void __RPC_STUB IStorage_OpenStorage_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IStorage_CopyTo_Proxy(
			IStorage* This,
			/* [in] */ DWORD ciidExclude,
			/* [size_is][unique][in] */ const IID* rgiidExclude,
			/* [unique][in] */ SNB snbExclude,
			/* [unique][in] */ IStorage* pstgDest);


		void __RPC_STUB IStorage_CopyTo_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IStorage_MoveElementTo_Proxy(
			IStorage* This,
			/* [string][in] */ const OLECHAR* pwcsName,
			/* [unique][in] */ IStorage* pstgDest,
			/* [string][in] */ const OLECHAR* pwcsNewName,
			/* [in] */ DWORD grfFlags);


		void __RPC_STUB IStorage_MoveElementTo_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IStorage_Commit_Proxy(
			IStorage* This,
			/* [in] */ DWORD grfCommitFlags);


		void __RPC_STUB IStorage_Commit_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IStorage_Revert_Proxy(
			IStorage* This);


		void __RPC_STUB IStorage_Revert_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IStorage_RemoteEnumElements_Proxy(
			IStorage* This,
			/* [in] */ DWORD reserved1,
			/* [in] */ unsigned long cbReserved2,
			/* [size_is][unique][in] */ byte* reserved2,
			/* [in] */ DWORD reserved3,
			/* [out] */ IEnumSTATSTG** ppenum);


		void __RPC_STUB IStorage_RemoteEnumElements_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IStorage_DestroyElement_Proxy(
			IStorage* This,
			/* [string][in] */ const OLECHAR* pwcsName);


		void __RPC_STUB IStorage_DestroyElement_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IStorage_RenameElement_Proxy(
			IStorage* This,
			/* [string][in] */ const OLECHAR* pwcsOldName,
			/* [string][in] */ const OLECHAR* pwcsNewName);


		void __RPC_STUB IStorage_RenameElement_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IStorage_SetElementTimes_Proxy(
			IStorage* This,
			/* [string][unique][in] */ const OLECHAR* pwcsName,
			/* [unique][in] */ const FILETIME* pctime,
			/* [unique][in] */ const FILETIME* patime,
			/* [unique][in] */ const FILETIME* pmtime);


		void __RPC_STUB IStorage_SetElementTimes_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IStorage_SetClass_Proxy(
			IStorage* This,
			/* [in] */ REFCLSID clsid);


		void __RPC_STUB IStorage_SetClass_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IStorage_SetStateBits_Proxy(
			IStorage* This,
			/* [in] */ DWORD grfStateBits,
			/* [in] */ DWORD grfMask);


		void __RPC_STUB IStorage_SetStateBits_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IStorage_Stat_Proxy(
			IStorage* This,
			/* [out] */ STATSTG* pstatstg,
			/* [in] */ DWORD grfStatFlag);


		void __RPC_STUB IStorage_Stat_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IStorage_INTERFACE_DEFINED__ */


#ifndef __IPersistFile_INTERFACE_DEFINED__
#define __IPersistFile_INTERFACE_DEFINED__

		/* interface IPersistFile */
		/* [unique][uuid][object] */

		typedef /* [unique] */ IPersistFile* LPPERSISTFILE;


		EXTERN_C const IID IID_IPersistFile;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("0000010b-0000-0000-C000-000000000046")
			IPersistFile : public IPersist
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE IsDirty(void) = 0;

			virtual HRESULT STDMETHODCALLTYPE Load(
				/* [in] */ LPCOLESTR pszFileName,
				/* [in] */ DWORD dwMode) = 0;

			virtual HRESULT STDMETHODCALLTYPE Save(
				/* [unique][in] */ LPCOLESTR pszFileName,
				/* [in] */ BOOL fRemember) = 0;

			virtual HRESULT STDMETHODCALLTYPE SaveCompleted(
				/* [unique][in] */ LPCOLESTR pszFileName) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetCurFile(
				/* [out] */ LPOLESTR* ppszFileName) = 0;

		};

#else 	/* C style interface */

		typedef struct IPersistFileVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IPersistFile* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IPersistFile* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IPersistFile* This);

			HRESULT(STDMETHODCALLTYPE* GetClassID)(
				IPersistFile* This,
				/* [out] */ CLSID* pClassID);

			HRESULT(STDMETHODCALLTYPE* IsDirty)(
				IPersistFile* This);

			HRESULT(STDMETHODCALLTYPE* Load)(
				IPersistFile* This,
				/* [in] */ LPCOLESTR pszFileName,
				/* [in] */ DWORD dwMode);

			HRESULT(STDMETHODCALLTYPE* Save)(
				IPersistFile* This,
				/* [unique][in] */ LPCOLESTR pszFileName,
				/* [in] */ BOOL fRemember);

			HRESULT(STDMETHODCALLTYPE* SaveCompleted)(
				IPersistFile* This,
				/* [unique][in] */ LPCOLESTR pszFileName);

			HRESULT(STDMETHODCALLTYPE* GetCurFile)(
				IPersistFile* This,
				/* [out] */ LPOLESTR* ppszFileName);

			END_INTERFACE
		} IPersistFileVtbl;

		interface IPersistFile
		{
			CONST_VTBL struct IPersistFileVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IPersistFile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPersistFile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPersistFile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPersistFile_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IPersistFile_IsDirty(This)	\
    (This)->lpVtbl -> IsDirty(This)

#define IPersistFile_Load(This,pszFileName,dwMode)	\
    (This)->lpVtbl -> Load(This,pszFileName,dwMode)

#define IPersistFile_Save(This,pszFileName,fRemember)	\
    (This)->lpVtbl -> Save(This,pszFileName,fRemember)

#define IPersistFile_SaveCompleted(This,pszFileName)	\
    (This)->lpVtbl -> SaveCompleted(This,pszFileName)

#define IPersistFile_GetCurFile(This,ppszFileName)	\
    (This)->lpVtbl -> GetCurFile(This,ppszFileName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IPersistFile_IsDirty_Proxy(
			IPersistFile* This);


		void __RPC_STUB IPersistFile_IsDirty_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPersistFile_Load_Proxy(
			IPersistFile* This,
			/* [in] */ LPCOLESTR pszFileName,
			/* [in] */ DWORD dwMode);


		void __RPC_STUB IPersistFile_Load_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPersistFile_Save_Proxy(
			IPersistFile* This,
			/* [unique][in] */ LPCOLESTR pszFileName,
			/* [in] */ BOOL fRemember);


		void __RPC_STUB IPersistFile_Save_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPersistFile_SaveCompleted_Proxy(
			IPersistFile* This,
			/* [unique][in] */ LPCOLESTR pszFileName);


		void __RPC_STUB IPersistFile_SaveCompleted_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPersistFile_GetCurFile_Proxy(
			IPersistFile* This,
			/* [out] */ LPOLESTR* ppszFileName);


		void __RPC_STUB IPersistFile_GetCurFile_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IPersistFile_INTERFACE_DEFINED__ */


#ifndef __IPersistStorage_INTERFACE_DEFINED__
#define __IPersistStorage_INTERFACE_DEFINED__

		/* interface IPersistStorage */
		/* [unique][uuid][object] */

		typedef /* [unique] */ IPersistStorage* LPPERSISTSTORAGE;


		EXTERN_C const IID IID_IPersistStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("0000010a-0000-0000-C000-000000000046")
			IPersistStorage : public IPersist
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE IsDirty(void) = 0;

			virtual HRESULT STDMETHODCALLTYPE InitNew(
				/* [unique][in] */ IStorage* pStg) = 0;

			virtual HRESULT STDMETHODCALLTYPE Load(
				/* [unique][in] */ IStorage* pStg) = 0;

			virtual HRESULT STDMETHODCALLTYPE Save(
				/* [unique][in] */ IStorage* pStgSave,
				/* [in] */ BOOL fSameAsLoad) = 0;

			virtual HRESULT STDMETHODCALLTYPE SaveCompleted(
				/* [unique][in] */ IStorage* pStgNew) = 0;

			virtual HRESULT STDMETHODCALLTYPE HandsOffStorage(void) = 0;

		};

#else 	/* C style interface */

		typedef struct IPersistStorageVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IPersistStorage* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IPersistStorage* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IPersistStorage* This);

			HRESULT(STDMETHODCALLTYPE* GetClassID)(
				IPersistStorage* This,
				/* [out] */ CLSID* pClassID);

			HRESULT(STDMETHODCALLTYPE* IsDirty)(
				IPersistStorage* This);

			HRESULT(STDMETHODCALLTYPE* InitNew)(
				IPersistStorage* This,
				/* [unique][in] */ IStorage* pStg);

			HRESULT(STDMETHODCALLTYPE* Load)(
				IPersistStorage* This,
				/* [unique][in] */ IStorage* pStg);

			HRESULT(STDMETHODCALLTYPE* Save)(
				IPersistStorage* This,
				/* [unique][in] */ IStorage* pStgSave,
				/* [in] */ BOOL fSameAsLoad);

			HRESULT(STDMETHODCALLTYPE* SaveCompleted)(
				IPersistStorage* This,
				/* [unique][in] */ IStorage* pStgNew);

			HRESULT(STDMETHODCALLTYPE* HandsOffStorage)(
				IPersistStorage* This);

			END_INTERFACE
		} IPersistStorageVtbl;

		interface IPersistStorage
		{
			CONST_VTBL struct IPersistStorageVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IPersistStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPersistStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPersistStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPersistStorage_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IPersistStorage_IsDirty(This)	\
    (This)->lpVtbl -> IsDirty(This)

#define IPersistStorage_InitNew(This,pStg)	\
    (This)->lpVtbl -> InitNew(This,pStg)

#define IPersistStorage_Load(This,pStg)	\
    (This)->lpVtbl -> Load(This,pStg)

#define IPersistStorage_Save(This,pStgSave,fSameAsLoad)	\
    (This)->lpVtbl -> Save(This,pStgSave,fSameAsLoad)

#define IPersistStorage_SaveCompleted(This,pStgNew)	\
    (This)->lpVtbl -> SaveCompleted(This,pStgNew)

#define IPersistStorage_HandsOffStorage(This)	\
    (This)->lpVtbl -> HandsOffStorage(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IPersistStorage_IsDirty_Proxy(
			IPersistStorage* This);


		void __RPC_STUB IPersistStorage_IsDirty_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPersistStorage_InitNew_Proxy(
			IPersistStorage* This,
			/* [unique][in] */ IStorage* pStg);


		void __RPC_STUB IPersistStorage_InitNew_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPersistStorage_Load_Proxy(
			IPersistStorage* This,
			/* [unique][in] */ IStorage* pStg);


		void __RPC_STUB IPersistStorage_Load_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPersistStorage_Save_Proxy(
			IPersistStorage* This,
			/* [unique][in] */ IStorage* pStgSave,
			/* [in] */ BOOL fSameAsLoad);


		void __RPC_STUB IPersistStorage_Save_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPersistStorage_SaveCompleted_Proxy(
			IPersistStorage* This,
			/* [unique][in] */ IStorage* pStgNew);


		void __RPC_STUB IPersistStorage_SaveCompleted_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPersistStorage_HandsOffStorage_Proxy(
			IPersistStorage* This);


		void __RPC_STUB IPersistStorage_HandsOffStorage_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IPersistStorage_INTERFACE_DEFINED__ */


#ifndef __ILockBytes_INTERFACE_DEFINED__
#define __ILockBytes_INTERFACE_DEFINED__

		/* interface ILockBytes */
		/* [unique][uuid][object] */

		typedef /* [unique] */ ILockBytes* LPLOCKBYTES;


		EXTERN_C const IID IID_ILockBytes;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("0000000a-0000-0000-C000-000000000046")
			ILockBytes : public IUnknown
		{
		public:
			virtual /* [local] */ HRESULT STDMETHODCALLTYPE ReadAt(
				/* [in] */ ULARGE_INTEGER ulOffset,
				/* [length_is][size_is][out] */ void* pv,
				/* [in] */ ULONG cb,
				/* [out] */ ULONG * pcbRead) = 0;

			virtual /* [local] */ HRESULT STDMETHODCALLTYPE WriteAt(
				/* [in] */ ULARGE_INTEGER ulOffset,
				/* [size_is][in] */ const void* pv,
				/* [in] */ ULONG cb,
				/* [out] */ ULONG* pcbWritten) = 0;

			virtual HRESULT STDMETHODCALLTYPE Flush(void) = 0;

			virtual HRESULT STDMETHODCALLTYPE SetSize(
				/* [in] */ ULARGE_INTEGER cb) = 0;

			virtual HRESULT STDMETHODCALLTYPE LockRegion(
				/* [in] */ ULARGE_INTEGER libOffset,
				/* [in] */ ULARGE_INTEGER cb,
				/* [in] */ DWORD dwLockType) = 0;

			virtual HRESULT STDMETHODCALLTYPE UnlockRegion(
				/* [in] */ ULARGE_INTEGER libOffset,
				/* [in] */ ULARGE_INTEGER cb,
				/* [in] */ DWORD dwLockType) = 0;

			virtual HRESULT STDMETHODCALLTYPE Stat(
				/* [out] */ STATSTG* pstatstg,
				/* [in] */ DWORD grfStatFlag) = 0;

		};

#else 	/* C style interface */

		typedef struct ILockBytesVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					ILockBytes* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				ILockBytes* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				ILockBytes* This);

			/* [local] */ HRESULT(STDMETHODCALLTYPE* ReadAt)(
				ILockBytes* This,
				/* [in] */ ULARGE_INTEGER ulOffset,
				/* [length_is][size_is][out] */ void* pv,
				/* [in] */ ULONG cb,
				/* [out] */ ULONG* pcbRead);

			/* [local] */ HRESULT(STDMETHODCALLTYPE* WriteAt)(
				ILockBytes* This,
				/* [in] */ ULARGE_INTEGER ulOffset,
				/* [size_is][in] */ const void* pv,
				/* [in] */ ULONG cb,
				/* [out] */ ULONG* pcbWritten);

			HRESULT(STDMETHODCALLTYPE* Flush)(
				ILockBytes* This);

			HRESULT(STDMETHODCALLTYPE* SetSize)(
				ILockBytes* This,
				/* [in] */ ULARGE_INTEGER cb);

			HRESULT(STDMETHODCALLTYPE* LockRegion)(
				ILockBytes* This,
				/* [in] */ ULARGE_INTEGER libOffset,
				/* [in] */ ULARGE_INTEGER cb,
				/* [in] */ DWORD dwLockType);

			HRESULT(STDMETHODCALLTYPE* UnlockRegion)(
				ILockBytes* This,
				/* [in] */ ULARGE_INTEGER libOffset,
				/* [in] */ ULARGE_INTEGER cb,
				/* [in] */ DWORD dwLockType);

			HRESULT(STDMETHODCALLTYPE* Stat)(
				ILockBytes* This,
				/* [out] */ STATSTG* pstatstg,
				/* [in] */ DWORD grfStatFlag);

			END_INTERFACE
		} ILockBytesVtbl;

		interface ILockBytes
		{
			CONST_VTBL struct ILockBytesVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define ILockBytes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILockBytes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILockBytes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILockBytes_ReadAt(This,ulOffset,pv,cb,pcbRead)	\
    (This)->lpVtbl -> ReadAt(This,ulOffset,pv,cb,pcbRead)

#define ILockBytes_WriteAt(This,ulOffset,pv,cb,pcbWritten)	\
    (This)->lpVtbl -> WriteAt(This,ulOffset,pv,cb,pcbWritten)

#define ILockBytes_Flush(This)	\
    (This)->lpVtbl -> Flush(This)

#define ILockBytes_SetSize(This,cb)	\
    (This)->lpVtbl -> SetSize(This,cb)

#define ILockBytes_LockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> LockRegion(This,libOffset,cb,dwLockType)

#define ILockBytes_UnlockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> UnlockRegion(This,libOffset,cb,dwLockType)

#define ILockBytes_Stat(This,pstatstg,grfStatFlag)	\
    (This)->lpVtbl -> Stat(This,pstatstg,grfStatFlag)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		/* [call_as] */ HRESULT __stdcall ILockBytes_RemoteReadAt_Proxy(
			ILockBytes* This,
			/* [in] */ ULARGE_INTEGER ulOffset,
			/* [length_is][size_is][out] */ byte* pv,
			/* [in] */ ULONG cb,
			/* [out] */ ULONG* pcbRead);


		void __RPC_STUB ILockBytes_RemoteReadAt_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE ILockBytes_RemoteWriteAt_Proxy(
			ILockBytes* This,
			/* [in] */ ULARGE_INTEGER ulOffset,
			/* [size_is][in] */ const byte* pv,
			/* [in] */ ULONG cb,
			/* [out] */ ULONG* pcbWritten);


		void __RPC_STUB ILockBytes_RemoteWriteAt_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE ILockBytes_Flush_Proxy(
			ILockBytes* This);


		void __RPC_STUB ILockBytes_Flush_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE ILockBytes_SetSize_Proxy(
			ILockBytes* This,
			/* [in] */ ULARGE_INTEGER cb);


		void __RPC_STUB ILockBytes_SetSize_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE ILockBytes_LockRegion_Proxy(
			ILockBytes* This,
			/* [in] */ ULARGE_INTEGER libOffset,
			/* [in] */ ULARGE_INTEGER cb,
			/* [in] */ DWORD dwLockType);


		void __RPC_STUB ILockBytes_LockRegion_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE ILockBytes_UnlockRegion_Proxy(
			ILockBytes* This,
			/* [in] */ ULARGE_INTEGER libOffset,
			/* [in] */ ULARGE_INTEGER cb,
			/* [in] */ DWORD dwLockType);


		void __RPC_STUB ILockBytes_UnlockRegion_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE ILockBytes_Stat_Proxy(
			ILockBytes* This,
			/* [out] */ STATSTG* pstatstg,
			/* [in] */ DWORD grfStatFlag);


		void __RPC_STUB ILockBytes_Stat_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __ILockBytes_INTERFACE_DEFINED__ */


#ifndef __IEnumFORMATETC_INTERFACE_DEFINED__
#define __IEnumFORMATETC_INTERFACE_DEFINED__

		/* interface IEnumFORMATETC */
		/* [unique][uuid][object] */

		typedef /* [unique] */ IEnumFORMATETC* LPENUMFORMATETC;

		typedef struct tagDVTARGETDEVICE
		{
			DWORD tdSize;
			WORD tdDriverNameOffset;
			WORD tdDeviceNameOffset;
			WORD tdPortNameOffset;
			WORD tdExtDevmodeOffset;
			/* [size_is] */ BYTE tdData[1];
		} 	DVTARGETDEVICE;

		typedef CLIPFORMAT* LPCLIPFORMAT;

		typedef struct tagFORMATETC
		{
			CLIPFORMAT cfFormat;
			/* [unique] */ DVTARGETDEVICE* ptd;
			DWORD dwAspect;
			LONG lindex;
			DWORD tymed;
		} 	FORMATETC;

		typedef struct tagFORMATETC* LPFORMATETC;


		EXTERN_C const IID IID_IEnumFORMATETC;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000103-0000-0000-C000-000000000046")
			IEnumFORMATETC : public IUnknown
		{
		public:
			virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next(
				/* [in] */ ULONG celt,
				/* [length_is][size_is][out] */ FORMATETC * rgelt,
				/* [out] */ ULONG * pceltFetched) = 0;

			virtual HRESULT STDMETHODCALLTYPE Skip(
				/* [in] */ ULONG celt) = 0;

			virtual HRESULT STDMETHODCALLTYPE Reset(void) = 0;

			virtual HRESULT STDMETHODCALLTYPE Clone(
				/* [out] */ IEnumFORMATETC** ppenum) = 0;

		};

#else 	/* C style interface */

		typedef struct IEnumFORMATETCVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IEnumFORMATETC* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IEnumFORMATETC* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IEnumFORMATETC* This);

			/* [local] */ HRESULT(STDMETHODCALLTYPE* Next)(
				IEnumFORMATETC* This,
				/* [in] */ ULONG celt,
				/* [length_is][size_is][out] */ FORMATETC* rgelt,
				/* [out] */ ULONG* pceltFetched);

			HRESULT(STDMETHODCALLTYPE* Skip)(
				IEnumFORMATETC* This,
				/* [in] */ ULONG celt);

			HRESULT(STDMETHODCALLTYPE* Reset)(
				IEnumFORMATETC* This);

			HRESULT(STDMETHODCALLTYPE* Clone)(
				IEnumFORMATETC* This,
				/* [out] */ IEnumFORMATETC** ppenum);

			END_INTERFACE
		} IEnumFORMATETCVtbl;

		interface IEnumFORMATETC
		{
			CONST_VTBL struct IEnumFORMATETCVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IEnumFORMATETC_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumFORMATETC_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumFORMATETC_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumFORMATETC_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumFORMATETC_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumFORMATETC_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumFORMATETC_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumFORMATETC_RemoteNext_Proxy(
			IEnumFORMATETC* This,
			/* [in] */ ULONG celt,
			/* [length_is][size_is][out] */ FORMATETC* rgelt,
			/* [out] */ ULONG* pceltFetched);


		void __RPC_STUB IEnumFORMATETC_RemoteNext_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IEnumFORMATETC_Skip_Proxy(
			IEnumFORMATETC* This,
			/* [in] */ ULONG celt);


		void __RPC_STUB IEnumFORMATETC_Skip_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IEnumFORMATETC_Reset_Proxy(
			IEnumFORMATETC* This);


		void __RPC_STUB IEnumFORMATETC_Reset_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IEnumFORMATETC_Clone_Proxy(
			IEnumFORMATETC* This,
			/* [out] */ IEnumFORMATETC** ppenum);


		void __RPC_STUB IEnumFORMATETC_Clone_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IEnumFORMATETC_INTERFACE_DEFINED__ */


#ifndef __IEnumSTATDATA_INTERFACE_DEFINED__
#define __IEnumSTATDATA_INTERFACE_DEFINED__

		/* interface IEnumSTATDATA */
		/* [unique][uuid][object] */

		typedef /* [unique] */ IEnumSTATDATA* LPENUMSTATDATA;

		typedef
			enum tagADVF
		{
			ADVF_NODATA = 1,
			ADVF_PRIMEFIRST = 2,
			ADVF_ONLYONCE = 4,
			ADVF_DATAONSTOP = 64,
			ADVFCACHE_NOHANDLER = 8,
			ADVFCACHE_FORCEBUILTIN = 16,
			ADVFCACHE_ONSAVE = 32
		} 	ADVF;

		typedef struct tagSTATDATA
		{
			FORMATETC formatetc;
			DWORD advf;
			/* [unique] */ IAdviseSink* pAdvSink;
			DWORD dwConnection;
		} 	STATDATA;

		typedef STATDATA* LPSTATDATA;


		EXTERN_C const IID IID_IEnumSTATDATA;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000105-0000-0000-C000-000000000046")
			IEnumSTATDATA : public IUnknown
		{
		public:
			virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next(
				/* [in] */ ULONG celt,
				/* [length_is][size_is][out] */ STATDATA * rgelt,
				/* [out] */ ULONG * pceltFetched) = 0;

			virtual HRESULT STDMETHODCALLTYPE Skip(
				/* [in] */ ULONG celt) = 0;

			virtual HRESULT STDMETHODCALLTYPE Reset(void) = 0;

			virtual HRESULT STDMETHODCALLTYPE Clone(
				/* [out] */ IEnumSTATDATA** ppenum) = 0;

		};

#else 	/* C style interface */

		typedef struct IEnumSTATDATAVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IEnumSTATDATA* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IEnumSTATDATA* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IEnumSTATDATA* This);

			/* [local] */ HRESULT(STDMETHODCALLTYPE* Next)(
				IEnumSTATDATA* This,
				/* [in] */ ULONG celt,
				/* [length_is][size_is][out] */ STATDATA* rgelt,
				/* [out] */ ULONG* pceltFetched);

			HRESULT(STDMETHODCALLTYPE* Skip)(
				IEnumSTATDATA* This,
				/* [in] */ ULONG celt);

			HRESULT(STDMETHODCALLTYPE* Reset)(
				IEnumSTATDATA* This);

			HRESULT(STDMETHODCALLTYPE* Clone)(
				IEnumSTATDATA* This,
				/* [out] */ IEnumSTATDATA** ppenum);

			END_INTERFACE
		} IEnumSTATDATAVtbl;

		interface IEnumSTATDATA
		{
			CONST_VTBL struct IEnumSTATDATAVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IEnumSTATDATA_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumSTATDATA_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumSTATDATA_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumSTATDATA_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumSTATDATA_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumSTATDATA_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumSTATDATA_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumSTATDATA_RemoteNext_Proxy(
			IEnumSTATDATA* This,
			/* [in] */ ULONG celt,
			/* [length_is][size_is][out] */ STATDATA* rgelt,
			/* [out] */ ULONG* pceltFetched);


		void __RPC_STUB IEnumSTATDATA_RemoteNext_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IEnumSTATDATA_Skip_Proxy(
			IEnumSTATDATA* This,
			/* [in] */ ULONG celt);


		void __RPC_STUB IEnumSTATDATA_Skip_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IEnumSTATDATA_Reset_Proxy(
			IEnumSTATDATA* This);


		void __RPC_STUB IEnumSTATDATA_Reset_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IEnumSTATDATA_Clone_Proxy(
			IEnumSTATDATA* This,
			/* [out] */ IEnumSTATDATA** ppenum);


		void __RPC_STUB IEnumSTATDATA_Clone_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IEnumSTATDATA_INTERFACE_DEFINED__ */


#ifndef __IRootStorage_INTERFACE_DEFINED__
#define __IRootStorage_INTERFACE_DEFINED__

		/* interface IRootStorage */
		/* [unique][uuid][object] */

		typedef /* [unique] */ IRootStorage* LPROOTSTORAGE;


		EXTERN_C const IID IID_IRootStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000012-0000-0000-C000-000000000046")
			IRootStorage : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE SwitchToFile(
				/* [in] */ LPOLESTR pszFile) = 0;

		};

#else 	/* C style interface */

		typedef struct IRootStorageVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IRootStorage* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IRootStorage* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IRootStorage* This);

			HRESULT(STDMETHODCALLTYPE* SwitchToFile)(
				IRootStorage* This,
				/* [in] */ LPOLESTR pszFile);

			END_INTERFACE
		} IRootStorageVtbl;

		interface IRootStorage
		{
			CONST_VTBL struct IRootStorageVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IRootStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRootStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRootStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRootStorage_SwitchToFile(This,pszFile)	\
    (This)->lpVtbl -> SwitchToFile(This,pszFile)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IRootStorage_SwitchToFile_Proxy(
			IRootStorage* This,
			/* [in] */ LPOLESTR pszFile);


		void __RPC_STUB IRootStorage_SwitchToFile_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IRootStorage_INTERFACE_DEFINED__ */


#ifndef __IAdviseSink_INTERFACE_DEFINED__
#define __IAdviseSink_INTERFACE_DEFINED__

		/* interface IAdviseSink */
		/* [unique][async_uuid][uuid][object] */

		typedef IAdviseSink* LPADVISESINK;

		typedef /* [v1_enum] */
			enum tagTYMED
		{
			TYMED_HGLOBAL = 1,
			TYMED_FILE = 2,
			TYMED_ISTREAM = 4,
			TYMED_ISTORAGE = 8,
			TYMED_GDI = 16,
			TYMED_MFPICT = 32,
			TYMED_ENHMF = 64,
			TYMED_NULL = 0
		} 	TYMED;

#ifndef RC_INVOKED
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4200)
#endif
		typedef struct tagRemSTGMEDIUM
		{
			DWORD tymed;
			DWORD dwHandleType;
			unsigned long pData;
			unsigned long pUnkForRelease;
			unsigned long cbData;
			/* [size_is] */ byte data[1];
		} 	RemSTGMEDIUM;

#ifndef RC_INVOKED
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4200)
#endif
#endif
#ifdef NONAMELESSUNION
		typedef struct tagSTGMEDIUM {
			DWORD tymed;
			union {
				HBITMAP hBitmap;
				HMETAFILEPICT hMetaFilePict;
				HENHMETAFILE hEnhMetaFile;
				HGLOBAL hGlobal;
				LPOLESTR lpszFileName;
				IStream* pstm;
				IStorage* pstg;
			} u;
			IUnknown* pUnkForRelease;
		}uSTGMEDIUM;
#else
		typedef struct tagSTGMEDIUM
		{
			DWORD tymed;
			/* [switch_is][switch_type] */ union
			{
				/* [case()] */ HBITMAP hBitmap;
				/* [case()] */ HMETAFILEPICT hMetaFilePict;
				/* [case()] */ HENHMETAFILE hEnhMetaFile;
				/* [case()] */ HGLOBAL hGlobal;
				/* [case()] */ LPOLESTR lpszFileName;
				/* [case()] */ IStream* pstm;
				/* [case()] */ IStorage* pstg;
				/* [default] */  /* Empty union arm */
			};
			/* [unique] */ IUnknown* pUnkForRelease;
		} 	uSTGMEDIUM;

#endif /* !NONAMELESSUNION */
		typedef struct _GDI_OBJECT
		{
			DWORD ObjectType;
			/* [switch_is] */ /* [switch_type] */ union __MIDL_IAdviseSink_0002
			{
				/* [case()] */ wireHBITMAP hBitmap;
				/* [case()] */ wireHPALETTE hPalette;
				/* [default] */ wireHGLOBAL hGeneric;
			} 	u;
		} 	GDI_OBJECT;

		typedef struct _userSTGMEDIUM
		{
			struct _STGMEDIUM_UNION
			{
				DWORD tymed;
				/* [switch_is] */ /* [switch_type] */ union __MIDL_IAdviseSink_0003
				{
					/* [case()] */  /* Empty union arm */
					/* [case()] */ wireHMETAFILEPICT hMetaFilePict;
					/* [case()] */ wireHENHMETAFILE hHEnhMetaFile;
					/* [case()] */ GDI_OBJECT* hGdiHandle;
					/* [case()] */ wireHGLOBAL hGlobal;
					/* [case()] */ LPOLESTR lpszFileName;
					/* [case()] */ BYTE_BLOB* pstm;
					/* [case()] */ BYTE_BLOB* pstg;
				} 	u;
			};
			IUnknown* pUnkForRelease;
		} 	userSTGMEDIUM;

		typedef /* [unique] */ userSTGMEDIUM* wireSTGMEDIUM;

		typedef /* [wire_marshal] */ uSTGMEDIUM STGMEDIUM;

		typedef /* [unique] */ userSTGMEDIUM* wireASYNC_STGMEDIUM;

		typedef /* [wire_marshal] */ STGMEDIUM ASYNC_STGMEDIUM;

		typedef STGMEDIUM* LPSTGMEDIUM;

		typedef struct _userFLAG_STGMEDIUM
		{
			long ContextFlags;
			long fPassOwnership;
			userSTGMEDIUM Stgmed;
		} 	userFLAG_STGMEDIUM;

		typedef /* [unique] */ userFLAG_STGMEDIUM* wireFLAG_STGMEDIUM;

		typedef /* [wire_marshal] */ struct _FLAG_STGMEDIUM
		{
			long ContextFlags;
			long fPassOwnership;
			STGMEDIUM Stgmed;
		} 	FLAG_STGMEDIUM;


		EXTERN_C const IID IID_IAdviseSink;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("0000010f-0000-0000-C000-000000000046")
			IAdviseSink : public IUnknown
		{
		public:
			virtual /* [local] */ void STDMETHODCALLTYPE OnDataChange(
				/* [unique][in] */ FORMATETC * pFormatetc,
				/* [unique][in] */ STGMEDIUM * pStgmed) = 0;

			virtual /* [local] */ void STDMETHODCALLTYPE OnViewChange(
				/* [in] */ DWORD dwAspect,
				/* [in] */ LONG lindex) = 0;

			virtual /* [local] */ void STDMETHODCALLTYPE OnRename(
				/* [in] */ IMoniker* pmk) = 0;

			virtual /* [local] */ void STDMETHODCALLTYPE OnSave(void) = 0;

			virtual /* [local] */ void STDMETHODCALLTYPE OnClose(void) = 0;

		};

#else 	/* C style interface */

		typedef struct IAdviseSinkVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IAdviseSink* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IAdviseSink* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IAdviseSink* This);

			/* [local] */ void (STDMETHODCALLTYPE* OnDataChange)(
				IAdviseSink* This,
				/* [unique][in] */ FORMATETC* pFormatetc,
				/* [unique][in] */ STGMEDIUM* pStgmed);

			/* [local] */ void (STDMETHODCALLTYPE* OnViewChange)(
				IAdviseSink* This,
				/* [in] */ DWORD dwAspect,
				/* [in] */ LONG lindex);

			/* [local] */ void (STDMETHODCALLTYPE* OnRename)(
				IAdviseSink* This,
				/* [in] */ IMoniker* pmk);

			/* [local] */ void (STDMETHODCALLTYPE* OnSave)(
				IAdviseSink* This);

			/* [local] */ void (STDMETHODCALLTYPE* OnClose)(
				IAdviseSink* This);

			END_INTERFACE
		} IAdviseSinkVtbl;

		interface IAdviseSink
		{
			CONST_VTBL struct IAdviseSinkVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IAdviseSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAdviseSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAdviseSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAdviseSink_OnDataChange(This,pFormatetc,pStgmed)	\
    (This)->lpVtbl -> OnDataChange(This,pFormatetc,pStgmed)

#define IAdviseSink_OnViewChange(This,dwAspect,lindex)	\
    (This)->lpVtbl -> OnViewChange(This,dwAspect,lindex)

#define IAdviseSink_OnRename(This,pmk)	\
    (This)->lpVtbl -> OnRename(This,pmk)

#define IAdviseSink_OnSave(This)	\
    (This)->lpVtbl -> OnSave(This)

#define IAdviseSink_OnClose(This)	\
    (This)->lpVtbl -> OnClose(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		/* [call_as] */ HRESULT STDMETHODCALLTYPE IAdviseSink_RemoteOnDataChange_Proxy(
			IAdviseSink* This,
			/* [unique][in] */ FORMATETC* pFormatetc,
			/* [unique][in] */ ASYNC_STGMEDIUM* pStgmed);


		void __RPC_STUB IAdviseSink_RemoteOnDataChange_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IAdviseSink_RemoteOnViewChange_Proxy(
			IAdviseSink* This,
			/* [in] */ DWORD dwAspect,
			/* [in] */ LONG lindex);


		void __RPC_STUB IAdviseSink_RemoteOnViewChange_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IAdviseSink_RemoteOnRename_Proxy(
			IAdviseSink* This,
			/* [in] */ IMoniker* pmk);


		void __RPC_STUB IAdviseSink_RemoteOnRename_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IAdviseSink_RemoteOnSave_Proxy(
			IAdviseSink* This);


		void __RPC_STUB IAdviseSink_RemoteOnSave_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IAdviseSink_RemoteOnClose_Proxy(
			IAdviseSink* This);


		void __RPC_STUB IAdviseSink_RemoteOnClose_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IAdviseSink_INTERFACE_DEFINED__ */


#ifndef __AsyncIAdviseSink_INTERFACE_DEFINED__
#define __AsyncIAdviseSink_INTERFACE_DEFINED__

		/* interface AsyncIAdviseSink */
		/* [uuid][unique][object] */


		EXTERN_C const IID IID_AsyncIAdviseSink;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000150-0000-0000-C000-000000000046")
			AsyncIAdviseSink : public IUnknown
		{
		public:
			virtual /* [local] */ void STDMETHODCALLTYPE Begin_OnDataChange(
				/* [unique][in] */ FORMATETC * pFormatetc,
				/* [unique][in] */ STGMEDIUM * pStgmed) = 0;

			virtual /* [local] */ void STDMETHODCALLTYPE Finish_OnDataChange(void) = 0;

			virtual /* [local] */ void STDMETHODCALLTYPE Begin_OnViewChange(
				/* [in] */ DWORD dwAspect,
				/* [in] */ LONG lindex) = 0;

			virtual /* [local] */ void STDMETHODCALLTYPE Finish_OnViewChange(void) = 0;

			virtual /* [local] */ void STDMETHODCALLTYPE Begin_OnRename(
				/* [in] */ IMoniker* pmk) = 0;

			virtual /* [local] */ void STDMETHODCALLTYPE Finish_OnRename(void) = 0;

			virtual /* [local] */ void STDMETHODCALLTYPE Begin_OnSave(void) = 0;

			virtual /* [local] */ void STDMETHODCALLTYPE Finish_OnSave(void) = 0;

			virtual /* [local] */ void STDMETHODCALLTYPE Begin_OnClose(void) = 0;

			virtual /* [local] */ void STDMETHODCALLTYPE Finish_OnClose(void) = 0;

		};

#else 	/* C style interface */

		typedef struct AsyncIAdviseSinkVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					AsyncIAdviseSink* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				AsyncIAdviseSink* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				AsyncIAdviseSink* This);

			/* [local] */ void (STDMETHODCALLTYPE* Begin_OnDataChange)(
				AsyncIAdviseSink* This,
				/* [unique][in] */ FORMATETC* pFormatetc,
				/* [unique][in] */ STGMEDIUM* pStgmed);

			/* [local] */ void (STDMETHODCALLTYPE* Finish_OnDataChange)(
				AsyncIAdviseSink* This);

			/* [local] */ void (STDMETHODCALLTYPE* Begin_OnViewChange)(
				AsyncIAdviseSink* This,
				/* [in] */ DWORD dwAspect,
				/* [in] */ LONG lindex);

			/* [local] */ void (STDMETHODCALLTYPE* Finish_OnViewChange)(
				AsyncIAdviseSink* This);

			/* [local] */ void (STDMETHODCALLTYPE* Begin_OnRename)(
				AsyncIAdviseSink* This,
				/* [in] */ IMoniker* pmk);

			/* [local] */ void (STDMETHODCALLTYPE* Finish_OnRename)(
				AsyncIAdviseSink* This);

			/* [local] */ void (STDMETHODCALLTYPE* Begin_OnSave)(
				AsyncIAdviseSink* This);

			/* [local] */ void (STDMETHODCALLTYPE* Finish_OnSave)(
				AsyncIAdviseSink* This);

			/* [local] */ void (STDMETHODCALLTYPE* Begin_OnClose)(
				AsyncIAdviseSink* This);

			/* [local] */ void (STDMETHODCALLTYPE* Finish_OnClose)(
				AsyncIAdviseSink* This);

			END_INTERFACE
		} AsyncIAdviseSinkVtbl;

		interface AsyncIAdviseSink
		{
			CONST_VTBL struct AsyncIAdviseSinkVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define AsyncIAdviseSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define AsyncIAdviseSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define AsyncIAdviseSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define AsyncIAdviseSink_Begin_OnDataChange(This,pFormatetc,pStgmed)	\
    (This)->lpVtbl -> Begin_OnDataChange(This,pFormatetc,pStgmed)

#define AsyncIAdviseSink_Finish_OnDataChange(This)	\
    (This)->lpVtbl -> Finish_OnDataChange(This)

#define AsyncIAdviseSink_Begin_OnViewChange(This,dwAspect,lindex)	\
    (This)->lpVtbl -> Begin_OnViewChange(This,dwAspect,lindex)

#define AsyncIAdviseSink_Finish_OnViewChange(This)	\
    (This)->lpVtbl -> Finish_OnViewChange(This)

#define AsyncIAdviseSink_Begin_OnRename(This,pmk)	\
    (This)->lpVtbl -> Begin_OnRename(This,pmk)

#define AsyncIAdviseSink_Finish_OnRename(This)	\
    (This)->lpVtbl -> Finish_OnRename(This)

#define AsyncIAdviseSink_Begin_OnSave(This)	\
    (This)->lpVtbl -> Begin_OnSave(This)

#define AsyncIAdviseSink_Finish_OnSave(This)	\
    (This)->lpVtbl -> Finish_OnSave(This)

#define AsyncIAdviseSink_Begin_OnClose(This)	\
    (This)->lpVtbl -> Begin_OnClose(This)

#define AsyncIAdviseSink_Finish_OnClose(This)	\
    (This)->lpVtbl -> Finish_OnClose(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		/* [call_as] */ HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Begin_RemoteOnDataChange_Proxy(
			AsyncIAdviseSink* This,
			/* [unique][in] */ FORMATETC* pFormatetc,
			/* [unique][in] */ ASYNC_STGMEDIUM* pStgmed);


		void __RPC_STUB AsyncIAdviseSink_Begin_RemoteOnDataChange_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Finish_RemoteOnDataChange_Proxy(
			AsyncIAdviseSink* This);


		void __RPC_STUB AsyncIAdviseSink_Finish_RemoteOnDataChange_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Begin_RemoteOnViewChange_Proxy(
			AsyncIAdviseSink* This,
			/* [in] */ DWORD dwAspect,
			/* [in] */ LONG lindex);


		void __RPC_STUB AsyncIAdviseSink_Begin_RemoteOnViewChange_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Finish_RemoteOnViewChange_Proxy(
			AsyncIAdviseSink* This);


		void __RPC_STUB AsyncIAdviseSink_Finish_RemoteOnViewChange_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Begin_RemoteOnRename_Proxy(
			AsyncIAdviseSink* This,
			/* [in] */ IMoniker* pmk);


		void __RPC_STUB AsyncIAdviseSink_Begin_RemoteOnRename_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Finish_RemoteOnRename_Proxy(
			AsyncIAdviseSink* This);


		void __RPC_STUB AsyncIAdviseSink_Finish_RemoteOnRename_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Begin_RemoteOnSave_Proxy(
			AsyncIAdviseSink* This);


		void __RPC_STUB AsyncIAdviseSink_Begin_RemoteOnSave_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Finish_RemoteOnSave_Proxy(
			AsyncIAdviseSink* This);


		void __RPC_STUB AsyncIAdviseSink_Finish_RemoteOnSave_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Begin_RemoteOnClose_Proxy(
			AsyncIAdviseSink* This);


		void __RPC_STUB AsyncIAdviseSink_Begin_RemoteOnClose_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Finish_RemoteOnClose_Proxy(
			AsyncIAdviseSink* This);


		void __RPC_STUB AsyncIAdviseSink_Finish_RemoteOnClose_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __AsyncIAdviseSink_INTERFACE_DEFINED__ */


#ifndef __IAdviseSink2_INTERFACE_DEFINED__
#define __IAdviseSink2_INTERFACE_DEFINED__

		/* interface IAdviseSink2 */
		/* [unique][async_uuid][uuid][object] */

		typedef /* [unique] */ IAdviseSink2* LPADVISESINK2;


		EXTERN_C const IID IID_IAdviseSink2;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000125-0000-0000-C000-000000000046")
			IAdviseSink2 : public IAdviseSink
		{
		public:
			virtual /* [local] */ void STDMETHODCALLTYPE OnLinkSrcChange(
				/* [unique][in] */ IMoniker * pmk) = 0;

		};

#else 	/* C style interface */

		typedef struct IAdviseSink2Vtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IAdviseSink2* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IAdviseSink2* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IAdviseSink2* This);

			/* [local] */ void (STDMETHODCALLTYPE* OnDataChange)(
				IAdviseSink2* This,
				/* [unique][in] */ FORMATETC* pFormatetc,
				/* [unique][in] */ STGMEDIUM* pStgmed);

			/* [local] */ void (STDMETHODCALLTYPE* OnViewChange)(
				IAdviseSink2* This,
				/* [in] */ DWORD dwAspect,
				/* [in] */ LONG lindex);

			/* [local] */ void (STDMETHODCALLTYPE* OnRename)(
				IAdviseSink2* This,
				/* [in] */ IMoniker* pmk);

			/* [local] */ void (STDMETHODCALLTYPE* OnSave)(
				IAdviseSink2* This);

			/* [local] */ void (STDMETHODCALLTYPE* OnClose)(
				IAdviseSink2* This);

			/* [local] */ void (STDMETHODCALLTYPE* OnLinkSrcChange)(
				IAdviseSink2* This,
				/* [unique][in] */ IMoniker* pmk);

			END_INTERFACE
		} IAdviseSink2Vtbl;

		interface IAdviseSink2
		{
			CONST_VTBL struct IAdviseSink2Vtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IAdviseSink2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAdviseSink2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAdviseSink2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAdviseSink2_OnDataChange(This,pFormatetc,pStgmed)	\
    (This)->lpVtbl -> OnDataChange(This,pFormatetc,pStgmed)

#define IAdviseSink2_OnViewChange(This,dwAspect,lindex)	\
    (This)->lpVtbl -> OnViewChange(This,dwAspect,lindex)

#define IAdviseSink2_OnRename(This,pmk)	\
    (This)->lpVtbl -> OnRename(This,pmk)

#define IAdviseSink2_OnSave(This)	\
    (This)->lpVtbl -> OnSave(This)

#define IAdviseSink2_OnClose(This)	\
    (This)->lpVtbl -> OnClose(This)


#define IAdviseSink2_OnLinkSrcChange(This,pmk)	\
    (This)->lpVtbl -> OnLinkSrcChange(This,pmk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		/* [call_as] */ HRESULT STDMETHODCALLTYPE IAdviseSink2_RemoteOnLinkSrcChange_Proxy(
			IAdviseSink2* This,
			/* [unique][in] */ IMoniker* pmk);


		void __RPC_STUB IAdviseSink2_RemoteOnLinkSrcChange_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IAdviseSink2_INTERFACE_DEFINED__ */


#ifndef __AsyncIAdviseSink2_INTERFACE_DEFINED__
#define __AsyncIAdviseSink2_INTERFACE_DEFINED__

		/* interface AsyncIAdviseSink2 */
		/* [uuid][unique][object] */


		EXTERN_C const IID IID_AsyncIAdviseSink2;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000151-0000-0000-C000-000000000046")
			AsyncIAdviseSink2 : public AsyncIAdviseSink
		{
		public:
			virtual /* [local] */ void STDMETHODCALLTYPE Begin_OnLinkSrcChange(
				/* [unique][in] */ IMoniker * pmk) = 0;

			virtual /* [local] */ void STDMETHODCALLTYPE Finish_OnLinkSrcChange(void) = 0;

		};

#else 	/* C style interface */

		typedef struct AsyncIAdviseSink2Vtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					AsyncIAdviseSink2* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				AsyncIAdviseSink2* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				AsyncIAdviseSink2* This);

			/* [local] */ void (STDMETHODCALLTYPE* Begin_OnDataChange)(
				AsyncIAdviseSink2* This,
				/* [unique][in] */ FORMATETC* pFormatetc,
				/* [unique][in] */ STGMEDIUM* pStgmed);

			/* [local] */ void (STDMETHODCALLTYPE* Finish_OnDataChange)(
				AsyncIAdviseSink2* This);

			/* [local] */ void (STDMETHODCALLTYPE* Begin_OnViewChange)(
				AsyncIAdviseSink2* This,
				/* [in] */ DWORD dwAspect,
				/* [in] */ LONG lindex);

			/* [local] */ void (STDMETHODCALLTYPE* Finish_OnViewChange)(
				AsyncIAdviseSink2* This);

			/* [local] */ void (STDMETHODCALLTYPE* Begin_OnRename)(
				AsyncIAdviseSink2* This,
				/* [in] */ IMoniker* pmk);

			/* [local] */ void (STDMETHODCALLTYPE* Finish_OnRename)(
				AsyncIAdviseSink2* This);

			/* [local] */ void (STDMETHODCALLTYPE* Begin_OnSave)(
				AsyncIAdviseSink2* This);

			/* [local] */ void (STDMETHODCALLTYPE* Finish_OnSave)(
				AsyncIAdviseSink2* This);

			/* [local] */ void (STDMETHODCALLTYPE* Begin_OnClose)(
				AsyncIAdviseSink2* This);

			/* [local] */ void (STDMETHODCALLTYPE* Finish_OnClose)(
				AsyncIAdviseSink2* This);

			/* [local] */ void (STDMETHODCALLTYPE* Begin_OnLinkSrcChange)(
				AsyncIAdviseSink2* This,
				/* [unique][in] */ IMoniker* pmk);

			/* [local] */ void (STDMETHODCALLTYPE* Finish_OnLinkSrcChange)(
				AsyncIAdviseSink2* This);

			END_INTERFACE
		} AsyncIAdviseSink2Vtbl;

		interface AsyncIAdviseSink2
		{
			CONST_VTBL struct AsyncIAdviseSink2Vtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define AsyncIAdviseSink2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define AsyncIAdviseSink2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define AsyncIAdviseSink2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define AsyncIAdviseSink2_Begin_OnDataChange(This,pFormatetc,pStgmed)	\
    (This)->lpVtbl -> Begin_OnDataChange(This,pFormatetc,pStgmed)

#define AsyncIAdviseSink2_Finish_OnDataChange(This)	\
    (This)->lpVtbl -> Finish_OnDataChange(This)

#define AsyncIAdviseSink2_Begin_OnViewChange(This,dwAspect,lindex)	\
    (This)->lpVtbl -> Begin_OnViewChange(This,dwAspect,lindex)

#define AsyncIAdviseSink2_Finish_OnViewChange(This)	\
    (This)->lpVtbl -> Finish_OnViewChange(This)

#define AsyncIAdviseSink2_Begin_OnRename(This,pmk)	\
    (This)->lpVtbl -> Begin_OnRename(This,pmk)

#define AsyncIAdviseSink2_Finish_OnRename(This)	\
    (This)->lpVtbl -> Finish_OnRename(This)

#define AsyncIAdviseSink2_Begin_OnSave(This)	\
    (This)->lpVtbl -> Begin_OnSave(This)

#define AsyncIAdviseSink2_Finish_OnSave(This)	\
    (This)->lpVtbl -> Finish_OnSave(This)

#define AsyncIAdviseSink2_Begin_OnClose(This)	\
    (This)->lpVtbl -> Begin_OnClose(This)

#define AsyncIAdviseSink2_Finish_OnClose(This)	\
    (This)->lpVtbl -> Finish_OnClose(This)


#define AsyncIAdviseSink2_Begin_OnLinkSrcChange(This,pmk)	\
    (This)->lpVtbl -> Begin_OnLinkSrcChange(This,pmk)

#define AsyncIAdviseSink2_Finish_OnLinkSrcChange(This)	\
    (This)->lpVtbl -> Finish_OnLinkSrcChange(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		/* [call_as] */ HRESULT STDMETHODCALLTYPE AsyncIAdviseSink2_Begin_RemoteOnLinkSrcChange_Proxy(
			AsyncIAdviseSink2* This,
			/* [unique][in] */ IMoniker* pmk);


		void __RPC_STUB AsyncIAdviseSink2_Begin_RemoteOnLinkSrcChange_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE AsyncIAdviseSink2_Finish_RemoteOnLinkSrcChange_Proxy(
			AsyncIAdviseSink2* This);


		void __RPC_STUB AsyncIAdviseSink2_Finish_RemoteOnLinkSrcChange_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __AsyncIAdviseSink2_INTERFACE_DEFINED__ */


#ifndef __IDataObject_INTERFACE_DEFINED__
#define __IDataObject_INTERFACE_DEFINED__

		/* interface IDataObject */
		/* [unique][uuid][object] */

		typedef /* [unique] */ IDataObject* LPDATAOBJECT;

		typedef
			enum tagDATADIR
		{
			DATADIR_GET = 1,
			DATADIR_SET = 2
		} 	DATADIR;


		EXTERN_C const IID IID_IDataObject;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("0000010e-0000-0000-C000-000000000046")
			IDataObject : public IUnknown
		{
		public:
			virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetData(
				/* [unique][in] */ FORMATETC * pformatetcIn,
				/* [out] */ STGMEDIUM * pmedium) = 0;

			virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetDataHere(
				/* [unique][in] */ FORMATETC* pformatetc,
				/* [out][in] */ STGMEDIUM* pmedium) = 0;

			virtual HRESULT STDMETHODCALLTYPE QueryGetData(
				/* [unique][in] */ FORMATETC* pformatetc) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetCanonicalFormatEtc(
				/* [unique][in] */ FORMATETC* pformatectIn,
				/* [out] */ FORMATETC* pformatetcOut) = 0;

			virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetData(
				/* [unique][in] */ FORMATETC* pformatetc,
				/* [unique][in] */ STGMEDIUM* pmedium,
				/* [in] */ BOOL fRelease) = 0;

			virtual HRESULT STDMETHODCALLTYPE EnumFormatEtc(
				/* [in] */ DWORD dwDirection,
				/* [out] */ IEnumFORMATETC** ppenumFormatEtc) = 0;

			virtual HRESULT STDMETHODCALLTYPE DAdvise(
				/* [in] */ FORMATETC* pformatetc,
				/* [in] */ DWORD advf,
				/* [unique][in] */ IAdviseSink* pAdvSink,
				/* [out] */ DWORD* pdwConnection) = 0;

			virtual HRESULT STDMETHODCALLTYPE DUnadvise(
				/* [in] */ DWORD dwConnection) = 0;

			virtual HRESULT STDMETHODCALLTYPE EnumDAdvise(
				/* [out] */ IEnumSTATDATA** ppenumAdvise) = 0;

		};

#else 	/* C style interface */

		typedef struct IDataObjectVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IDataObject* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IDataObject* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IDataObject* This);

			/* [local] */ HRESULT(STDMETHODCALLTYPE* GetData)(
				IDataObject* This,
				/* [unique][in] */ FORMATETC* pformatetcIn,
				/* [out] */ STGMEDIUM* pmedium);

			/* [local] */ HRESULT(STDMETHODCALLTYPE* GetDataHere)(
				IDataObject* This,
				/* [unique][in] */ FORMATETC* pformatetc,
				/* [out][in] */ STGMEDIUM* pmedium);

			HRESULT(STDMETHODCALLTYPE* QueryGetData)(
				IDataObject* This,
				/* [unique][in] */ FORMATETC* pformatetc);

			HRESULT(STDMETHODCALLTYPE* GetCanonicalFormatEtc)(
				IDataObject* This,
				/* [unique][in] */ FORMATETC* pformatectIn,
				/* [out] */ FORMATETC* pformatetcOut);

			/* [local] */ HRESULT(STDMETHODCALLTYPE* SetData)(
				IDataObject* This,
				/* [unique][in] */ FORMATETC* pformatetc,
				/* [unique][in] */ STGMEDIUM* pmedium,
				/* [in] */ BOOL fRelease);

			HRESULT(STDMETHODCALLTYPE* EnumFormatEtc)(
				IDataObject* This,
				/* [in] */ DWORD dwDirection,
				/* [out] */ IEnumFORMATETC** ppenumFormatEtc);

			HRESULT(STDMETHODCALLTYPE* DAdvise)(
				IDataObject* This,
				/* [in] */ FORMATETC* pformatetc,
				/* [in] */ DWORD advf,
				/* [unique][in] */ IAdviseSink* pAdvSink,
				/* [out] */ DWORD* pdwConnection);

			HRESULT(STDMETHODCALLTYPE* DUnadvise)(
				IDataObject* This,
				/* [in] */ DWORD dwConnection);

			HRESULT(STDMETHODCALLTYPE* EnumDAdvise)(
				IDataObject* This,
				/* [out] */ IEnumSTATDATA** ppenumAdvise);

			END_INTERFACE
		} IDataObjectVtbl;

		interface IDataObject
		{
			CONST_VTBL struct IDataObjectVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IDataObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDataObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDataObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDataObject_GetData(This,pformatetcIn,pmedium)	\
    (This)->lpVtbl -> GetData(This,pformatetcIn,pmedium)

#define IDataObject_GetDataHere(This,pformatetc,pmedium)	\
    (This)->lpVtbl -> GetDataHere(This,pformatetc,pmedium)

#define IDataObject_QueryGetData(This,pformatetc)	\
    (This)->lpVtbl -> QueryGetData(This,pformatetc)

#define IDataObject_GetCanonicalFormatEtc(This,pformatectIn,pformatetcOut)	\
    (This)->lpVtbl -> GetCanonicalFormatEtc(This,pformatectIn,pformatetcOut)

#define IDataObject_SetData(This,pformatetc,pmedium,fRelease)	\
    (This)->lpVtbl -> SetData(This,pformatetc,pmedium,fRelease)

#define IDataObject_EnumFormatEtc(This,dwDirection,ppenumFormatEtc)	\
    (This)->lpVtbl -> EnumFormatEtc(This,dwDirection,ppenumFormatEtc)

#define IDataObject_DAdvise(This,pformatetc,advf,pAdvSink,pdwConnection)	\
    (This)->lpVtbl -> DAdvise(This,pformatetc,advf,pAdvSink,pdwConnection)

#define IDataObject_DUnadvise(This,dwConnection)	\
    (This)->lpVtbl -> DUnadvise(This,dwConnection)

#define IDataObject_EnumDAdvise(This,ppenumAdvise)	\
    (This)->lpVtbl -> EnumDAdvise(This,ppenumAdvise)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		/* [call_as] */ HRESULT STDMETHODCALLTYPE IDataObject_RemoteGetData_Proxy(
			IDataObject* This,
			/* [unique][in] */ FORMATETC* pformatetcIn,
			/* [out] */ STGMEDIUM* pRemoteMedium);


		void __RPC_STUB IDataObject_RemoteGetData_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IDataObject_RemoteGetDataHere_Proxy(
			IDataObject* This,
			/* [unique][in] */ FORMATETC* pformatetc,
			/* [out][in] */ STGMEDIUM* pRemoteMedium);


		void __RPC_STUB IDataObject_RemoteGetDataHere_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IDataObject_QueryGetData_Proxy(
			IDataObject* This,
			/* [unique][in] */ FORMATETC* pformatetc);


		void __RPC_STUB IDataObject_QueryGetData_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IDataObject_GetCanonicalFormatEtc_Proxy(
			IDataObject* This,
			/* [unique][in] */ FORMATETC* pformatectIn,
			/* [out] */ FORMATETC* pformatetcOut);


		void __RPC_STUB IDataObject_GetCanonicalFormatEtc_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IDataObject_RemoteSetData_Proxy(
			IDataObject* This,
			/* [unique][in] */ FORMATETC* pformatetc,
			/* [unique][in] */ FLAG_STGMEDIUM* pmedium,
			/* [in] */ BOOL fRelease);


		void __RPC_STUB IDataObject_RemoteSetData_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IDataObject_EnumFormatEtc_Proxy(
			IDataObject* This,
			/* [in] */ DWORD dwDirection,
			/* [out] */ IEnumFORMATETC** ppenumFormatEtc);


		void __RPC_STUB IDataObject_EnumFormatEtc_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IDataObject_DAdvise_Proxy(
			IDataObject* This,
			/* [in] */ FORMATETC* pformatetc,
			/* [in] */ DWORD advf,
			/* [unique][in] */ IAdviseSink* pAdvSink,
			/* [out] */ DWORD* pdwConnection);


		void __RPC_STUB IDataObject_DAdvise_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IDataObject_DUnadvise_Proxy(
			IDataObject* This,
			/* [in] */ DWORD dwConnection);


		void __RPC_STUB IDataObject_DUnadvise_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IDataObject_EnumDAdvise_Proxy(
			IDataObject* This,
			/* [out] */ IEnumSTATDATA** ppenumAdvise);


		void __RPC_STUB IDataObject_EnumDAdvise_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IDataObject_INTERFACE_DEFINED__ */


#ifndef __IDataAdviseHolder_INTERFACE_DEFINED__
#define __IDataAdviseHolder_INTERFACE_DEFINED__

		/* interface IDataAdviseHolder */
		/* [uuid][object][local] */

		typedef /* [unique] */ IDataAdviseHolder* LPDATAADVISEHOLDER;


		EXTERN_C const IID IID_IDataAdviseHolder;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000110-0000-0000-C000-000000000046")
			IDataAdviseHolder : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE Advise(
				/* [unique][in] */ IDataObject * pDataObject,
				/* [unique][in] */ FORMATETC * pFetc,
				/* [in] */ DWORD advf,
				/* [unique][in] */ IAdviseSink * pAdvise,
				/* [out] */ DWORD * pdwConnection) = 0;

			virtual HRESULT STDMETHODCALLTYPE Unadvise(
				/* [in] */ DWORD dwConnection) = 0;

			virtual HRESULT STDMETHODCALLTYPE EnumAdvise(
				/* [out] */ IEnumSTATDATA** ppenumAdvise) = 0;

			virtual HRESULT STDMETHODCALLTYPE SendOnDataChange(
				/* [unique][in] */ IDataObject* pDataObject,
				/* [in] */ DWORD dwReserved,
				/* [in] */ DWORD advf) = 0;

		};

#else 	/* C style interface */

		typedef struct IDataAdviseHolderVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IDataAdviseHolder* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IDataAdviseHolder* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IDataAdviseHolder* This);

			HRESULT(STDMETHODCALLTYPE* Advise)(
				IDataAdviseHolder* This,
				/* [unique][in] */ IDataObject* pDataObject,
				/* [unique][in] */ FORMATETC* pFetc,
				/* [in] */ DWORD advf,
				/* [unique][in] */ IAdviseSink* pAdvise,
				/* [out] */ DWORD* pdwConnection);

			HRESULT(STDMETHODCALLTYPE* Unadvise)(
				IDataAdviseHolder* This,
				/* [in] */ DWORD dwConnection);

			HRESULT(STDMETHODCALLTYPE* EnumAdvise)(
				IDataAdviseHolder* This,
				/* [out] */ IEnumSTATDATA** ppenumAdvise);

			HRESULT(STDMETHODCALLTYPE* SendOnDataChange)(
				IDataAdviseHolder* This,
				/* [unique][in] */ IDataObject* pDataObject,
				/* [in] */ DWORD dwReserved,
				/* [in] */ DWORD advf);

			END_INTERFACE
		} IDataAdviseHolderVtbl;

		interface IDataAdviseHolder
		{
			CONST_VTBL struct IDataAdviseHolderVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IDataAdviseHolder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDataAdviseHolder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDataAdviseHolder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDataAdviseHolder_Advise(This,pDataObject,pFetc,advf,pAdvise,pdwConnection)	\
    (This)->lpVtbl -> Advise(This,pDataObject,pFetc,advf,pAdvise,pdwConnection)

#define IDataAdviseHolder_Unadvise(This,dwConnection)	\
    (This)->lpVtbl -> Unadvise(This,dwConnection)

#define IDataAdviseHolder_EnumAdvise(This,ppenumAdvise)	\
    (This)->lpVtbl -> EnumAdvise(This,ppenumAdvise)

#define IDataAdviseHolder_SendOnDataChange(This,pDataObject,dwReserved,advf)	\
    (This)->lpVtbl -> SendOnDataChange(This,pDataObject,dwReserved,advf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IDataAdviseHolder_Advise_Proxy(
			IDataAdviseHolder* This,
			/* [unique][in] */ IDataObject* pDataObject,
			/* [unique][in] */ FORMATETC* pFetc,
			/* [in] */ DWORD advf,
			/* [unique][in] */ IAdviseSink* pAdvise,
			/* [out] */ DWORD* pdwConnection);


		void __RPC_STUB IDataAdviseHolder_Advise_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IDataAdviseHolder_Unadvise_Proxy(
			IDataAdviseHolder* This,
			/* [in] */ DWORD dwConnection);


		void __RPC_STUB IDataAdviseHolder_Unadvise_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IDataAdviseHolder_EnumAdvise_Proxy(
			IDataAdviseHolder* This,
			/* [out] */ IEnumSTATDATA** ppenumAdvise);


		void __RPC_STUB IDataAdviseHolder_EnumAdvise_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IDataAdviseHolder_SendOnDataChange_Proxy(
			IDataAdviseHolder* This,
			/* [unique][in] */ IDataObject* pDataObject,
			/* [in] */ DWORD dwReserved,
			/* [in] */ DWORD advf);


		void __RPC_STUB IDataAdviseHolder_SendOnDataChange_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IDataAdviseHolder_INTERFACE_DEFINED__ */


#ifndef __IMessageFilter_INTERFACE_DEFINED__
#define __IMessageFilter_INTERFACE_DEFINED__

		/* interface IMessageFilter */
		/* [uuid][object][local] */

		typedef /* [unique] */ IMessageFilter* LPMESSAGEFILTER;

		typedef
			enum tagCALLTYPE
		{
			CALLTYPE_TOPLEVEL = 1,
			CALLTYPE_NESTED = 2,
			CALLTYPE_ASYNC = 3,
			CALLTYPE_TOPLEVEL_CALLPENDING = 4,
			CALLTYPE_ASYNC_CALLPENDING = 5
		} 	CALLTYPE;

		typedef
			enum tagSERVERCALL
		{
			SERVERCALL_ISHANDLED = 0,
			SERVERCALL_REJECTED = 1,
			SERVERCALL_RETRYLATER = 2
		} 	SERVERCALL;

		typedef
			enum tagPENDINGTYPE
		{
			PENDINGTYPE_TOPLEVEL = 1,
			PENDINGTYPE_NESTED = 2
		} 	PENDINGTYPE;

		typedef
			enum tagPENDINGMSG
		{
			PENDINGMSG_CANCELCALL = 0,
			PENDINGMSG_WAITNOPROCESS = 1,
			PENDINGMSG_WAITDEFPROCESS = 2
		} 	PENDINGMSG;

		typedef struct tagINTERFACEINFO
		{
			IUnknown* pUnk;
			IID iid;
			WORD wMethod;
		} 	INTERFACEINFO;

		typedef struct tagINTERFACEINFO* LPINTERFACEINFO;


		EXTERN_C const IID IID_IMessageFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000016-0000-0000-C000-000000000046")
			IMessageFilter : public IUnknown
		{
		public:
			virtual DWORD STDMETHODCALLTYPE HandleInComingCall(
				/* [in] */ DWORD dwCallType,
				/* [in] */ HTASK htaskCaller,
				/* [in] */ DWORD dwTickCount,
				/* [in] */ LPINTERFACEINFO lpInterfaceInfo) = 0;

			virtual DWORD STDMETHODCALLTYPE RetryRejectedCall(
				/* [in] */ HTASK htaskCallee,
				/* [in] */ DWORD dwTickCount,
				/* [in] */ DWORD dwRejectType) = 0;

			virtual DWORD STDMETHODCALLTYPE MessagePending(
				/* [in] */ HTASK htaskCallee,
				/* [in] */ DWORD dwTickCount,
				/* [in] */ DWORD dwPendingType) = 0;

		};

#else 	/* C style interface */

		typedef struct IMessageFilterVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IMessageFilter* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IMessageFilter* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IMessageFilter* This);

			DWORD(STDMETHODCALLTYPE* HandleInComingCall)(
				IMessageFilter* This,
				/* [in] */ DWORD dwCallType,
				/* [in] */ HTASK htaskCaller,
				/* [in] */ DWORD dwTickCount,
				/* [in] */ LPINTERFACEINFO lpInterfaceInfo);

			DWORD(STDMETHODCALLTYPE* RetryRejectedCall)(
				IMessageFilter* This,
				/* [in] */ HTASK htaskCallee,
				/* [in] */ DWORD dwTickCount,
				/* [in] */ DWORD dwRejectType);

			DWORD(STDMETHODCALLTYPE* MessagePending)(
				IMessageFilter* This,
				/* [in] */ HTASK htaskCallee,
				/* [in] */ DWORD dwTickCount,
				/* [in] */ DWORD dwPendingType);

			END_INTERFACE
		} IMessageFilterVtbl;

		interface IMessageFilter
		{
			CONST_VTBL struct IMessageFilterVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IMessageFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMessageFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMessageFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMessageFilter_HandleInComingCall(This,dwCallType,htaskCaller,dwTickCount,lpInterfaceInfo)	\
    (This)->lpVtbl -> HandleInComingCall(This,dwCallType,htaskCaller,dwTickCount,lpInterfaceInfo)

#define IMessageFilter_RetryRejectedCall(This,htaskCallee,dwTickCount,dwRejectType)	\
    (This)->lpVtbl -> RetryRejectedCall(This,htaskCallee,dwTickCount,dwRejectType)

#define IMessageFilter_MessagePending(This,htaskCallee,dwTickCount,dwPendingType)	\
    (This)->lpVtbl -> MessagePending(This,htaskCallee,dwTickCount,dwPendingType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		DWORD STDMETHODCALLTYPE IMessageFilter_HandleInComingCall_Proxy(
			IMessageFilter* This,
			/* [in] */ DWORD dwCallType,
			/* [in] */ HTASK htaskCaller,
			/* [in] */ DWORD dwTickCount,
			/* [in] */ LPINTERFACEINFO lpInterfaceInfo);


		void __RPC_STUB IMessageFilter_HandleInComingCall_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		DWORD STDMETHODCALLTYPE IMessageFilter_RetryRejectedCall_Proxy(
			IMessageFilter* This,
			/* [in] */ HTASK htaskCallee,
			/* [in] */ DWORD dwTickCount,
			/* [in] */ DWORD dwRejectType);


		void __RPC_STUB IMessageFilter_RetryRejectedCall_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		DWORD STDMETHODCALLTYPE IMessageFilter_MessagePending_Proxy(
			IMessageFilter* This,
			/* [in] */ HTASK htaskCallee,
			/* [in] */ DWORD dwTickCount,
			/* [in] */ DWORD dwPendingType);


		void __RPC_STUB IMessageFilter_MessagePending_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IMessageFilter_INTERFACE_DEFINED__ */


#ifndef __IRpcChannelBuffer_INTERFACE_DEFINED__
#define __IRpcChannelBuffer_INTERFACE_DEFINED__

		/* interface IRpcChannelBuffer */
		/* [uuid][object][local] */

		typedef unsigned long RPCOLEDATAREP;

		typedef struct tagRPCOLEMESSAGE
		{
			void* reserved1;
			RPCOLEDATAREP dataRepresentation;
			void* Buffer;
			ULONG cbBuffer;
			ULONG iMethod;
			void* reserved2[5];
			ULONG rpcFlags;
		} 	RPCOLEMESSAGE;

		typedef RPCOLEMESSAGE* PRPCOLEMESSAGE;


		EXTERN_C const IID IID_IRpcChannelBuffer;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("D5F56B60-593B-101A-B569-08002B2DBF7A")
			IRpcChannelBuffer : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE GetBuffer(
				/* [in] */ RPCOLEMESSAGE * pMessage,
				/* [in] */ REFIID riid) = 0;

			virtual HRESULT STDMETHODCALLTYPE SendReceive(
				/* [out][in] */ RPCOLEMESSAGE* pMessage,
				/* [out] */ ULONG* pStatus) = 0;

			virtual HRESULT STDMETHODCALLTYPE FreeBuffer(
				/* [in] */ RPCOLEMESSAGE* pMessage) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetDestCtx(
				/* [out] */ DWORD* pdwDestContext,
				/* [out] */ void** ppvDestContext) = 0;

			virtual HRESULT STDMETHODCALLTYPE IsConnected(void) = 0;

		};

#else 	/* C style interface */

		typedef struct IRpcChannelBufferVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IRpcChannelBuffer* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IRpcChannelBuffer* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IRpcChannelBuffer* This);

			HRESULT(STDMETHODCALLTYPE* GetBuffer)(
				IRpcChannelBuffer* This,
				/* [in] */ RPCOLEMESSAGE* pMessage,
				/* [in] */ REFIID riid);

			HRESULT(STDMETHODCALLTYPE* SendReceive)(
				IRpcChannelBuffer* This,
				/* [out][in] */ RPCOLEMESSAGE* pMessage,
				/* [out] */ ULONG* pStatus);

			HRESULT(STDMETHODCALLTYPE* FreeBuffer)(
				IRpcChannelBuffer* This,
				/* [in] */ RPCOLEMESSAGE* pMessage);

			HRESULT(STDMETHODCALLTYPE* GetDestCtx)(
				IRpcChannelBuffer* This,
				/* [out] */ DWORD* pdwDestContext,
				/* [out] */ void** ppvDestContext);

			HRESULT(STDMETHODCALLTYPE* IsConnected)(
				IRpcChannelBuffer* This);

			END_INTERFACE
		} IRpcChannelBufferVtbl;

		interface IRpcChannelBuffer
		{
			CONST_VTBL struct IRpcChannelBufferVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IRpcChannelBuffer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRpcChannelBuffer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRpcChannelBuffer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRpcChannelBuffer_GetBuffer(This,pMessage,riid)	\
    (This)->lpVtbl -> GetBuffer(This,pMessage,riid)

#define IRpcChannelBuffer_SendReceive(This,pMessage,pStatus)	\
    (This)->lpVtbl -> SendReceive(This,pMessage,pStatus)

#define IRpcChannelBuffer_FreeBuffer(This,pMessage)	\
    (This)->lpVtbl -> FreeBuffer(This,pMessage)

#define IRpcChannelBuffer_GetDestCtx(This,pdwDestContext,ppvDestContext)	\
    (This)->lpVtbl -> GetDestCtx(This,pdwDestContext,ppvDestContext)

#define IRpcChannelBuffer_IsConnected(This)	\
    (This)->lpVtbl -> IsConnected(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IRpcChannelBuffer_GetBuffer_Proxy(
			IRpcChannelBuffer* This,
			/* [in] */ RPCOLEMESSAGE* pMessage,
			/* [in] */ REFIID riid);


		void __RPC_STUB IRpcChannelBuffer_GetBuffer_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IRpcChannelBuffer_SendReceive_Proxy(
			IRpcChannelBuffer* This,
			/* [out][in] */ RPCOLEMESSAGE* pMessage,
			/* [out] */ ULONG* pStatus);


		void __RPC_STUB IRpcChannelBuffer_SendReceive_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IRpcChannelBuffer_FreeBuffer_Proxy(
			IRpcChannelBuffer* This,
			/* [in] */ RPCOLEMESSAGE* pMessage);


		void __RPC_STUB IRpcChannelBuffer_FreeBuffer_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IRpcChannelBuffer_GetDestCtx_Proxy(
			IRpcChannelBuffer* This,
			/* [out] */ DWORD* pdwDestContext,
			/* [out] */ void** ppvDestContext);


		void __RPC_STUB IRpcChannelBuffer_GetDestCtx_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IRpcChannelBuffer_IsConnected_Proxy(
			IRpcChannelBuffer* This);


		void __RPC_STUB IRpcChannelBuffer_IsConnected_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IRpcChannelBuffer_INTERFACE_DEFINED__ */


#ifndef __IRpcChannelBuffer2_INTERFACE_DEFINED__
#define __IRpcChannelBuffer2_INTERFACE_DEFINED__

		/* interface IRpcChannelBuffer2 */
		/* [uuid][object][local] */


		EXTERN_C const IID IID_IRpcChannelBuffer2;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("594f31d0-7f19-11d0-b194-00a0c90dc8bf")
			IRpcChannelBuffer2 : public IRpcChannelBuffer
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE GetProtocolVersion(
				/* [out][in] */ DWORD * pdwVersion) = 0;

		};

#else 	/* C style interface */

		typedef struct IRpcChannelBuffer2Vtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IRpcChannelBuffer2* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IRpcChannelBuffer2* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IRpcChannelBuffer2* This);

			HRESULT(STDMETHODCALLTYPE* GetBuffer)(
				IRpcChannelBuffer2* This,
				/* [in] */ RPCOLEMESSAGE* pMessage,
				/* [in] */ REFIID riid);

			HRESULT(STDMETHODCALLTYPE* SendReceive)(
				IRpcChannelBuffer2* This,
				/* [out][in] */ RPCOLEMESSAGE* pMessage,
				/* [out] */ ULONG* pStatus);

			HRESULT(STDMETHODCALLTYPE* FreeBuffer)(
				IRpcChannelBuffer2* This,
				/* [in] */ RPCOLEMESSAGE* pMessage);

			HRESULT(STDMETHODCALLTYPE* GetDestCtx)(
				IRpcChannelBuffer2* This,
				/* [out] */ DWORD* pdwDestContext,
				/* [out] */ void** ppvDestContext);

			HRESULT(STDMETHODCALLTYPE* IsConnected)(
				IRpcChannelBuffer2* This);

			HRESULT(STDMETHODCALLTYPE* GetProtocolVersion)(
				IRpcChannelBuffer2* This,
				/* [out][in] */ DWORD* pdwVersion);

			END_INTERFACE
		} IRpcChannelBuffer2Vtbl;

		interface IRpcChannelBuffer2
		{
			CONST_VTBL struct IRpcChannelBuffer2Vtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IRpcChannelBuffer2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRpcChannelBuffer2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRpcChannelBuffer2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRpcChannelBuffer2_GetBuffer(This,pMessage,riid)	\
    (This)->lpVtbl -> GetBuffer(This,pMessage,riid)

#define IRpcChannelBuffer2_SendReceive(This,pMessage,pStatus)	\
    (This)->lpVtbl -> SendReceive(This,pMessage,pStatus)

#define IRpcChannelBuffer2_FreeBuffer(This,pMessage)	\
    (This)->lpVtbl -> FreeBuffer(This,pMessage)

#define IRpcChannelBuffer2_GetDestCtx(This,pdwDestContext,ppvDestContext)	\
    (This)->lpVtbl -> GetDestCtx(This,pdwDestContext,ppvDestContext)

#define IRpcChannelBuffer2_IsConnected(This)	\
    (This)->lpVtbl -> IsConnected(This)


#define IRpcChannelBuffer2_GetProtocolVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetProtocolVersion(This,pdwVersion)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IRpcChannelBuffer2_GetProtocolVersion_Proxy(
			IRpcChannelBuffer2* This,
			/* [out][in] */ DWORD* pdwVersion);


		void __RPC_STUB IRpcChannelBuffer2_GetProtocolVersion_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IRpcChannelBuffer2_INTERFACE_DEFINED__ */


#ifndef __IAsyncRpcChannelBuffer_INTERFACE_DEFINED__
#define __IAsyncRpcChannelBuffer_INTERFACE_DEFINED__

		/* interface IAsyncRpcChannelBuffer */
		/* [unique][uuid][object][local] */


		EXTERN_C const IID IID_IAsyncRpcChannelBuffer;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("a5029fb6-3c34-11d1-9c99-00c04fb998aa")
			IAsyncRpcChannelBuffer : public IRpcChannelBuffer2
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE Send(
				/* [out][in] */ RPCOLEMESSAGE * pMsg,
				/* [in] */ ISynchronize * pSync,
				/* [out] */ ULONG * pulStatus) = 0;

			virtual HRESULT STDMETHODCALLTYPE Receive(
				/* [out][in] */ RPCOLEMESSAGE* pMsg,
				/* [out] */ ULONG* pulStatus) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetDestCtxEx(
				/* [in] */ RPCOLEMESSAGE* pMsg,
				/* [out] */ DWORD* pdwDestContext,
				/* [out] */ void** ppvDestContext) = 0;

		};

#else 	/* C style interface */

		typedef struct IAsyncRpcChannelBufferVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IAsyncRpcChannelBuffer* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IAsyncRpcChannelBuffer* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IAsyncRpcChannelBuffer* This);

			HRESULT(STDMETHODCALLTYPE* GetBuffer)(
				IAsyncRpcChannelBuffer* This,
				/* [in] */ RPCOLEMESSAGE* pMessage,
				/* [in] */ REFIID riid);

			HRESULT(STDMETHODCALLTYPE* SendReceive)(
				IAsyncRpcChannelBuffer* This,
				/* [out][in] */ RPCOLEMESSAGE* pMessage,
				/* [out] */ ULONG* pStatus);

			HRESULT(STDMETHODCALLTYPE* FreeBuffer)(
				IAsyncRpcChannelBuffer* This,
				/* [in] */ RPCOLEMESSAGE* pMessage);

			HRESULT(STDMETHODCALLTYPE* GetDestCtx)(
				IAsyncRpcChannelBuffer* This,
				/* [out] */ DWORD* pdwDestContext,
				/* [out] */ void** ppvDestContext);

			HRESULT(STDMETHODCALLTYPE* IsConnected)(
				IAsyncRpcChannelBuffer* This);

			HRESULT(STDMETHODCALLTYPE* GetProtocolVersion)(
				IAsyncRpcChannelBuffer* This,
				/* [out][in] */ DWORD* pdwVersion);

			HRESULT(STDMETHODCALLTYPE* Send)(
				IAsyncRpcChannelBuffer* This,
				/* [out][in] */ RPCOLEMESSAGE* pMsg,
				/* [in] */ ISynchronize* pSync,
				/* [out] */ ULONG* pulStatus);

			HRESULT(STDMETHODCALLTYPE* Receive)(
				IAsyncRpcChannelBuffer* This,
				/* [out][in] */ RPCOLEMESSAGE* pMsg,
				/* [out] */ ULONG* pulStatus);

			HRESULT(STDMETHODCALLTYPE* GetDestCtxEx)(
				IAsyncRpcChannelBuffer* This,
				/* [in] */ RPCOLEMESSAGE* pMsg,
				/* [out] */ DWORD* pdwDestContext,
				/* [out] */ void** ppvDestContext);

			END_INTERFACE
		} IAsyncRpcChannelBufferVtbl;

		interface IAsyncRpcChannelBuffer
		{
			CONST_VTBL struct IAsyncRpcChannelBufferVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IAsyncRpcChannelBuffer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAsyncRpcChannelBuffer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAsyncRpcChannelBuffer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAsyncRpcChannelBuffer_GetBuffer(This,pMessage,riid)	\
    (This)->lpVtbl -> GetBuffer(This,pMessage,riid)

#define IAsyncRpcChannelBuffer_SendReceive(This,pMessage,pStatus)	\
    (This)->lpVtbl -> SendReceive(This,pMessage,pStatus)

#define IAsyncRpcChannelBuffer_FreeBuffer(This,pMessage)	\
    (This)->lpVtbl -> FreeBuffer(This,pMessage)

#define IAsyncRpcChannelBuffer_GetDestCtx(This,pdwDestContext,ppvDestContext)	\
    (This)->lpVtbl -> GetDestCtx(This,pdwDestContext,ppvDestContext)

#define IAsyncRpcChannelBuffer_IsConnected(This)	\
    (This)->lpVtbl -> IsConnected(This)


#define IAsyncRpcChannelBuffer_GetProtocolVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetProtocolVersion(This,pdwVersion)


#define IAsyncRpcChannelBuffer_Send(This,pMsg,pSync,pulStatus)	\
    (This)->lpVtbl -> Send(This,pMsg,pSync,pulStatus)

#define IAsyncRpcChannelBuffer_Receive(This,pMsg,pulStatus)	\
    (This)->lpVtbl -> Receive(This,pMsg,pulStatus)

#define IAsyncRpcChannelBuffer_GetDestCtxEx(This,pMsg,pdwDestContext,ppvDestContext)	\
    (This)->lpVtbl -> GetDestCtxEx(This,pMsg,pdwDestContext,ppvDestContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IAsyncRpcChannelBuffer_Send_Proxy(
			IAsyncRpcChannelBuffer* This,
			/* [out][in] */ RPCOLEMESSAGE* pMsg,
			/* [in] */ ISynchronize* pSync,
			/* [out] */ ULONG* pulStatus);


		void __RPC_STUB IAsyncRpcChannelBuffer_Send_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IAsyncRpcChannelBuffer_Receive_Proxy(
			IAsyncRpcChannelBuffer* This,
			/* [out][in] */ RPCOLEMESSAGE* pMsg,
			/* [out] */ ULONG* pulStatus);


		void __RPC_STUB IAsyncRpcChannelBuffer_Receive_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IAsyncRpcChannelBuffer_GetDestCtxEx_Proxy(
			IAsyncRpcChannelBuffer* This,
			/* [in] */ RPCOLEMESSAGE* pMsg,
			/* [out] */ DWORD* pdwDestContext,
			/* [out] */ void** ppvDestContext);


		void __RPC_STUB IAsyncRpcChannelBuffer_GetDestCtxEx_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IAsyncRpcChannelBuffer_INTERFACE_DEFINED__ */


#ifndef __IRpcChannelBuffer3_INTERFACE_DEFINED__
#define __IRpcChannelBuffer3_INTERFACE_DEFINED__

		/* interface IRpcChannelBuffer3 */
		/* [uuid][object][local] */


		EXTERN_C const IID IID_IRpcChannelBuffer3;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("25B15600-0115-11d0-BF0D-00AA00B8DFD2")
			IRpcChannelBuffer3 : public IRpcChannelBuffer2
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE Send(
				/* [out][in] */ RPCOLEMESSAGE * pMsg,
				/* [out] */ ULONG * pulStatus) = 0;

			virtual HRESULT STDMETHODCALLTYPE Receive(
				/* [out][in] */ RPCOLEMESSAGE* pMsg,
				/* [in] */ ULONG ulSize,
				/* [out] */ ULONG* pulStatus) = 0;

			virtual HRESULT STDMETHODCALLTYPE Cancel(
				/* [in] */ RPCOLEMESSAGE* pMsg) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetCallContext(
				/* [in] */ RPCOLEMESSAGE* pMsg,
				/* [in] */ REFIID riid,
				/* [out] */ void** pInterface) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetDestCtxEx(
				/* [in] */ RPCOLEMESSAGE* pMsg,
				/* [out] */ DWORD* pdwDestContext,
				/* [out] */ void** ppvDestContext) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetState(
				/* [in] */ RPCOLEMESSAGE* pMsg,
				/* [out] */ DWORD* pState) = 0;

			virtual HRESULT STDMETHODCALLTYPE RegisterAsync(
				/* [in] */ RPCOLEMESSAGE* pMsg,
				/* [in] */ IAsyncManager* pAsyncMgr) = 0;

		};

#else 	/* C style interface */

		typedef struct IRpcChannelBuffer3Vtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IRpcChannelBuffer3* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IRpcChannelBuffer3* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IRpcChannelBuffer3* This);

			HRESULT(STDMETHODCALLTYPE* GetBuffer)(
				IRpcChannelBuffer3* This,
				/* [in] */ RPCOLEMESSAGE* pMessage,
				/* [in] */ REFIID riid);

			HRESULT(STDMETHODCALLTYPE* SendReceive)(
				IRpcChannelBuffer3* This,
				/* [out][in] */ RPCOLEMESSAGE* pMessage,
				/* [out] */ ULONG* pStatus);

			HRESULT(STDMETHODCALLTYPE* FreeBuffer)(
				IRpcChannelBuffer3* This,
				/* [in] */ RPCOLEMESSAGE* pMessage);

			HRESULT(STDMETHODCALLTYPE* GetDestCtx)(
				IRpcChannelBuffer3* This,
				/* [out] */ DWORD* pdwDestContext,
				/* [out] */ void** ppvDestContext);

			HRESULT(STDMETHODCALLTYPE* IsConnected)(
				IRpcChannelBuffer3* This);

			HRESULT(STDMETHODCALLTYPE* GetProtocolVersion)(
				IRpcChannelBuffer3* This,
				/* [out][in] */ DWORD* pdwVersion);

			HRESULT(STDMETHODCALLTYPE* Send)(
				IRpcChannelBuffer3* This,
				/* [out][in] */ RPCOLEMESSAGE* pMsg,
				/* [out] */ ULONG* pulStatus);

			HRESULT(STDMETHODCALLTYPE* Receive)(
				IRpcChannelBuffer3* This,
				/* [out][in] */ RPCOLEMESSAGE* pMsg,
				/* [in] */ ULONG ulSize,
				/* [out] */ ULONG* pulStatus);

			HRESULT(STDMETHODCALLTYPE* Cancel)(
				IRpcChannelBuffer3* This,
				/* [in] */ RPCOLEMESSAGE* pMsg);

			HRESULT(STDMETHODCALLTYPE* GetCallContext)(
				IRpcChannelBuffer3* This,
				/* [in] */ RPCOLEMESSAGE* pMsg,
				/* [in] */ REFIID riid,
				/* [out] */ void** pInterface);

			HRESULT(STDMETHODCALLTYPE* GetDestCtxEx)(
				IRpcChannelBuffer3* This,
				/* [in] */ RPCOLEMESSAGE* pMsg,
				/* [out] */ DWORD* pdwDestContext,
				/* [out] */ void** ppvDestContext);

			HRESULT(STDMETHODCALLTYPE* GetState)(
				IRpcChannelBuffer3* This,
				/* [in] */ RPCOLEMESSAGE* pMsg,
				/* [out] */ DWORD* pState);

			HRESULT(STDMETHODCALLTYPE* RegisterAsync)(
				IRpcChannelBuffer3* This,
				/* [in] */ RPCOLEMESSAGE* pMsg,
				/* [in] */ IAsyncManager* pAsyncMgr);

			END_INTERFACE
		} IRpcChannelBuffer3Vtbl;

		interface IRpcChannelBuffer3
		{
			CONST_VTBL struct IRpcChannelBuffer3Vtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IRpcChannelBuffer3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRpcChannelBuffer3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRpcChannelBuffer3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRpcChannelBuffer3_GetBuffer(This,pMessage,riid)	\
    (This)->lpVtbl -> GetBuffer(This,pMessage,riid)

#define IRpcChannelBuffer3_SendReceive(This,pMessage,pStatus)	\
    (This)->lpVtbl -> SendReceive(This,pMessage,pStatus)

#define IRpcChannelBuffer3_FreeBuffer(This,pMessage)	\
    (This)->lpVtbl -> FreeBuffer(This,pMessage)

#define IRpcChannelBuffer3_GetDestCtx(This,pdwDestContext,ppvDestContext)	\
    (This)->lpVtbl -> GetDestCtx(This,pdwDestContext,ppvDestContext)

#define IRpcChannelBuffer3_IsConnected(This)	\
    (This)->lpVtbl -> IsConnected(This)


#define IRpcChannelBuffer3_GetProtocolVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetProtocolVersion(This,pdwVersion)


#define IRpcChannelBuffer3_Send(This,pMsg,pulStatus)	\
    (This)->lpVtbl -> Send(This,pMsg,pulStatus)

#define IRpcChannelBuffer3_Receive(This,pMsg,ulSize,pulStatus)	\
    (This)->lpVtbl -> Receive(This,pMsg,ulSize,pulStatus)

#define IRpcChannelBuffer3_Cancel(This,pMsg)	\
    (This)->lpVtbl -> Cancel(This,pMsg)

#define IRpcChannelBuffer3_GetCallContext(This,pMsg,riid,pInterface)	\
    (This)->lpVtbl -> GetCallContext(This,pMsg,riid,pInterface)

#define IRpcChannelBuffer3_GetDestCtxEx(This,pMsg,pdwDestContext,ppvDestContext)	\
    (This)->lpVtbl -> GetDestCtxEx(This,pMsg,pdwDestContext,ppvDestContext)

#define IRpcChannelBuffer3_GetState(This,pMsg,pState)	\
    (This)->lpVtbl -> GetState(This,pMsg,pState)

#define IRpcChannelBuffer3_RegisterAsync(This,pMsg,pAsyncMgr)	\
    (This)->lpVtbl -> RegisterAsync(This,pMsg,pAsyncMgr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IRpcChannelBuffer3_Send_Proxy(
			IRpcChannelBuffer3* This,
			/* [out][in] */ RPCOLEMESSAGE* pMsg,
			/* [out] */ ULONG* pulStatus);


		void __RPC_STUB IRpcChannelBuffer3_Send_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IRpcChannelBuffer3_Receive_Proxy(
			IRpcChannelBuffer3* This,
			/* [out][in] */ RPCOLEMESSAGE* pMsg,
			/* [in] */ ULONG ulSize,
			/* [out] */ ULONG* pulStatus);


		void __RPC_STUB IRpcChannelBuffer3_Receive_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IRpcChannelBuffer3_Cancel_Proxy(
			IRpcChannelBuffer3* This,
			/* [in] */ RPCOLEMESSAGE* pMsg);


		void __RPC_STUB IRpcChannelBuffer3_Cancel_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IRpcChannelBuffer3_GetCallContext_Proxy(
			IRpcChannelBuffer3* This,
			/* [in] */ RPCOLEMESSAGE* pMsg,
			/* [in] */ REFIID riid,
			/* [out] */ void** pInterface);


		void __RPC_STUB IRpcChannelBuffer3_GetCallContext_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IRpcChannelBuffer3_GetDestCtxEx_Proxy(
			IRpcChannelBuffer3* This,
			/* [in] */ RPCOLEMESSAGE* pMsg,
			/* [out] */ DWORD* pdwDestContext,
			/* [out] */ void** ppvDestContext);


		void __RPC_STUB IRpcChannelBuffer3_GetDestCtxEx_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IRpcChannelBuffer3_GetState_Proxy(
			IRpcChannelBuffer3* This,
			/* [in] */ RPCOLEMESSAGE* pMsg,
			/* [out] */ DWORD* pState);


		void __RPC_STUB IRpcChannelBuffer3_GetState_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IRpcChannelBuffer3_RegisterAsync_Proxy(
			IRpcChannelBuffer3* This,
			/* [in] */ RPCOLEMESSAGE* pMsg,
			/* [in] */ IAsyncManager* pAsyncMgr);


		void __RPC_STUB IRpcChannelBuffer3_RegisterAsync_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IRpcChannelBuffer3_INTERFACE_DEFINED__ */


#ifndef __IRpcSyntaxNegotiate_INTERFACE_DEFINED__
#define __IRpcSyntaxNegotiate_INTERFACE_DEFINED__

		/* interface IRpcSyntaxNegotiate */
		/* [uuid][object][local] */


		EXTERN_C const IID IID_IRpcSyntaxNegotiate;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("58a08519-24c8-4935-b482-3fd823333a4f")
			IRpcSyntaxNegotiate : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE NegotiateSyntax(
				/* [out][in] */ RPCOLEMESSAGE * pMsg) = 0;

		};

#else 	/* C style interface */

		typedef struct IRpcSyntaxNegotiateVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IRpcSyntaxNegotiate* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IRpcSyntaxNegotiate* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IRpcSyntaxNegotiate* This);

			HRESULT(STDMETHODCALLTYPE* NegotiateSyntax)(
				IRpcSyntaxNegotiate* This,
				/* [out][in] */ RPCOLEMESSAGE* pMsg);

			END_INTERFACE
		} IRpcSyntaxNegotiateVtbl;

		interface IRpcSyntaxNegotiate
		{
			CONST_VTBL struct IRpcSyntaxNegotiateVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IRpcSyntaxNegotiate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRpcSyntaxNegotiate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRpcSyntaxNegotiate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRpcSyntaxNegotiate_NegotiateSyntax(This,pMsg)	\
    (This)->lpVtbl -> NegotiateSyntax(This,pMsg)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IRpcSyntaxNegotiate_NegotiateSyntax_Proxy(
			IRpcSyntaxNegotiate* This,
			/* [out][in] */ RPCOLEMESSAGE* pMsg);


		void __RPC_STUB IRpcSyntaxNegotiate_NegotiateSyntax_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IRpcSyntaxNegotiate_INTERFACE_DEFINED__ */


#ifndef __IRpcProxyBuffer_INTERFACE_DEFINED__
#define __IRpcProxyBuffer_INTERFACE_DEFINED__

		/* interface IRpcProxyBuffer */
		/* [uuid][object][local] */


		EXTERN_C const IID IID_IRpcProxyBuffer;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("D5F56A34-593B-101A-B569-08002B2DBF7A")
			IRpcProxyBuffer : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE Connect(
				/* [unique][in] */ IRpcChannelBuffer * pRpcChannelBuffer) = 0;

			virtual void STDMETHODCALLTYPE Disconnect(void) = 0;

		};

#else 	/* C style interface */

		typedef struct IRpcProxyBufferVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IRpcProxyBuffer* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IRpcProxyBuffer* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IRpcProxyBuffer* This);

			HRESULT(STDMETHODCALLTYPE* Connect)(
				IRpcProxyBuffer* This,
				/* [unique][in] */ IRpcChannelBuffer* pRpcChannelBuffer);

			void (STDMETHODCALLTYPE* Disconnect)(
				IRpcProxyBuffer* This);

			END_INTERFACE
		} IRpcProxyBufferVtbl;

		interface IRpcProxyBuffer
		{
			CONST_VTBL struct IRpcProxyBufferVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IRpcProxyBuffer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRpcProxyBuffer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRpcProxyBuffer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRpcProxyBuffer_Connect(This,pRpcChannelBuffer)	\
    (This)->lpVtbl -> Connect(This,pRpcChannelBuffer)

#define IRpcProxyBuffer_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IRpcProxyBuffer_Connect_Proxy(
			IRpcProxyBuffer* This,
			/* [unique][in] */ IRpcChannelBuffer* pRpcChannelBuffer);


		void __RPC_STUB IRpcProxyBuffer_Connect_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		void STDMETHODCALLTYPE IRpcProxyBuffer_Disconnect_Proxy(
			IRpcProxyBuffer* This);


		void __RPC_STUB IRpcProxyBuffer_Disconnect_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IRpcProxyBuffer_INTERFACE_DEFINED__ */


#ifndef __IRpcStubBuffer_INTERFACE_DEFINED__
#define __IRpcStubBuffer_INTERFACE_DEFINED__

		/* interface IRpcStubBuffer */
		/* [uuid][object][local] */


		EXTERN_C const IID IID_IRpcStubBuffer;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("D5F56AFC-593B-101A-B569-08002B2DBF7A")
			IRpcStubBuffer : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE Connect(
				/* [in] */ IUnknown * pUnkServer) = 0;

			virtual void STDMETHODCALLTYPE Disconnect(void) = 0;

			virtual HRESULT STDMETHODCALLTYPE Invoke(
				/* [in] */ RPCOLEMESSAGE* _prpcmsg,
				/* [in] */ IRpcChannelBuffer* _pRpcChannelBuffer) = 0;

			virtual IRpcStubBuffer* STDMETHODCALLTYPE IsIIDSupported(
				/* [in] */ REFIID riid) = 0;

			virtual ULONG STDMETHODCALLTYPE CountRefs(void) = 0;

			virtual HRESULT STDMETHODCALLTYPE DebugServerQueryInterface(
				void** ppv) = 0;

			virtual void STDMETHODCALLTYPE DebugServerRelease(
				void* pv) = 0;

		};

#else 	/* C style interface */

		typedef struct IRpcStubBufferVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IRpcStubBuffer* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IRpcStubBuffer* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IRpcStubBuffer* This);

			HRESULT(STDMETHODCALLTYPE* Connect)(
				IRpcStubBuffer* This,
				/* [in] */ IUnknown* pUnkServer);

			void (STDMETHODCALLTYPE* Disconnect)(
				IRpcStubBuffer* This);

			HRESULT(STDMETHODCALLTYPE* Invoke)(
				IRpcStubBuffer* This,
				/* [in] */ RPCOLEMESSAGE* _prpcmsg,
				/* [in] */ IRpcChannelBuffer* _pRpcChannelBuffer);

			IRpcStubBuffer* (STDMETHODCALLTYPE* IsIIDSupported)(
				IRpcStubBuffer* This,
				/* [in] */ REFIID riid);

			ULONG(STDMETHODCALLTYPE* CountRefs)(
				IRpcStubBuffer* This);

			HRESULT(STDMETHODCALLTYPE* DebugServerQueryInterface)(
				IRpcStubBuffer* This,
				void** ppv);

			void (STDMETHODCALLTYPE* DebugServerRelease)(
				IRpcStubBuffer* This,
				void* pv);

			END_INTERFACE
		} IRpcStubBufferVtbl;

		interface IRpcStubBuffer
		{
			CONST_VTBL struct IRpcStubBufferVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IRpcStubBuffer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRpcStubBuffer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRpcStubBuffer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRpcStubBuffer_Connect(This,pUnkServer)	\
    (This)->lpVtbl -> Connect(This,pUnkServer)

#define IRpcStubBuffer_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IRpcStubBuffer_Invoke(This,_prpcmsg,_pRpcChannelBuffer)	\
    (This)->lpVtbl -> Invoke(This,_prpcmsg,_pRpcChannelBuffer)

#define IRpcStubBuffer_IsIIDSupported(This,riid)	\
    (This)->lpVtbl -> IsIIDSupported(This,riid)

#define IRpcStubBuffer_CountRefs(This)	\
    (This)->lpVtbl -> CountRefs(This)

#define IRpcStubBuffer_DebugServerQueryInterface(This,ppv)	\
    (This)->lpVtbl -> DebugServerQueryInterface(This,ppv)

#define IRpcStubBuffer_DebugServerRelease(This,pv)	\
    (This)->lpVtbl -> DebugServerRelease(This,pv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IRpcStubBuffer_Connect_Proxy(
			IRpcStubBuffer* This,
			/* [in] */ IUnknown* pUnkServer);


		void __RPC_STUB IRpcStubBuffer_Connect_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		void STDMETHODCALLTYPE IRpcStubBuffer_Disconnect_Proxy(
			IRpcStubBuffer* This);


		void __RPC_STUB IRpcStubBuffer_Disconnect_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IRpcStubBuffer_Invoke_Proxy(
			IRpcStubBuffer* This,
			/* [in] */ RPCOLEMESSAGE* _prpcmsg,
			/* [in] */ IRpcChannelBuffer* _pRpcChannelBuffer);


		void __RPC_STUB IRpcStubBuffer_Invoke_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		IRpcStubBuffer* STDMETHODCALLTYPE IRpcStubBuffer_IsIIDSupported_Proxy(
			IRpcStubBuffer* This,
			/* [in] */ REFIID riid);


		void __RPC_STUB IRpcStubBuffer_IsIIDSupported_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		ULONG STDMETHODCALLTYPE IRpcStubBuffer_CountRefs_Proxy(
			IRpcStubBuffer* This);


		void __RPC_STUB IRpcStubBuffer_CountRefs_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IRpcStubBuffer_DebugServerQueryInterface_Proxy(
			IRpcStubBuffer* This,
			void** ppv);


		void __RPC_STUB IRpcStubBuffer_DebugServerQueryInterface_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		void STDMETHODCALLTYPE IRpcStubBuffer_DebugServerRelease_Proxy(
			IRpcStubBuffer* This,
			void* pv);


		void __RPC_STUB IRpcStubBuffer_DebugServerRelease_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IRpcStubBuffer_INTERFACE_DEFINED__ */


#ifndef __IPSFactoryBuffer_INTERFACE_DEFINED__
#define __IPSFactoryBuffer_INTERFACE_DEFINED__

		/* interface IPSFactoryBuffer */
		/* [uuid][object][local] */


		EXTERN_C const IID IID_IPSFactoryBuffer;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("D5F569D0-593B-101A-B569-08002B2DBF7A")
			IPSFactoryBuffer : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE CreateProxy(
				/* [in] */ IUnknown * pUnkOuter,
				/* [in] */ REFIID riid,
				/* [out] */ IRpcProxyBuffer * *ppProxy,
				/* [out] */ void** ppv) = 0;

			virtual HRESULT STDMETHODCALLTYPE CreateStub(
				/* [in] */ REFIID riid,
				/* [unique][in] */ IUnknown* pUnkServer,
				/* [out] */ IRpcStubBuffer** ppStub) = 0;

		};

#else 	/* C style interface */

		typedef struct IPSFactoryBufferVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IPSFactoryBuffer* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IPSFactoryBuffer* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IPSFactoryBuffer* This);

			HRESULT(STDMETHODCALLTYPE* CreateProxy)(
				IPSFactoryBuffer* This,
				/* [in] */ IUnknown* pUnkOuter,
				/* [in] */ REFIID riid,
				/* [out] */ IRpcProxyBuffer** ppProxy,
				/* [out] */ void** ppv);

			HRESULT(STDMETHODCALLTYPE* CreateStub)(
				IPSFactoryBuffer* This,
				/* [in] */ REFIID riid,
				/* [unique][in] */ IUnknown* pUnkServer,
				/* [out] */ IRpcStubBuffer** ppStub);

			END_INTERFACE
		} IPSFactoryBufferVtbl;

		interface IPSFactoryBuffer
		{
			CONST_VTBL struct IPSFactoryBufferVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IPSFactoryBuffer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPSFactoryBuffer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPSFactoryBuffer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPSFactoryBuffer_CreateProxy(This,pUnkOuter,riid,ppProxy,ppv)	\
    (This)->lpVtbl -> CreateProxy(This,pUnkOuter,riid,ppProxy,ppv)

#define IPSFactoryBuffer_CreateStub(This,riid,pUnkServer,ppStub)	\
    (This)->lpVtbl -> CreateStub(This,riid,pUnkServer,ppStub)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IPSFactoryBuffer_CreateProxy_Proxy(
			IPSFactoryBuffer* This,
			/* [in] */ IUnknown* pUnkOuter,
			/* [in] */ REFIID riid,
			/* [out] */ IRpcProxyBuffer** ppProxy,
			/* [out] */ void** ppv);


		void __RPC_STUB IPSFactoryBuffer_CreateProxy_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPSFactoryBuffer_CreateStub_Proxy(
			IPSFactoryBuffer* This,
			/* [in] */ REFIID riid,
			/* [unique][in] */ IUnknown* pUnkServer,
			/* [out] */ IRpcStubBuffer** ppStub);


		void __RPC_STUB IPSFactoryBuffer_CreateStub_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IPSFactoryBuffer_INTERFACE_DEFINED__ */


		/* interface __MIDL_itf_objidl_0050 */
		/* [local] */

#if  (_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM) // DCOM
// This interface is only valid on Windows NT 4.0
		typedef struct SChannelHookCallInfo
		{
			IID iid;
			DWORD cbSize;
			GUID uCausality;
			DWORD dwServerPid;
			DWORD iMethod;
			void* pObject;
		} 	SChannelHookCallInfo;



		extern RPC_IF_HANDLE __MIDL_itf_objidl_0050_v0_0_c_ifspec;
		extern RPC_IF_HANDLE __MIDL_itf_objidl_0050_v0_0_s_ifspec;

#ifndef __IChannelHook_INTERFACE_DEFINED__
#define __IChannelHook_INTERFACE_DEFINED__

		/* interface IChannelHook */
		/* [uuid][object][local] */


		EXTERN_C const IID IID_IChannelHook;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("1008c4a0-7613-11cf-9af1-0020af6e72f4")
			IChannelHook : public IUnknown
		{
		public:
			virtual void STDMETHODCALLTYPE ClientGetSize(
				/* [in] */ REFGUID uExtent,
				/* [in] */ REFIID riid,
				/* [out] */ ULONG * pDataSize) = 0;

			virtual void STDMETHODCALLTYPE ClientFillBuffer(
				/* [in] */ REFGUID uExtent,
				/* [in] */ REFIID riid,
				/* [out][in] */ ULONG* pDataSize,
				/* [in] */ void* pDataBuffer) = 0;

			virtual void STDMETHODCALLTYPE ClientNotify(
				/* [in] */ REFGUID uExtent,
				/* [in] */ REFIID riid,
				/* [in] */ ULONG cbDataSize,
				/* [in] */ void* pDataBuffer,
				/* [in] */ DWORD lDataRep,
				/* [in] */ HRESULT hrFault) = 0;

			virtual void STDMETHODCALLTYPE ServerNotify(
				/* [in] */ REFGUID uExtent,
				/* [in] */ REFIID riid,
				/* [in] */ ULONG cbDataSize,
				/* [in] */ void* pDataBuffer,
				/* [in] */ DWORD lDataRep) = 0;

			virtual void STDMETHODCALLTYPE ServerGetSize(
				/* [in] */ REFGUID uExtent,
				/* [in] */ REFIID riid,
				/* [in] */ HRESULT hrFault,
				/* [out] */ ULONG* pDataSize) = 0;

			virtual void STDMETHODCALLTYPE ServerFillBuffer(
				/* [in] */ REFGUID uExtent,
				/* [in] */ REFIID riid,
				/* [out][in] */ ULONG* pDataSize,
				/* [in] */ void* pDataBuffer,
				/* [in] */ HRESULT hrFault) = 0;

		};

#else 	/* C style interface */

		typedef struct IChannelHookVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IChannelHook* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IChannelHook* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IChannelHook* This);

			void (STDMETHODCALLTYPE* ClientGetSize)(
				IChannelHook* This,
				/* [in] */ REFGUID uExtent,
				/* [in] */ REFIID riid,
				/* [out] */ ULONG* pDataSize);

			void (STDMETHODCALLTYPE* ClientFillBuffer)(
				IChannelHook* This,
				/* [in] */ REFGUID uExtent,
				/* [in] */ REFIID riid,
				/* [out][in] */ ULONG* pDataSize,
				/* [in] */ void* pDataBuffer);

			void (STDMETHODCALLTYPE* ClientNotify)(
				IChannelHook* This,
				/* [in] */ REFGUID uExtent,
				/* [in] */ REFIID riid,
				/* [in] */ ULONG cbDataSize,
				/* [in] */ void* pDataBuffer,
				/* [in] */ DWORD lDataRep,
				/* [in] */ HRESULT hrFault);

			void (STDMETHODCALLTYPE* ServerNotify)(
				IChannelHook* This,
				/* [in] */ REFGUID uExtent,
				/* [in] */ REFIID riid,
				/* [in] */ ULONG cbDataSize,
				/* [in] */ void* pDataBuffer,
				/* [in] */ DWORD lDataRep);

			void (STDMETHODCALLTYPE* ServerGetSize)(
				IChannelHook* This,
				/* [in] */ REFGUID uExtent,
				/* [in] */ REFIID riid,
				/* [in] */ HRESULT hrFault,
				/* [out] */ ULONG* pDataSize);

			void (STDMETHODCALLTYPE* ServerFillBuffer)(
				IChannelHook* This,
				/* [in] */ REFGUID uExtent,
				/* [in] */ REFIID riid,
				/* [out][in] */ ULONG* pDataSize,
				/* [in] */ void* pDataBuffer,
				/* [in] */ HRESULT hrFault);

			END_INTERFACE
		} IChannelHookVtbl;

		interface IChannelHook
		{
			CONST_VTBL struct IChannelHookVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IChannelHook_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IChannelHook_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IChannelHook_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IChannelHook_ClientGetSize(This,uExtent,riid,pDataSize)	\
    (This)->lpVtbl -> ClientGetSize(This,uExtent,riid,pDataSize)

#define IChannelHook_ClientFillBuffer(This,uExtent,riid,pDataSize,pDataBuffer)	\
    (This)->lpVtbl -> ClientFillBuffer(This,uExtent,riid,pDataSize,pDataBuffer)

#define IChannelHook_ClientNotify(This,uExtent,riid,cbDataSize,pDataBuffer,lDataRep,hrFault)	\
    (This)->lpVtbl -> ClientNotify(This,uExtent,riid,cbDataSize,pDataBuffer,lDataRep,hrFault)

#define IChannelHook_ServerNotify(This,uExtent,riid,cbDataSize,pDataBuffer,lDataRep)	\
    (This)->lpVtbl -> ServerNotify(This,uExtent,riid,cbDataSize,pDataBuffer,lDataRep)

#define IChannelHook_ServerGetSize(This,uExtent,riid,hrFault,pDataSize)	\
    (This)->lpVtbl -> ServerGetSize(This,uExtent,riid,hrFault,pDataSize)

#define IChannelHook_ServerFillBuffer(This,uExtent,riid,pDataSize,pDataBuffer,hrFault)	\
    (This)->lpVtbl -> ServerFillBuffer(This,uExtent,riid,pDataSize,pDataBuffer,hrFault)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		void STDMETHODCALLTYPE IChannelHook_ClientGetSize_Proxy(
			IChannelHook* This,
			/* [in] */ REFGUID uExtent,
			/* [in] */ REFIID riid,
			/* [out] */ ULONG* pDataSize);


		void __RPC_STUB IChannelHook_ClientGetSize_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		void STDMETHODCALLTYPE IChannelHook_ClientFillBuffer_Proxy(
			IChannelHook* This,
			/* [in] */ REFGUID uExtent,
			/* [in] */ REFIID riid,
			/* [out][in] */ ULONG* pDataSize,
			/* [in] */ void* pDataBuffer);


		void __RPC_STUB IChannelHook_ClientFillBuffer_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		void STDMETHODCALLTYPE IChannelHook_ClientNotify_Proxy(
			IChannelHook* This,
			/* [in] */ REFGUID uExtent,
			/* [in] */ REFIID riid,
			/* [in] */ ULONG cbDataSize,
			/* [in] */ void* pDataBuffer,
			/* [in] */ DWORD lDataRep,
			/* [in] */ HRESULT hrFault);


		void __RPC_STUB IChannelHook_ClientNotify_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		void STDMETHODCALLTYPE IChannelHook_ServerNotify_Proxy(
			IChannelHook* This,
			/* [in] */ REFGUID uExtent,
			/* [in] */ REFIID riid,
			/* [in] */ ULONG cbDataSize,
			/* [in] */ void* pDataBuffer,
			/* [in] */ DWORD lDataRep);


		void __RPC_STUB IChannelHook_ServerNotify_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		void STDMETHODCALLTYPE IChannelHook_ServerGetSize_Proxy(
			IChannelHook* This,
			/* [in] */ REFGUID uExtent,
			/* [in] */ REFIID riid,
			/* [in] */ HRESULT hrFault,
			/* [out] */ ULONG* pDataSize);


		void __RPC_STUB IChannelHook_ServerGetSize_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		void STDMETHODCALLTYPE IChannelHook_ServerFillBuffer_Proxy(
			IChannelHook* This,
			/* [in] */ REFGUID uExtent,
			/* [in] */ REFIID riid,
			/* [out][in] */ ULONG* pDataSize,
			/* [in] */ void* pDataBuffer,
			/* [in] */ HRESULT hrFault);


		void __RPC_STUB IChannelHook_ServerFillBuffer_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IChannelHook_INTERFACE_DEFINED__ */


		/* interface __MIDL_itf_objidl_0051 */
		/* [local] */

#endif //DCOM

// Well-known Property Set Format IDs
		extern const FMTID FMTID_SummaryInformation;

		extern const FMTID FMTID_DocSummaryInformation;

		extern const FMTID FMTID_UserDefinedProperties;

		extern const FMTID FMTID_DiscardableInformation;

		extern const FMTID FMTID_ImageSummaryInformation;

		extern const FMTID FMTID_AudioSummaryInformation;

		extern const FMTID FMTID_VideoSummaryInformation;

		extern const FMTID FMTID_MediaFileSummaryInformation;

#if  (_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM) // DCOM
		// This interface is only valid on Windows NT 4.0


		extern RPC_IF_HANDLE __MIDL_itf_objidl_0051_v0_0_c_ifspec;
		extern RPC_IF_HANDLE __MIDL_itf_objidl_0051_v0_0_s_ifspec;

#ifndef __IClientSecurity_INTERFACE_DEFINED__
#define __IClientSecurity_INTERFACE_DEFINED__

		/* interface IClientSecurity */
		/* [uuid][object][local] */

		typedef struct tagSOLE_AUTHENTICATION_SERVICE
		{
			DWORD dwAuthnSvc;
			DWORD dwAuthzSvc;
			OLECHAR* pPrincipalName;
			HRESULT hr;
		} 	SOLE_AUTHENTICATION_SERVICE;

		typedef SOLE_AUTHENTICATION_SERVICE* PSOLE_AUTHENTICATION_SERVICE;

		typedef
			enum tagEOLE_AUTHENTICATION_CAPABILITIES
		{
			EOAC_NONE = 0,
			EOAC_MUTUAL_AUTH = 0x1,
			EOAC_STATIC_CLOAKING = 0x20,
			EOAC_DYNAMIC_CLOAKING = 0x40,
			EOAC_ANY_AUTHORITY = 0x80,
			EOAC_MAKE_FULLSIC = 0x100,
			EOAC_DEFAULT = 0x800,
			EOAC_SECURE_REFS = 0x2,
			EOAC_ACCESS_CONTROL = 0x4,
			EOAC_APPID = 0x8,
			EOAC_DYNAMIC = 0x10,
			EOAC_REQUIRE_FULLSIC = 0x200,
			EOAC_AUTO_IMPERSONATE = 0x400,
			EOAC_NO_CUSTOM_MARSHAL = 0x2000,
			EOAC_DISABLE_AAA = 0x1000
		} 	EOLE_AUTHENTICATION_CAPABILITIES;

#define	COLE_DEFAULT_PRINCIPAL	( ( OLECHAR * )-1 )

#define	COLE_DEFAULT_AUTHINFO	( ( void * )-1 )

		typedef struct tagSOLE_AUTHENTICATION_INFO
		{
			DWORD dwAuthnSvc;
			DWORD dwAuthzSvc;
			void* pAuthInfo;
		} 	SOLE_AUTHENTICATION_INFO;

		typedef struct tagSOLE_AUTHENTICATION_INFO* PSOLE_AUTHENTICATION_INFO;

		typedef struct tagSOLE_AUTHENTICATION_LIST
		{
			DWORD cAuthInfo;
			SOLE_AUTHENTICATION_INFO* aAuthInfo;
		} 	SOLE_AUTHENTICATION_LIST;

		typedef struct tagSOLE_AUTHENTICATION_LIST* PSOLE_AUTHENTICATION_LIST;


		EXTERN_C const IID IID_IClientSecurity;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("0000013D-0000-0000-C000-000000000046")
			IClientSecurity : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE QueryBlanket(
				/* [in] */ IUnknown * pProxy,
				/* [out] */ DWORD * pAuthnSvc,
				/* [out] */ DWORD * pAuthzSvc,
				/* [out] */ OLECHAR * *pServerPrincName,
				/* [out] */ DWORD * pAuthnLevel,
				/* [out] */ DWORD * pImpLevel,
				/* [out] */ void** pAuthInfo,
				/* [out] */ DWORD * pCapabilites) = 0;

			virtual HRESULT STDMETHODCALLTYPE SetBlanket(
				/* [in] */ IUnknown* pProxy,
				/* [in] */ DWORD dwAuthnSvc,
				/* [in] */ DWORD dwAuthzSvc,
				/* [in] */ OLECHAR* pServerPrincName,
				/* [in] */ DWORD dwAuthnLevel,
				/* [in] */ DWORD dwImpLevel,
				/* [in] */ void* pAuthInfo,
				/* [in] */ DWORD dwCapabilities) = 0;

			virtual HRESULT STDMETHODCALLTYPE CopyProxy(
				/* [in] */ IUnknown* pProxy,
				/* [out] */ IUnknown** ppCopy) = 0;

		};

#else 	/* C style interface */

		typedef struct IClientSecurityVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IClientSecurity* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IClientSecurity* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IClientSecurity* This);

			HRESULT(STDMETHODCALLTYPE* QueryBlanket)(
				IClientSecurity* This,
				/* [in] */ IUnknown* pProxy,
				/* [out] */ DWORD* pAuthnSvc,
				/* [out] */ DWORD* pAuthzSvc,
				/* [out] */ OLECHAR** pServerPrincName,
				/* [out] */ DWORD* pAuthnLevel,
				/* [out] */ DWORD* pImpLevel,
				/* [out] */ void** pAuthInfo,
				/* [out] */ DWORD* pCapabilites);

			HRESULT(STDMETHODCALLTYPE* SetBlanket)(
				IClientSecurity* This,
				/* [in] */ IUnknown* pProxy,
				/* [in] */ DWORD dwAuthnSvc,
				/* [in] */ DWORD dwAuthzSvc,
				/* [in] */ OLECHAR* pServerPrincName,
				/* [in] */ DWORD dwAuthnLevel,
				/* [in] */ DWORD dwImpLevel,
				/* [in] */ void* pAuthInfo,
				/* [in] */ DWORD dwCapabilities);

			HRESULT(STDMETHODCALLTYPE* CopyProxy)(
				IClientSecurity* This,
				/* [in] */ IUnknown* pProxy,
				/* [out] */ IUnknown** ppCopy);

			END_INTERFACE
		} IClientSecurityVtbl;

		interface IClientSecurity
		{
			CONST_VTBL struct IClientSecurityVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IClientSecurity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IClientSecurity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IClientSecurity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IClientSecurity_QueryBlanket(This,pProxy,pAuthnSvc,pAuthzSvc,pServerPrincName,pAuthnLevel,pImpLevel,pAuthInfo,pCapabilites)	\
    (This)->lpVtbl -> QueryBlanket(This,pProxy,pAuthnSvc,pAuthzSvc,pServerPrincName,pAuthnLevel,pImpLevel,pAuthInfo,pCapabilites)

#define IClientSecurity_SetBlanket(This,pProxy,dwAuthnSvc,dwAuthzSvc,pServerPrincName,dwAuthnLevel,dwImpLevel,pAuthInfo,dwCapabilities)	\
    (This)->lpVtbl -> SetBlanket(This,pProxy,dwAuthnSvc,dwAuthzSvc,pServerPrincName,dwAuthnLevel,dwImpLevel,pAuthInfo,dwCapabilities)

#define IClientSecurity_CopyProxy(This,pProxy,ppCopy)	\
    (This)->lpVtbl -> CopyProxy(This,pProxy,ppCopy)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IClientSecurity_QueryBlanket_Proxy(
			IClientSecurity* This,
			/* [in] */ IUnknown* pProxy,
			/* [out] */ DWORD* pAuthnSvc,
			/* [out] */ DWORD* pAuthzSvc,
			/* [out] */ OLECHAR** pServerPrincName,
			/* [out] */ DWORD* pAuthnLevel,
			/* [out] */ DWORD* pImpLevel,
			/* [out] */ void** pAuthInfo,
			/* [out] */ DWORD* pCapabilites);


		void __RPC_STUB IClientSecurity_QueryBlanket_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IClientSecurity_SetBlanket_Proxy(
			IClientSecurity* This,
			/* [in] */ IUnknown* pProxy,
			/* [in] */ DWORD dwAuthnSvc,
			/* [in] */ DWORD dwAuthzSvc,
			/* [in] */ OLECHAR* pServerPrincName,
			/* [in] */ DWORD dwAuthnLevel,
			/* [in] */ DWORD dwImpLevel,
			/* [in] */ void* pAuthInfo,
			/* [in] */ DWORD dwCapabilities);


		void __RPC_STUB IClientSecurity_SetBlanket_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IClientSecurity_CopyProxy_Proxy(
			IClientSecurity* This,
			/* [in] */ IUnknown* pProxy,
			/* [out] */ IUnknown** ppCopy);


		void __RPC_STUB IClientSecurity_CopyProxy_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IClientSecurity_INTERFACE_DEFINED__ */


#ifndef __IServerSecurity_INTERFACE_DEFINED__
#define __IServerSecurity_INTERFACE_DEFINED__

		/* interface IServerSecurity */
		/* [uuid][object][local] */


		EXTERN_C const IID IID_IServerSecurity;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("0000013E-0000-0000-C000-000000000046")
			IServerSecurity : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE QueryBlanket(
				/* [out] */ DWORD * pAuthnSvc,
				/* [out] */ DWORD * pAuthzSvc,
				/* [out] */ OLECHAR * *pServerPrincName,
				/* [out] */ DWORD * pAuthnLevel,
				/* [out] */ DWORD * pImpLevel,
				/* [out] */ void** pPrivs,
				/* [out][in] */ DWORD * pCapabilities) = 0;

			virtual HRESULT STDMETHODCALLTYPE ImpersonateClient(void) = 0;

			virtual HRESULT STDMETHODCALLTYPE RevertToSelf(void) = 0;

			virtual BOOL STDMETHODCALLTYPE IsImpersonating(void) = 0;

		};

#else 	/* C style interface */

		typedef struct IServerSecurityVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IServerSecurity* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IServerSecurity* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IServerSecurity* This);

			HRESULT(STDMETHODCALLTYPE* QueryBlanket)(
				IServerSecurity* This,
				/* [out] */ DWORD* pAuthnSvc,
				/* [out] */ DWORD* pAuthzSvc,
				/* [out] */ OLECHAR** pServerPrincName,
				/* [out] */ DWORD* pAuthnLevel,
				/* [out] */ DWORD* pImpLevel,
				/* [out] */ void** pPrivs,
				/* [out][in] */ DWORD* pCapabilities);

			HRESULT(STDMETHODCALLTYPE* ImpersonateClient)(
				IServerSecurity* This);

			HRESULT(STDMETHODCALLTYPE* RevertToSelf)(
				IServerSecurity* This);

			BOOL(STDMETHODCALLTYPE* IsImpersonating)(
				IServerSecurity* This);

			END_INTERFACE
		} IServerSecurityVtbl;

		interface IServerSecurity
		{
			CONST_VTBL struct IServerSecurityVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IServerSecurity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServerSecurity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServerSecurity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServerSecurity_QueryBlanket(This,pAuthnSvc,pAuthzSvc,pServerPrincName,pAuthnLevel,pImpLevel,pPrivs,pCapabilities)	\
    (This)->lpVtbl -> QueryBlanket(This,pAuthnSvc,pAuthzSvc,pServerPrincName,pAuthnLevel,pImpLevel,pPrivs,pCapabilities)

#define IServerSecurity_ImpersonateClient(This)	\
    (This)->lpVtbl -> ImpersonateClient(This)

#define IServerSecurity_RevertToSelf(This)	\
    (This)->lpVtbl -> RevertToSelf(This)

#define IServerSecurity_IsImpersonating(This)	\
    (This)->lpVtbl -> IsImpersonating(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IServerSecurity_QueryBlanket_Proxy(
			IServerSecurity* This,
			/* [out] */ DWORD* pAuthnSvc,
			/* [out] */ DWORD* pAuthzSvc,
			/* [out] */ OLECHAR** pServerPrincName,
			/* [out] */ DWORD* pAuthnLevel,
			/* [out] */ DWORD* pImpLevel,
			/* [out] */ void** pPrivs,
			/* [out][in] */ DWORD* pCapabilities);


		void __RPC_STUB IServerSecurity_QueryBlanket_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IServerSecurity_ImpersonateClient_Proxy(
			IServerSecurity* This);


		void __RPC_STUB IServerSecurity_ImpersonateClient_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IServerSecurity_RevertToSelf_Proxy(
			IServerSecurity* This);


		void __RPC_STUB IServerSecurity_RevertToSelf_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		BOOL STDMETHODCALLTYPE IServerSecurity_IsImpersonating_Proxy(
			IServerSecurity* This);


		void __RPC_STUB IServerSecurity_IsImpersonating_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IServerSecurity_INTERFACE_DEFINED__ */


#ifndef __IClassActivator_INTERFACE_DEFINED__
#define __IClassActivator_INTERFACE_DEFINED__

		/* interface IClassActivator */
		/* [uuid][object] */


		EXTERN_C const IID IID_IClassActivator;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000140-0000-0000-C000-000000000046")
			IClassActivator : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE GetClassObject(
				/* [in] */ REFCLSID rclsid,
				/* [in] */ DWORD dwClassContext,
				/* [in] */ LCID locale,
				/* [in] */ REFIID riid,
				/* [iid_is][out] */ void** ppv) = 0;

		};

#else 	/* C style interface */

		typedef struct IClassActivatorVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IClassActivator* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IClassActivator* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IClassActivator* This);

			HRESULT(STDMETHODCALLTYPE* GetClassObject)(
				IClassActivator* This,
				/* [in] */ REFCLSID rclsid,
				/* [in] */ DWORD dwClassContext,
				/* [in] */ LCID locale,
				/* [in] */ REFIID riid,
				/* [iid_is][out] */ void** ppv);

			END_INTERFACE
		} IClassActivatorVtbl;

		interface IClassActivator
		{
			CONST_VTBL struct IClassActivatorVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IClassActivator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IClassActivator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IClassActivator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IClassActivator_GetClassObject(This,rclsid,dwClassContext,locale,riid,ppv)	\
    (This)->lpVtbl -> GetClassObject(This,rclsid,dwClassContext,locale,riid,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IClassActivator_GetClassObject_Proxy(
			IClassActivator* This,
			/* [in] */ REFCLSID rclsid,
			/* [in] */ DWORD dwClassContext,
			/* [in] */ LCID locale,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void** ppv);


		void __RPC_STUB IClassActivator_GetClassObject_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IClassActivator_INTERFACE_DEFINED__ */


#ifndef __IRpcOptions_INTERFACE_DEFINED__
#define __IRpcOptions_INTERFACE_DEFINED__

		/* interface IRpcOptions */
		/* [uuid][local][object] */


		EXTERN_C const IID IID_IRpcOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000144-0000-0000-C000-000000000046")
			IRpcOptions : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE Set(
				/* [in] */ IUnknown * pPrx,
				/* [in] */ DWORD dwProperty,
				/* [in] */ ULONG_PTR dwValue) = 0;

			virtual HRESULT STDMETHODCALLTYPE Query(
				/* [in] */ IUnknown* pPrx,
				/* [in] */ DWORD dwProperty,
				/* [out] */ ULONG_PTR* pdwValue) = 0;

		};

#else 	/* C style interface */

		typedef struct IRpcOptionsVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IRpcOptions* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IRpcOptions* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IRpcOptions* This);

			HRESULT(STDMETHODCALLTYPE* Set)(
				IRpcOptions* This,
				/* [in] */ IUnknown* pPrx,
				/* [in] */ DWORD dwProperty,
				/* [in] */ ULONG_PTR dwValue);

			HRESULT(STDMETHODCALLTYPE* Query)(
				IRpcOptions* This,
				/* [in] */ IUnknown* pPrx,
				/* [in] */ DWORD dwProperty,
				/* [out] */ ULONG_PTR* pdwValue);

			END_INTERFACE
		} IRpcOptionsVtbl;

		interface IRpcOptions
		{
			CONST_VTBL struct IRpcOptionsVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IRpcOptions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRpcOptions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRpcOptions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRpcOptions_Set(This,pPrx,dwProperty,dwValue)	\
    (This)->lpVtbl -> Set(This,pPrx,dwProperty,dwValue)

#define IRpcOptions_Query(This,pPrx,dwProperty,pdwValue)	\
    (This)->lpVtbl -> Query(This,pPrx,dwProperty,pdwValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IRpcOptions_Set_Proxy(
			IRpcOptions* This,
			/* [in] */ IUnknown* pPrx,
			/* [in] */ DWORD dwProperty,
			/* [in] */ ULONG_PTR dwValue);


		void __RPC_STUB IRpcOptions_Set_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IRpcOptions_Query_Proxy(
			IRpcOptions* This,
			/* [in] */ IUnknown* pPrx,
			/* [in] */ DWORD dwProperty,
			/* [out] */ ULONG_PTR* pdwValue);


		void __RPC_STUB IRpcOptions_Query_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IRpcOptions_INTERFACE_DEFINED__ */


		/* interface __MIDL_itf_objidl_0055 */
		/* [local] */


		enum __MIDL___MIDL_itf_objidl_0055_0001
		{
			COMBND_RPCTIMEOUT = 0x1,
			COMBND_SERVER_LOCALITY = 0x2
		};

		enum __MIDL___MIDL_itf_objidl_0055_0002
		{
			SERVER_LOCALITY_PROCESS_LOCAL = 0,
			SERVER_LOCALITY_MACHINE_LOCAL = 1,
			SERVER_LOCALITY_REMOTE = 2
		};
#endif //DCOM


		extern RPC_IF_HANDLE __MIDL_itf_objidl_0055_v0_0_c_ifspec;
		extern RPC_IF_HANDLE __MIDL_itf_objidl_0055_v0_0_s_ifspec;

#ifndef __IFillLockBytes_INTERFACE_DEFINED__
#define __IFillLockBytes_INTERFACE_DEFINED__

		/* interface IFillLockBytes */
		/* [unique][uuid][object] */


		EXTERN_C const IID IID_IFillLockBytes;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("99caf010-415e-11cf-8814-00aa00b569f5")
			IFillLockBytes : public IUnknown
		{
		public:
			virtual /* [local] */ HRESULT STDMETHODCALLTYPE FillAppend(
				/* [size_is][in] */ const void* pv,
				/* [in] */ ULONG cb,
				/* [out] */ ULONG * pcbWritten) = 0;

			virtual /* [local] */ HRESULT STDMETHODCALLTYPE FillAt(
				/* [in] */ ULARGE_INTEGER ulOffset,
				/* [size_is][in] */ const void* pv,
				/* [in] */ ULONG cb,
				/* [out] */ ULONG* pcbWritten) = 0;

			virtual HRESULT STDMETHODCALLTYPE SetFillSize(
				/* [in] */ ULARGE_INTEGER ulSize) = 0;

			virtual HRESULT STDMETHODCALLTYPE Terminate(
				/* [in] */ BOOL bCanceled) = 0;

		};

#else 	/* C style interface */

		typedef struct IFillLockBytesVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IFillLockBytes* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IFillLockBytes* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IFillLockBytes* This);

			/* [local] */ HRESULT(STDMETHODCALLTYPE* FillAppend)(
				IFillLockBytes* This,
				/* [size_is][in] */ const void* pv,
				/* [in] */ ULONG cb,
				/* [out] */ ULONG* pcbWritten);

			/* [local] */ HRESULT(STDMETHODCALLTYPE* FillAt)(
				IFillLockBytes* This,
				/* [in] */ ULARGE_INTEGER ulOffset,
				/* [size_is][in] */ const void* pv,
				/* [in] */ ULONG cb,
				/* [out] */ ULONG* pcbWritten);

			HRESULT(STDMETHODCALLTYPE* SetFillSize)(
				IFillLockBytes* This,
				/* [in] */ ULARGE_INTEGER ulSize);

			HRESULT(STDMETHODCALLTYPE* Terminate)(
				IFillLockBytes* This,
				/* [in] */ BOOL bCanceled);

			END_INTERFACE
		} IFillLockBytesVtbl;

		interface IFillLockBytes
		{
			CONST_VTBL struct IFillLockBytesVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IFillLockBytes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFillLockBytes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFillLockBytes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFillLockBytes_FillAppend(This,pv,cb,pcbWritten)	\
    (This)->lpVtbl -> FillAppend(This,pv,cb,pcbWritten)

#define IFillLockBytes_FillAt(This,ulOffset,pv,cb,pcbWritten)	\
    (This)->lpVtbl -> FillAt(This,ulOffset,pv,cb,pcbWritten)

#define IFillLockBytes_SetFillSize(This,ulSize)	\
    (This)->lpVtbl -> SetFillSize(This,ulSize)

#define IFillLockBytes_Terminate(This,bCanceled)	\
    (This)->lpVtbl -> Terminate(This,bCanceled)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		/* [call_as] */ HRESULT __stdcall IFillLockBytes_RemoteFillAppend_Proxy(
			IFillLockBytes* This,
			/* [size_is][in] */ const byte* pv,
			/* [in] */ ULONG cb,
			/* [out] */ ULONG* pcbWritten);


		void __RPC_STUB IFillLockBytes_RemoteFillAppend_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		/* [call_as] */ HRESULT __stdcall IFillLockBytes_RemoteFillAt_Proxy(
			IFillLockBytes* This,
			/* [in] */ ULARGE_INTEGER ulOffset,
			/* [size_is][in] */ const byte* pv,
			/* [in] */ ULONG cb,
			/* [out] */ ULONG* pcbWritten);


		void __RPC_STUB IFillLockBytes_RemoteFillAt_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IFillLockBytes_SetFillSize_Proxy(
			IFillLockBytes* This,
			/* [in] */ ULARGE_INTEGER ulSize);


		void __RPC_STUB IFillLockBytes_SetFillSize_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IFillLockBytes_Terminate_Proxy(
			IFillLockBytes* This,
			/* [in] */ BOOL bCanceled);


		void __RPC_STUB IFillLockBytes_Terminate_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IFillLockBytes_INTERFACE_DEFINED__ */


#ifndef __IProgressNotify_INTERFACE_DEFINED__
#define __IProgressNotify_INTERFACE_DEFINED__

		/* interface IProgressNotify */
		/* [unique][uuid][object] */


		EXTERN_C const IID IID_IProgressNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("a9d758a0-4617-11cf-95fc-00aa00680db4")
			IProgressNotify : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE OnProgress(
				/* [in] */ DWORD dwProgressCurrent,
				/* [in] */ DWORD dwProgressMaximum,
				/* [in] */ BOOL fAccurate,
				/* [in] */ BOOL fOwner) = 0;

		};

#else 	/* C style interface */

		typedef struct IProgressNotifyVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IProgressNotify* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IProgressNotify* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IProgressNotify* This);

			HRESULT(STDMETHODCALLTYPE* OnProgress)(
				IProgressNotify* This,
				/* [in] */ DWORD dwProgressCurrent,
				/* [in] */ DWORD dwProgressMaximum,
				/* [in] */ BOOL fAccurate,
				/* [in] */ BOOL fOwner);

			END_INTERFACE
		} IProgressNotifyVtbl;

		interface IProgressNotify
		{
			CONST_VTBL struct IProgressNotifyVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IProgressNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProgressNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProgressNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProgressNotify_OnProgress(This,dwProgressCurrent,dwProgressMaximum,fAccurate,fOwner)	\
    (This)->lpVtbl -> OnProgress(This,dwProgressCurrent,dwProgressMaximum,fAccurate,fOwner)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IProgressNotify_OnProgress_Proxy(
			IProgressNotify* This,
			/* [in] */ DWORD dwProgressCurrent,
			/* [in] */ DWORD dwProgressMaximum,
			/* [in] */ BOOL fAccurate,
			/* [in] */ BOOL fOwner);


		void __RPC_STUB IProgressNotify_OnProgress_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IProgressNotify_INTERFACE_DEFINED__ */


#ifndef __ILayoutStorage_INTERFACE_DEFINED__
#define __ILayoutStorage_INTERFACE_DEFINED__

		/* interface ILayoutStorage */
		/* [unique][uuid][object][local] */

		typedef struct tagStorageLayout
		{
			DWORD LayoutType;
			OLECHAR* pwcsElementName;
			LARGE_INTEGER cOffset;
			LARGE_INTEGER cBytes;
		} 	StorageLayout;


		EXTERN_C const IID IID_ILayoutStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("0e6d4d90-6738-11cf-9608-00aa00680db4")
			ILayoutStorage : public IUnknown
		{
		public:
			virtual HRESULT __stdcall LayoutScript(
				/* [in] */ StorageLayout * pStorageLayout,
				/* [in] */ DWORD nEntries,
				/* [in] */ DWORD glfInterleavedFlag) = 0;

			virtual HRESULT __stdcall BeginMonitor(void) = 0;

			virtual HRESULT __stdcall EndMonitor(void) = 0;

			virtual HRESULT __stdcall ReLayoutDocfile(
				/* [in] */ OLECHAR* pwcsNewDfName) = 0;

			virtual HRESULT __stdcall ReLayoutDocfileOnILockBytes(
				/* [in] */ ILockBytes* pILockBytes) = 0;

		};

#else 	/* C style interface */

		typedef struct ILayoutStorageVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					ILayoutStorage* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				ILayoutStorage* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				ILayoutStorage* This);

			HRESULT(__stdcall* LayoutScript)(
				ILayoutStorage* This,
				/* [in] */ StorageLayout* pStorageLayout,
				/* [in] */ DWORD nEntries,
				/* [in] */ DWORD glfInterleavedFlag);

			HRESULT(__stdcall* BeginMonitor)(
				ILayoutStorage* This);

			HRESULT(__stdcall* EndMonitor)(
				ILayoutStorage* This);

			HRESULT(__stdcall* ReLayoutDocfile)(
				ILayoutStorage* This,
				/* [in] */ OLECHAR* pwcsNewDfName);

			HRESULT(__stdcall* ReLayoutDocfileOnILockBytes)(
				ILayoutStorage* This,
				/* [in] */ ILockBytes* pILockBytes);

			END_INTERFACE
		} ILayoutStorageVtbl;

		interface ILayoutStorage
		{
			CONST_VTBL struct ILayoutStorageVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define ILayoutStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILayoutStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILayoutStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILayoutStorage_LayoutScript(This,pStorageLayout,nEntries,glfInterleavedFlag)	\
    (This)->lpVtbl -> LayoutScript(This,pStorageLayout,nEntries,glfInterleavedFlag)

#define ILayoutStorage_BeginMonitor(This)	\
    (This)->lpVtbl -> BeginMonitor(This)

#define ILayoutStorage_EndMonitor(This)	\
    (This)->lpVtbl -> EndMonitor(This)

#define ILayoutStorage_ReLayoutDocfile(This,pwcsNewDfName)	\
    (This)->lpVtbl -> ReLayoutDocfile(This,pwcsNewDfName)

#define ILayoutStorage_ReLayoutDocfileOnILockBytes(This,pILockBytes)	\
    (This)->lpVtbl -> ReLayoutDocfileOnILockBytes(This,pILockBytes)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT __stdcall ILayoutStorage_LayoutScript_Proxy(
			ILayoutStorage* This,
			/* [in] */ StorageLayout* pStorageLayout,
			/* [in] */ DWORD nEntries,
			/* [in] */ DWORD glfInterleavedFlag);


		void __RPC_STUB ILayoutStorage_LayoutScript_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT __stdcall ILayoutStorage_BeginMonitor_Proxy(
			ILayoutStorage* This);


		void __RPC_STUB ILayoutStorage_BeginMonitor_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT __stdcall ILayoutStorage_EndMonitor_Proxy(
			ILayoutStorage* This);


		void __RPC_STUB ILayoutStorage_EndMonitor_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT __stdcall ILayoutStorage_ReLayoutDocfile_Proxy(
			ILayoutStorage* This,
			/* [in] */ OLECHAR* pwcsNewDfName);


		void __RPC_STUB ILayoutStorage_ReLayoutDocfile_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT __stdcall ILayoutStorage_ReLayoutDocfileOnILockBytes_Proxy(
			ILayoutStorage* This,
			/* [in] */ ILockBytes* pILockBytes);


		void __RPC_STUB ILayoutStorage_ReLayoutDocfileOnILockBytes_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __ILayoutStorage_INTERFACE_DEFINED__ */


#ifndef __IBlockingLock_INTERFACE_DEFINED__
#define __IBlockingLock_INTERFACE_DEFINED__

		/* interface IBlockingLock */
		/* [uuid][object] */


		EXTERN_C const IID IID_IBlockingLock;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("30f3d47a-6447-11d1-8e3c-00c04fb9386d")
			IBlockingLock : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE Lock(
				/* [in] */ DWORD dwTimeout) = 0;

			virtual HRESULT STDMETHODCALLTYPE Unlock(void) = 0;

		};

#else 	/* C style interface */

		typedef struct IBlockingLockVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IBlockingLock* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IBlockingLock* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IBlockingLock* This);

			HRESULT(STDMETHODCALLTYPE* Lock)(
				IBlockingLock* This,
				/* [in] */ DWORD dwTimeout);

			HRESULT(STDMETHODCALLTYPE* Unlock)(
				IBlockingLock* This);

			END_INTERFACE
		} IBlockingLockVtbl;

		interface IBlockingLock
		{
			CONST_VTBL struct IBlockingLockVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IBlockingLock_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBlockingLock_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBlockingLock_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBlockingLock_Lock(This,dwTimeout)	\
    (This)->lpVtbl -> Lock(This,dwTimeout)

#define IBlockingLock_Unlock(This)	\
    (This)->lpVtbl -> Unlock(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IBlockingLock_Lock_Proxy(
			IBlockingLock* This,
			/* [in] */ DWORD dwTimeout);


		void __RPC_STUB IBlockingLock_Lock_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IBlockingLock_Unlock_Proxy(
			IBlockingLock* This);


		void __RPC_STUB IBlockingLock_Unlock_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IBlockingLock_INTERFACE_DEFINED__ */


#ifndef __ITimeAndNoticeControl_INTERFACE_DEFINED__
#define __ITimeAndNoticeControl_INTERFACE_DEFINED__

		/* interface ITimeAndNoticeControl */
		/* [uuid][object] */


		EXTERN_C const IID IID_ITimeAndNoticeControl;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("bc0bf6ae-8878-11d1-83e9-00c04fc2c6d4")
			ITimeAndNoticeControl : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE SuppressChanges(
				/* [in] */ DWORD res1,
				/* [in] */ DWORD res2) = 0;

		};

#else 	/* C style interface */

		typedef struct ITimeAndNoticeControlVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					ITimeAndNoticeControl* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				ITimeAndNoticeControl* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				ITimeAndNoticeControl* This);

			HRESULT(STDMETHODCALLTYPE* SuppressChanges)(
				ITimeAndNoticeControl* This,
				/* [in] */ DWORD res1,
				/* [in] */ DWORD res2);

			END_INTERFACE
		} ITimeAndNoticeControlVtbl;

		interface ITimeAndNoticeControl
		{
			CONST_VTBL struct ITimeAndNoticeControlVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define ITimeAndNoticeControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITimeAndNoticeControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITimeAndNoticeControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITimeAndNoticeControl_SuppressChanges(This,res1,res2)	\
    (This)->lpVtbl -> SuppressChanges(This,res1,res2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE ITimeAndNoticeControl_SuppressChanges_Proxy(
			ITimeAndNoticeControl* This,
			/* [in] */ DWORD res1,
			/* [in] */ DWORD res2);


		void __RPC_STUB ITimeAndNoticeControl_SuppressChanges_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __ITimeAndNoticeControl_INTERFACE_DEFINED__ */


#ifndef __IOplockStorage_INTERFACE_DEFINED__
#define __IOplockStorage_INTERFACE_DEFINED__

		/* interface IOplockStorage */
		/* [uuid][object] */


		EXTERN_C const IID IID_IOplockStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("8d19c834-8879-11d1-83e9-00c04fc2c6d4")
			IOplockStorage : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE CreateStorageEx(
				/* [in] */ LPCWSTR pwcsName,
				/* [in] */ DWORD grfMode,
				/* [in] */ DWORD stgfmt,
				/* [in] */ DWORD grfAttrs,
				/* [in] */ REFIID riid,
				/* [iid_is][out] */ void** ppstgOpen) = 0;

			virtual HRESULT STDMETHODCALLTYPE OpenStorageEx(
				/* [in] */ LPCWSTR pwcsName,
				/* [in] */ DWORD grfMode,
				/* [in] */ DWORD stgfmt,
				/* [in] */ DWORD grfAttrs,
				/* [in] */ REFIID riid,
				/* [iid_is][out] */ void** ppstgOpen) = 0;

		};

#else 	/* C style interface */

		typedef struct IOplockStorageVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IOplockStorage* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IOplockStorage* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IOplockStorage* This);

			HRESULT(STDMETHODCALLTYPE* CreateStorageEx)(
				IOplockStorage* This,
				/* [in] */ LPCWSTR pwcsName,
				/* [in] */ DWORD grfMode,
				/* [in] */ DWORD stgfmt,
				/* [in] */ DWORD grfAttrs,
				/* [in] */ REFIID riid,
				/* [iid_is][out] */ void** ppstgOpen);

			HRESULT(STDMETHODCALLTYPE* OpenStorageEx)(
				IOplockStorage* This,
				/* [in] */ LPCWSTR pwcsName,
				/* [in] */ DWORD grfMode,
				/* [in] */ DWORD stgfmt,
				/* [in] */ DWORD grfAttrs,
				/* [in] */ REFIID riid,
				/* [iid_is][out] */ void** ppstgOpen);

			END_INTERFACE
		} IOplockStorageVtbl;

		interface IOplockStorage
		{
			CONST_VTBL struct IOplockStorageVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IOplockStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOplockStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOplockStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOplockStorage_CreateStorageEx(This,pwcsName,grfMode,stgfmt,grfAttrs,riid,ppstgOpen)	\
    (This)->lpVtbl -> CreateStorageEx(This,pwcsName,grfMode,stgfmt,grfAttrs,riid,ppstgOpen)

#define IOplockStorage_OpenStorageEx(This,pwcsName,grfMode,stgfmt,grfAttrs,riid,ppstgOpen)	\
    (This)->lpVtbl -> OpenStorageEx(This,pwcsName,grfMode,stgfmt,grfAttrs,riid,ppstgOpen)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IOplockStorage_CreateStorageEx_Proxy(
			IOplockStorage* This,
			/* [in] */ LPCWSTR pwcsName,
			/* [in] */ DWORD grfMode,
			/* [in] */ DWORD stgfmt,
			/* [in] */ DWORD grfAttrs,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void** ppstgOpen);


		void __RPC_STUB IOplockStorage_CreateStorageEx_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IOplockStorage_OpenStorageEx_Proxy(
			IOplockStorage* This,
			/* [in] */ LPCWSTR pwcsName,
			/* [in] */ DWORD grfMode,
			/* [in] */ DWORD stgfmt,
			/* [in] */ DWORD grfAttrs,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void** ppstgOpen);


		void __RPC_STUB IOplockStorage_OpenStorageEx_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IOplockStorage_INTERFACE_DEFINED__ */


#ifndef __ISurrogate_INTERFACE_DEFINED__
#define __ISurrogate_INTERFACE_DEFINED__

		/* interface ISurrogate */
		/* [object][unique][version][uuid] */

		typedef /* [unique] */ ISurrogate* LPSURROGATE;


		EXTERN_C const IID IID_ISurrogate;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000022-0000-0000-C000-000000000046")
			ISurrogate : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE LoadDllServer(
				/* [in] */ REFCLSID Clsid) = 0;

			virtual HRESULT STDMETHODCALLTYPE FreeSurrogate(void) = 0;

		};

#else 	/* C style interface */

		typedef struct ISurrogateVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					ISurrogate* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				ISurrogate* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				ISurrogate* This);

			HRESULT(STDMETHODCALLTYPE* LoadDllServer)(
				ISurrogate* This,
				/* [in] */ REFCLSID Clsid);

			HRESULT(STDMETHODCALLTYPE* FreeSurrogate)(
				ISurrogate* This);

			END_INTERFACE
		} ISurrogateVtbl;

		interface ISurrogate
		{
			CONST_VTBL struct ISurrogateVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define ISurrogate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISurrogate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISurrogate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISurrogate_LoadDllServer(This,Clsid)	\
    (This)->lpVtbl -> LoadDllServer(This,Clsid)

#define ISurrogate_FreeSurrogate(This)	\
    (This)->lpVtbl -> FreeSurrogate(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE ISurrogate_LoadDllServer_Proxy(
			ISurrogate* This,
			/* [in] */ REFCLSID Clsid);


		void __RPC_STUB ISurrogate_LoadDllServer_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE ISurrogate_FreeSurrogate_Proxy(
			ISurrogate* This);


		void __RPC_STUB ISurrogate_FreeSurrogate_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __ISurrogate_INTERFACE_DEFINED__ */


#ifndef __IGlobalInterfaceTable_INTERFACE_DEFINED__
#define __IGlobalInterfaceTable_INTERFACE_DEFINED__

		/* interface IGlobalInterfaceTable */
		/* [uuid][object][local] */

		typedef /* [unique] */ IGlobalInterfaceTable* LPGLOBALINTERFACETABLE;


		EXTERN_C const IID IID_IGlobalInterfaceTable;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000146-0000-0000-C000-000000000046")
			IGlobalInterfaceTable : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE RegisterInterfaceInGlobal(
				/* [in] */ IUnknown * pUnk,
				/* [in] */ REFIID riid,
				/* [out] */ DWORD * pdwCookie) = 0;

			virtual HRESULT STDMETHODCALLTYPE RevokeInterfaceFromGlobal(
				/* [in] */ DWORD dwCookie) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetInterfaceFromGlobal(
				/* [in] */ DWORD dwCookie,
				/* [in] */ REFIID riid,
				/* [iid_is][out] */ void** ppv) = 0;

		};

#else 	/* C style interface */

		typedef struct IGlobalInterfaceTableVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IGlobalInterfaceTable* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IGlobalInterfaceTable* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IGlobalInterfaceTable* This);

			HRESULT(STDMETHODCALLTYPE* RegisterInterfaceInGlobal)(
				IGlobalInterfaceTable* This,
				/* [in] */ IUnknown* pUnk,
				/* [in] */ REFIID riid,
				/* [out] */ DWORD* pdwCookie);

			HRESULT(STDMETHODCALLTYPE* RevokeInterfaceFromGlobal)(
				IGlobalInterfaceTable* This,
				/* [in] */ DWORD dwCookie);

			HRESULT(STDMETHODCALLTYPE* GetInterfaceFromGlobal)(
				IGlobalInterfaceTable* This,
				/* [in] */ DWORD dwCookie,
				/* [in] */ REFIID riid,
				/* [iid_is][out] */ void** ppv);

			END_INTERFACE
		} IGlobalInterfaceTableVtbl;

		interface IGlobalInterfaceTable
		{
			CONST_VTBL struct IGlobalInterfaceTableVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IGlobalInterfaceTable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGlobalInterfaceTable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGlobalInterfaceTable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGlobalInterfaceTable_RegisterInterfaceInGlobal(This,pUnk,riid,pdwCookie)	\
    (This)->lpVtbl -> RegisterInterfaceInGlobal(This,pUnk,riid,pdwCookie)

#define IGlobalInterfaceTable_RevokeInterfaceFromGlobal(This,dwCookie)	\
    (This)->lpVtbl -> RevokeInterfaceFromGlobal(This,dwCookie)

#define IGlobalInterfaceTable_GetInterfaceFromGlobal(This,dwCookie,riid,ppv)	\
    (This)->lpVtbl -> GetInterfaceFromGlobal(This,dwCookie,riid,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IGlobalInterfaceTable_RegisterInterfaceInGlobal_Proxy(
			IGlobalInterfaceTable* This,
			/* [in] */ IUnknown* pUnk,
			/* [in] */ REFIID riid,
			/* [out] */ DWORD* pdwCookie);


		void __RPC_STUB IGlobalInterfaceTable_RegisterInterfaceInGlobal_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IGlobalInterfaceTable_RevokeInterfaceFromGlobal_Proxy(
			IGlobalInterfaceTable* This,
			/* [in] */ DWORD dwCookie);


		void __RPC_STUB IGlobalInterfaceTable_RevokeInterfaceFromGlobal_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IGlobalInterfaceTable_GetInterfaceFromGlobal_Proxy(
			IGlobalInterfaceTable* This,
			/* [in] */ DWORD dwCookie,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void** ppv);


		void __RPC_STUB IGlobalInterfaceTable_GetInterfaceFromGlobal_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IGlobalInterfaceTable_INTERFACE_DEFINED__ */


#ifndef __IDirectWriterLock_INTERFACE_DEFINED__
#define __IDirectWriterLock_INTERFACE_DEFINED__

		/* interface IDirectWriterLock */
		/* [unique][uuid][object] */


		EXTERN_C const IID IID_IDirectWriterLock;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("0e6d4d92-6738-11cf-9608-00aa00680db4")
			IDirectWriterLock : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE WaitForWriteAccess(
				/* [in] */ DWORD dwTimeout) = 0;

			virtual HRESULT STDMETHODCALLTYPE ReleaseWriteAccess(void) = 0;

			virtual HRESULT STDMETHODCALLTYPE HaveWriteAccess(void) = 0;

		};

#else 	/* C style interface */

		typedef struct IDirectWriterLockVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IDirectWriterLock* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IDirectWriterLock* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IDirectWriterLock* This);

			HRESULT(STDMETHODCALLTYPE* WaitForWriteAccess)(
				IDirectWriterLock* This,
				/* [in] */ DWORD dwTimeout);

			HRESULT(STDMETHODCALLTYPE* ReleaseWriteAccess)(
				IDirectWriterLock* This);

			HRESULT(STDMETHODCALLTYPE* HaveWriteAccess)(
				IDirectWriterLock* This);

			END_INTERFACE
		} IDirectWriterLockVtbl;

		interface IDirectWriterLock
		{
			CONST_VTBL struct IDirectWriterLockVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IDirectWriterLock_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirectWriterLock_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirectWriterLock_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirectWriterLock_WaitForWriteAccess(This,dwTimeout)	\
    (This)->lpVtbl -> WaitForWriteAccess(This,dwTimeout)

#define IDirectWriterLock_ReleaseWriteAccess(This)	\
    (This)->lpVtbl -> ReleaseWriteAccess(This)

#define IDirectWriterLock_HaveWriteAccess(This)	\
    (This)->lpVtbl -> HaveWriteAccess(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IDirectWriterLock_WaitForWriteAccess_Proxy(
			IDirectWriterLock* This,
			/* [in] */ DWORD dwTimeout);


		void __RPC_STUB IDirectWriterLock_WaitForWriteAccess_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IDirectWriterLock_ReleaseWriteAccess_Proxy(
			IDirectWriterLock* This);


		void __RPC_STUB IDirectWriterLock_ReleaseWriteAccess_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IDirectWriterLock_HaveWriteAccess_Proxy(
			IDirectWriterLock* This);


		void __RPC_STUB IDirectWriterLock_HaveWriteAccess_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IDirectWriterLock_INTERFACE_DEFINED__ */


#ifndef __ISynchronize_INTERFACE_DEFINED__
#define __ISynchronize_INTERFACE_DEFINED__

		/* interface ISynchronize */
		/* [uuid][object] */


		EXTERN_C const IID IID_ISynchronize;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000030-0000-0000-C000-000000000046")
			ISynchronize : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE Wait(
				/* [in] */ DWORD dwFlags,
				/* [in] */ DWORD dwMilliseconds) = 0;

			virtual HRESULT STDMETHODCALLTYPE Signal(void) = 0;

			virtual HRESULT STDMETHODCALLTYPE Reset(void) = 0;

		};

#else 	/* C style interface */

		typedef struct ISynchronizeVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					ISynchronize* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				ISynchronize* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				ISynchronize* This);

			HRESULT(STDMETHODCALLTYPE* Wait)(
				ISynchronize* This,
				/* [in] */ DWORD dwFlags,
				/* [in] */ DWORD dwMilliseconds);

			HRESULT(STDMETHODCALLTYPE* Signal)(
				ISynchronize* This);

			HRESULT(STDMETHODCALLTYPE* Reset)(
				ISynchronize* This);

			END_INTERFACE
		} ISynchronizeVtbl;

		interface ISynchronize
		{
			CONST_VTBL struct ISynchronizeVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define ISynchronize_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISynchronize_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISynchronize_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISynchronize_Wait(This,dwFlags,dwMilliseconds)	\
    (This)->lpVtbl -> Wait(This,dwFlags,dwMilliseconds)

#define ISynchronize_Signal(This)	\
    (This)->lpVtbl -> Signal(This)

#define ISynchronize_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE ISynchronize_Wait_Proxy(
			ISynchronize* This,
			/* [in] */ DWORD dwFlags,
			/* [in] */ DWORD dwMilliseconds);


		void __RPC_STUB ISynchronize_Wait_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE ISynchronize_Signal_Proxy(
			ISynchronize* This);


		void __RPC_STUB ISynchronize_Signal_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE ISynchronize_Reset_Proxy(
			ISynchronize* This);


		void __RPC_STUB ISynchronize_Reset_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __ISynchronize_INTERFACE_DEFINED__ */


#ifndef __ISynchronizeHandle_INTERFACE_DEFINED__
#define __ISynchronizeHandle_INTERFACE_DEFINED__

		/* interface ISynchronizeHandle */
		/* [uuid][object][local] */


		EXTERN_C const IID IID_ISynchronizeHandle;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000031-0000-0000-C000-000000000046")
			ISynchronizeHandle : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE GetHandle(
				/* [out] */ HANDLE * ph) = 0;

		};

#else 	/* C style interface */

		typedef struct ISynchronizeHandleVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					ISynchronizeHandle* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				ISynchronizeHandle* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				ISynchronizeHandle* This);

			HRESULT(STDMETHODCALLTYPE* GetHandle)(
				ISynchronizeHandle* This,
				/* [out] */ HANDLE* ph);

			END_INTERFACE
		} ISynchronizeHandleVtbl;

		interface ISynchronizeHandle
		{
			CONST_VTBL struct ISynchronizeHandleVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define ISynchronizeHandle_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISynchronizeHandle_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISynchronizeHandle_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISynchronizeHandle_GetHandle(This,ph)	\
    (This)->lpVtbl -> GetHandle(This,ph)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE ISynchronizeHandle_GetHandle_Proxy(
			ISynchronizeHandle* This,
			/* [out] */ HANDLE* ph);


		void __RPC_STUB ISynchronizeHandle_GetHandle_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __ISynchronizeHandle_INTERFACE_DEFINED__ */


#ifndef __ISynchronizeEvent_INTERFACE_DEFINED__
#define __ISynchronizeEvent_INTERFACE_DEFINED__

		/* interface ISynchronizeEvent */
		/* [uuid][object][local] */


		EXTERN_C const IID IID_ISynchronizeEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000032-0000-0000-C000-000000000046")
			ISynchronizeEvent : public ISynchronizeHandle
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE SetEventHandle(
				/* [in] */ HANDLE * ph) = 0;

		};

#else 	/* C style interface */

		typedef struct ISynchronizeEventVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					ISynchronizeEvent* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				ISynchronizeEvent* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				ISynchronizeEvent* This);

			HRESULT(STDMETHODCALLTYPE* GetHandle)(
				ISynchronizeEvent* This,
				/* [out] */ HANDLE* ph);

			HRESULT(STDMETHODCALLTYPE* SetEventHandle)(
				ISynchronizeEvent* This,
				/* [in] */ HANDLE* ph);

			END_INTERFACE
		} ISynchronizeEventVtbl;

		interface ISynchronizeEvent
		{
			CONST_VTBL struct ISynchronizeEventVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define ISynchronizeEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISynchronizeEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISynchronizeEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISynchronizeEvent_GetHandle(This,ph)	\
    (This)->lpVtbl -> GetHandle(This,ph)


#define ISynchronizeEvent_SetEventHandle(This,ph)	\
    (This)->lpVtbl -> SetEventHandle(This,ph)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE ISynchronizeEvent_SetEventHandle_Proxy(
			ISynchronizeEvent* This,
			/* [in] */ HANDLE* ph);


		void __RPC_STUB ISynchronizeEvent_SetEventHandle_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __ISynchronizeEvent_INTERFACE_DEFINED__ */


#ifndef __ISynchronizeContainer_INTERFACE_DEFINED__
#define __ISynchronizeContainer_INTERFACE_DEFINED__

		/* interface ISynchronizeContainer */
		/* [uuid][object][local] */


		EXTERN_C const IID IID_ISynchronizeContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000033-0000-0000-C000-000000000046")
			ISynchronizeContainer : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE AddSynchronize(
				/* [in] */ ISynchronize * pSync) = 0;

			virtual HRESULT STDMETHODCALLTYPE WaitMultiple(
				/* [in] */ DWORD dwFlags,
				/* [in] */ DWORD dwTimeOut,
				/* [out] */ ISynchronize** ppSync) = 0;

		};

#else 	/* C style interface */

		typedef struct ISynchronizeContainerVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					ISynchronizeContainer* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				ISynchronizeContainer* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				ISynchronizeContainer* This);

			HRESULT(STDMETHODCALLTYPE* AddSynchronize)(
				ISynchronizeContainer* This,
				/* [in] */ ISynchronize* pSync);

			HRESULT(STDMETHODCALLTYPE* WaitMultiple)(
				ISynchronizeContainer* This,
				/* [in] */ DWORD dwFlags,
				/* [in] */ DWORD dwTimeOut,
				/* [out] */ ISynchronize** ppSync);

			END_INTERFACE
		} ISynchronizeContainerVtbl;

		interface ISynchronizeContainer
		{
			CONST_VTBL struct ISynchronizeContainerVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define ISynchronizeContainer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISynchronizeContainer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISynchronizeContainer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISynchronizeContainer_AddSynchronize(This,pSync)	\
    (This)->lpVtbl -> AddSynchronize(This,pSync)

#define ISynchronizeContainer_WaitMultiple(This,dwFlags,dwTimeOut,ppSync)	\
    (This)->lpVtbl -> WaitMultiple(This,dwFlags,dwTimeOut,ppSync)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE ISynchronizeContainer_AddSynchronize_Proxy(
			ISynchronizeContainer* This,
			/* [in] */ ISynchronize* pSync);


		void __RPC_STUB ISynchronizeContainer_AddSynchronize_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE ISynchronizeContainer_WaitMultiple_Proxy(
			ISynchronizeContainer* This,
			/* [in] */ DWORD dwFlags,
			/* [in] */ DWORD dwTimeOut,
			/* [out] */ ISynchronize** ppSync);


		void __RPC_STUB ISynchronizeContainer_WaitMultiple_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __ISynchronizeContainer_INTERFACE_DEFINED__ */


#ifndef __ISynchronizeMutex_INTERFACE_DEFINED__
#define __ISynchronizeMutex_INTERFACE_DEFINED__

		/* interface ISynchronizeMutex */
		/* [uuid][object][local] */


		EXTERN_C const IID IID_ISynchronizeMutex;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000025-0000-0000-C000-000000000046")
			ISynchronizeMutex : public ISynchronize
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE ReleaseMutex(void) = 0;

		};

#else 	/* C style interface */

		typedef struct ISynchronizeMutexVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					ISynchronizeMutex* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				ISynchronizeMutex* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				ISynchronizeMutex* This);

			HRESULT(STDMETHODCALLTYPE* Wait)(
				ISynchronizeMutex* This,
				/* [in] */ DWORD dwFlags,
				/* [in] */ DWORD dwMilliseconds);

			HRESULT(STDMETHODCALLTYPE* Signal)(
				ISynchronizeMutex* This);

			HRESULT(STDMETHODCALLTYPE* Reset)(
				ISynchronizeMutex* This);

			HRESULT(STDMETHODCALLTYPE* ReleaseMutex)(
				ISynchronizeMutex* This);

			END_INTERFACE
		} ISynchronizeMutexVtbl;

		interface ISynchronizeMutex
		{
			CONST_VTBL struct ISynchronizeMutexVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define ISynchronizeMutex_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISynchronizeMutex_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISynchronizeMutex_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISynchronizeMutex_Wait(This,dwFlags,dwMilliseconds)	\
    (This)->lpVtbl -> Wait(This,dwFlags,dwMilliseconds)

#define ISynchronizeMutex_Signal(This)	\
    (This)->lpVtbl -> Signal(This)

#define ISynchronizeMutex_Reset(This)	\
    (This)->lpVtbl -> Reset(This)


#define ISynchronizeMutex_ReleaseMutex(This)	\
    (This)->lpVtbl -> ReleaseMutex(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE ISynchronizeMutex_ReleaseMutex_Proxy(
			ISynchronizeMutex* This);


		void __RPC_STUB ISynchronizeMutex_ReleaseMutex_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __ISynchronizeMutex_INTERFACE_DEFINED__ */


#ifndef __ICancelMethodCalls_INTERFACE_DEFINED__
#define __ICancelMethodCalls_INTERFACE_DEFINED__

		/* interface ICancelMethodCalls */
		/* [uuid][object][local] */

		typedef /* [unique] */ ICancelMethodCalls* LPCANCELMETHODCALLS;


		EXTERN_C const IID IID_ICancelMethodCalls;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000029-0000-0000-C000-000000000046")
			ICancelMethodCalls : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE Cancel(
				/* [in] */ ULONG ulSeconds) = 0;

			virtual HRESULT STDMETHODCALLTYPE TestCancel(void) = 0;

		};

#else 	/* C style interface */

		typedef struct ICancelMethodCallsVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					ICancelMethodCalls* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				ICancelMethodCalls* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				ICancelMethodCalls* This);

			HRESULT(STDMETHODCALLTYPE* Cancel)(
				ICancelMethodCalls* This,
				/* [in] */ ULONG ulSeconds);

			HRESULT(STDMETHODCALLTYPE* TestCancel)(
				ICancelMethodCalls* This);

			END_INTERFACE
		} ICancelMethodCallsVtbl;

		interface ICancelMethodCalls
		{
			CONST_VTBL struct ICancelMethodCallsVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define ICancelMethodCalls_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICancelMethodCalls_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICancelMethodCalls_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICancelMethodCalls_Cancel(This,ulSeconds)	\
    (This)->lpVtbl -> Cancel(This,ulSeconds)

#define ICancelMethodCalls_TestCancel(This)	\
    (This)->lpVtbl -> TestCancel(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE ICancelMethodCalls_Cancel_Proxy(
			ICancelMethodCalls* This,
			/* [in] */ ULONG ulSeconds);


		void __RPC_STUB ICancelMethodCalls_Cancel_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE ICancelMethodCalls_TestCancel_Proxy(
			ICancelMethodCalls* This);


		void __RPC_STUB ICancelMethodCalls_TestCancel_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __ICancelMethodCalls_INTERFACE_DEFINED__ */


#ifndef __IAsyncManager_INTERFACE_DEFINED__
#define __IAsyncManager_INTERFACE_DEFINED__

		/* interface IAsyncManager */
		/* [uuid][object][local] */

		typedef
			enum tagDCOM_CALL_STATE
		{
			DCOM_NONE = 0,
			DCOM_CALL_COMPLETE = 0x1,
			DCOM_CALL_CANCELED = 0x2
		} 	DCOM_CALL_STATE;


		EXTERN_C const IID IID_IAsyncManager;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("0000002A-0000-0000-C000-000000000046")
			IAsyncManager : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE CompleteCall(
				/* [in] */ HRESULT Result) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetCallContext(
				/* [in] */ REFIID riid,
				/* [out] */ void** pInterface) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetState(
				/* [out] */ ULONG* pulStateFlags) = 0;

		};

#else 	/* C style interface */

		typedef struct IAsyncManagerVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IAsyncManager* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IAsyncManager* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IAsyncManager* This);

			HRESULT(STDMETHODCALLTYPE* CompleteCall)(
				IAsyncManager* This,
				/* [in] */ HRESULT Result);

			HRESULT(STDMETHODCALLTYPE* GetCallContext)(
				IAsyncManager* This,
				/* [in] */ REFIID riid,
				/* [out] */ void** pInterface);

			HRESULT(STDMETHODCALLTYPE* GetState)(
				IAsyncManager* This,
				/* [out] */ ULONG* pulStateFlags);

			END_INTERFACE
		} IAsyncManagerVtbl;

		interface IAsyncManager
		{
			CONST_VTBL struct IAsyncManagerVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IAsyncManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAsyncManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAsyncManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAsyncManager_CompleteCall(This,Result)	\
    (This)->lpVtbl -> CompleteCall(This,Result)

#define IAsyncManager_GetCallContext(This,riid,pInterface)	\
    (This)->lpVtbl -> GetCallContext(This,riid,pInterface)

#define IAsyncManager_GetState(This,pulStateFlags)	\
    (This)->lpVtbl -> GetState(This,pulStateFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IAsyncManager_CompleteCall_Proxy(
			IAsyncManager* This,
			/* [in] */ HRESULT Result);


		void __RPC_STUB IAsyncManager_CompleteCall_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IAsyncManager_GetCallContext_Proxy(
			IAsyncManager* This,
			/* [in] */ REFIID riid,
			/* [out] */ void** pInterface);


		void __RPC_STUB IAsyncManager_GetCallContext_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IAsyncManager_GetState_Proxy(
			IAsyncManager* This,
			/* [out] */ ULONG* pulStateFlags);


		void __RPC_STUB IAsyncManager_GetState_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IAsyncManager_INTERFACE_DEFINED__ */


#ifndef __ICallFactory_INTERFACE_DEFINED__
#define __ICallFactory_INTERFACE_DEFINED__

		/* interface ICallFactory */
		/* [unique][uuid][object][local] */


		EXTERN_C const IID IID_ICallFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("1c733a30-2a1c-11ce-ade5-00aa0044773d")
			ICallFactory : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE CreateCall(
				/* [in] */ REFIID riid,
				/* [in] */ IUnknown * pCtrlUnk,
				/* [in] */ REFIID riid2,
				/* [iid_is][out] */ IUnknown * *ppv) = 0;

		};

#else 	/* C style interface */

		typedef struct ICallFactoryVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					ICallFactory* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				ICallFactory* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				ICallFactory* This);

			HRESULT(STDMETHODCALLTYPE* CreateCall)(
				ICallFactory* This,
				/* [in] */ REFIID riid,
				/* [in] */ IUnknown* pCtrlUnk,
				/* [in] */ REFIID riid2,
				/* [iid_is][out] */ IUnknown** ppv);

			END_INTERFACE
		} ICallFactoryVtbl;

		interface ICallFactory
		{
			CONST_VTBL struct ICallFactoryVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define ICallFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICallFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICallFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICallFactory_CreateCall(This,riid,pCtrlUnk,riid2,ppv)	\
    (This)->lpVtbl -> CreateCall(This,riid,pCtrlUnk,riid2,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE ICallFactory_CreateCall_Proxy(
			ICallFactory* This,
			/* [in] */ REFIID riid,
			/* [in] */ IUnknown* pCtrlUnk,
			/* [in] */ REFIID riid2,
			/* [iid_is][out] */ IUnknown** ppv);


		void __RPC_STUB ICallFactory_CreateCall_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __ICallFactory_INTERFACE_DEFINED__ */


#ifndef __IRpcHelper_INTERFACE_DEFINED__
#define __IRpcHelper_INTERFACE_DEFINED__

		/* interface IRpcHelper */
		/* [object][local][unique][version][uuid] */


		EXTERN_C const IID IID_IRpcHelper;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000149-0000-0000-C000-000000000046")
			IRpcHelper : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE GetDCOMProtocolVersion(
				/* [out] */ DWORD * pComVersion) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetIIDFromOBJREF(
				/* [in] */ void* pObjRef,
				/* [out] */ IID** piid) = 0;

		};

#else 	/* C style interface */

		typedef struct IRpcHelperVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IRpcHelper* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IRpcHelper* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IRpcHelper* This);

			HRESULT(STDMETHODCALLTYPE* GetDCOMProtocolVersion)(
				IRpcHelper* This,
				/* [out] */ DWORD* pComVersion);

			HRESULT(STDMETHODCALLTYPE* GetIIDFromOBJREF)(
				IRpcHelper* This,
				/* [in] */ void* pObjRef,
				/* [out] */ IID** piid);

			END_INTERFACE
		} IRpcHelperVtbl;

		interface IRpcHelper
		{
			CONST_VTBL struct IRpcHelperVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IRpcHelper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRpcHelper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRpcHelper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRpcHelper_GetDCOMProtocolVersion(This,pComVersion)	\
    (This)->lpVtbl -> GetDCOMProtocolVersion(This,pComVersion)

#define IRpcHelper_GetIIDFromOBJREF(This,pObjRef,piid)	\
    (This)->lpVtbl -> GetIIDFromOBJREF(This,pObjRef,piid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IRpcHelper_GetDCOMProtocolVersion_Proxy(
			IRpcHelper* This,
			/* [out] */ DWORD* pComVersion);


		void __RPC_STUB IRpcHelper_GetDCOMProtocolVersion_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IRpcHelper_GetIIDFromOBJREF_Proxy(
			IRpcHelper* This,
			/* [in] */ void* pObjRef,
			/* [out] */ IID** piid);


		void __RPC_STUB IRpcHelper_GetIIDFromOBJREF_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IRpcHelper_INTERFACE_DEFINED__ */


#ifndef __IReleaseMarshalBuffers_INTERFACE_DEFINED__
#define __IReleaseMarshalBuffers_INTERFACE_DEFINED__

		/* interface IReleaseMarshalBuffers */
		/* [uuid][object][local] */


		EXTERN_C const IID IID_IReleaseMarshalBuffers;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("eb0cb9e8-7996-11d2-872e-0000f8080859")
			IReleaseMarshalBuffers : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE ReleaseMarshalBuffer(
				/* [in] */ RPCOLEMESSAGE * pMsg,
				/* [in] */ DWORD dwFlags,
				/* [unique][in] */ IUnknown * pChnl) = 0;

		};

#else 	/* C style interface */

		typedef struct IReleaseMarshalBuffersVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IReleaseMarshalBuffers* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IReleaseMarshalBuffers* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IReleaseMarshalBuffers* This);

			HRESULT(STDMETHODCALLTYPE* ReleaseMarshalBuffer)(
				IReleaseMarshalBuffers* This,
				/* [in] */ RPCOLEMESSAGE* pMsg,
				/* [in] */ DWORD dwFlags,
				/* [unique][in] */ IUnknown* pChnl);

			END_INTERFACE
		} IReleaseMarshalBuffersVtbl;

		interface IReleaseMarshalBuffers
		{
			CONST_VTBL struct IReleaseMarshalBuffersVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IReleaseMarshalBuffers_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReleaseMarshalBuffers_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReleaseMarshalBuffers_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReleaseMarshalBuffers_ReleaseMarshalBuffer(This,pMsg,dwFlags,pChnl)	\
    (This)->lpVtbl -> ReleaseMarshalBuffer(This,pMsg,dwFlags,pChnl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IReleaseMarshalBuffers_ReleaseMarshalBuffer_Proxy(
			IReleaseMarshalBuffers* This,
			/* [in] */ RPCOLEMESSAGE* pMsg,
			/* [in] */ DWORD dwFlags,
			/* [unique][in] */ IUnknown* pChnl);


		void __RPC_STUB IReleaseMarshalBuffers_ReleaseMarshalBuffer_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IReleaseMarshalBuffers_INTERFACE_DEFINED__ */


#ifndef __IWaitMultiple_INTERFACE_DEFINED__
#define __IWaitMultiple_INTERFACE_DEFINED__

		/* interface IWaitMultiple */
		/* [uuid][object][local] */


		EXTERN_C const IID IID_IWaitMultiple;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("0000002B-0000-0000-C000-000000000046")
			IWaitMultiple : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE WaitMultiple(
				/* [in] */ DWORD timeout,
				/* [out] */ ISynchronize * *pSync) = 0;

			virtual HRESULT STDMETHODCALLTYPE AddSynchronize(
				/* [in] */ ISynchronize* pSync) = 0;

		};

#else 	/* C style interface */

		typedef struct IWaitMultipleVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IWaitMultiple* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IWaitMultiple* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IWaitMultiple* This);

			HRESULT(STDMETHODCALLTYPE* WaitMultiple)(
				IWaitMultiple* This,
				/* [in] */ DWORD timeout,
				/* [out] */ ISynchronize** pSync);

			HRESULT(STDMETHODCALLTYPE* AddSynchronize)(
				IWaitMultiple* This,
				/* [in] */ ISynchronize* pSync);

			END_INTERFACE
		} IWaitMultipleVtbl;

		interface IWaitMultiple
		{
			CONST_VTBL struct IWaitMultipleVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IWaitMultiple_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWaitMultiple_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWaitMultiple_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWaitMultiple_WaitMultiple(This,timeout,pSync)	\
    (This)->lpVtbl -> WaitMultiple(This,timeout,pSync)

#define IWaitMultiple_AddSynchronize(This,pSync)	\
    (This)->lpVtbl -> AddSynchronize(This,pSync)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IWaitMultiple_WaitMultiple_Proxy(
			IWaitMultiple* This,
			/* [in] */ DWORD timeout,
			/* [out] */ ISynchronize** pSync);


		void __RPC_STUB IWaitMultiple_WaitMultiple_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IWaitMultiple_AddSynchronize_Proxy(
			IWaitMultiple* This,
			/* [in] */ ISynchronize* pSync);


		void __RPC_STUB IWaitMultiple_AddSynchronize_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IWaitMultiple_INTERFACE_DEFINED__ */


#ifndef __IUrlMon_INTERFACE_DEFINED__
#define __IUrlMon_INTERFACE_DEFINED__

		/* interface IUrlMon */
		/* [uuid][object] */


		EXTERN_C const IID IID_IUrlMon;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000026-0000-0000-C000-000000000046")
			IUrlMon : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE AsyncGetClassBits(
				/* [in] */ REFCLSID rclsid,
				/* [unique][in] */ LPCWSTR pszTYPE,
				/* [unique][in] */ LPCWSTR pszExt,
				/* [in] */ DWORD dwFileVersionMS,
				/* [in] */ DWORD dwFileVersionLS,
				/* [unique][in] */ LPCWSTR pszCodeBase,
				/* [in] */ IBindCtx * pbc,
				/* [in] */ DWORD dwClassContext,
				/* [in] */ REFIID riid,
				/* [in] */ DWORD flags) = 0;

		};

#else 	/* C style interface */

		typedef struct IUrlMonVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IUrlMon* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IUrlMon* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IUrlMon* This);

			HRESULT(STDMETHODCALLTYPE* AsyncGetClassBits)(
				IUrlMon* This,
				/* [in] */ REFCLSID rclsid,
				/* [unique][in] */ LPCWSTR pszTYPE,
				/* [unique][in] */ LPCWSTR pszExt,
				/* [in] */ DWORD dwFileVersionMS,
				/* [in] */ DWORD dwFileVersionLS,
				/* [unique][in] */ LPCWSTR pszCodeBase,
				/* [in] */ IBindCtx* pbc,
				/* [in] */ DWORD dwClassContext,
				/* [in] */ REFIID riid,
				/* [in] */ DWORD flags);

			END_INTERFACE
		} IUrlMonVtbl;

		interface IUrlMon
		{
			CONST_VTBL struct IUrlMonVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IUrlMon_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUrlMon_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUrlMon_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUrlMon_AsyncGetClassBits(This,rclsid,pszTYPE,pszExt,dwFileVersionMS,dwFileVersionLS,pszCodeBase,pbc,dwClassContext,riid,flags)	\
    (This)->lpVtbl -> AsyncGetClassBits(This,rclsid,pszTYPE,pszExt,dwFileVersionMS,dwFileVersionLS,pszCodeBase,pbc,dwClassContext,riid,flags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IUrlMon_AsyncGetClassBits_Proxy(
			IUrlMon* This,
			/* [in] */ REFCLSID rclsid,
			/* [unique][in] */ LPCWSTR pszTYPE,
			/* [unique][in] */ LPCWSTR pszExt,
			/* [in] */ DWORD dwFileVersionMS,
			/* [in] */ DWORD dwFileVersionLS,
			/* [unique][in] */ LPCWSTR pszCodeBase,
			/* [in] */ IBindCtx* pbc,
			/* [in] */ DWORD dwClassContext,
			/* [in] */ REFIID riid,
			/* [in] */ DWORD flags);


		void __RPC_STUB IUrlMon_AsyncGetClassBits_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IUrlMon_INTERFACE_DEFINED__ */


#ifndef __IForegroundTransfer_INTERFACE_DEFINED__
#define __IForegroundTransfer_INTERFACE_DEFINED__

		/* interface IForegroundTransfer */
		/* [uuid][object][local] */


		EXTERN_C const IID IID_IForegroundTransfer;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000145-0000-0000-C000-000000000046")
			IForegroundTransfer : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE AllowForegroundTransfer(
				/* [in] */ void* lpvReserved) = 0;

		};

#else 	/* C style interface */

		typedef struct IForegroundTransferVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IForegroundTransfer* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IForegroundTransfer* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IForegroundTransfer* This);

			HRESULT(STDMETHODCALLTYPE* AllowForegroundTransfer)(
				IForegroundTransfer* This,
				/* [in] */ void* lpvReserved);

			END_INTERFACE
		} IForegroundTransferVtbl;

		interface IForegroundTransfer
		{
			CONST_VTBL struct IForegroundTransferVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IForegroundTransfer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IForegroundTransfer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IForegroundTransfer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IForegroundTransfer_AllowForegroundTransfer(This,lpvReserved)	\
    (This)->lpVtbl -> AllowForegroundTransfer(This,lpvReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IForegroundTransfer_AllowForegroundTransfer_Proxy(
			IForegroundTransfer* This,
			/* [in] */ void* lpvReserved);


		void __RPC_STUB IForegroundTransfer_AllowForegroundTransfer_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IForegroundTransfer_INTERFACE_DEFINED__ */


#ifndef __IAddrTrackingControl_INTERFACE_DEFINED__
#define __IAddrTrackingControl_INTERFACE_DEFINED__

		/* interface IAddrTrackingControl */
		/* [uuid][object][local] */

		typedef /* [unique] */ IAddrTrackingControl* LPADDRTRACKINGCONTROL;


		EXTERN_C const IID IID_IAddrTrackingControl;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000147-0000-0000-C000-000000000046")
			IAddrTrackingControl : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE EnableCOMDynamicAddrTracking(void) = 0;

			virtual HRESULT STDMETHODCALLTYPE DisableCOMDynamicAddrTracking(void) = 0;

		};

#else 	/* C style interface */

		typedef struct IAddrTrackingControlVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IAddrTrackingControl* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IAddrTrackingControl* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IAddrTrackingControl* This);

			HRESULT(STDMETHODCALLTYPE* EnableCOMDynamicAddrTracking)(
				IAddrTrackingControl* This);

			HRESULT(STDMETHODCALLTYPE* DisableCOMDynamicAddrTracking)(
				IAddrTrackingControl* This);

			END_INTERFACE
		} IAddrTrackingControlVtbl;

		interface IAddrTrackingControl
		{
			CONST_VTBL struct IAddrTrackingControlVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IAddrTrackingControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAddrTrackingControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAddrTrackingControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAddrTrackingControl_EnableCOMDynamicAddrTracking(This)	\
    (This)->lpVtbl -> EnableCOMDynamicAddrTracking(This)

#define IAddrTrackingControl_DisableCOMDynamicAddrTracking(This)	\
    (This)->lpVtbl -> DisableCOMDynamicAddrTracking(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IAddrTrackingControl_EnableCOMDynamicAddrTracking_Proxy(
			IAddrTrackingControl* This);


		void __RPC_STUB IAddrTrackingControl_EnableCOMDynamicAddrTracking_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IAddrTrackingControl_DisableCOMDynamicAddrTracking_Proxy(
			IAddrTrackingControl* This);


		void __RPC_STUB IAddrTrackingControl_DisableCOMDynamicAddrTracking_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IAddrTrackingControl_INTERFACE_DEFINED__ */


#ifndef __IAddrExclusionControl_INTERFACE_DEFINED__
#define __IAddrExclusionControl_INTERFACE_DEFINED__

		/* interface IAddrExclusionControl */
		/* [uuid][object][local] */

		typedef /* [unique] */ IAddrExclusionControl* LPADDREXCLUSIONCONTROL;


		EXTERN_C const IID IID_IAddrExclusionControl;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000148-0000-0000-C000-000000000046")
			IAddrExclusionControl : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE GetCurrentAddrExclusionList(
				/* [in] */ REFIID riid,
				/* [iid_is][out] */ void** ppEnumerator) = 0;

			virtual HRESULT STDMETHODCALLTYPE UpdateAddrExclusionList(
				/* [in] */ IUnknown* pEnumerator) = 0;

		};

#else 	/* C style interface */

		typedef struct IAddrExclusionControlVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IAddrExclusionControl* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IAddrExclusionControl* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IAddrExclusionControl* This);

			HRESULT(STDMETHODCALLTYPE* GetCurrentAddrExclusionList)(
				IAddrExclusionControl* This,
				/* [in] */ REFIID riid,
				/* [iid_is][out] */ void** ppEnumerator);

			HRESULT(STDMETHODCALLTYPE* UpdateAddrExclusionList)(
				IAddrExclusionControl* This,
				/* [in] */ IUnknown* pEnumerator);

			END_INTERFACE
		} IAddrExclusionControlVtbl;

		interface IAddrExclusionControl
		{
			CONST_VTBL struct IAddrExclusionControlVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IAddrExclusionControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAddrExclusionControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAddrExclusionControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAddrExclusionControl_GetCurrentAddrExclusionList(This,riid,ppEnumerator)	\
    (This)->lpVtbl -> GetCurrentAddrExclusionList(This,riid,ppEnumerator)

#define IAddrExclusionControl_UpdateAddrExclusionList(This,pEnumerator)	\
    (This)->lpVtbl -> UpdateAddrExclusionList(This,pEnumerator)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IAddrExclusionControl_GetCurrentAddrExclusionList_Proxy(
			IAddrExclusionControl* This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void** ppEnumerator);


		void __RPC_STUB IAddrExclusionControl_GetCurrentAddrExclusionList_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IAddrExclusionControl_UpdateAddrExclusionList_Proxy(
			IAddrExclusionControl* This,
			/* [in] */ IUnknown* pEnumerator);


		void __RPC_STUB IAddrExclusionControl_UpdateAddrExclusionList_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IAddrExclusionControl_INTERFACE_DEFINED__ */


#ifndef __IPipeByte_INTERFACE_DEFINED__
#define __IPipeByte_INTERFACE_DEFINED__

		/* interface IPipeByte */
		/* [unique][async_uuid][uuid][object] */


		EXTERN_C const IID IID_IPipeByte;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("DB2F3ACA-2F86-11d1-8E04-00C04FB9989A")
			IPipeByte : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE Pull(
				/* [length_is][size_is][out] */ BYTE * buf,
				/* [in] */ ULONG cRequest,
				/* [out] */ ULONG * pcReturned) = 0;

			virtual HRESULT STDMETHODCALLTYPE Push(
				/* [size_is][in] */ BYTE* buf,
				/* [in] */ ULONG cSent) = 0;

		};

#else 	/* C style interface */

		typedef struct IPipeByteVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IPipeByte* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IPipeByte* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IPipeByte* This);

			HRESULT(STDMETHODCALLTYPE* Pull)(
				IPipeByte* This,
				/* [length_is][size_is][out] */ BYTE* buf,
				/* [in] */ ULONG cRequest,
				/* [out] */ ULONG* pcReturned);

			HRESULT(STDMETHODCALLTYPE* Push)(
				IPipeByte* This,
				/* [size_is][in] */ BYTE* buf,
				/* [in] */ ULONG cSent);

			END_INTERFACE
		} IPipeByteVtbl;

		interface IPipeByte
		{
			CONST_VTBL struct IPipeByteVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IPipeByte_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPipeByte_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPipeByte_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPipeByte_Pull(This,buf,cRequest,pcReturned)	\
    (This)->lpVtbl -> Pull(This,buf,cRequest,pcReturned)

#define IPipeByte_Push(This,buf,cSent)	\
    (This)->lpVtbl -> Push(This,buf,cSent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IPipeByte_Pull_Proxy(
			IPipeByte* This,
			/* [length_is][size_is][out] */ BYTE* buf,
			/* [in] */ ULONG cRequest,
			/* [out] */ ULONG* pcReturned);


		void __RPC_STUB IPipeByte_Pull_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPipeByte_Push_Proxy(
			IPipeByte* This,
			/* [size_is][in] */ BYTE* buf,
			/* [in] */ ULONG cSent);


		void __RPC_STUB IPipeByte_Push_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IPipeByte_INTERFACE_DEFINED__ */


#ifndef __AsyncIPipeByte_INTERFACE_DEFINED__
#define __AsyncIPipeByte_INTERFACE_DEFINED__

		/* interface AsyncIPipeByte */
		/* [uuid][unique][object] */


		EXTERN_C const IID IID_AsyncIPipeByte;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("DB2F3ACB-2F86-11d1-8E04-00C04FB9989A")
			AsyncIPipeByte : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE Begin_Pull(
				/* [in] */ ULONG cRequest) = 0;

			virtual HRESULT STDMETHODCALLTYPE Finish_Pull(
				/* [length_is][size_is][out] */ BYTE* buf,
				/* [out] */ ULONG* pcReturned) = 0;

			virtual HRESULT STDMETHODCALLTYPE Begin_Push(
				/* [size_is][in] */ BYTE* buf,
				/* [in] */ ULONG cSent) = 0;

			virtual HRESULT STDMETHODCALLTYPE Finish_Push(void) = 0;

		};

#else 	/* C style interface */

		typedef struct AsyncIPipeByteVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					AsyncIPipeByte* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				AsyncIPipeByte* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				AsyncIPipeByte* This);

			HRESULT(STDMETHODCALLTYPE* Begin_Pull)(
				AsyncIPipeByte* This,
				/* [in] */ ULONG cRequest);

			HRESULT(STDMETHODCALLTYPE* Finish_Pull)(
				AsyncIPipeByte* This,
				/* [length_is][size_is][out] */ BYTE* buf,
				/* [out] */ ULONG* pcReturned);

			HRESULT(STDMETHODCALLTYPE* Begin_Push)(
				AsyncIPipeByte* This,
				/* [size_is][in] */ BYTE* buf,
				/* [in] */ ULONG cSent);

			HRESULT(STDMETHODCALLTYPE* Finish_Push)(
				AsyncIPipeByte* This);

			END_INTERFACE
		} AsyncIPipeByteVtbl;

		interface AsyncIPipeByte
		{
			CONST_VTBL struct AsyncIPipeByteVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define AsyncIPipeByte_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define AsyncIPipeByte_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define AsyncIPipeByte_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define AsyncIPipeByte_Begin_Pull(This,cRequest)	\
    (This)->lpVtbl -> Begin_Pull(This,cRequest)

#define AsyncIPipeByte_Finish_Pull(This,buf,pcReturned)	\
    (This)->lpVtbl -> Finish_Pull(This,buf,pcReturned)

#define AsyncIPipeByte_Begin_Push(This,buf,cSent)	\
    (This)->lpVtbl -> Begin_Push(This,buf,cSent)

#define AsyncIPipeByte_Finish_Push(This)	\
    (This)->lpVtbl -> Finish_Push(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE AsyncIPipeByte_Begin_Pull_Proxy(
			AsyncIPipeByte* This,
			/* [in] */ ULONG cRequest);


		void __RPC_STUB AsyncIPipeByte_Begin_Pull_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE AsyncIPipeByte_Finish_Pull_Proxy(
			AsyncIPipeByte* This,
			/* [length_is][size_is][out] */ BYTE* buf,
			/* [out] */ ULONG* pcReturned);


		void __RPC_STUB AsyncIPipeByte_Finish_Pull_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE AsyncIPipeByte_Begin_Push_Proxy(
			AsyncIPipeByte* This,
			/* [size_is][in] */ BYTE* buf,
			/* [in] */ ULONG cSent);


		void __RPC_STUB AsyncIPipeByte_Begin_Push_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE AsyncIPipeByte_Finish_Push_Proxy(
			AsyncIPipeByte* This);


		void __RPC_STUB AsyncIPipeByte_Finish_Push_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __AsyncIPipeByte_INTERFACE_DEFINED__ */


#ifndef __IPipeLong_INTERFACE_DEFINED__
#define __IPipeLong_INTERFACE_DEFINED__

		/* interface IPipeLong */
		/* [unique][async_uuid][uuid][object] */


		EXTERN_C const IID IID_IPipeLong;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("DB2F3ACC-2F86-11d1-8E04-00C04FB9989A")
			IPipeLong : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE Pull(
				/* [length_is][size_is][out] */ LONG * buf,
				/* [in] */ ULONG cRequest,
				/* [out] */ ULONG * pcReturned) = 0;

			virtual HRESULT STDMETHODCALLTYPE Push(
				/* [size_is][in] */ LONG* buf,
				/* [in] */ ULONG cSent) = 0;

		};

#else 	/* C style interface */

		typedef struct IPipeLongVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IPipeLong* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IPipeLong* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IPipeLong* This);

			HRESULT(STDMETHODCALLTYPE* Pull)(
				IPipeLong* This,
				/* [length_is][size_is][out] */ LONG* buf,
				/* [in] */ ULONG cRequest,
				/* [out] */ ULONG* pcReturned);

			HRESULT(STDMETHODCALLTYPE* Push)(
				IPipeLong* This,
				/* [size_is][in] */ LONG* buf,
				/* [in] */ ULONG cSent);

			END_INTERFACE
		} IPipeLongVtbl;

		interface IPipeLong
		{
			CONST_VTBL struct IPipeLongVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IPipeLong_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPipeLong_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPipeLong_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPipeLong_Pull(This,buf,cRequest,pcReturned)	\
    (This)->lpVtbl -> Pull(This,buf,cRequest,pcReturned)

#define IPipeLong_Push(This,buf,cSent)	\
    (This)->lpVtbl -> Push(This,buf,cSent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IPipeLong_Pull_Proxy(
			IPipeLong* This,
			/* [length_is][size_is][out] */ LONG* buf,
			/* [in] */ ULONG cRequest,
			/* [out] */ ULONG* pcReturned);


		void __RPC_STUB IPipeLong_Pull_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPipeLong_Push_Proxy(
			IPipeLong* This,
			/* [size_is][in] */ LONG* buf,
			/* [in] */ ULONG cSent);


		void __RPC_STUB IPipeLong_Push_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IPipeLong_INTERFACE_DEFINED__ */


#ifndef __AsyncIPipeLong_INTERFACE_DEFINED__
#define __AsyncIPipeLong_INTERFACE_DEFINED__

		/* interface AsyncIPipeLong */
		/* [uuid][unique][object] */


		EXTERN_C const IID IID_AsyncIPipeLong;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("DB2F3ACD-2F86-11d1-8E04-00C04FB9989A")
			AsyncIPipeLong : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE Begin_Pull(
				/* [in] */ ULONG cRequest) = 0;

			virtual HRESULT STDMETHODCALLTYPE Finish_Pull(
				/* [length_is][size_is][out] */ LONG* buf,
				/* [out] */ ULONG* pcReturned) = 0;

			virtual HRESULT STDMETHODCALLTYPE Begin_Push(
				/* [size_is][in] */ LONG* buf,
				/* [in] */ ULONG cSent) = 0;

			virtual HRESULT STDMETHODCALLTYPE Finish_Push(void) = 0;

		};

#else 	/* C style interface */

		typedef struct AsyncIPipeLongVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					AsyncIPipeLong* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				AsyncIPipeLong* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				AsyncIPipeLong* This);

			HRESULT(STDMETHODCALLTYPE* Begin_Pull)(
				AsyncIPipeLong* This,
				/* [in] */ ULONG cRequest);

			HRESULT(STDMETHODCALLTYPE* Finish_Pull)(
				AsyncIPipeLong* This,
				/* [length_is][size_is][out] */ LONG* buf,
				/* [out] */ ULONG* pcReturned);

			HRESULT(STDMETHODCALLTYPE* Begin_Push)(
				AsyncIPipeLong* This,
				/* [size_is][in] */ LONG* buf,
				/* [in] */ ULONG cSent);

			HRESULT(STDMETHODCALLTYPE* Finish_Push)(
				AsyncIPipeLong* This);

			END_INTERFACE
		} AsyncIPipeLongVtbl;

		interface AsyncIPipeLong
		{
			CONST_VTBL struct AsyncIPipeLongVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define AsyncIPipeLong_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define AsyncIPipeLong_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define AsyncIPipeLong_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define AsyncIPipeLong_Begin_Pull(This,cRequest)	\
    (This)->lpVtbl -> Begin_Pull(This,cRequest)

#define AsyncIPipeLong_Finish_Pull(This,buf,pcReturned)	\
    (This)->lpVtbl -> Finish_Pull(This,buf,pcReturned)

#define AsyncIPipeLong_Begin_Push(This,buf,cSent)	\
    (This)->lpVtbl -> Begin_Push(This,buf,cSent)

#define AsyncIPipeLong_Finish_Push(This)	\
    (This)->lpVtbl -> Finish_Push(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE AsyncIPipeLong_Begin_Pull_Proxy(
			AsyncIPipeLong* This,
			/* [in] */ ULONG cRequest);


		void __RPC_STUB AsyncIPipeLong_Begin_Pull_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE AsyncIPipeLong_Finish_Pull_Proxy(
			AsyncIPipeLong* This,
			/* [length_is][size_is][out] */ LONG* buf,
			/* [out] */ ULONG* pcReturned);


		void __RPC_STUB AsyncIPipeLong_Finish_Pull_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE AsyncIPipeLong_Begin_Push_Proxy(
			AsyncIPipeLong* This,
			/* [size_is][in] */ LONG* buf,
			/* [in] */ ULONG cSent);


		void __RPC_STUB AsyncIPipeLong_Begin_Push_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE AsyncIPipeLong_Finish_Push_Proxy(
			AsyncIPipeLong* This);


		void __RPC_STUB AsyncIPipeLong_Finish_Push_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __AsyncIPipeLong_INTERFACE_DEFINED__ */


#ifndef __IPipeDouble_INTERFACE_DEFINED__
#define __IPipeDouble_INTERFACE_DEFINED__

		/* interface IPipeDouble */
		/* [unique][async_uuid][uuid][object] */


		EXTERN_C const IID IID_IPipeDouble;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("DB2F3ACE-2F86-11d1-8E04-00C04FB9989A")
			IPipeDouble : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE Pull(
				/* [length_is][size_is][out] */ DOUBLE * buf,
				/* [in] */ ULONG cRequest,
				/* [out] */ ULONG * pcReturned) = 0;

			virtual HRESULT STDMETHODCALLTYPE Push(
				/* [size_is][in] */ DOUBLE* buf,
				/* [in] */ ULONG cSent) = 0;

		};

#else 	/* C style interface */

		typedef struct IPipeDoubleVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IPipeDouble* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IPipeDouble* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IPipeDouble* This);

			HRESULT(STDMETHODCALLTYPE* Pull)(
				IPipeDouble* This,
				/* [length_is][size_is][out] */ DOUBLE* buf,
				/* [in] */ ULONG cRequest,
				/* [out] */ ULONG* pcReturned);

			HRESULT(STDMETHODCALLTYPE* Push)(
				IPipeDouble* This,
				/* [size_is][in] */ DOUBLE* buf,
				/* [in] */ ULONG cSent);

			END_INTERFACE
		} IPipeDoubleVtbl;

		interface IPipeDouble
		{
			CONST_VTBL struct IPipeDoubleVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IPipeDouble_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPipeDouble_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPipeDouble_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPipeDouble_Pull(This,buf,cRequest,pcReturned)	\
    (This)->lpVtbl -> Pull(This,buf,cRequest,pcReturned)

#define IPipeDouble_Push(This,buf,cSent)	\
    (This)->lpVtbl -> Push(This,buf,cSent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IPipeDouble_Pull_Proxy(
			IPipeDouble* This,
			/* [length_is][size_is][out] */ DOUBLE* buf,
			/* [in] */ ULONG cRequest,
			/* [out] */ ULONG* pcReturned);


		void __RPC_STUB IPipeDouble_Pull_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPipeDouble_Push_Proxy(
			IPipeDouble* This,
			/* [size_is][in] */ DOUBLE* buf,
			/* [in] */ ULONG cSent);


		void __RPC_STUB IPipeDouble_Push_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IPipeDouble_INTERFACE_DEFINED__ */


#ifndef __AsyncIPipeDouble_INTERFACE_DEFINED__
#define __AsyncIPipeDouble_INTERFACE_DEFINED__

		/* interface AsyncIPipeDouble */
		/* [uuid][unique][object] */


		EXTERN_C const IID IID_AsyncIPipeDouble;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("DB2F3ACF-2F86-11d1-8E04-00C04FB9989A")
			AsyncIPipeDouble : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE Begin_Pull(
				/* [in] */ ULONG cRequest) = 0;

			virtual HRESULT STDMETHODCALLTYPE Finish_Pull(
				/* [length_is][size_is][out] */ DOUBLE* buf,
				/* [out] */ ULONG* pcReturned) = 0;

			virtual HRESULT STDMETHODCALLTYPE Begin_Push(
				/* [size_is][in] */ DOUBLE* buf,
				/* [in] */ ULONG cSent) = 0;

			virtual HRESULT STDMETHODCALLTYPE Finish_Push(void) = 0;

		};

#else 	/* C style interface */

		typedef struct AsyncIPipeDoubleVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					AsyncIPipeDouble* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				AsyncIPipeDouble* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				AsyncIPipeDouble* This);

			HRESULT(STDMETHODCALLTYPE* Begin_Pull)(
				AsyncIPipeDouble* This,
				/* [in] */ ULONG cRequest);

			HRESULT(STDMETHODCALLTYPE* Finish_Pull)(
				AsyncIPipeDouble* This,
				/* [length_is][size_is][out] */ DOUBLE* buf,
				/* [out] */ ULONG* pcReturned);

			HRESULT(STDMETHODCALLTYPE* Begin_Push)(
				AsyncIPipeDouble* This,
				/* [size_is][in] */ DOUBLE* buf,
				/* [in] */ ULONG cSent);

			HRESULT(STDMETHODCALLTYPE* Finish_Push)(
				AsyncIPipeDouble* This);

			END_INTERFACE
		} AsyncIPipeDoubleVtbl;

		interface AsyncIPipeDouble
		{
			CONST_VTBL struct AsyncIPipeDoubleVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define AsyncIPipeDouble_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define AsyncIPipeDouble_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define AsyncIPipeDouble_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define AsyncIPipeDouble_Begin_Pull(This,cRequest)	\
    (This)->lpVtbl -> Begin_Pull(This,cRequest)

#define AsyncIPipeDouble_Finish_Pull(This,buf,pcReturned)	\
    (This)->lpVtbl -> Finish_Pull(This,buf,pcReturned)

#define AsyncIPipeDouble_Begin_Push(This,buf,cSent)	\
    (This)->lpVtbl -> Begin_Push(This,buf,cSent)

#define AsyncIPipeDouble_Finish_Push(This)	\
    (This)->lpVtbl -> Finish_Push(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE AsyncIPipeDouble_Begin_Pull_Proxy(
			AsyncIPipeDouble* This,
			/* [in] */ ULONG cRequest);


		void __RPC_STUB AsyncIPipeDouble_Begin_Pull_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE AsyncIPipeDouble_Finish_Pull_Proxy(
			AsyncIPipeDouble* This,
			/* [length_is][size_is][out] */ DOUBLE* buf,
			/* [out] */ ULONG* pcReturned);


		void __RPC_STUB AsyncIPipeDouble_Finish_Pull_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE AsyncIPipeDouble_Begin_Push_Proxy(
			AsyncIPipeDouble* This,
			/* [size_is][in] */ DOUBLE* buf,
			/* [in] */ ULONG cSent);


		void __RPC_STUB AsyncIPipeDouble_Begin_Push_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE AsyncIPipeDouble_Finish_Push_Proxy(
			AsyncIPipeDouble* This);


		void __RPC_STUB AsyncIPipeDouble_Finish_Push_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __AsyncIPipeDouble_INTERFACE_DEFINED__ */


#ifndef __IThumbnailExtractor_INTERFACE_DEFINED__
#define __IThumbnailExtractor_INTERFACE_DEFINED__

		/* interface IThumbnailExtractor */
		/* [object][uuid] */


		EXTERN_C const IID IID_IThumbnailExtractor;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("969dc708-5c76-11d1-8d86-0000f804b057")
			IThumbnailExtractor : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE ExtractThumbnail(
				/* [in] */ IStorage * pStg,
				/* [in] */ ULONG ulLength,
				/* [in] */ ULONG ulHeight,
				/* [out] */ ULONG * pulOutputLength,
				/* [out] */ ULONG * pulOutputHeight,
				/* [out] */ HBITMAP * phOutputBitmap) = 0;

			virtual HRESULT STDMETHODCALLTYPE OnFileUpdated(
				/* [in] */ IStorage* pStg) = 0;

		};

#else 	/* C style interface */

		typedef struct IThumbnailExtractorVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IThumbnailExtractor* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IThumbnailExtractor* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IThumbnailExtractor* This);

			HRESULT(STDMETHODCALLTYPE* ExtractThumbnail)(
				IThumbnailExtractor* This,
				/* [in] */ IStorage* pStg,
				/* [in] */ ULONG ulLength,
				/* [in] */ ULONG ulHeight,
				/* [out] */ ULONG* pulOutputLength,
				/* [out] */ ULONG* pulOutputHeight,
				/* [out] */ HBITMAP* phOutputBitmap);

			HRESULT(STDMETHODCALLTYPE* OnFileUpdated)(
				IThumbnailExtractor* This,
				/* [in] */ IStorage* pStg);

			END_INTERFACE
		} IThumbnailExtractorVtbl;

		interface IThumbnailExtractor
		{
			CONST_VTBL struct IThumbnailExtractorVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IThumbnailExtractor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IThumbnailExtractor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IThumbnailExtractor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IThumbnailExtractor_ExtractThumbnail(This,pStg,ulLength,ulHeight,pulOutputLength,pulOutputHeight,phOutputBitmap)	\
    (This)->lpVtbl -> ExtractThumbnail(This,pStg,ulLength,ulHeight,pulOutputLength,pulOutputHeight,phOutputBitmap)

#define IThumbnailExtractor_OnFileUpdated(This,pStg)	\
    (This)->lpVtbl -> OnFileUpdated(This,pStg)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IThumbnailExtractor_ExtractThumbnail_Proxy(
			IThumbnailExtractor* This,
			/* [in] */ IStorage* pStg,
			/* [in] */ ULONG ulLength,
			/* [in] */ ULONG ulHeight,
			/* [out] */ ULONG* pulOutputLength,
			/* [out] */ ULONG* pulOutputHeight,
			/* [out] */ HBITMAP* phOutputBitmap);


		void __RPC_STUB IThumbnailExtractor_ExtractThumbnail_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IThumbnailExtractor_OnFileUpdated_Proxy(
			IThumbnailExtractor* This,
			/* [in] */ IStorage* pStg);


		void __RPC_STUB IThumbnailExtractor_OnFileUpdated_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IThumbnailExtractor_INTERFACE_DEFINED__ */


#ifndef __IDummyHICONIncluder_INTERFACE_DEFINED__
#define __IDummyHICONIncluder_INTERFACE_DEFINED__

		/* interface IDummyHICONIncluder */
		/* [uuid][unique][object] */


		EXTERN_C const IID IID_IDummyHICONIncluder;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("947990de-cc28-11d2-a0f7-00805f858fb1")
			IDummyHICONIncluder : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE Dummy(
				/* [in] */ HICON h1,
				/* [in] */ HDC h2) = 0;

		};

#else 	/* C style interface */

		typedef struct IDummyHICONIncluderVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IDummyHICONIncluder* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IDummyHICONIncluder* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IDummyHICONIncluder* This);

			HRESULT(STDMETHODCALLTYPE* Dummy)(
				IDummyHICONIncluder* This,
				/* [in] */ HICON h1,
				/* [in] */ HDC h2);

			END_INTERFACE
		} IDummyHICONIncluderVtbl;

		interface IDummyHICONIncluder
		{
			CONST_VTBL struct IDummyHICONIncluderVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IDummyHICONIncluder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDummyHICONIncluder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDummyHICONIncluder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDummyHICONIncluder_Dummy(This,h1,h2)	\
    (This)->lpVtbl -> Dummy(This,h1,h2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IDummyHICONIncluder_Dummy_Proxy(
			IDummyHICONIncluder* This,
			/* [in] */ HICON h1,
			/* [in] */ HDC h2);


		void __RPC_STUB IDummyHICONIncluder_Dummy_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IDummyHICONIncluder_INTERFACE_DEFINED__ */


		/* interface __MIDL_itf_objidl_0084 */
		/* [local] */

		typedef DWORD CPFLAGS;

		typedef struct tagContextProperty
		{
			GUID policyId;
			CPFLAGS flags;
			/* [unique] */ IUnknown* pUnk;
		} 	ContextProperty;



		extern RPC_IF_HANDLE __MIDL_itf_objidl_0084_v0_0_c_ifspec;
		extern RPC_IF_HANDLE __MIDL_itf_objidl_0084_v0_0_s_ifspec;

#ifndef __IEnumContextProps_INTERFACE_DEFINED__
#define __IEnumContextProps_INTERFACE_DEFINED__

		/* interface IEnumContextProps */
		/* [unique][uuid][object][local] */

		typedef /* [unique] */ IEnumContextProps* LPENUMCONTEXTPROPS;


		EXTERN_C const IID IID_IEnumContextProps;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("000001c1-0000-0000-C000-000000000046")
			IEnumContextProps : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE Next(
				/* [in] */ ULONG celt,
				/* [length_is][size_is][out] */ ContextProperty * pContextProperties,
				/* [out] */ ULONG * pceltFetched) = 0;

			virtual HRESULT STDMETHODCALLTYPE Skip(
				/* [in] */ ULONG celt) = 0;

			virtual HRESULT STDMETHODCALLTYPE Reset(void) = 0;

			virtual HRESULT STDMETHODCALLTYPE Clone(
				/* [out] */ IEnumContextProps** ppEnumContextProps) = 0;

			virtual HRESULT STDMETHODCALLTYPE Count(
				/* [out] */ ULONG* pcelt) = 0;

		};

#else 	/* C style interface */

		typedef struct IEnumContextPropsVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IEnumContextProps* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IEnumContextProps* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IEnumContextProps* This);

			HRESULT(STDMETHODCALLTYPE* Next)(
				IEnumContextProps* This,
				/* [in] */ ULONG celt,
				/* [length_is][size_is][out] */ ContextProperty* pContextProperties,
				/* [out] */ ULONG* pceltFetched);

			HRESULT(STDMETHODCALLTYPE* Skip)(
				IEnumContextProps* This,
				/* [in] */ ULONG celt);

			HRESULT(STDMETHODCALLTYPE* Reset)(
				IEnumContextProps* This);

			HRESULT(STDMETHODCALLTYPE* Clone)(
				IEnumContextProps* This,
				/* [out] */ IEnumContextProps** ppEnumContextProps);

			HRESULT(STDMETHODCALLTYPE* Count)(
				IEnumContextProps* This,
				/* [out] */ ULONG* pcelt);

			END_INTERFACE
		} IEnumContextPropsVtbl;

		interface IEnumContextProps
		{
			CONST_VTBL struct IEnumContextPropsVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IEnumContextProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumContextProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumContextProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumContextProps_Next(This,celt,pContextProperties,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,pContextProperties,pceltFetched)

#define IEnumContextProps_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumContextProps_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumContextProps_Clone(This,ppEnumContextProps)	\
    (This)->lpVtbl -> Clone(This,ppEnumContextProps)

#define IEnumContextProps_Count(This,pcelt)	\
    (This)->lpVtbl -> Count(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IEnumContextProps_Next_Proxy(
			IEnumContextProps* This,
			/* [in] */ ULONG celt,
			/* [length_is][size_is][out] */ ContextProperty* pContextProperties,
			/* [out] */ ULONG* pceltFetched);


		void __RPC_STUB IEnumContextProps_Next_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IEnumContextProps_Skip_Proxy(
			IEnumContextProps* This,
			/* [in] */ ULONG celt);


		void __RPC_STUB IEnumContextProps_Skip_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IEnumContextProps_Reset_Proxy(
			IEnumContextProps* This);


		void __RPC_STUB IEnumContextProps_Reset_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IEnumContextProps_Clone_Proxy(
			IEnumContextProps* This,
			/* [out] */ IEnumContextProps** ppEnumContextProps);


		void __RPC_STUB IEnumContextProps_Clone_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IEnumContextProps_Count_Proxy(
			IEnumContextProps* This,
			/* [out] */ ULONG* pcelt);


		void __RPC_STUB IEnumContextProps_Count_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IEnumContextProps_INTERFACE_DEFINED__ */


#ifndef __IContext_INTERFACE_DEFINED__
#define __IContext_INTERFACE_DEFINED__

		/* interface IContext */
		/* [unique][uuid][object][local] */


		EXTERN_C const IID IID_IContext;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("000001c0-0000-0000-C000-000000000046")
			IContext : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE SetProperty(
				/* [in] */ REFGUID rpolicyId,
				/* [in] */ CPFLAGS flags,
				/* [in] */ IUnknown * pUnk) = 0;

			virtual HRESULT STDMETHODCALLTYPE RemoveProperty(
				/* [in] */ REFGUID rPolicyId) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetProperty(
				/* [in] */ REFGUID rGuid,
				/* [out] */ CPFLAGS* pFlags,
				/* [out] */ IUnknown** ppUnk) = 0;

			virtual HRESULT STDMETHODCALLTYPE EnumContextProps(
				/* [out] */ IEnumContextProps** ppEnumContextProps) = 0;

		};

#else 	/* C style interface */

		typedef struct IContextVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IContext* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IContext* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IContext* This);

			HRESULT(STDMETHODCALLTYPE* SetProperty)(
				IContext* This,
				/* [in] */ REFGUID rpolicyId,
				/* [in] */ CPFLAGS flags,
				/* [in] */ IUnknown* pUnk);

			HRESULT(STDMETHODCALLTYPE* RemoveProperty)(
				IContext* This,
				/* [in] */ REFGUID rPolicyId);

			HRESULT(STDMETHODCALLTYPE* GetProperty)(
				IContext* This,
				/* [in] */ REFGUID rGuid,
				/* [out] */ CPFLAGS* pFlags,
				/* [out] */ IUnknown** ppUnk);

			HRESULT(STDMETHODCALLTYPE* EnumContextProps)(
				IContext* This,
				/* [out] */ IEnumContextProps** ppEnumContextProps);

			END_INTERFACE
		} IContextVtbl;

		interface IContext
		{
			CONST_VTBL struct IContextVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContext_SetProperty(This,rpolicyId,flags,pUnk)	\
    (This)->lpVtbl -> SetProperty(This,rpolicyId,flags,pUnk)

#define IContext_RemoveProperty(This,rPolicyId)	\
    (This)->lpVtbl -> RemoveProperty(This,rPolicyId)

#define IContext_GetProperty(This,rGuid,pFlags,ppUnk)	\
    (This)->lpVtbl -> GetProperty(This,rGuid,pFlags,ppUnk)

#define IContext_EnumContextProps(This,ppEnumContextProps)	\
    (This)->lpVtbl -> EnumContextProps(This,ppEnumContextProps)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IContext_SetProperty_Proxy(
			IContext* This,
			/* [in] */ REFGUID rpolicyId,
			/* [in] */ CPFLAGS flags,
			/* [in] */ IUnknown* pUnk);


		void __RPC_STUB IContext_SetProperty_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IContext_RemoveProperty_Proxy(
			IContext* This,
			/* [in] */ REFGUID rPolicyId);


		void __RPC_STUB IContext_RemoveProperty_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IContext_GetProperty_Proxy(
			IContext* This,
			/* [in] */ REFGUID rGuid,
			/* [out] */ CPFLAGS* pFlags,
			/* [out] */ IUnknown** ppUnk);


		void __RPC_STUB IContext_GetProperty_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IContext_EnumContextProps_Proxy(
			IContext* This,
			/* [out] */ IEnumContextProps** ppEnumContextProps);


		void __RPC_STUB IContext_EnumContextProps_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IContext_INTERFACE_DEFINED__ */


		/* interface __MIDL_itf_objidl_0086 */
		/* [local] */

#if !defined BUILDTYPE_COMSVCS && !defined _OLE32_


		extern RPC_IF_HANDLE __MIDL_itf_objidl_0086_v0_0_c_ifspec;
		extern RPC_IF_HANDLE __MIDL_itf_objidl_0086_v0_0_s_ifspec;

#ifndef __IObjContext_INTERFACE_DEFINED__
#define __IObjContext_INTERFACE_DEFINED__

		/* interface IObjContext */
		/* [unique][uuid][object][local] */


		EXTERN_C const IID IID_IObjContext;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("000001c6-0000-0000-C000-000000000046")
			IObjContext : public IContext
		{
		public:
			virtual void STDMETHODCALLTYPE Reserved1(void) = 0;

			virtual void STDMETHODCALLTYPE Reserved2(void) = 0;

			virtual void STDMETHODCALLTYPE Reserved3(void) = 0;

			virtual void STDMETHODCALLTYPE Reserved4(void) = 0;

			virtual void STDMETHODCALLTYPE Reserved5(void) = 0;

			virtual void STDMETHODCALLTYPE Reserved6(void) = 0;

			virtual void STDMETHODCALLTYPE Reserved7(void) = 0;

		};

#else 	/* C style interface */

		typedef struct IObjContextVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IObjContext* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IObjContext* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IObjContext* This);

			HRESULT(STDMETHODCALLTYPE* SetProperty)(
				IObjContext* This,
				/* [in] */ REFGUID rpolicyId,
				/* [in] */ CPFLAGS flags,
				/* [in] */ IUnknown* pUnk);

			HRESULT(STDMETHODCALLTYPE* RemoveProperty)(
				IObjContext* This,
				/* [in] */ REFGUID rPolicyId);

			HRESULT(STDMETHODCALLTYPE* GetProperty)(
				IObjContext* This,
				/* [in] */ REFGUID rGuid,
				/* [out] */ CPFLAGS* pFlags,
				/* [out] */ IUnknown** ppUnk);

			HRESULT(STDMETHODCALLTYPE* EnumContextProps)(
				IObjContext* This,
				/* [out] */ IEnumContextProps** ppEnumContextProps);

			void (STDMETHODCALLTYPE* Reserved1)(
				IObjContext* This);

			void (STDMETHODCALLTYPE* Reserved2)(
				IObjContext* This);

			void (STDMETHODCALLTYPE* Reserved3)(
				IObjContext* This);

			void (STDMETHODCALLTYPE* Reserved4)(
				IObjContext* This);

			void (STDMETHODCALLTYPE* Reserved5)(
				IObjContext* This);

			void (STDMETHODCALLTYPE* Reserved6)(
				IObjContext* This);

			void (STDMETHODCALLTYPE* Reserved7)(
				IObjContext* This);

			END_INTERFACE
		} IObjContextVtbl;

		interface IObjContext
		{
			CONST_VTBL struct IObjContextVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IObjContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjContext_SetProperty(This,rpolicyId,flags,pUnk)	\
    (This)->lpVtbl -> SetProperty(This,rpolicyId,flags,pUnk)

#define IObjContext_RemoveProperty(This,rPolicyId)	\
    (This)->lpVtbl -> RemoveProperty(This,rPolicyId)

#define IObjContext_GetProperty(This,rGuid,pFlags,ppUnk)	\
    (This)->lpVtbl -> GetProperty(This,rGuid,pFlags,ppUnk)

#define IObjContext_EnumContextProps(This,ppEnumContextProps)	\
    (This)->lpVtbl -> EnumContextProps(This,ppEnumContextProps)


#define IObjContext_Reserved1(This)	\
    (This)->lpVtbl -> Reserved1(This)

#define IObjContext_Reserved2(This)	\
    (This)->lpVtbl -> Reserved2(This)

#define IObjContext_Reserved3(This)	\
    (This)->lpVtbl -> Reserved3(This)

#define IObjContext_Reserved4(This)	\
    (This)->lpVtbl -> Reserved4(This)

#define IObjContext_Reserved5(This)	\
    (This)->lpVtbl -> Reserved5(This)

#define IObjContext_Reserved6(This)	\
    (This)->lpVtbl -> Reserved6(This)

#define IObjContext_Reserved7(This)	\
    (This)->lpVtbl -> Reserved7(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		void STDMETHODCALLTYPE IObjContext_Reserved1_Proxy(
			IObjContext* This);


		void __RPC_STUB IObjContext_Reserved1_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		void STDMETHODCALLTYPE IObjContext_Reserved2_Proxy(
			IObjContext* This);


		void __RPC_STUB IObjContext_Reserved2_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		void STDMETHODCALLTYPE IObjContext_Reserved3_Proxy(
			IObjContext* This);


		void __RPC_STUB IObjContext_Reserved3_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		void STDMETHODCALLTYPE IObjContext_Reserved4_Proxy(
			IObjContext* This);


		void __RPC_STUB IObjContext_Reserved4_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		void STDMETHODCALLTYPE IObjContext_Reserved5_Proxy(
			IObjContext* This);


		void __RPC_STUB IObjContext_Reserved5_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		void STDMETHODCALLTYPE IObjContext_Reserved6_Proxy(
			IObjContext* This);


		void __RPC_STUB IObjContext_Reserved6_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		void STDMETHODCALLTYPE IObjContext_Reserved7_Proxy(
			IObjContext* This);


		void __RPC_STUB IObjContext_Reserved7_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IObjContext_INTERFACE_DEFINED__ */


		/* interface __MIDL_itf_objidl_0087 */
		/* [local] */

#endif
		typedef
			enum tagApplicationType
		{
			ServerApplication = 0,
			LibraryApplication = ServerApplication + 1
		} 	ApplicationType;

		typedef
			enum tagShutdownType
		{
			IdleShutdown = 0,
			ForcedShutdown = IdleShutdown + 1
		} 	ShutdownType;



		extern RPC_IF_HANDLE __MIDL_itf_objidl_0087_v0_0_c_ifspec;
		extern RPC_IF_HANDLE __MIDL_itf_objidl_0087_v0_0_s_ifspec;

#ifndef __IProcessLock_INTERFACE_DEFINED__
#define __IProcessLock_INTERFACE_DEFINED__

		/* interface IProcessLock */
		/* [unique][uuid][local][object] */


		EXTERN_C const IID IID_IProcessLock;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("000001d5-0000-0000-C000-000000000046")
			IProcessLock : public IUnknown
		{
		public:
			virtual ULONG STDMETHODCALLTYPE AddRefOnProcess(void) = 0;

			virtual ULONG STDMETHODCALLTYPE ReleaseRefOnProcess(void) = 0;

		};

#else 	/* C style interface */

		typedef struct IProcessLockVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IProcessLock* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IProcessLock* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IProcessLock* This);

			ULONG(STDMETHODCALLTYPE* AddRefOnProcess)(
				IProcessLock* This);

			ULONG(STDMETHODCALLTYPE* ReleaseRefOnProcess)(
				IProcessLock* This);

			END_INTERFACE
		} IProcessLockVtbl;

		interface IProcessLock
		{
			CONST_VTBL struct IProcessLockVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IProcessLock_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProcessLock_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProcessLock_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProcessLock_AddRefOnProcess(This)	\
    (This)->lpVtbl -> AddRefOnProcess(This)

#define IProcessLock_ReleaseRefOnProcess(This)	\
    (This)->lpVtbl -> ReleaseRefOnProcess(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		ULONG STDMETHODCALLTYPE IProcessLock_AddRefOnProcess_Proxy(
			IProcessLock* This);


		void __RPC_STUB IProcessLock_AddRefOnProcess_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		ULONG STDMETHODCALLTYPE IProcessLock_ReleaseRefOnProcess_Proxy(
			IProcessLock* This);


		void __RPC_STUB IProcessLock_ReleaseRefOnProcess_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IProcessLock_INTERFACE_DEFINED__ */


#ifndef __ISurrogateService_INTERFACE_DEFINED__
#define __ISurrogateService_INTERFACE_DEFINED__

		/* interface ISurrogateService */
		/* [unique][uuid][local][object] */


		EXTERN_C const IID IID_ISurrogateService;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("000001d4-0000-0000-C000-000000000046")
			ISurrogateService : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE Init(
				/* [in] */ REFGUID rguidProcessID,
				/* [in] */ IProcessLock * pProcessLock,
				/* [out] */ BOOL * pfApplicationAware) = 0;

			virtual HRESULT STDMETHODCALLTYPE ApplicationLaunch(
				/* [in] */ REFGUID rguidApplID,
				/* [in] */ ApplicationType appType) = 0;

			virtual HRESULT STDMETHODCALLTYPE ApplicationFree(
				/* [in] */ REFGUID rguidApplID) = 0;

			virtual HRESULT STDMETHODCALLTYPE CatalogRefresh(
				/* [in] */ ULONG ulReserved) = 0;

			virtual HRESULT STDMETHODCALLTYPE ProcessShutdown(
				/* [in] */ ShutdownType shutdownType) = 0;

		};

#else 	/* C style interface */

		typedef struct ISurrogateServiceVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					ISurrogateService* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				ISurrogateService* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				ISurrogateService* This);

			HRESULT(STDMETHODCALLTYPE* Init)(
				ISurrogateService* This,
				/* [in] */ REFGUID rguidProcessID,
				/* [in] */ IProcessLock* pProcessLock,
				/* [out] */ BOOL* pfApplicationAware);

			HRESULT(STDMETHODCALLTYPE* ApplicationLaunch)(
				ISurrogateService* This,
				/* [in] */ REFGUID rguidApplID,
				/* [in] */ ApplicationType appType);

			HRESULT(STDMETHODCALLTYPE* ApplicationFree)(
				ISurrogateService* This,
				/* [in] */ REFGUID rguidApplID);

			HRESULT(STDMETHODCALLTYPE* CatalogRefresh)(
				ISurrogateService* This,
				/* [in] */ ULONG ulReserved);

			HRESULT(STDMETHODCALLTYPE* ProcessShutdown)(
				ISurrogateService* This,
				/* [in] */ ShutdownType shutdownType);

			END_INTERFACE
		} ISurrogateServiceVtbl;

		interface ISurrogateService
		{
			CONST_VTBL struct ISurrogateServiceVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define ISurrogateService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISurrogateService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISurrogateService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISurrogateService_Init(This,rguidProcessID,pProcessLock,pfApplicationAware)	\
    (This)->lpVtbl -> Init(This,rguidProcessID,pProcessLock,pfApplicationAware)

#define ISurrogateService_ApplicationLaunch(This,rguidApplID,appType)	\
    (This)->lpVtbl -> ApplicationLaunch(This,rguidApplID,appType)

#define ISurrogateService_ApplicationFree(This,rguidApplID)	\
    (This)->lpVtbl -> ApplicationFree(This,rguidApplID)

#define ISurrogateService_CatalogRefresh(This,ulReserved)	\
    (This)->lpVtbl -> CatalogRefresh(This,ulReserved)

#define ISurrogateService_ProcessShutdown(This,shutdownType)	\
    (This)->lpVtbl -> ProcessShutdown(This,shutdownType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE ISurrogateService_Init_Proxy(
			ISurrogateService* This,
			/* [in] */ REFGUID rguidProcessID,
			/* [in] */ IProcessLock* pProcessLock,
			/* [out] */ BOOL* pfApplicationAware);


		void __RPC_STUB ISurrogateService_Init_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE ISurrogateService_ApplicationLaunch_Proxy(
			ISurrogateService* This,
			/* [in] */ REFGUID rguidApplID,
			/* [in] */ ApplicationType appType);


		void __RPC_STUB ISurrogateService_ApplicationLaunch_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE ISurrogateService_ApplicationFree_Proxy(
			ISurrogateService* This,
			/* [in] */ REFGUID rguidApplID);


		void __RPC_STUB ISurrogateService_ApplicationFree_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE ISurrogateService_CatalogRefresh_Proxy(
			ISurrogateService* This,
			/* [in] */ ULONG ulReserved);


		void __RPC_STUB ISurrogateService_CatalogRefresh_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE ISurrogateService_ProcessShutdown_Proxy(
			ISurrogateService* This,
			/* [in] */ ShutdownType shutdownType);


		void __RPC_STUB ISurrogateService_ProcessShutdown_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __ISurrogateService_INTERFACE_DEFINED__ */


		/* interface __MIDL_itf_objidl_0089 */
		/* [local] */

		typedef
			enum _APTTYPE
		{
			APTTYPE_CURRENT = -1,
			APTTYPE_STA = 0,
			APTTYPE_MTA = 1,
			APTTYPE_NA = 2,
			APTTYPE_MAINSTA = 3
		} 	APTTYPE;

		typedef
			enum _THDTYPE
		{
			THDTYPE_BLOCKMESSAGES = 0,
			THDTYPE_PROCESSMESSAGES = 1
		} 	THDTYPE;

		typedef DWORD APARTMENTID;



		extern RPC_IF_HANDLE __MIDL_itf_objidl_0089_v0_0_c_ifspec;
		extern RPC_IF_HANDLE __MIDL_itf_objidl_0089_v0_0_s_ifspec;

#ifndef __IComThreadingInfo_INTERFACE_DEFINED__
#define __IComThreadingInfo_INTERFACE_DEFINED__

		/* interface IComThreadingInfo */
		/* [unique][uuid][object][local] */


		EXTERN_C const IID IID_IComThreadingInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("000001ce-0000-0000-C000-000000000046")
			IComThreadingInfo : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE GetCurrentApartmentType(
				/* [out] */ APTTYPE * pAptType) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetCurrentThreadType(
				/* [out] */ THDTYPE* pThreadType) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetCurrentLogicalThreadId(
				/* [out] */ GUID* pguidLogicalThreadId) = 0;

			virtual HRESULT STDMETHODCALLTYPE SetCurrentLogicalThreadId(
				/* [in] */ REFGUID rguid) = 0;

		};

#else 	/* C style interface */

		typedef struct IComThreadingInfoVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IComThreadingInfo* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IComThreadingInfo* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IComThreadingInfo* This);

			HRESULT(STDMETHODCALLTYPE* GetCurrentApartmentType)(
				IComThreadingInfo* This,
				/* [out] */ APTTYPE* pAptType);

			HRESULT(STDMETHODCALLTYPE* GetCurrentThreadType)(
				IComThreadingInfo* This,
				/* [out] */ THDTYPE* pThreadType);

			HRESULT(STDMETHODCALLTYPE* GetCurrentLogicalThreadId)(
				IComThreadingInfo* This,
				/* [out] */ GUID* pguidLogicalThreadId);

			HRESULT(STDMETHODCALLTYPE* SetCurrentLogicalThreadId)(
				IComThreadingInfo* This,
				/* [in] */ REFGUID rguid);

			END_INTERFACE
		} IComThreadingInfoVtbl;

		interface IComThreadingInfo
		{
			CONST_VTBL struct IComThreadingInfoVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IComThreadingInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComThreadingInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComThreadingInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComThreadingInfo_GetCurrentApartmentType(This,pAptType)	\
    (This)->lpVtbl -> GetCurrentApartmentType(This,pAptType)

#define IComThreadingInfo_GetCurrentThreadType(This,pThreadType)	\
    (This)->lpVtbl -> GetCurrentThreadType(This,pThreadType)

#define IComThreadingInfo_GetCurrentLogicalThreadId(This,pguidLogicalThreadId)	\
    (This)->lpVtbl -> GetCurrentLogicalThreadId(This,pguidLogicalThreadId)

#define IComThreadingInfo_SetCurrentLogicalThreadId(This,rguid)	\
    (This)->lpVtbl -> SetCurrentLogicalThreadId(This,rguid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IComThreadingInfo_GetCurrentApartmentType_Proxy(
			IComThreadingInfo* This,
			/* [out] */ APTTYPE* pAptType);


		void __RPC_STUB IComThreadingInfo_GetCurrentApartmentType_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IComThreadingInfo_GetCurrentThreadType_Proxy(
			IComThreadingInfo* This,
			/* [out] */ THDTYPE* pThreadType);


		void __RPC_STUB IComThreadingInfo_GetCurrentThreadType_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IComThreadingInfo_GetCurrentLogicalThreadId_Proxy(
			IComThreadingInfo* This,
			/* [out] */ GUID* pguidLogicalThreadId);


		void __RPC_STUB IComThreadingInfo_GetCurrentLogicalThreadId_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IComThreadingInfo_SetCurrentLogicalThreadId_Proxy(
			IComThreadingInfo* This,
			/* [in] */ REFGUID rguid);


		void __RPC_STUB IComThreadingInfo_SetCurrentLogicalThreadId_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IComThreadingInfo_INTERFACE_DEFINED__ */


#ifndef __IProcessInitControl_INTERFACE_DEFINED__
#define __IProcessInitControl_INTERFACE_DEFINED__

		/* interface IProcessInitControl */
		/* [uuid][unique][object] */


		EXTERN_C const IID IID_IProcessInitControl;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("72380d55-8d2b-43a3-8513-2b6ef31434e9")
			IProcessInitControl : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE ResetInitializerTimeout(
				/* [in] */ DWORD dwSecondsRemaining) = 0;

		};

#else 	/* C style interface */

		typedef struct IProcessInitControlVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IProcessInitControl* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IProcessInitControl* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IProcessInitControl* This);

			HRESULT(STDMETHODCALLTYPE* ResetInitializerTimeout)(
				IProcessInitControl* This,
				/* [in] */ DWORD dwSecondsRemaining);

			END_INTERFACE
		} IProcessInitControlVtbl;

		interface IProcessInitControl
		{
			CONST_VTBL struct IProcessInitControlVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IProcessInitControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProcessInitControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProcessInitControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProcessInitControl_ResetInitializerTimeout(This,dwSecondsRemaining)	\
    (This)->lpVtbl -> ResetInitializerTimeout(This,dwSecondsRemaining)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IProcessInitControl_ResetInitializerTimeout_Proxy(
			IProcessInitControl* This,
			/* [in] */ DWORD dwSecondsRemaining);


		void __RPC_STUB IProcessInitControl_ResetInitializerTimeout_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IProcessInitControl_INTERFACE_DEFINED__ */


		/* interface __MIDL_itf_objidl_0091 */
		/* [local] */

#if  (_WIN32_WINNT >= 0x0501 )


		extern RPC_IF_HANDLE __MIDL_itf_objidl_0091_v0_0_c_ifspec;
		extern RPC_IF_HANDLE __MIDL_itf_objidl_0091_v0_0_s_ifspec;

#ifndef __IInitializeSpy_INTERFACE_DEFINED__
#define __IInitializeSpy_INTERFACE_DEFINED__

		/* interface IInitializeSpy */
		/* [unique][uuid][object][local] */

		typedef /* [unique] */ IInitializeSpy* LPINITIALIZESPY;


		EXTERN_C const IID IID_IInitializeSpy;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("00000034-0000-0000-C000-000000000046")
			IInitializeSpy : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE PreInitialize(
				/* [in] */ DWORD dwCoInit,
				/* [in] */ DWORD dwCurThreadAptRefs) = 0;

			virtual HRESULT STDMETHODCALLTYPE PostInitialize(
				/* [in] */ HRESULT hrCoInit,
				/* [in] */ DWORD dwCoInit,
				/* [in] */ DWORD dwNewThreadAptRefs) = 0;

			virtual HRESULT STDMETHODCALLTYPE PreUninitialize(
				/* [in] */ DWORD dwCurThreadAptRefs) = 0;

			virtual HRESULT STDMETHODCALLTYPE PostUninitialize(
				/* [in] */ DWORD dwNewThreadAptRefs) = 0;

		};

#else 	/* C style interface */

		typedef struct IInitializeSpyVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IInitializeSpy* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IInitializeSpy* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IInitializeSpy* This);

			HRESULT(STDMETHODCALLTYPE* PreInitialize)(
				IInitializeSpy* This,
				/* [in] */ DWORD dwCoInit,
				/* [in] */ DWORD dwCurThreadAptRefs);

			HRESULT(STDMETHODCALLTYPE* PostInitialize)(
				IInitializeSpy* This,
				/* [in] */ HRESULT hrCoInit,
				/* [in] */ DWORD dwCoInit,
				/* [in] */ DWORD dwNewThreadAptRefs);

			HRESULT(STDMETHODCALLTYPE* PreUninitialize)(
				IInitializeSpy* This,
				/* [in] */ DWORD dwCurThreadAptRefs);

			HRESULT(STDMETHODCALLTYPE* PostUninitialize)(
				IInitializeSpy* This,
				/* [in] */ DWORD dwNewThreadAptRefs);

			END_INTERFACE
		} IInitializeSpyVtbl;

		interface IInitializeSpy
		{
			CONST_VTBL struct IInitializeSpyVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IInitializeSpy_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInitializeSpy_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInitializeSpy_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInitializeSpy_PreInitialize(This,dwCoInit,dwCurThreadAptRefs)	\
    (This)->lpVtbl -> PreInitialize(This,dwCoInit,dwCurThreadAptRefs)

#define IInitializeSpy_PostInitialize(This,hrCoInit,dwCoInit,dwNewThreadAptRefs)	\
    (This)->lpVtbl -> PostInitialize(This,hrCoInit,dwCoInit,dwNewThreadAptRefs)

#define IInitializeSpy_PreUninitialize(This,dwCurThreadAptRefs)	\
    (This)->lpVtbl -> PreUninitialize(This,dwCurThreadAptRefs)

#define IInitializeSpy_PostUninitialize(This,dwNewThreadAptRefs)	\
    (This)->lpVtbl -> PostUninitialize(This,dwNewThreadAptRefs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IInitializeSpy_PreInitialize_Proxy(
			IInitializeSpy* This,
			/* [in] */ DWORD dwCoInit,
			/* [in] */ DWORD dwCurThreadAptRefs);


		void __RPC_STUB IInitializeSpy_PreInitialize_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IInitializeSpy_PostInitialize_Proxy(
			IInitializeSpy* This,
			/* [in] */ HRESULT hrCoInit,
			/* [in] */ DWORD dwCoInit,
			/* [in] */ DWORD dwNewThreadAptRefs);


		void __RPC_STUB IInitializeSpy_PostInitialize_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IInitializeSpy_PreUninitialize_Proxy(
			IInitializeSpy* This,
			/* [in] */ DWORD dwCurThreadAptRefs);


		void __RPC_STUB IInitializeSpy_PreUninitialize_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IInitializeSpy_PostUninitialize_Proxy(
			IInitializeSpy* This,
			/* [in] */ DWORD dwNewThreadAptRefs);


		void __RPC_STUB IInitializeSpy_PostUninitialize_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IInitializeSpy_INTERFACE_DEFINED__ */


		/* interface __MIDL_itf_objidl_0092 */
		/* [local] */

#endif
#if ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif
#endif


		extern RPC_IF_HANDLE __MIDL_itf_objidl_0092_v0_0_c_ifspec;
		extern RPC_IF_HANDLE __MIDL_itf_objidl_0092_v0_0_s_ifspec;

		/* Additional Prototypes for ALL interfaces */

		unsigned long             __RPC_USER  ASYNC_STGMEDIUM_UserSize(unsigned long*, unsigned long, ASYNC_STGMEDIUM*);
		unsigned char* __RPC_USER  ASYNC_STGMEDIUM_UserMarshal(unsigned long*, unsigned char*, ASYNC_STGMEDIUM*);
		unsigned char* __RPC_USER  ASYNC_STGMEDIUM_UserUnmarshal(unsigned long*, unsigned char*, ASYNC_STGMEDIUM*);
		void                      __RPC_USER  ASYNC_STGMEDIUM_UserFree(unsigned long*, ASYNC_STGMEDIUM*);

		unsigned long             __RPC_USER  CLIPFORMAT_UserSize(unsigned long*, unsigned long, CLIPFORMAT*);
		unsigned char* __RPC_USER  CLIPFORMAT_UserMarshal(unsigned long*, unsigned char*, CLIPFORMAT*);
		unsigned char* __RPC_USER  CLIPFORMAT_UserUnmarshal(unsigned long*, unsigned char*, CLIPFORMAT*);
		void                      __RPC_USER  CLIPFORMAT_UserFree(unsigned long*, CLIPFORMAT*);

		unsigned long             __RPC_USER  FLAG_STGMEDIUM_UserSize(unsigned long*, unsigned long, FLAG_STGMEDIUM*);
		unsigned char* __RPC_USER  FLAG_STGMEDIUM_UserMarshal(unsigned long*, unsigned char*, FLAG_STGMEDIUM*);
		unsigned char* __RPC_USER  FLAG_STGMEDIUM_UserUnmarshal(unsigned long*, unsigned char*, FLAG_STGMEDIUM*);
		void                      __RPC_USER  FLAG_STGMEDIUM_UserFree(unsigned long*, FLAG_STGMEDIUM*);

		unsigned long             __RPC_USER  HBITMAP_UserSize(unsigned long*, unsigned long, HBITMAP*);
		unsigned char* __RPC_USER  HBITMAP_UserMarshal(unsigned long*, unsigned char*, HBITMAP*);
		unsigned char* __RPC_USER  HBITMAP_UserUnmarshal(unsigned long*, unsigned char*, HBITMAP*);
		void                      __RPC_USER  HBITMAP_UserFree(unsigned long*, HBITMAP*);

		unsigned long             __RPC_USER  HDC_UserSize(unsigned long*, unsigned long, HDC*);
		unsigned char* __RPC_USER  HDC_UserMarshal(unsigned long*, unsigned char*, HDC*);
		unsigned char* __RPC_USER  HDC_UserUnmarshal(unsigned long*, unsigned char*, HDC*);
		void                      __RPC_USER  HDC_UserFree(unsigned long*, HDC*);

		unsigned long             __RPC_USER  HICON_UserSize(unsigned long*, unsigned long, HICON*);
		unsigned char* __RPC_USER  HICON_UserMarshal(unsigned long*, unsigned char*, HICON*);
		unsigned char* __RPC_USER  HICON_UserUnmarshal(unsigned long*, unsigned char*, HICON*);
		void                      __RPC_USER  HICON_UserFree(unsigned long*, HICON*);

		unsigned long             __RPC_USER  SNB_UserSize(unsigned long*, unsigned long, SNB*);
		unsigned char* __RPC_USER  SNB_UserMarshal(unsigned long*, unsigned char*, SNB*);
		unsigned char* __RPC_USER  SNB_UserUnmarshal(unsigned long*, unsigned char*, SNB*);
		void                      __RPC_USER  SNB_UserFree(unsigned long*, SNB*);

		unsigned long             __RPC_USER  STGMEDIUM_UserSize(unsigned long*, unsigned long, STGMEDIUM*);
		unsigned char* __RPC_USER  STGMEDIUM_UserMarshal(unsigned long*, unsigned char*, STGMEDIUM*);
		unsigned char* __RPC_USER  STGMEDIUM_UserUnmarshal(unsigned long*, unsigned char*, STGMEDIUM*);
		void                      __RPC_USER  STGMEDIUM_UserFree(unsigned long*, STGMEDIUM*);

		/* [local] */ HRESULT STDMETHODCALLTYPE IEnumUnknown_Next_Proxy(
			IEnumUnknown* This,
			/* [in] */ ULONG celt,
			/* [out] */ IUnknown** rgelt,
			/* [out] */ ULONG* pceltFetched);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumUnknown_Next_Stub(
			IEnumUnknown* This,
			/* [in] */ ULONG celt,
			/* [length_is][size_is][out] */ IUnknown** rgelt,
			/* [out] */ ULONG* pceltFetched);

		/* [local] */ HRESULT STDMETHODCALLTYPE IBindCtx_SetBindOptions_Proxy(
			IBindCtx* This,
			/* [in] */ BIND_OPTS* pbindopts);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindCtx_SetBindOptions_Stub(
			IBindCtx* This,
			/* [in] */ BIND_OPTS2* pbindopts);

		/* [local] */ HRESULT STDMETHODCALLTYPE IBindCtx_GetBindOptions_Proxy(
			IBindCtx* This,
			/* [out][in] */ BIND_OPTS* pbindopts);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindCtx_GetBindOptions_Stub(
			IBindCtx* This,
			/* [out][in] */ BIND_OPTS2* pbindopts);

		/* [local] */ HRESULT STDMETHODCALLTYPE IEnumMoniker_Next_Proxy(
			IEnumMoniker* This,
			/* [in] */ ULONG celt,
			/* [length_is][size_is][out] */ IMoniker** rgelt,
			/* [out] */ ULONG* pceltFetched);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumMoniker_Next_Stub(
			IEnumMoniker* This,
			/* [in] */ ULONG celt,
			/* [length_is][size_is][out] */ IMoniker** rgelt,
			/* [out] */ ULONG* pceltFetched);

		/* [local] */ BOOL STDMETHODCALLTYPE IRunnableObject_IsRunning_Proxy(
			IRunnableObject* This);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IRunnableObject_IsRunning_Stub(
			IRunnableObject* This);

		/* [local] */ HRESULT STDMETHODCALLTYPE IMoniker_BindToObject_Proxy(
			IMoniker* This,
			/* [unique][in] */ IBindCtx* pbc,
			/* [unique][in] */ IMoniker* pmkToLeft,
			/* [in] */ REFIID riidResult,
			/* [iid_is][out] */ void** ppvResult);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IMoniker_BindToObject_Stub(
			IMoniker* This,
			/* [unique][in] */ IBindCtx* pbc,
			/* [unique][in] */ IMoniker* pmkToLeft,
			/* [in] */ REFIID riidResult,
			/* [iid_is][out] */ IUnknown** ppvResult);

		/* [local] */ HRESULT STDMETHODCALLTYPE IMoniker_BindToStorage_Proxy(
			IMoniker* This,
			/* [unique][in] */ IBindCtx* pbc,
			/* [unique][in] */ IMoniker* pmkToLeft,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void** ppvObj);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IMoniker_BindToStorage_Stub(
			IMoniker* This,
			/* [unique][in] */ IBindCtx* pbc,
			/* [unique][in] */ IMoniker* pmkToLeft,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ IUnknown** ppvObj);

		/* [local] */ HRESULT STDMETHODCALLTYPE IEnumString_Next_Proxy(
			IEnumString* This,
			/* [in] */ ULONG celt,
			/* [length_is][size_is][out] */ LPOLESTR* rgelt,
			/* [out] */ ULONG* pceltFetched);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumString_Next_Stub(
			IEnumString* This,
			/* [in] */ ULONG celt,
			/* [length_is][size_is][out] */ LPOLESTR* rgelt,
			/* [out] */ ULONG* pceltFetched);

		/* [local] */ HRESULT STDMETHODCALLTYPE ISequentialStream_Read_Proxy(
			ISequentialStream* This,
			/* [length_is][size_is][out] */ void* pv,
			/* [in] */ ULONG cb,
			/* [out] */ ULONG* pcbRead);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE ISequentialStream_Read_Stub(
			ISequentialStream* This,
			/* [length_is][size_is][out] */ byte* pv,
			/* [in] */ ULONG cb,
			/* [out] */ ULONG* pcbRead);

		/* [local] */ HRESULT STDMETHODCALLTYPE ISequentialStream_Write_Proxy(
			ISequentialStream* This,
			/* [size_is][in] */ const void* pv,
			/* [in] */ ULONG cb,
			/* [out] */ ULONG* pcbWritten);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE ISequentialStream_Write_Stub(
			ISequentialStream* This,
			/* [size_is][in] */ const byte* pv,
			/* [in] */ ULONG cb,
			/* [out] */ ULONG* pcbWritten);

		/* [local] */ HRESULT STDMETHODCALLTYPE IStream_Seek_Proxy(
			IStream* This,
			/* [in] */ LARGE_INTEGER dlibMove,
			/* [in] */ DWORD dwOrigin,
			/* [out] */ ULARGE_INTEGER* plibNewPosition);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IStream_Seek_Stub(
			IStream* This,
			/* [in] */ LARGE_INTEGER dlibMove,
			/* [in] */ DWORD dwOrigin,
			/* [out] */ ULARGE_INTEGER* plibNewPosition);

		/* [local] */ HRESULT STDMETHODCALLTYPE IStream_CopyTo_Proxy(
			IStream* This,
			/* [unique][in] */ IStream* pstm,
			/* [in] */ ULARGE_INTEGER cb,
			/* [out] */ ULARGE_INTEGER* pcbRead,
			/* [out] */ ULARGE_INTEGER* pcbWritten);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IStream_CopyTo_Stub(
			IStream* This,
			/* [unique][in] */ IStream* pstm,
			/* [in] */ ULARGE_INTEGER cb,
			/* [out] */ ULARGE_INTEGER* pcbRead,
			/* [out] */ ULARGE_INTEGER* pcbWritten);

		/* [local] */ HRESULT STDMETHODCALLTYPE IEnumSTATSTG_Next_Proxy(
			IEnumSTATSTG* This,
			/* [in] */ ULONG celt,
			/* [length_is][size_is][out] */ STATSTG* rgelt,
			/* [out] */ ULONG* pceltFetched);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumSTATSTG_Next_Stub(
			IEnumSTATSTG* This,
			/* [in] */ ULONG celt,
			/* [length_is][size_is][out] */ STATSTG* rgelt,
			/* [out] */ ULONG* pceltFetched);

		/* [local] */ HRESULT STDMETHODCALLTYPE IStorage_OpenStream_Proxy(
			IStorage* This,
			/* [string][in] */ const OLECHAR* pwcsName,
			/* [unique][in] */ void* reserved1,
			/* [in] */ DWORD grfMode,
			/* [in] */ DWORD reserved2,
			/* [out] */ IStream** ppstm);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IStorage_OpenStream_Stub(
			IStorage* This,
			/* [string][in] */ const OLECHAR* pwcsName,
			/* [in] */ unsigned long cbReserved1,
			/* [size_is][unique][in] */ byte* reserved1,
			/* [in] */ DWORD grfMode,
			/* [in] */ DWORD reserved2,
			/* [out] */ IStream** ppstm);

		/* [local] */ HRESULT STDMETHODCALLTYPE IStorage_EnumElements_Proxy(
			IStorage* This,
			/* [in] */ DWORD reserved1,
			/* [size_is][unique][in] */ void* reserved2,
			/* [in] */ DWORD reserved3,
			/* [out] */ IEnumSTATSTG** ppenum);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IStorage_EnumElements_Stub(
			IStorage* This,
			/* [in] */ DWORD reserved1,
			/* [in] */ unsigned long cbReserved2,
			/* [size_is][unique][in] */ byte* reserved2,
			/* [in] */ DWORD reserved3,
			/* [out] */ IEnumSTATSTG** ppenum);

		/* [local] */ HRESULT STDMETHODCALLTYPE ILockBytes_ReadAt_Proxy(
			ILockBytes* This,
			/* [in] */ ULARGE_INTEGER ulOffset,
			/* [length_is][size_is][out] */ void* pv,
			/* [in] */ ULONG cb,
			/* [out] */ ULONG* pcbRead);


		/* [call_as] */ HRESULT __stdcall ILockBytes_ReadAt_Stub(
			ILockBytes* This,
			/* [in] */ ULARGE_INTEGER ulOffset,
			/* [length_is][size_is][out] */ byte* pv,
			/* [in] */ ULONG cb,
			/* [out] */ ULONG* pcbRead);

		/* [local] */ HRESULT STDMETHODCALLTYPE ILockBytes_WriteAt_Proxy(
			ILockBytes* This,
			/* [in] */ ULARGE_INTEGER ulOffset,
			/* [size_is][in] */ const void* pv,
			/* [in] */ ULONG cb,
			/* [out] */ ULONG* pcbWritten);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE ILockBytes_WriteAt_Stub(
			ILockBytes* This,
			/* [in] */ ULARGE_INTEGER ulOffset,
			/* [size_is][in] */ const byte* pv,
			/* [in] */ ULONG cb,
			/* [out] */ ULONG* pcbWritten);

		/* [local] */ HRESULT STDMETHODCALLTYPE IEnumFORMATETC_Next_Proxy(
			IEnumFORMATETC* This,
			/* [in] */ ULONG celt,
			/* [length_is][size_is][out] */ FORMATETC* rgelt,
			/* [out] */ ULONG* pceltFetched);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumFORMATETC_Next_Stub(
			IEnumFORMATETC* This,
			/* [in] */ ULONG celt,
			/* [length_is][size_is][out] */ FORMATETC* rgelt,
			/* [out] */ ULONG* pceltFetched);

		/* [local] */ HRESULT STDMETHODCALLTYPE IEnumSTATDATA_Next_Proxy(
			IEnumSTATDATA* This,
			/* [in] */ ULONG celt,
			/* [length_is][size_is][out] */ STATDATA* rgelt,
			/* [out] */ ULONG* pceltFetched);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumSTATDATA_Next_Stub(
			IEnumSTATDATA* This,
			/* [in] */ ULONG celt,
			/* [length_is][size_is][out] */ STATDATA* rgelt,
			/* [out] */ ULONG* pceltFetched);

		/* [local] */ void STDMETHODCALLTYPE IAdviseSink_OnDataChange_Proxy(
			IAdviseSink* This,
			/* [unique][in] */ FORMATETC* pFormatetc,
			/* [unique][in] */ STGMEDIUM* pStgmed);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IAdviseSink_OnDataChange_Stub(
			IAdviseSink* This,
			/* [unique][in] */ FORMATETC* pFormatetc,
			/* [unique][in] */ ASYNC_STGMEDIUM* pStgmed);

		/* [local] */ void STDMETHODCALLTYPE IAdviseSink_OnViewChange_Proxy(
			IAdviseSink* This,
			/* [in] */ DWORD dwAspect,
			/* [in] */ LONG lindex);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IAdviseSink_OnViewChange_Stub(
			IAdviseSink* This,
			/* [in] */ DWORD dwAspect,
			/* [in] */ LONG lindex);

		/* [local] */ void STDMETHODCALLTYPE IAdviseSink_OnRename_Proxy(
			IAdviseSink* This,
			/* [in] */ IMoniker* pmk);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IAdviseSink_OnRename_Stub(
			IAdviseSink* This,
			/* [in] */ IMoniker* pmk);

		/* [local] */ void STDMETHODCALLTYPE IAdviseSink_OnSave_Proxy(
			IAdviseSink* This);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IAdviseSink_OnSave_Stub(
			IAdviseSink* This);

		/* [local] */ void STDMETHODCALLTYPE IAdviseSink_OnClose_Proxy(
			IAdviseSink* This);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IAdviseSink_OnClose_Stub(
			IAdviseSink* This);

		/* [local] */ void STDMETHODCALLTYPE IAdviseSink2_OnLinkSrcChange_Proxy(
			IAdviseSink2* This,
			/* [unique][in] */ IMoniker* pmk);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IAdviseSink2_OnLinkSrcChange_Stub(
			IAdviseSink2* This,
			/* [unique][in] */ IMoniker* pmk);

		/* [local] */ HRESULT STDMETHODCALLTYPE IDataObject_GetData_Proxy(
			IDataObject* This,
			/* [unique][in] */ FORMATETC* pformatetcIn,
			/* [out] */ STGMEDIUM* pmedium);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IDataObject_GetData_Stub(
			IDataObject* This,
			/* [unique][in] */ FORMATETC* pformatetcIn,
			/* [out] */ STGMEDIUM* pRemoteMedium);

		/* [local] */ HRESULT STDMETHODCALLTYPE IDataObject_GetDataHere_Proxy(
			IDataObject* This,
			/* [unique][in] */ FORMATETC* pformatetc,
			/* [out][in] */ STGMEDIUM* pmedium);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IDataObject_GetDataHere_Stub(
			IDataObject* This,
			/* [unique][in] */ FORMATETC* pformatetc,
			/* [out][in] */ STGMEDIUM* pRemoteMedium);

		/* [local] */ HRESULT STDMETHODCALLTYPE IDataObject_SetData_Proxy(
			IDataObject* This,
			/* [unique][in] */ FORMATETC* pformatetc,
			/* [unique][in] */ STGMEDIUM* pmedium,
			/* [in] */ BOOL fRelease);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE IDataObject_SetData_Stub(
			IDataObject* This,
			/* [unique][in] */ FORMATETC* pformatetc,
			/* [unique][in] */ FLAG_STGMEDIUM* pmedium,
			/* [in] */ BOOL fRelease);

		/* [local] */ HRESULT STDMETHODCALLTYPE IFillLockBytes_FillAppend_Proxy(
			IFillLockBytes* This,
			/* [size_is][in] */ const void* pv,
			/* [in] */ ULONG cb,
			/* [out] */ ULONG* pcbWritten);


		/* [call_as] */ HRESULT __stdcall IFillLockBytes_FillAppend_Stub(
			IFillLockBytes* This,
			/* [size_is][in] */ const byte* pv,
			/* [in] */ ULONG cb,
			/* [out] */ ULONG* pcbWritten);

		/* [local] */ HRESULT STDMETHODCALLTYPE IFillLockBytes_FillAt_Proxy(
			IFillLockBytes* This,
			/* [in] */ ULARGE_INTEGER ulOffset,
			/* [size_is][in] */ const void* pv,
			/* [in] */ ULONG cb,
			/* [out] */ ULONG* pcbWritten);


		/* [call_as] */ HRESULT __stdcall IFillLockBytes_FillAt_Stub(
			IFillLockBytes* This,
			/* [in] */ ULARGE_INTEGER ulOffset,
			/* [size_is][in] */ const byte* pv,
			/* [in] */ ULONG cb,
			/* [out] */ ULONG* pcbWritten);

		/* [local] */ void STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnDataChange_Proxy(
			AsyncIAdviseSink* This,
			/* [unique][in] */ FORMATETC* pFormatetc,
			/* [unique][in] */ STGMEDIUM* pStgmed);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnDataChange_Stub(
			AsyncIAdviseSink* This,
			/* [unique][in] */ FORMATETC* pFormatetc,
			/* [unique][in] */ ASYNC_STGMEDIUM* pStgmed);

		/* [local] */ void STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnDataChange_Proxy(
			AsyncIAdviseSink* This);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnDataChange_Stub(
			AsyncIAdviseSink* This);

		/* [local] */ void STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnViewChange_Proxy(
			AsyncIAdviseSink* This,
			/* [in] */ DWORD dwAspect,
			/* [in] */ LONG lindex);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnViewChange_Stub(
			AsyncIAdviseSink* This,
			/* [in] */ DWORD dwAspect,
			/* [in] */ LONG lindex);

		/* [local] */ void STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnViewChange_Proxy(
			AsyncIAdviseSink* This);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnViewChange_Stub(
			AsyncIAdviseSink* This);

		/* [local] */ void STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnRename_Proxy(
			AsyncIAdviseSink* This,
			/* [in] */ IMoniker* pmk);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnRename_Stub(
			AsyncIAdviseSink* This,
			/* [in] */ IMoniker* pmk);

		/* [local] */ void STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnRename_Proxy(
			AsyncIAdviseSink* This);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnRename_Stub(
			AsyncIAdviseSink* This);

		/* [local] */ void STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnSave_Proxy(
			AsyncIAdviseSink* This);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnSave_Stub(
			AsyncIAdviseSink* This);

		/* [local] */ void STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnSave_Proxy(
			AsyncIAdviseSink* This);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnSave_Stub(
			AsyncIAdviseSink* This);

		/* [local] */ void STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnClose_Proxy(
			AsyncIAdviseSink* This);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Begin_OnClose_Stub(
			AsyncIAdviseSink* This);

		/* [local] */ void STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnClose_Proxy(
			AsyncIAdviseSink* This);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE AsyncIAdviseSink_Finish_OnClose_Stub(
			AsyncIAdviseSink* This);

		/* [local] */ void STDMETHODCALLTYPE AsyncIAdviseSink2_Begin_OnLinkSrcChange_Proxy(
			AsyncIAdviseSink2* This,
			/* [unique][in] */ IMoniker* pmk);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE AsyncIAdviseSink2_Begin_OnLinkSrcChange_Stub(
			AsyncIAdviseSink2* This,
			/* [unique][in] */ IMoniker* pmk);

		/* [local] */ void STDMETHODCALLTYPE AsyncIAdviseSink2_Finish_OnLinkSrcChange_Proxy(
			AsyncIAdviseSink2* This);


		/* [call_as] */ HRESULT STDMETHODCALLTYPE AsyncIAdviseSink2_Finish_OnLinkSrcChange_Stub(
			AsyncIAdviseSink2* This);



		/* end of Additional Prototypes */

#ifdef __cplusplus
	}
#endif

#endif


	// DOINC popped back into header 'pbprop.h'
	// ***** DOINC including pbtypes.h *****


	/* this ALWAYS GENERATED file contains the definitions for the interfaces */


	 /* File created by MIDL compiler version 6.00.0361 */
	/* at Tue Apr 29 21:01:12 2014
	 */
	 /* Compiler settings for pbtypes.idl:
		 Oicf, W1, Zp8, env=Win32 (32b run)
		 protocol : dce , ms_ext, c_ext, robust
		 error checks: allocation ref bounds_check enum stub_data
		 VC __declspec() decoration level:
			  __declspec(uuid()), __declspec(selectany), __declspec(novtable)
			  DECLSPEC_UUID(), MIDL_INTERFACE()
	 */
	 //@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

// ***** DOINC including rpc.h *****
	// DOINC skipping duplicate include
// ***** DOINC including rpcndr.h *****
	// DOINC skipping duplicate include

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
// ***** DOINC including windows.h *****
	// DOINC skipping duplicate include
// ***** DOINC including ole2.h *****
	// DOINC skipping duplicate include
#endif /*COM_NO_WINDOWS_H*/

#ifndef __pbtypes_h__
#define __pbtypes_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */

#ifndef __IPB_Decimal_FWD_DEFINED__
#define __IPB_Decimal_FWD_DEFINED__
	typedef interface IPB_Decimal IPB_Decimal;
#endif 	/* __IPB_Decimal_FWD_DEFINED__ */


#ifndef __IPB_Blob_FWD_DEFINED__
#define __IPB_Blob_FWD_DEFINED__
	typedef interface IPB_Blob IPB_Blob;
#endif 	/* __IPB_Blob_FWD_DEFINED__ */


#ifndef __IPB_String_FWD_DEFINED__
#define __IPB_String_FWD_DEFINED__
	typedef interface IPB_String IPB_String;
#endif 	/* __IPB_String_FWD_DEFINED__ */


#ifndef __IPB_StringBuffer_FWD_DEFINED__
#define __IPB_StringBuffer_FWD_DEFINED__
	typedef interface IPB_StringBuffer IPB_StringBuffer;
#endif 	/* __IPB_StringBuffer_FWD_DEFINED__ */


#ifndef __IPB_ConvBlob_FWD_DEFINED__
#define __IPB_ConvBlob_FWD_DEFINED__
	typedef interface IPB_ConvBlob IPB_ConvBlob;
#endif 	/* __IPB_ConvBlob_FWD_DEFINED__ */


#ifndef __IPB_ConvString_FWD_DEFINED__
#define __IPB_ConvString_FWD_DEFINED__
	typedef interface IPB_ConvString IPB_ConvString;
#endif 	/* __IPB_ConvString_FWD_DEFINED__ */


#ifndef __IPB_Date_FWD_DEFINED__
#define __IPB_Date_FWD_DEFINED__
	typedef interface IPB_Date IPB_Date;
#endif 	/* __IPB_Date_FWD_DEFINED__ */


#ifndef __IPB_Time_FWD_DEFINED__
#define __IPB_Time_FWD_DEFINED__
	typedef interface IPB_Time IPB_Time;
#endif 	/* __IPB_Time_FWD_DEFINED__ */


#ifndef __IPB_DateTime_FWD_DEFINED__
#define __IPB_DateTime_FWD_DEFINED__
	typedef interface IPB_DateTime IPB_DateTime;
#endif 	/* __IPB_DateTime_FWD_DEFINED__ */


	/* header files for imported files */
	// ***** DOINC including unknwn.h *****
		// DOINC skipping duplicate include

#ifdef __cplusplus
	extern "C" {
#endif 

		void* __RPC_USER MIDL_user_allocate(size_t);
		void __RPC_USER MIDL_user_free(void*);

		/* interface __MIDL_itf_pbtypes_0000 */
		/* [local] */

		//	Copyright Sybase, Inc. 1998
		//
		//	Sybase, Inc. ("Sybase") claims copyright in this
		//	program and documentation as an unpublished work, versions of
		//	which were first licensed on the date indicated in the foregoing
		//	notice.  Claim of copyright does not imply waiver of Sybase's
		//   other rights. See Notice of Proprietary Rights.
		//
		//   NOTICE OF PROPRIETARY RIGHTS
		//
		//   This program and documentation are confidential trade
		//   secrets and the property of Sybase.  Use, examination,
		//   reproduction, copying, disassembly, decompilation, transfer
		//   and/or disclosure to others are strictly prohibited except by
		//   express written agreement with Sybase.
		//
		//      Filename :	types.h
		//
		//      Author   :	Chris McLaren
		//
		//      Purpose  : 	COM Definition of interfaces to primitives
		//
#ifndef OSWINDOW_H
// ***** DOINC including oswindow.h *****
	// DOINC skipping duplicate include
#endif
#ifndef SHRESULT_H
// ***** DOINC including shresult.h *****
//      Copyright Sybase, Inc. 1998
//
//      Sybase, Inc. ("Sybase") claims copyright in this
//      program and documentation as an unpublished work, versions of
//      which were first licensed on the date indicated in the foregoing
//      notice.  Claim of copyright does not imply waiver of Sybase's
//      other rights. See Notice of Proprietary Rights.
//
//      NOTICE OF PROPRIETARY RIGHTS
//
//      This program and documentation are confidential trade
//      secrets and the property of Sybase.  Use, examination,
//      reproduction, copying, disassembly, decompilation, transfer
//      and/or disclosure to others are strictly prohibited except by
//      express written agreement with Sybase.
//
//      Filename :	shresult.h
//
//      Author   :	Chris McLaren
//
//      Purpose  : 	HRESULT definitions for PBSHR functions
//

#ifndef SHRESULT_H
#define SHRESULT_H

#ifndef PBCOM_H
// ***** DOINC including pbcom.h *****
	// DOINC skipping duplicate include
#endif

// Macro definitions to make this file easier to read.
#define SHPBRESULT_ERROR(code)	MAKE_PBRESULT(SEVERITY_ERROR, PBMODULE_SHR, code)
#define SHPBRESULT_SUCCESS(code)	MAKE_PBRESULT(SEVERITY_SUCCESS, PBMODULE_SHR, code)

/****************************************************************/
/* General PBSHR codes -        Reserved 						*/
/* Range: 0x0000 - 0x003F				  						*/
/****************************************************************/

/****************************************************************/
/* Decimal Package codes     - Reserved 						*/
/* Range: 0x0040 - 0x005F				  						*/
/****************************************************************/

//unspecified error from decimal package
#define PBE_DEC_UNSPEC		SHPBRESULT_ERROR(0x0040);
//decimal value overflow error
#define PBE_DEC_OVERFLOW	SHPBRESULT_ERROR(0x0041);
//decimal divide by zero
#define PBE_DEC_DIV0		SHPBRESULT_ERROR(0x0042);

/****************************************************************/
/* String Package codes     - Reserved 							*/
/* Range: 0x0060 - 0x007F				  						*/
/****************************************************************/

/****************************************************************/
/* CPB_List Package codes     - Reserved 						 	*/
/* Range: 0x00A0 - 0x00AF				  						*/
/****************************************************************/

/****************************************************************/
/* CDynVec Package codes     - Reserved 					 	*/
/* Range: 0x00B0 - 0x00BF				  						*/
/****************************************************************/
//this slot is empty
#define PB_W_DYNVEC_EMPTY		SHPBRESULT_SUCCESS(0x00B1);

/****************************************************************/
/* CPB_DictionaryImpl Package codes     - Reserved 						 	*/
/* Range: 0x00C0 - 0x00CF				  						*/
/****************************************************************/

#endif //shresult_h
// DOINC popped back into header 'pbtypes.h'
#endif
#ifndef PBSTG_H
// ***** DOINC including pbstg.h *****
	// DOINC skipping duplicate include
#endif
#ifndef SHDEC_H
// ***** DOINC including shdec.h *****
	// DOINC skipping duplicate include
#endif
#ifndef SHFORMAT_H
// ***** DOINC including shformat.h *****
	// DOINC skipping duplicate include
#endif
#ifndef PBASSERT_H
// ***** DOINC including pbassert.h *****
	// DOINC skipping duplicate include
#endif

		typedef /* [public][public][public][public][public][public][public][public][public][v1_enum] */
			enum __MIDL___MIDL_itf_pbtypes_0000_0001
		{
			PB_LessThan = -1,
			PB_EqualTo = 0,
			PB_GreaterThan = 1
		} 	PB_Relational;

		typedef /* [public][public][public][v1_enum] */
			enum __MIDL___MIDL_itf_pbtypes_0000_0002
		{
			PB_FromLeft = -1,
			PB_FromBoth = 0,
			PB_FromRight = 1
		} 	PB_TrimDir;

		typedef /* [public][public][public][public][public][public][public][v1_enum] */
			enum __MIDL___MIDL_itf_pbtypes_0000_0003
		{
			PB_Year = 0,
			PB_Month = 1,
			PB_Day = 2,
			PB_Hour = 3,
			PB_Minute = 4,
			PB_Second = 5,
			PB_Microseconds = 6
		} 	PB_DateTimeFields;



		extern RPC_IF_HANDLE __MIDL_itf_pbtypes_0000_v0_0_c_ifspec;
		extern RPC_IF_HANDLE __MIDL_itf_pbtypes_0000_v0_0_s_ifspec;

#ifndef __IPB_Decimal_INTERFACE_DEFINED__
#define __IPB_Decimal_INTERFACE_DEFINED__

		/* interface IPB_Decimal */
		/* [unique][uuid][object][local] */

		typedef /* [unique] */ IPB_Decimal* LPPBDEC;


		EXTERN_C const IID IID_IPB_Decimal;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("7967F1C1-610D-11d1-9E97-0000F8778DC6")
			IPB_Decimal : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE CompareTo(
				/* [in] */ IPB_Decimal * pDecimal,
				/* [out] */ PB_Relational * piComparison) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetAsDouble(
				/* [out] */ DOUBLE* pDouble) = 0;

			virtual HRESULT STDMETHODCALLTYPE Negate(
				/* [out] */ IPB_Decimal** ppNegative) = 0;

			virtual HRESULT STDMETHODCALLTYPE Round(
				/* [out] */ IPB_Decimal** ppRound,
				/* [in] */ ULONG ulPrecision) = 0;

			virtual HRESULT STDMETHODCALLTYPE Truncate(
				/* [out] */ IPB_Decimal** ppTrunc,
				/* [in] */ ULONG ulPrecision) = 0;

			virtual HRESULT STDMETHODCALLTYPE Absolute(
				/* [out] */ IPB_Decimal** ppAbsolute) = 0;

			virtual HRESULT STDMETHODCALLTYPE Precision(
				/* [out] */ ULONG* ulPrecision) = 0;

			virtual HRESULT STDMETHODCALLTYPE Add(
				/* [in] */ IPB_Decimal* pOperand,
				/* [out] */ IPB_Decimal** ppResult) = 0;

			virtual HRESULT STDMETHODCALLTYPE Subtract(
				/* [in] */ IPB_Decimal* pOperand,
				/* [out] */ IPB_Decimal** ppResult) = 0;

			virtual HRESULT STDMETHODCALLTYPE Multiply(
				/* [in] */ IPB_Decimal* pOperand,
				/* [out] */ IPB_Decimal** ppResult) = 0;

			virtual HRESULT STDMETHODCALLTYPE Divide(
				/* [in] */ IPB_Decimal* pOperand,
				/* [out] */ IPB_Decimal** ppResult) = 0;

			virtual HRESULT STDMETHODCALLTYPE Mod(
				/* [in] */ IPB_Decimal* pOperand,
				/* [out] */ IPB_Decimal** ppResult) = 0;

			virtual HRESULT STDMETHODCALLTYPE Exp(
				/* [in] */ IPB_Decimal* pOperand,
				/* [out] */ IPB_Decimal** ppResult) = 0;

		};

#else 	/* C style interface */

		typedef struct IPB_DecimalVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IPB_Decimal* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IPB_Decimal* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IPB_Decimal* This);

			HRESULT(STDMETHODCALLTYPE* CompareTo)(
				IPB_Decimal* This,
				/* [in] */ IPB_Decimal* pDecimal,
				/* [out] */ PB_Relational* piComparison);

			HRESULT(STDMETHODCALLTYPE* GetAsDouble)(
				IPB_Decimal* This,
				/* [out] */ DOUBLE* pDouble);

			HRESULT(STDMETHODCALLTYPE* Negate)(
				IPB_Decimal* This,
				/* [out] */ IPB_Decimal** ppNegative);

			HRESULT(STDMETHODCALLTYPE* Round)(
				IPB_Decimal* This,
				/* [out] */ IPB_Decimal** ppRound,
				/* [in] */ ULONG ulPrecision);

			HRESULT(STDMETHODCALLTYPE* Truncate)(
				IPB_Decimal* This,
				/* [out] */ IPB_Decimal** ppTrunc,
				/* [in] */ ULONG ulPrecision);

			HRESULT(STDMETHODCALLTYPE* Absolute)(
				IPB_Decimal* This,
				/* [out] */ IPB_Decimal** ppAbsolute);

			HRESULT(STDMETHODCALLTYPE* Precision)(
				IPB_Decimal* This,
				/* [out] */ ULONG* ulPrecision);

			HRESULT(STDMETHODCALLTYPE* Add)(
				IPB_Decimal* This,
				/* [in] */ IPB_Decimal* pOperand,
				/* [out] */ IPB_Decimal** ppResult);

			HRESULT(STDMETHODCALLTYPE* Subtract)(
				IPB_Decimal* This,
				/* [in] */ IPB_Decimal* pOperand,
				/* [out] */ IPB_Decimal** ppResult);

			HRESULT(STDMETHODCALLTYPE* Multiply)(
				IPB_Decimal* This,
				/* [in] */ IPB_Decimal* pOperand,
				/* [out] */ IPB_Decimal** ppResult);

			HRESULT(STDMETHODCALLTYPE* Divide)(
				IPB_Decimal* This,
				/* [in] */ IPB_Decimal* pOperand,
				/* [out] */ IPB_Decimal** ppResult);

			HRESULT(STDMETHODCALLTYPE* Mod)(
				IPB_Decimal* This,
				/* [in] */ IPB_Decimal* pOperand,
				/* [out] */ IPB_Decimal** ppResult);

			HRESULT(STDMETHODCALLTYPE* Exp)(
				IPB_Decimal* This,
				/* [in] */ IPB_Decimal* pOperand,
				/* [out] */ IPB_Decimal** ppResult);

			END_INTERFACE
		} IPB_DecimalVtbl;

		interface IPB_Decimal
		{
			CONST_VTBL struct IPB_DecimalVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IPB_Decimal_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_Decimal_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_Decimal_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_Decimal_CompareTo(This,pDecimal,piComparison)	\
    (This)->lpVtbl -> CompareTo(This,pDecimal,piComparison)

#define IPB_Decimal_GetAsDouble(This,pDouble)	\
    (This)->lpVtbl -> GetAsDouble(This,pDouble)

#define IPB_Decimal_Negate(This,ppNegative)	\
    (This)->lpVtbl -> Negate(This,ppNegative)

#define IPB_Decimal_Round(This,ppRound,ulPrecision)	\
    (This)->lpVtbl -> Round(This,ppRound,ulPrecision)

#define IPB_Decimal_Truncate(This,ppTrunc,ulPrecision)	\
    (This)->lpVtbl -> Truncate(This,ppTrunc,ulPrecision)

#define IPB_Decimal_Absolute(This,ppAbsolute)	\
    (This)->lpVtbl -> Absolute(This,ppAbsolute)

#define IPB_Decimal_Precision(This,ulPrecision)	\
    (This)->lpVtbl -> Precision(This,ulPrecision)

#define IPB_Decimal_Add(This,pOperand,ppResult)	\
    (This)->lpVtbl -> Add(This,pOperand,ppResult)

#define IPB_Decimal_Subtract(This,pOperand,ppResult)	\
    (This)->lpVtbl -> Subtract(This,pOperand,ppResult)

#define IPB_Decimal_Multiply(This,pOperand,ppResult)	\
    (This)->lpVtbl -> Multiply(This,pOperand,ppResult)

#define IPB_Decimal_Divide(This,pOperand,ppResult)	\
    (This)->lpVtbl -> Divide(This,pOperand,ppResult)

#define IPB_Decimal_Mod(This,pOperand,ppResult)	\
    (This)->lpVtbl -> Mod(This,pOperand,ppResult)

#define IPB_Decimal_Exp(This,pOperand,ppResult)	\
    (This)->lpVtbl -> Exp(This,pOperand,ppResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IPB_Decimal_CompareTo_Proxy(
			IPB_Decimal* This,
			/* [in] */ IPB_Decimal* pDecimal,
			/* [out] */ PB_Relational* piComparison);


		void __RPC_STUB IPB_Decimal_CompareTo_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Decimal_GetAsDouble_Proxy(
			IPB_Decimal* This,
			/* [out] */ DOUBLE* pDouble);


		void __RPC_STUB IPB_Decimal_GetAsDouble_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Decimal_Negate_Proxy(
			IPB_Decimal* This,
			/* [out] */ IPB_Decimal** ppNegative);


		void __RPC_STUB IPB_Decimal_Negate_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Decimal_Round_Proxy(
			IPB_Decimal* This,
			/* [out] */ IPB_Decimal** ppRound,
			/* [in] */ ULONG ulPrecision);


		void __RPC_STUB IPB_Decimal_Round_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Decimal_Truncate_Proxy(
			IPB_Decimal* This,
			/* [out] */ IPB_Decimal** ppTrunc,
			/* [in] */ ULONG ulPrecision);


		void __RPC_STUB IPB_Decimal_Truncate_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Decimal_Absolute_Proxy(
			IPB_Decimal* This,
			/* [out] */ IPB_Decimal** ppAbsolute);


		void __RPC_STUB IPB_Decimal_Absolute_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Decimal_Precision_Proxy(
			IPB_Decimal* This,
			/* [out] */ ULONG* ulPrecision);


		void __RPC_STUB IPB_Decimal_Precision_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Decimal_Add_Proxy(
			IPB_Decimal* This,
			/* [in] */ IPB_Decimal* pOperand,
			/* [out] */ IPB_Decimal** ppResult);


		void __RPC_STUB IPB_Decimal_Add_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Decimal_Subtract_Proxy(
			IPB_Decimal* This,
			/* [in] */ IPB_Decimal* pOperand,
			/* [out] */ IPB_Decimal** ppResult);


		void __RPC_STUB IPB_Decimal_Subtract_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Decimal_Multiply_Proxy(
			IPB_Decimal* This,
			/* [in] */ IPB_Decimal* pOperand,
			/* [out] */ IPB_Decimal** ppResult);


		void __RPC_STUB IPB_Decimal_Multiply_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Decimal_Divide_Proxy(
			IPB_Decimal* This,
			/* [in] */ IPB_Decimal* pOperand,
			/* [out] */ IPB_Decimal** ppResult);


		void __RPC_STUB IPB_Decimal_Divide_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Decimal_Mod_Proxy(
			IPB_Decimal* This,
			/* [in] */ IPB_Decimal* pOperand,
			/* [out] */ IPB_Decimal** ppResult);


		void __RPC_STUB IPB_Decimal_Mod_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Decimal_Exp_Proxy(
			IPB_Decimal* This,
			/* [in] */ IPB_Decimal* pOperand,
			/* [out] */ IPB_Decimal** ppResult);


		void __RPC_STUB IPB_Decimal_Exp_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IPB_Decimal_INTERFACE_DEFINED__ */


#ifndef __IPB_Blob_INTERFACE_DEFINED__
#define __IPB_Blob_INTERFACE_DEFINED__

		/* interface IPB_Blob */
		/* [unique][uuid][object][local] */

		typedef /* [unique] */ IPB_Blob* LPPBBLOB;


		EXTERN_C const IID IID_IPB_Blob;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("5CEEEEB4-6118-11d1-9E97-0000F8778DC6")
			IPB_Blob : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE GetSize(
				/* [out] */ ULONG * pulSize) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetData(
				/* [out] */ BYTE** ppData) = 0;

			virtual HRESULT STDMETHODCALLTYPE ExtractData(
				/* [in] */ ULONG ulStart,
				/* [in] */ ULONG ulLength,
				/* [out] */ IPB_Blob** ppExtract) = 0;

			virtual HRESULT STDMETHODCALLTYPE InsertBytes(
				/* [in] */ ULONG ulOffset,
				/* [in] */ BYTE* pDataToInsert,
				/* [in] */ ULONG ulLength,
				/* [out] */ IPB_Blob** ppNewBlob) = 0;

			virtual HRESULT STDMETHODCALLTYPE InsertBlob(
				/* [in] */ ULONG ulOffset,
				/* [in] */ IPB_Blob* pDataToInsert,
				/* [out] */ IPB_Blob** ppNewBlob) = 0;

		};

#else 	/* C style interface */

		typedef struct IPB_BlobVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IPB_Blob* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IPB_Blob* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IPB_Blob* This);

			HRESULT(STDMETHODCALLTYPE* GetSize)(
				IPB_Blob* This,
				/* [out] */ ULONG* pulSize);

			HRESULT(STDMETHODCALLTYPE* GetData)(
				IPB_Blob* This,
				/* [out] */ BYTE** ppData);

			HRESULT(STDMETHODCALLTYPE* ExtractData)(
				IPB_Blob* This,
				/* [in] */ ULONG ulStart,
				/* [in] */ ULONG ulLength,
				/* [out] */ IPB_Blob** ppExtract);

			HRESULT(STDMETHODCALLTYPE* InsertBytes)(
				IPB_Blob* This,
				/* [in] */ ULONG ulOffset,
				/* [in] */ BYTE* pDataToInsert,
				/* [in] */ ULONG ulLength,
				/* [out] */ IPB_Blob** ppNewBlob);

			HRESULT(STDMETHODCALLTYPE* InsertBlob)(
				IPB_Blob* This,
				/* [in] */ ULONG ulOffset,
				/* [in] */ IPB_Blob* pDataToInsert,
				/* [out] */ IPB_Blob** ppNewBlob);

			END_INTERFACE
		} IPB_BlobVtbl;

		interface IPB_Blob
		{
			CONST_VTBL struct IPB_BlobVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IPB_Blob_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_Blob_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_Blob_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_Blob_GetSize(This,pulSize)	\
    (This)->lpVtbl -> GetSize(This,pulSize)

#define IPB_Blob_GetData(This,ppData)	\
    (This)->lpVtbl -> GetData(This,ppData)

#define IPB_Blob_ExtractData(This,ulStart,ulLength,ppExtract)	\
    (This)->lpVtbl -> ExtractData(This,ulStart,ulLength,ppExtract)

#define IPB_Blob_InsertBytes(This,ulOffset,pDataToInsert,ulLength,ppNewBlob)	\
    (This)->lpVtbl -> InsertBytes(This,ulOffset,pDataToInsert,ulLength,ppNewBlob)

#define IPB_Blob_InsertBlob(This,ulOffset,pDataToInsert,ppNewBlob)	\
    (This)->lpVtbl -> InsertBlob(This,ulOffset,pDataToInsert,ppNewBlob)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IPB_Blob_GetSize_Proxy(
			IPB_Blob* This,
			/* [out] */ ULONG* pulSize);


		void __RPC_STUB IPB_Blob_GetSize_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Blob_GetData_Proxy(
			IPB_Blob* This,
			/* [out] */ BYTE** ppData);


		void __RPC_STUB IPB_Blob_GetData_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Blob_ExtractData_Proxy(
			IPB_Blob* This,
			/* [in] */ ULONG ulStart,
			/* [in] */ ULONG ulLength,
			/* [out] */ IPB_Blob** ppExtract);


		void __RPC_STUB IPB_Blob_ExtractData_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Blob_InsertBytes_Proxy(
			IPB_Blob* This,
			/* [in] */ ULONG ulOffset,
			/* [in] */ BYTE* pDataToInsert,
			/* [in] */ ULONG ulLength,
			/* [out] */ IPB_Blob** ppNewBlob);


		void __RPC_STUB IPB_Blob_InsertBytes_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Blob_InsertBlob_Proxy(
			IPB_Blob* This,
			/* [in] */ ULONG ulOffset,
			/* [in] */ IPB_Blob* pDataToInsert,
			/* [out] */ IPB_Blob** ppNewBlob);


		void __RPC_STUB IPB_Blob_InsertBlob_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IPB_Blob_INTERFACE_DEFINED__ */


#ifndef __IPB_String_INTERFACE_DEFINED__
#define __IPB_String_INTERFACE_DEFINED__

		/* interface IPB_String */
		/* [unique][uuid][object][local] */

		typedef /* [unique] */ IPB_String* LPPBSTRING;


		EXTERN_C const IID IID_IPB_String;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("5CEEEEB0-6118-11d1-9E97-0000F8778DC6")
			IPB_String : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE CompareTo(
				/* [in] */ IPB_String * pString,
				/* [out] */ PB_Relational * piComparison) = 0;

			virtual HRESULT STDMETHODCALLTYPE CompareToIgnoreCase(
				/* [in] */ IPB_String* pString,
				/* [out] */ PB_Relational* piComparison) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetValue(
				/* [out] */ LPTSTR* pValue) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetLength(
				/* [out] */ ULONG* pulLength) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetCharAt(
				/* [in] */ ULONG ulOffset,
				/* [out] */ TCHAR* pChar) = 0;

			virtual HRESULT STDMETHODCALLTYPE SubString(
				/* [in] */ ULONG ulFrom,
				/* [in] */ ULONG ulLength,
				/* [out] */ IPB_String** ppSubString) = 0;

			virtual HRESULT STDMETHODCALLTYPE Concat(
				/* [in] */ IPB_String* pStringToAppend,
				/* [out] */ IPB_String** ppNewString) = 0;

			virtual HRESULT STDMETHODCALLTYPE Upper(
				/* [out] */ IPB_String** ppNewString) = 0;

			virtual HRESULT STDMETHODCALLTYPE Lower(
				/* [out] */ IPB_String** ppNewString) = 0;

			virtual HRESULT STDMETHODCALLTYPE Trim(
				/* [in] */ TCHAR charToTrim,
				/* [in] */ PB_TrimDir iTrimDirection,
				/* [out] */ IPB_String** ppNewString) = 0;

			virtual HRESULT STDMETHODCALLTYPE Pos(
				/* [in] */ ULONG ulStart,
				/* [in] */ IPB_String* pString,
				/* [out] */ ULONG* ulIndex) = 0;

		};

#else 	/* C style interface */

		typedef struct IPB_StringVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IPB_String* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IPB_String* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IPB_String* This);

			HRESULT(STDMETHODCALLTYPE* CompareTo)(
				IPB_String* This,
				/* [in] */ IPB_String* pString,
				/* [out] */ PB_Relational* piComparison);

			HRESULT(STDMETHODCALLTYPE* CompareToIgnoreCase)(
				IPB_String* This,
				/* [in] */ IPB_String* pString,
				/* [out] */ PB_Relational* piComparison);

			HRESULT(STDMETHODCALLTYPE* GetValue)(
				IPB_String* This,
				/* [out] */ LPTSTR* pValue);

			HRESULT(STDMETHODCALLTYPE* GetLength)(
				IPB_String* This,
				/* [out] */ ULONG* pulLength);

			HRESULT(STDMETHODCALLTYPE* GetCharAt)(
				IPB_String* This,
				/* [in] */ ULONG ulOffset,
				/* [out] */ TCHAR* pChar);

			HRESULT(STDMETHODCALLTYPE* SubString)(
				IPB_String* This,
				/* [in] */ ULONG ulFrom,
				/* [in] */ ULONG ulLength,
				/* [out] */ IPB_String** ppSubString);

			HRESULT(STDMETHODCALLTYPE* Concat)(
				IPB_String* This,
				/* [in] */ IPB_String* pStringToAppend,
				/* [out] */ IPB_String** ppNewString);

			HRESULT(STDMETHODCALLTYPE* Upper)(
				IPB_String* This,
				/* [out] */ IPB_String** ppNewString);

			HRESULT(STDMETHODCALLTYPE* Lower)(
				IPB_String* This,
				/* [out] */ IPB_String** ppNewString);

			HRESULT(STDMETHODCALLTYPE* Trim)(
				IPB_String* This,
				/* [in] */ TCHAR charToTrim,
				/* [in] */ PB_TrimDir iTrimDirection,
				/* [out] */ IPB_String** ppNewString);

			HRESULT(STDMETHODCALLTYPE* Pos)(
				IPB_String* This,
				/* [in] */ ULONG ulStart,
				/* [in] */ IPB_String* pString,
				/* [out] */ ULONG* ulIndex);

			END_INTERFACE
		} IPB_StringVtbl;

		interface IPB_String
		{
			CONST_VTBL struct IPB_StringVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IPB_String_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_String_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_String_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_String_CompareTo(This,pString,piComparison)	\
    (This)->lpVtbl -> CompareTo(This,pString,piComparison)

#define IPB_String_CompareToIgnoreCase(This,pString,piComparison)	\
    (This)->lpVtbl -> CompareToIgnoreCase(This,pString,piComparison)

#define IPB_String_GetValue(This,pValue)	\
    (This)->lpVtbl -> GetValue(This,pValue)

#define IPB_String_GetLength(This,pulLength)	\
    (This)->lpVtbl -> GetLength(This,pulLength)

#define IPB_String_GetCharAt(This,ulOffset,pChar)	\
    (This)->lpVtbl -> GetCharAt(This,ulOffset,pChar)

#define IPB_String_SubString(This,ulFrom,ulLength,ppSubString)	\
    (This)->lpVtbl -> SubString(This,ulFrom,ulLength,ppSubString)

#define IPB_String_Concat(This,pStringToAppend,ppNewString)	\
    (This)->lpVtbl -> Concat(This,pStringToAppend,ppNewString)

#define IPB_String_Upper(This,ppNewString)	\
    (This)->lpVtbl -> Upper(This,ppNewString)

#define IPB_String_Lower(This,ppNewString)	\
    (This)->lpVtbl -> Lower(This,ppNewString)

#define IPB_String_Trim(This,charToTrim,iTrimDirection,ppNewString)	\
    (This)->lpVtbl -> Trim(This,charToTrim,iTrimDirection,ppNewString)

#define IPB_String_Pos(This,ulStart,pString,ulIndex)	\
    (This)->lpVtbl -> Pos(This,ulStart,pString,ulIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IPB_String_CompareTo_Proxy(
			IPB_String* This,
			/* [in] */ IPB_String* pString,
			/* [out] */ PB_Relational* piComparison);


		void __RPC_STUB IPB_String_CompareTo_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_String_CompareToIgnoreCase_Proxy(
			IPB_String* This,
			/* [in] */ IPB_String* pString,
			/* [out] */ PB_Relational* piComparison);


		void __RPC_STUB IPB_String_CompareToIgnoreCase_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_String_GetValue_Proxy(
			IPB_String* This,
			/* [out] */ LPTSTR* pValue);


		void __RPC_STUB IPB_String_GetValue_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_String_GetLength_Proxy(
			IPB_String* This,
			/* [out] */ ULONG* pulLength);


		void __RPC_STUB IPB_String_GetLength_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_String_GetCharAt_Proxy(
			IPB_String* This,
			/* [in] */ ULONG ulOffset,
			/* [out] */ TCHAR* pChar);


		void __RPC_STUB IPB_String_GetCharAt_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_String_SubString_Proxy(
			IPB_String* This,
			/* [in] */ ULONG ulFrom,
			/* [in] */ ULONG ulLength,
			/* [out] */ IPB_String** ppSubString);


		void __RPC_STUB IPB_String_SubString_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_String_Concat_Proxy(
			IPB_String* This,
			/* [in] */ IPB_String* pStringToAppend,
			/* [out] */ IPB_String** ppNewString);


		void __RPC_STUB IPB_String_Concat_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_String_Upper_Proxy(
			IPB_String* This,
			/* [out] */ IPB_String** ppNewString);


		void __RPC_STUB IPB_String_Upper_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_String_Lower_Proxy(
			IPB_String* This,
			/* [out] */ IPB_String** ppNewString);


		void __RPC_STUB IPB_String_Lower_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_String_Trim_Proxy(
			IPB_String* This,
			/* [in] */ TCHAR charToTrim,
			/* [in] */ PB_TrimDir iTrimDirection,
			/* [out] */ IPB_String** ppNewString);


		void __RPC_STUB IPB_String_Trim_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_String_Pos_Proxy(
			IPB_String* This,
			/* [in] */ ULONG ulStart,
			/* [in] */ IPB_String* pString,
			/* [out] */ ULONG* ulIndex);


		void __RPC_STUB IPB_String_Pos_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IPB_String_INTERFACE_DEFINED__ */


#ifndef __IPB_StringBuffer_INTERFACE_DEFINED__
#define __IPB_StringBuffer_INTERFACE_DEFINED__

		/* interface IPB_StringBuffer */
		/* [unique][uuid][object][local] */

		typedef /* [unique] */ IPB_StringBuffer* LPPBSTRINGBUF;


		EXTERN_C const IID IID_IPB_StringBuffer;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("5CEEEEB1-6118-11d1-9E97-0000F8778DC6")
			IPB_StringBuffer : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE Clone(
				/* [out] */ IPB_StringBuffer * *ppString) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetValue(
				/* [out] */ LPTSTR* ppValue) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetLength(
				/* [out] */ ULONG* pulLength) = 0;

			virtual HRESULT STDMETHODCALLTYPE CompareTo(
				/* [in] */ IPB_StringBuffer* pString,
				/* [out] */ PB_Relational* piComparison) = 0;

			virtual HRESULT STDMETHODCALLTYPE CompareToIgnoreCase(
				/* [in] */ IPB_StringBuffer* pString,
				/* [out] */ PB_Relational* piComparison) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetCharAt(
				/* [in] */ ULONG ulOffset,
				/* [out] */ TCHAR* pChar) = 0;

			virtual HRESULT STDMETHODCALLTYPE SetCharAt(
				/* [in] */ ULONG ulOffset,
				/* [in] */ TCHAR theChar) = 0;

			virtual HRESULT STDMETHODCALLTYPE SubString(
				/* [in] */ ULONG ulFrom,
				/* [in] */ ULONG ulLength,
				/* [out] */ IPB_String** ppSubString) = 0;

			virtual HRESULT STDMETHODCALLTYPE Concat(
				/* [in] */ IPB_String* pStringToAppend) = 0;

			virtual HRESULT STDMETHODCALLTYPE InsertAt(
				/* [in] */ ULONG ulOffset,
				/* [in] */ IPB_String* pStringToInsert) = 0;

			virtual HRESULT STDMETHODCALLTYPE Delete(
				/* [in] */ ULONG ulBegin,
				/* [in] */ ULONG ulLength) = 0;

			virtual HRESULT STDMETHODCALLTYPE Replace(
				/* [in] */ ULONG ulBegin,
				/* [in] */ ULONG ulLength,
				/* [in] */ IPB_String* pInserted) = 0;

			virtual HRESULT STDMETHODCALLTYPE ToUpper(void) = 0;

			virtual HRESULT STDMETHODCALLTYPE ToLower(void) = 0;

			virtual HRESULT STDMETHODCALLTYPE Trim(
				/* [in] */ TCHAR charToTrim,
				/* [in] */ PB_TrimDir iTrimDirection) = 0;

			virtual HRESULT STDMETHODCALLTYPE Pos(
				/* [in] */ ULONG ulStart,
				/* [in] */ IPB_String* pString,
				/* [out] */ ULONG* ulIndex) = 0;

			virtual HRESULT STDMETHODCALLTYPE SetFromChars(
				/* [in] */ TCHAR* pChars) = 0;

			virtual HRESULT STDMETHODCALLTYPE SetFromString(
				/* [in] */ IPB_String* pString) = 0;

		};

#else 	/* C style interface */

		typedef struct IPB_StringBufferVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IPB_StringBuffer* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IPB_StringBuffer* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IPB_StringBuffer* This);

			HRESULT(STDMETHODCALLTYPE* Clone)(
				IPB_StringBuffer* This,
				/* [out] */ IPB_StringBuffer** ppString);

			HRESULT(STDMETHODCALLTYPE* GetValue)(
				IPB_StringBuffer* This,
				/* [out] */ LPTSTR* ppValue);

			HRESULT(STDMETHODCALLTYPE* GetLength)(
				IPB_StringBuffer* This,
				/* [out] */ ULONG* pulLength);

			HRESULT(STDMETHODCALLTYPE* CompareTo)(
				IPB_StringBuffer* This,
				/* [in] */ IPB_StringBuffer* pString,
				/* [out] */ PB_Relational* piComparison);

			HRESULT(STDMETHODCALLTYPE* CompareToIgnoreCase)(
				IPB_StringBuffer* This,
				/* [in] */ IPB_StringBuffer* pString,
				/* [out] */ PB_Relational* piComparison);

			HRESULT(STDMETHODCALLTYPE* GetCharAt)(
				IPB_StringBuffer* This,
				/* [in] */ ULONG ulOffset,
				/* [out] */ TCHAR* pChar);

			HRESULT(STDMETHODCALLTYPE* SetCharAt)(
				IPB_StringBuffer* This,
				/* [in] */ ULONG ulOffset,
				/* [in] */ TCHAR theChar);

			HRESULT(STDMETHODCALLTYPE* SubString)(
				IPB_StringBuffer* This,
				/* [in] */ ULONG ulFrom,
				/* [in] */ ULONG ulLength,
				/* [out] */ IPB_String** ppSubString);

			HRESULT(STDMETHODCALLTYPE* Concat)(
				IPB_StringBuffer* This,
				/* [in] */ IPB_String* pStringToAppend);

			HRESULT(STDMETHODCALLTYPE* InsertAt)(
				IPB_StringBuffer* This,
				/* [in] */ ULONG ulOffset,
				/* [in] */ IPB_String* pStringToInsert);

			HRESULT(STDMETHODCALLTYPE* Delete)(
				IPB_StringBuffer* This,
				/* [in] */ ULONG ulBegin,
				/* [in] */ ULONG ulLength);

			HRESULT(STDMETHODCALLTYPE* Replace)(
				IPB_StringBuffer* This,
				/* [in] */ ULONG ulBegin,
				/* [in] */ ULONG ulLength,
				/* [in] */ IPB_String* pInserted);

			HRESULT(STDMETHODCALLTYPE* ToUpper)(
				IPB_StringBuffer* This);

			HRESULT(STDMETHODCALLTYPE* ToLower)(
				IPB_StringBuffer* This);

			HRESULT(STDMETHODCALLTYPE* Trim)(
				IPB_StringBuffer* This,
				/* [in] */ TCHAR charToTrim,
				/* [in] */ PB_TrimDir iTrimDirection);

			HRESULT(STDMETHODCALLTYPE* Pos)(
				IPB_StringBuffer* This,
				/* [in] */ ULONG ulStart,
				/* [in] */ IPB_String* pString,
				/* [out] */ ULONG* ulIndex);

			HRESULT(STDMETHODCALLTYPE* SetFromChars)(
				IPB_StringBuffer* This,
				/* [in] */ TCHAR* pChars);

			HRESULT(STDMETHODCALLTYPE* SetFromString)(
				IPB_StringBuffer* This,
				/* [in] */ IPB_String* pString);

			END_INTERFACE
		} IPB_StringBufferVtbl;

		interface IPB_StringBuffer
		{
			CONST_VTBL struct IPB_StringBufferVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IPB_StringBuffer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_StringBuffer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_StringBuffer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_StringBuffer_Clone(This,ppString)	\
    (This)->lpVtbl -> Clone(This,ppString)

#define IPB_StringBuffer_GetValue(This,ppValue)	\
    (This)->lpVtbl -> GetValue(This,ppValue)

#define IPB_StringBuffer_GetLength(This,pulLength)	\
    (This)->lpVtbl -> GetLength(This,pulLength)

#define IPB_StringBuffer_CompareTo(This,pString,piComparison)	\
    (This)->lpVtbl -> CompareTo(This,pString,piComparison)

#define IPB_StringBuffer_CompareToIgnoreCase(This,pString,piComparison)	\
    (This)->lpVtbl -> CompareToIgnoreCase(This,pString,piComparison)

#define IPB_StringBuffer_GetCharAt(This,ulOffset,pChar)	\
    (This)->lpVtbl -> GetCharAt(This,ulOffset,pChar)

#define IPB_StringBuffer_SetCharAt(This,ulOffset,theChar)	\
    (This)->lpVtbl -> SetCharAt(This,ulOffset,theChar)

#define IPB_StringBuffer_SubString(This,ulFrom,ulLength,ppSubString)	\
    (This)->lpVtbl -> SubString(This,ulFrom,ulLength,ppSubString)

#define IPB_StringBuffer_Concat(This,pStringToAppend)	\
    (This)->lpVtbl -> Concat(This,pStringToAppend)

#define IPB_StringBuffer_InsertAt(This,ulOffset,pStringToInsert)	\
    (This)->lpVtbl -> InsertAt(This,ulOffset,pStringToInsert)

#define IPB_StringBuffer_Delete(This,ulBegin,ulLength)	\
    (This)->lpVtbl -> Delete(This,ulBegin,ulLength)

#define IPB_StringBuffer_Replace(This,ulBegin,ulLength,pInserted)	\
    (This)->lpVtbl -> Replace(This,ulBegin,ulLength,pInserted)

#define IPB_StringBuffer_ToUpper(This)	\
    (This)->lpVtbl -> ToUpper(This)

#define IPB_StringBuffer_ToLower(This)	\
    (This)->lpVtbl -> ToLower(This)

#define IPB_StringBuffer_Trim(This,charToTrim,iTrimDirection)	\
    (This)->lpVtbl -> Trim(This,charToTrim,iTrimDirection)

#define IPB_StringBuffer_Pos(This,ulStart,pString,ulIndex)	\
    (This)->lpVtbl -> Pos(This,ulStart,pString,ulIndex)

#define IPB_StringBuffer_SetFromChars(This,pChars)	\
    (This)->lpVtbl -> SetFromChars(This,pChars)

#define IPB_StringBuffer_SetFromString(This,pString)	\
    (This)->lpVtbl -> SetFromString(This,pString)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IPB_StringBuffer_Clone_Proxy(
			IPB_StringBuffer* This,
			/* [out] */ IPB_StringBuffer** ppString);


		void __RPC_STUB IPB_StringBuffer_Clone_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_StringBuffer_GetValue_Proxy(
			IPB_StringBuffer* This,
			/* [out] */ LPTSTR* ppValue);


		void __RPC_STUB IPB_StringBuffer_GetValue_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_StringBuffer_GetLength_Proxy(
			IPB_StringBuffer* This,
			/* [out] */ ULONG* pulLength);


		void __RPC_STUB IPB_StringBuffer_GetLength_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_StringBuffer_CompareTo_Proxy(
			IPB_StringBuffer* This,
			/* [in] */ IPB_StringBuffer* pString,
			/* [out] */ PB_Relational* piComparison);


		void __RPC_STUB IPB_StringBuffer_CompareTo_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_StringBuffer_CompareToIgnoreCase_Proxy(
			IPB_StringBuffer* This,
			/* [in] */ IPB_StringBuffer* pString,
			/* [out] */ PB_Relational* piComparison);


		void __RPC_STUB IPB_StringBuffer_CompareToIgnoreCase_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_StringBuffer_GetCharAt_Proxy(
			IPB_StringBuffer* This,
			/* [in] */ ULONG ulOffset,
			/* [out] */ TCHAR* pChar);


		void __RPC_STUB IPB_StringBuffer_GetCharAt_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_StringBuffer_SetCharAt_Proxy(
			IPB_StringBuffer* This,
			/* [in] */ ULONG ulOffset,
			/* [in] */ TCHAR theChar);


		void __RPC_STUB IPB_StringBuffer_SetCharAt_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_StringBuffer_SubString_Proxy(
			IPB_StringBuffer* This,
			/* [in] */ ULONG ulFrom,
			/* [in] */ ULONG ulLength,
			/* [out] */ IPB_String** ppSubString);


		void __RPC_STUB IPB_StringBuffer_SubString_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_StringBuffer_Concat_Proxy(
			IPB_StringBuffer* This,
			/* [in] */ IPB_String* pStringToAppend);


		void __RPC_STUB IPB_StringBuffer_Concat_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_StringBuffer_InsertAt_Proxy(
			IPB_StringBuffer* This,
			/* [in] */ ULONG ulOffset,
			/* [in] */ IPB_String* pStringToInsert);


		void __RPC_STUB IPB_StringBuffer_InsertAt_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_StringBuffer_Delete_Proxy(
			IPB_StringBuffer* This,
			/* [in] */ ULONG ulBegin,
			/* [in] */ ULONG ulLength);


		void __RPC_STUB IPB_StringBuffer_Delete_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_StringBuffer_Replace_Proxy(
			IPB_StringBuffer* This,
			/* [in] */ ULONG ulBegin,
			/* [in] */ ULONG ulLength,
			/* [in] */ IPB_String* pInserted);


		void __RPC_STUB IPB_StringBuffer_Replace_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_StringBuffer_ToUpper_Proxy(
			IPB_StringBuffer* This);


		void __RPC_STUB IPB_StringBuffer_ToUpper_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_StringBuffer_ToLower_Proxy(
			IPB_StringBuffer* This);


		void __RPC_STUB IPB_StringBuffer_ToLower_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_StringBuffer_Trim_Proxy(
			IPB_StringBuffer* This,
			/* [in] */ TCHAR charToTrim,
			/* [in] */ PB_TrimDir iTrimDirection);


		void __RPC_STUB IPB_StringBuffer_Trim_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_StringBuffer_Pos_Proxy(
			IPB_StringBuffer* This,
			/* [in] */ ULONG ulStart,
			/* [in] */ IPB_String* pString,
			/* [out] */ ULONG* ulIndex);


		void __RPC_STUB IPB_StringBuffer_Pos_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_StringBuffer_SetFromChars_Proxy(
			IPB_StringBuffer* This,
			/* [in] */ TCHAR* pChars);


		void __RPC_STUB IPB_StringBuffer_SetFromChars_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_StringBuffer_SetFromString_Proxy(
			IPB_StringBuffer* This,
			/* [in] */ IPB_String* pString);


		void __RPC_STUB IPB_StringBuffer_SetFromString_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IPB_StringBuffer_INTERFACE_DEFINED__ */


#ifndef __IPB_ConvBlob_INTERFACE_DEFINED__
#define __IPB_ConvBlob_INTERFACE_DEFINED__

		/* interface IPB_ConvBlob */
		/* [unique][uuid][object][local] */

		typedef /* [unique] */ IPB_ConvBlob* LPPBCONVBLOB;


		EXTERN_C const IID IID_IPB_ConvBlob;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("5CEEEEB2-6118-11d1-9E97-0000F8778DC6")
			IPB_ConvBlob : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE GetAsBlob(
				/* [out] */ IPB_Blob * *ppBlob) = 0;

		};

#else 	/* C style interface */

		typedef struct IPB_ConvBlobVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IPB_ConvBlob* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IPB_ConvBlob* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IPB_ConvBlob* This);

			HRESULT(STDMETHODCALLTYPE* GetAsBlob)(
				IPB_ConvBlob* This,
				/* [out] */ IPB_Blob** ppBlob);

			END_INTERFACE
		} IPB_ConvBlobVtbl;

		interface IPB_ConvBlob
		{
			CONST_VTBL struct IPB_ConvBlobVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IPB_ConvBlob_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_ConvBlob_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_ConvBlob_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_ConvBlob_GetAsBlob(This,ppBlob)	\
    (This)->lpVtbl -> GetAsBlob(This,ppBlob)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IPB_ConvBlob_GetAsBlob_Proxy(
			IPB_ConvBlob* This,
			/* [out] */ IPB_Blob** ppBlob);


		void __RPC_STUB IPB_ConvBlob_GetAsBlob_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IPB_ConvBlob_INTERFACE_DEFINED__ */


#ifndef __IPB_ConvString_INTERFACE_DEFINED__
#define __IPB_ConvString_INTERFACE_DEFINED__

		/* interface IPB_ConvString */
		/* [unique][uuid][object][local] */

		typedef /* [unique] */ IPB_ConvString* LPPBCONVSTRING;


		EXTERN_C const IID IID_IPB_ConvString;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("5CEEEEB3-6118-11d1-9E97-0000F8778DC6")
			IPB_ConvString : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE GetAsString(
				/* [out] */ IPB_String * *ppString) = 0;

		};

#else 	/* C style interface */

		typedef struct IPB_ConvStringVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IPB_ConvString* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IPB_ConvString* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IPB_ConvString* This);

			HRESULT(STDMETHODCALLTYPE* GetAsString)(
				IPB_ConvString* This,
				/* [out] */ IPB_String** ppString);

			END_INTERFACE
		} IPB_ConvStringVtbl;

		interface IPB_ConvString
		{
			CONST_VTBL struct IPB_ConvStringVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IPB_ConvString_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_ConvString_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_ConvString_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_ConvString_GetAsString(This,ppString)	\
    (This)->lpVtbl -> GetAsString(This,ppString)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IPB_ConvString_GetAsString_Proxy(
			IPB_ConvString* This,
			/* [out] */ IPB_String** ppString);


		void __RPC_STUB IPB_ConvString_GetAsString_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IPB_ConvString_INTERFACE_DEFINED__ */


#ifndef __IPB_Date_INTERFACE_DEFINED__
#define __IPB_Date_INTERFACE_DEFINED__

		/* interface IPB_Date */
		/* [unique][uuid][object][local] */

		typedef /* [unique] */ IPB_Date* LPPBDATE;


		EXTERN_C const IID IID_IPB_Date;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("5CEEEEB7-6118-11d1-9E97-0000F8778DC6")
			IPB_Date : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE CompareTo(
				/* [in] */ IPB_Date * pDate,
				/* [out] */ PB_Relational * pComparison) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetYear(
				/* [out] */ ULONG* pulYear) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetMonth(
				/* [out] */ ULONG* pulMonth) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetDayOfMonth(
				/* [out] */ ULONG* pulDay) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetDayOfWeek(
				/* [out] */ ULONG* pulDay) = 0;

			virtual HRESULT STDMETHODCALLTYPE Elapsed(
				/* [in] */ IPB_Date* pDate,
				/* [in] */ PB_DateTimeFields iFlag,
				/* [out] */ LONG* plElapsed) = 0;

			virtual HRESULT STDMETHODCALLTYPE Increment(
				/* [in] */ PB_DateTimeFields iFlag,
				/* [out] */ IPB_Date** ppDate,
				/* [in] */ LONG lIncrement) = 0;

		};

#else 	/* C style interface */

		typedef struct IPB_DateVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IPB_Date* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IPB_Date* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IPB_Date* This);

			HRESULT(STDMETHODCALLTYPE* CompareTo)(
				IPB_Date* This,
				/* [in] */ IPB_Date* pDate,
				/* [out] */ PB_Relational* pComparison);

			HRESULT(STDMETHODCALLTYPE* GetYear)(
				IPB_Date* This,
				/* [out] */ ULONG* pulYear);

			HRESULT(STDMETHODCALLTYPE* GetMonth)(
				IPB_Date* This,
				/* [out] */ ULONG* pulMonth);

			HRESULT(STDMETHODCALLTYPE* GetDayOfMonth)(
				IPB_Date* This,
				/* [out] */ ULONG* pulDay);

			HRESULT(STDMETHODCALLTYPE* GetDayOfWeek)(
				IPB_Date* This,
				/* [out] */ ULONG* pulDay);

			HRESULT(STDMETHODCALLTYPE* Elapsed)(
				IPB_Date* This,
				/* [in] */ IPB_Date* pDate,
				/* [in] */ PB_DateTimeFields iFlag,
				/* [out] */ LONG* plElapsed);

			HRESULT(STDMETHODCALLTYPE* Increment)(
				IPB_Date* This,
				/* [in] */ PB_DateTimeFields iFlag,
				/* [out] */ IPB_Date** ppDate,
				/* [in] */ LONG lIncrement);

			END_INTERFACE
		} IPB_DateVtbl;

		interface IPB_Date
		{
			CONST_VTBL struct IPB_DateVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IPB_Date_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_Date_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_Date_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_Date_CompareTo(This,pDate,pComparison)	\
    (This)->lpVtbl -> CompareTo(This,pDate,pComparison)

#define IPB_Date_GetYear(This,pulYear)	\
    (This)->lpVtbl -> GetYear(This,pulYear)

#define IPB_Date_GetMonth(This,pulMonth)	\
    (This)->lpVtbl -> GetMonth(This,pulMonth)

#define IPB_Date_GetDayOfMonth(This,pulDay)	\
    (This)->lpVtbl -> GetDayOfMonth(This,pulDay)

#define IPB_Date_GetDayOfWeek(This,pulDay)	\
    (This)->lpVtbl -> GetDayOfWeek(This,pulDay)

#define IPB_Date_Elapsed(This,pDate,iFlag,plElapsed)	\
    (This)->lpVtbl -> Elapsed(This,pDate,iFlag,plElapsed)

#define IPB_Date_Increment(This,iFlag,ppDate,lIncrement)	\
    (This)->lpVtbl -> Increment(This,iFlag,ppDate,lIncrement)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IPB_Date_CompareTo_Proxy(
			IPB_Date* This,
			/* [in] */ IPB_Date* pDate,
			/* [out] */ PB_Relational* pComparison);


		void __RPC_STUB IPB_Date_CompareTo_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Date_GetYear_Proxy(
			IPB_Date* This,
			/* [out] */ ULONG* pulYear);


		void __RPC_STUB IPB_Date_GetYear_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Date_GetMonth_Proxy(
			IPB_Date* This,
			/* [out] */ ULONG* pulMonth);


		void __RPC_STUB IPB_Date_GetMonth_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Date_GetDayOfMonth_Proxy(
			IPB_Date* This,
			/* [out] */ ULONG* pulDay);


		void __RPC_STUB IPB_Date_GetDayOfMonth_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Date_GetDayOfWeek_Proxy(
			IPB_Date* This,
			/* [out] */ ULONG* pulDay);


		void __RPC_STUB IPB_Date_GetDayOfWeek_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Date_Elapsed_Proxy(
			IPB_Date* This,
			/* [in] */ IPB_Date* pDate,
			/* [in] */ PB_DateTimeFields iFlag,
			/* [out] */ LONG* plElapsed);


		void __RPC_STUB IPB_Date_Elapsed_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Date_Increment_Proxy(
			IPB_Date* This,
			/* [in] */ PB_DateTimeFields iFlag,
			/* [out] */ IPB_Date** ppDate,
			/* [in] */ LONG lIncrement);


		void __RPC_STUB IPB_Date_Increment_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IPB_Date_INTERFACE_DEFINED__ */


#ifndef __IPB_Time_INTERFACE_DEFINED__
#define __IPB_Time_INTERFACE_DEFINED__

		/* interface IPB_Time */
		/* [unique][uuid][object][local] */

		typedef /* [unique] */ IPB_Time* LPPBTIME;


		EXTERN_C const IID IID_IPB_Time;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("5CEEEEB8-6118-11d1-9E97-0000F8778DC6")
			IPB_Time : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE CompareTo(
				/* [in] */ IPB_Time * pTime,
				/* [out] */ PB_Relational * pComparison) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetHour(
				/* [out] */ ULONG* pulHour) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetMinute(
				/* [out] */ ULONG* pulMinute) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetSecond(
				/* [out] */ ULONG* pulSecond) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetMicrosecond(
				/* [out] */ ULONG* ulMicroseconds) = 0;

			virtual HRESULT STDMETHODCALLTYPE Elapsed(
				/* [in] */ IPB_Time* pTime,
				/* [in] */ PB_DateTimeFields iFlag,
				/* [out] */ LONG* plElapsed) = 0;

			virtual HRESULT STDMETHODCALLTYPE Increment(
				/* [in] */ PB_DateTimeFields iFlag,
				/* [out] */ IPB_Time** ppTime,
				/* [in] */ LONG lIncrement) = 0;

		};

#else 	/* C style interface */

		typedef struct IPB_TimeVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IPB_Time* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IPB_Time* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IPB_Time* This);

			HRESULT(STDMETHODCALLTYPE* CompareTo)(
				IPB_Time* This,
				/* [in] */ IPB_Time* pTime,
				/* [out] */ PB_Relational* pComparison);

			HRESULT(STDMETHODCALLTYPE* GetHour)(
				IPB_Time* This,
				/* [out] */ ULONG* pulHour);

			HRESULT(STDMETHODCALLTYPE* GetMinute)(
				IPB_Time* This,
				/* [out] */ ULONG* pulMinute);

			HRESULT(STDMETHODCALLTYPE* GetSecond)(
				IPB_Time* This,
				/* [out] */ ULONG* pulSecond);

			HRESULT(STDMETHODCALLTYPE* GetMicrosecond)(
				IPB_Time* This,
				/* [out] */ ULONG* ulMicroseconds);

			HRESULT(STDMETHODCALLTYPE* Elapsed)(
				IPB_Time* This,
				/* [in] */ IPB_Time* pTime,
				/* [in] */ PB_DateTimeFields iFlag,
				/* [out] */ LONG* plElapsed);

			HRESULT(STDMETHODCALLTYPE* Increment)(
				IPB_Time* This,
				/* [in] */ PB_DateTimeFields iFlag,
				/* [out] */ IPB_Time** ppTime,
				/* [in] */ LONG lIncrement);

			END_INTERFACE
		} IPB_TimeVtbl;

		interface IPB_Time
		{
			CONST_VTBL struct IPB_TimeVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IPB_Time_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_Time_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_Time_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_Time_CompareTo(This,pTime,pComparison)	\
    (This)->lpVtbl -> CompareTo(This,pTime,pComparison)

#define IPB_Time_GetHour(This,pulHour)	\
    (This)->lpVtbl -> GetHour(This,pulHour)

#define IPB_Time_GetMinute(This,pulMinute)	\
    (This)->lpVtbl -> GetMinute(This,pulMinute)

#define IPB_Time_GetSecond(This,pulSecond)	\
    (This)->lpVtbl -> GetSecond(This,pulSecond)

#define IPB_Time_GetMicrosecond(This,ulMicroseconds)	\
    (This)->lpVtbl -> GetMicrosecond(This,ulMicroseconds)

#define IPB_Time_Elapsed(This,pTime,iFlag,plElapsed)	\
    (This)->lpVtbl -> Elapsed(This,pTime,iFlag,plElapsed)

#define IPB_Time_Increment(This,iFlag,ppTime,lIncrement)	\
    (This)->lpVtbl -> Increment(This,iFlag,ppTime,lIncrement)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IPB_Time_CompareTo_Proxy(
			IPB_Time* This,
			/* [in] */ IPB_Time* pTime,
			/* [out] */ PB_Relational* pComparison);


		void __RPC_STUB IPB_Time_CompareTo_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Time_GetHour_Proxy(
			IPB_Time* This,
			/* [out] */ ULONG* pulHour);


		void __RPC_STUB IPB_Time_GetHour_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Time_GetMinute_Proxy(
			IPB_Time* This,
			/* [out] */ ULONG* pulMinute);


		void __RPC_STUB IPB_Time_GetMinute_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Time_GetSecond_Proxy(
			IPB_Time* This,
			/* [out] */ ULONG* pulSecond);


		void __RPC_STUB IPB_Time_GetSecond_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Time_GetMicrosecond_Proxy(
			IPB_Time* This,
			/* [out] */ ULONG* ulMicroseconds);


		void __RPC_STUB IPB_Time_GetMicrosecond_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Time_Elapsed_Proxy(
			IPB_Time* This,
			/* [in] */ IPB_Time* pTime,
			/* [in] */ PB_DateTimeFields iFlag,
			/* [out] */ LONG* plElapsed);


		void __RPC_STUB IPB_Time_Elapsed_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_Time_Increment_Proxy(
			IPB_Time* This,
			/* [in] */ PB_DateTimeFields iFlag,
			/* [out] */ IPB_Time** ppTime,
			/* [in] */ LONG lIncrement);


		void __RPC_STUB IPB_Time_Increment_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IPB_Time_INTERFACE_DEFINED__ */


#ifndef __IPB_DateTime_INTERFACE_DEFINED__
#define __IPB_DateTime_INTERFACE_DEFINED__

		/* interface IPB_DateTime */
		/* [unique][uuid][object][local] */

		typedef /* [unique] */ IPB_DateTime* LPPBDATETIME;


		EXTERN_C const IID IID_IPB_DateTime;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("5CEEEEB6-6118-11d1-9E97-0000F8778DC6")
			IPB_DateTime : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE CompareTo(
				/* [in] */ IPB_DateTime * pDateTime,
				/* [out] */ PB_Relational * pComparison) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetDate(
				/* [out] */ IPB_Date** ppDate) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetTime(
				/* [out] */ IPB_Time** ppTime) = 0;

			virtual HRESULT STDMETHODCALLTYPE Elapsed(
				/* [in] */ IPB_DateTime* pDateTime,
				/* [in] */ PB_DateTimeFields iFlag,
				/* [out] */ LONG* plElapsed) = 0;

			virtual HRESULT STDMETHODCALLTYPE Increment(
				/* [in] */ PB_DateTimeFields iFlag,
				/* [out] */ IPB_DateTime** ppDateTime,
				/* [in] */ LONG lIncrement) = 0;

		};

#else 	/* C style interface */

		typedef struct IPB_DateTimeVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IPB_DateTime* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IPB_DateTime* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IPB_DateTime* This);

			HRESULT(STDMETHODCALLTYPE* CompareTo)(
				IPB_DateTime* This,
				/* [in] */ IPB_DateTime* pDateTime,
				/* [out] */ PB_Relational* pComparison);

			HRESULT(STDMETHODCALLTYPE* GetDate)(
				IPB_DateTime* This,
				/* [out] */ IPB_Date** ppDate);

			HRESULT(STDMETHODCALLTYPE* GetTime)(
				IPB_DateTime* This,
				/* [out] */ IPB_Time** ppTime);

			HRESULT(STDMETHODCALLTYPE* Elapsed)(
				IPB_DateTime* This,
				/* [in] */ IPB_DateTime* pDateTime,
				/* [in] */ PB_DateTimeFields iFlag,
				/* [out] */ LONG* plElapsed);

			HRESULT(STDMETHODCALLTYPE* Increment)(
				IPB_DateTime* This,
				/* [in] */ PB_DateTimeFields iFlag,
				/* [out] */ IPB_DateTime** ppDateTime,
				/* [in] */ LONG lIncrement);

			END_INTERFACE
		} IPB_DateTimeVtbl;

		interface IPB_DateTime
		{
			CONST_VTBL struct IPB_DateTimeVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IPB_DateTime_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_DateTime_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_DateTime_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_DateTime_CompareTo(This,pDateTime,pComparison)	\
    (This)->lpVtbl -> CompareTo(This,pDateTime,pComparison)

#define IPB_DateTime_GetDate(This,ppDate)	\
    (This)->lpVtbl -> GetDate(This,ppDate)

#define IPB_DateTime_GetTime(This,ppTime)	\
    (This)->lpVtbl -> GetTime(This,ppTime)

#define IPB_DateTime_Elapsed(This,pDateTime,iFlag,plElapsed)	\
    (This)->lpVtbl -> Elapsed(This,pDateTime,iFlag,plElapsed)

#define IPB_DateTime_Increment(This,iFlag,ppDateTime,lIncrement)	\
    (This)->lpVtbl -> Increment(This,iFlag,ppDateTime,lIncrement)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IPB_DateTime_CompareTo_Proxy(
			IPB_DateTime* This,
			/* [in] */ IPB_DateTime* pDateTime,
			/* [out] */ PB_Relational* pComparison);


		void __RPC_STUB IPB_DateTime_CompareTo_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_DateTime_GetDate_Proxy(
			IPB_DateTime* This,
			/* [out] */ IPB_Date** ppDate);


		void __RPC_STUB IPB_DateTime_GetDate_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_DateTime_GetTime_Proxy(
			IPB_DateTime* This,
			/* [out] */ IPB_Time** ppTime);


		void __RPC_STUB IPB_DateTime_GetTime_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_DateTime_Elapsed_Proxy(
			IPB_DateTime* This,
			/* [in] */ IPB_DateTime* pDateTime,
			/* [in] */ PB_DateTimeFields iFlag,
			/* [out] */ LONG* plElapsed);


		void __RPC_STUB IPB_DateTime_Elapsed_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_DateTime_Increment_Proxy(
			IPB_DateTime* This,
			/* [in] */ PB_DateTimeFields iFlag,
			/* [out] */ IPB_DateTime** ppDateTime,
			/* [in] */ LONG lIncrement);


		void __RPC_STUB IPB_DateTime_Increment_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IPB_DateTime_INTERFACE_DEFINED__ */


		/* interface __MIDL_itf_pbtypes_0017 */
		/* [local] */


#define PB_DEC_MAX_PRECISION 30ul

#ifdef __cplusplus
		extern "C" {
#endif
			//Declare Creation Functions
			PBWINAPI(HRESULT, CreateStringBuffer)(IPB_StringBuffer**);
			PBWINAPI(HRESULT, CreateStringBufferFromLPTSTR)(LPTSTR lpszString, IPB_StringBuffer**);

			PBWINAPI(HRESULT, CreateString)(LPTSTR lpszString, IPB_String**);

			PBWINAPI(HRESULT, CreateBlob)(IPB_Blob**);
			PBWINAPI(HRESULT, CreateBlobWithSize)(ULONG ulSize, IPB_Blob**);
			PBWINAPI(HRESULT, CreateBlobFromBytes)(BYTE* pData, ULONG ulSize, IPB_Blob**);
			PBWINAPI(HRESULT, CreateBlobFromLPTSTR)(LPTSTR lpszData, IPB_Blob**);

			PBWINAPI(HRESULT, CreateDecimal)(IPB_Decimal**);
			PBWINAPI(HRESULT, CreateDecimalFromPSH_DEC)(PSH_DEC pdecVal, IPB_Decimal**);
			PBWINAPI(HRESULT, CreateDecimalFromLong)(long lInital, IPB_Decimal**);
			PBWINAPI(HRESULT, CreateDecimalFromDouble)(double dInitial, IPB_Decimal**);
			PBWINAPI(HRESULT, CreateDecimalFromLPTSTR)(LPTSTR lpszInitial, IPB_Decimal**);
			PBWINAPI(HRESULT, CopyDecimalToPSH_DEC)(IPB_Decimal*, PSH_DEC pdecVal);

			PBWINAPI(HRESULT, CreateDateTimeFromLPTSTR)(LPTSTR lpszString, IPB_DateTime**);
			PBWINAPI(HRESULT, CreateDateTimeFromString)(IPB_String* pString, IPB_DateTime**);
			PBWINAPI(HRESULT, CreateDateTimeFromPSH_TIME)(PSH_TIME pDTime, IPB_DateTime**);
			PBWINAPI(HRESULT, CopyDateTimeToPSH_TIME)(IPB_DateTime*, PSH_TIME pDTime);

			PBWINAPI(HRESULT, CreateDateFromLPTSTR)(LPTSTR lpszString, IPB_Date**);
			PBWINAPI(HRESULT, CreateDateFromString)(IPB_String* pString, IPB_Date**);
			PBWINAPI(HRESULT, CreateDateFromPSH_TIME)(PSH_TIME pDTime, IPB_Date**);
			PBWINAPI(HRESULT, CopyDateToPSH_TIME)(IPB_Date*, PSH_TIME pDTime);

			PBWINAPI(HRESULT, CreateTimeFromLPTSTR)(LPTSTR lpszString, IPB_Time**);
			PBWINAPI(HRESULT, CreateTimeFromString)(IPB_String* pString, IPB_Time**);
			PBWINAPI(HRESULT, CreateTimeFromPSH_TIME)(PSH_TIME pDTime, IPB_Time**);
			PBWINAPI(HRESULT, CopyTimeToPSH_TIME)(IPB_Time*, PSH_TIME pDTime);

#ifdef __cplusplus
		}; // extern "C"
#endif


		extern RPC_IF_HANDLE __MIDL_itf_pbtypes_0017_v0_0_c_ifspec;
		extern RPC_IF_HANDLE __MIDL_itf_pbtypes_0017_v0_0_s_ifspec;

		/* Additional Prototypes for ALL interfaces */

		/* end of Additional Prototypes */

#ifdef __cplusplus
	}
#endif

#endif


	// DOINC popped back into header 'pbprop.h'

#ifdef __cplusplus
	extern "C" {
#endif 

		void* __RPC_USER MIDL_user_allocate(size_t);
		void __RPC_USER MIDL_user_free(void*);

		/* interface __MIDL_itf_pbprop_0000 */
		/* [local] */

		//       Copyright Sybase, Inc. 1998
		//
		//   Sybase, Inc. ("Sybase") claims copyright in this
		//   program and documentation as an unpublished work, versions of
		//   which were first licensed on the date indicated in the foregoing
		//   notice.  Claim of copyright does not imply waiver of Sybase's
		//   other rights.


		extern RPC_IF_HANDLE __MIDL_itf_pbprop_0000_v0_0_c_ifspec;
		extern RPC_IF_HANDLE __MIDL_itf_pbprop_0000_v0_0_s_ifspec;

#ifndef __IPB_PropertySet_INTERFACE_DEFINED__
#define __IPB_PropertySet_INTERFACE_DEFINED__

		/* interface IPB_PropertySet */
		/* [unique][uuid][object][local] */


		EXTERN_C const IID IID_IPB_PropertySet;

#if defined(__cplusplus) && !defined(CINTERFACE)

		MIDL_INTERFACE("C025C04B-9402-11d1-9847-0060B01AC697")
			IPB_PropertySet : public IUnknown
		{
		public:
			virtual HRESULT STDMETHODCALLTYPE GetPropertyAsString(
				/* [in] */ IPB_String * pName,
				/* [out] */ IPB_String * *ppValue) = 0;

			virtual HRESULT STDMETHODCALLTYPE SetPropertyAsString(
				/* [in] */ IPB_String* pName,
				/* [in] */ IPB_String* pNewValue) = 0;

			virtual HRESULT STDMETHODCALLTYPE DeleteProperty(
				/* [in] */ IPB_String* pName) = 0;

			virtual HRESULT STDMETHODCALLTYPE Enumerate(
				/* [out] */ IEnumUnknown** ppEnumeration) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetPropertyAsLong(
				/* [in] */ IPB_String* pName,
				/* [out] */ long* pLong) = 0;

			virtual HRESULT STDMETHODCALLTYPE SetPropertyAsLong(
				/* [in] */ IPB_String* pName,
				/* [in] */ long longValue) = 0;

			virtual HRESULT STDMETHODCALLTYPE GetPropertyEditFormat(
				/* [in] */ IPB_String* pName,
				/* [out] */ IPB_String** ppEditFormat) = 0;

			virtual HRESULT STDMETHODCALLTYPE SetPropertyEditFormat(
				/* [in] */ IPB_String* pName,
				/* [in] */ IPB_String* pEditFormat) = 0;

		};

#else 	/* C style interface */

		typedef struct IPB_PropertySetVtbl
		{
			BEGIN_INTERFACE

				HRESULT(STDMETHODCALLTYPE* QueryInterface)(
					IPB_PropertySet* This,
					/* [in] */ REFIID riid,
					/* [iid_is][out] */ void** ppvObject);

			ULONG(STDMETHODCALLTYPE* AddRef)(
				IPB_PropertySet* This);

			ULONG(STDMETHODCALLTYPE* Release)(
				IPB_PropertySet* This);

			HRESULT(STDMETHODCALLTYPE* GetPropertyAsString)(
				IPB_PropertySet* This,
				/* [in] */ IPB_String* pName,
				/* [out] */ IPB_String** ppValue);

			HRESULT(STDMETHODCALLTYPE* SetPropertyAsString)(
				IPB_PropertySet* This,
				/* [in] */ IPB_String* pName,
				/* [in] */ IPB_String* pNewValue);

			HRESULT(STDMETHODCALLTYPE* DeleteProperty)(
				IPB_PropertySet* This,
				/* [in] */ IPB_String* pName);

			HRESULT(STDMETHODCALLTYPE* Enumerate)(
				IPB_PropertySet* This,
				/* [out] */ IEnumUnknown** ppEnumeration);

			HRESULT(STDMETHODCALLTYPE* GetPropertyAsLong)(
				IPB_PropertySet* This,
				/* [in] */ IPB_String* pName,
				/* [out] */ long* pLong);

			HRESULT(STDMETHODCALLTYPE* SetPropertyAsLong)(
				IPB_PropertySet* This,
				/* [in] */ IPB_String* pName,
				/* [in] */ long longValue);

			HRESULT(STDMETHODCALLTYPE* GetPropertyEditFormat)(
				IPB_PropertySet* This,
				/* [in] */ IPB_String* pName,
				/* [out] */ IPB_String** ppEditFormat);

			HRESULT(STDMETHODCALLTYPE* SetPropertyEditFormat)(
				IPB_PropertySet* This,
				/* [in] */ IPB_String* pName,
				/* [in] */ IPB_String* pEditFormat);

			END_INTERFACE
		} IPB_PropertySetVtbl;

		interface IPB_PropertySet
		{
			CONST_VTBL struct IPB_PropertySetVtbl* lpVtbl;
		};



#ifdef COBJMACROS


#define IPB_PropertySet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_PropertySet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_PropertySet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_PropertySet_GetPropertyAsString(This,pName,ppValue)	\
    (This)->lpVtbl -> GetPropertyAsString(This,pName,ppValue)

#define IPB_PropertySet_SetPropertyAsString(This,pName,pNewValue)	\
    (This)->lpVtbl -> SetPropertyAsString(This,pName,pNewValue)

#define IPB_PropertySet_DeleteProperty(This,pName)	\
    (This)->lpVtbl -> DeleteProperty(This,pName)

#define IPB_PropertySet_Enumerate(This,ppEnumeration)	\
    (This)->lpVtbl -> Enumerate(This,ppEnumeration)

#define IPB_PropertySet_GetPropertyAsLong(This,pName,pLong)	\
    (This)->lpVtbl -> GetPropertyAsLong(This,pName,pLong)

#define IPB_PropertySet_SetPropertyAsLong(This,pName,longValue)	\
    (This)->lpVtbl -> SetPropertyAsLong(This,pName,longValue)

#define IPB_PropertySet_GetPropertyEditFormat(This,pName,ppEditFormat)	\
    (This)->lpVtbl -> GetPropertyEditFormat(This,pName,ppEditFormat)

#define IPB_PropertySet_SetPropertyEditFormat(This,pName,pEditFormat)	\
    (This)->lpVtbl -> SetPropertyEditFormat(This,pName,pEditFormat)

#endif /* COBJMACROS */


#endif 	/* C style interface */



		HRESULT STDMETHODCALLTYPE IPB_PropertySet_GetPropertyAsString_Proxy(
			IPB_PropertySet* This,
			/* [in] */ IPB_String* pName,
			/* [out] */ IPB_String** ppValue);


		void __RPC_STUB IPB_PropertySet_GetPropertyAsString_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_PropertySet_SetPropertyAsString_Proxy(
			IPB_PropertySet* This,
			/* [in] */ IPB_String* pName,
			/* [in] */ IPB_String* pNewValue);


		void __RPC_STUB IPB_PropertySet_SetPropertyAsString_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_PropertySet_DeleteProperty_Proxy(
			IPB_PropertySet* This,
			/* [in] */ IPB_String* pName);


		void __RPC_STUB IPB_PropertySet_DeleteProperty_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_PropertySet_Enumerate_Proxy(
			IPB_PropertySet* This,
			/* [out] */ IEnumUnknown** ppEnumeration);


		void __RPC_STUB IPB_PropertySet_Enumerate_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_PropertySet_GetPropertyAsLong_Proxy(
			IPB_PropertySet* This,
			/* [in] */ IPB_String* pName,
			/* [out] */ long* pLong);


		void __RPC_STUB IPB_PropertySet_GetPropertyAsLong_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_PropertySet_SetPropertyAsLong_Proxy(
			IPB_PropertySet* This,
			/* [in] */ IPB_String* pName,
			/* [in] */ long longValue);


		void __RPC_STUB IPB_PropertySet_SetPropertyAsLong_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_PropertySet_GetPropertyEditFormat_Proxy(
			IPB_PropertySet* This,
			/* [in] */ IPB_String* pName,
			/* [out] */ IPB_String** ppEditFormat);


		void __RPC_STUB IPB_PropertySet_GetPropertyEditFormat_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);


		HRESULT STDMETHODCALLTYPE IPB_PropertySet_SetPropertyEditFormat_Proxy(
			IPB_PropertySet* This,
			/* [in] */ IPB_String* pName,
			/* [in] */ IPB_String* pEditFormat);


		void __RPC_STUB IPB_PropertySet_SetPropertyEditFormat_Stub(
			IRpcStubBuffer* This,
			IRpcChannelBuffer* _pRpcChannelBuffer,
			PRPC_MESSAGE _pRpcMessage,
			DWORD* _pdwStubPhase);



#endif 	/* __IPB_PropertySet_INTERFACE_DEFINED__ */


		/* interface __MIDL_itf_pbprop_0106 */
		/* [local] */

		PBWINAPI_(HRESULT) PB_CreatePropertySet(IPB_PropertySet** ppPropertySet);


		extern RPC_IF_HANDLE __MIDL_itf_pbprop_0106_v0_0_c_ifspec;
		extern RPC_IF_HANDLE __MIDL_itf_pbprop_0106_v0_0_s_ifspec;

		/* Additional Prototypes for ALL interfaces */

		/* end of Additional Prototypes */

#ifdef __cplusplus
	}
#endif

#endif


	// DOINC popped back into header 'obproper.h'
#endif

// Property list.
	class OB_PROPERTY_LIST
	{
		friend class OB_PROPERTY_LIST_ITER;

	private:
		// Instance variables.
		POB_THIS		d_obthis;		// obthis growblocks were allocated in.
		PVOID   		d_conpool;		// Constant pool for this property list.
		PSH_GROWBLOCK 	d_nameIds;		// Holds of all of the name const ids
		PSH_GROWBLOCK	d_valueIds;		// Holds of all of the value const ids

		LPTSTR			getNameAt(UINT index);
		LPTSTR			getValueAt(UINT index);

	public:
		OB_PROPERTY_LIST(POB_THIS obthis, PVOID conpool);
		~OB_PROPERTY_LIST();

		// Make it virtual so it can be used across dll's
		virtual PBRESULT	setProperty(LPTSTR name, LPTSTR value);
		LPTSTR		getProperty(LPTSTR name);
		UINT		getNumberOfProperties() { return sh_grwblk_no_entries(d_nameIds); };

		// Methods to allow streaming of the property list.
		PBRESULT	write(POB_THIS obthis);
		PBRESULT	read(POB_THIS obthis);
	};

	typedef class OB_PROPERTY_LIST FAR* POB_PROPERTY_LIST;

	typedef struct ob_property
	{
		LPTSTR	tag;		// The identifier or tag of the property.
		LPTSTR	value;		// The value at that tag.
	} OB_PROPERTY_STRUCT, FAR* POB_PROPERTY;

	// Property list iterator.
	class OB_PROPERTY_LIST_ITER
	{
	private:
		POB_PROPERTY_LIST	d_list;
		UINT				d_current;

	public:
		OB_PROPERTY_LIST_ITER(POB_PROPERTY_LIST propertyList) : d_list(propertyList), d_current(0) {};
		~OB_PROPERTY_LIST_ITER() { };

		// Returns true if there are more items in the list to process.
		BOOL 		hasMore() { return (d_list->getNumberOfProperties() > d_current); };
		PBRESULT	getNext(POB_PROPERTY property);		// Gets the next item in the list.
		VOID		reset() { d_current = 0; };		// Resets the iterator to the first item.
	};

	// Forward declarations:

	typedef class OB_PROPERTY_LIST FAR* POB_PROPERTY_LIST;
	typedef class OB_GROUP_PROPERTIES FAR* POB_GROUP_PROPERTIES;
	typedef class OB_CLASS_PROPERTIES FAR* POB_CLASS_PROPERTIES;
	typedef class OB_FIELD_PROPERTIES FAR* POB_FIELD_PROPERTIES;
	typedef class OB_ROUTINE_PROPERTIES FAR* POB_ROUTINE_PROPERTIES;
	typedef class OB_ROUTINE_ARG_PROPERTIES FAR* POB_ROUTINE_ARG_PROPERTIES;

#define OB_NO_GROUP_PROPS_ON_DISK	((POB_GROUP_PROPERTIES) -1L)

	// Group properties.
	class OB_GROUP_PROPERTIES
	{
	private:	// Instance variables
		POB_THIS				d_obthis;
		POB_GROUP				d_group;				// Group id of this property list.
		PVOID					d_conpool;				// Constant pool used by all group's property lists.
		PSH_GROWBLOCK			d_class_properties;		// Classes in this group that have properties

	private: 	// Methods
		OB_GROUP_PROPERTIES() : d_obthis(NULL), d_group(NULL), d_conpool(NULL), d_class_properties(NULL) {};
		OB_GROUP_PROPERTIES(POB_THIS obthis, POB_GROUP group);
		static POB_GROUP_PROPERTIES loadFromDisk(POB_THIS obthis, POB_GROUP group);
		VOID	initialize();	// Creates the constant pool and growblock

	public:
		// Creates a new group properties object. If one already exists for this group (i.e. 
		// the group->ts.group_properties entry is not NULL or -1), the old one is deleted and 
		// replaced by this new object.
		~OB_GROUP_PROPERTIES();

		static POB_GROUP_PROPERTIES fetch(POB_THIS obthis, POB_GROUP group, BOOL create = FALSE);

		POB_THIS				getObthis() { return d_obthis; };
		POB_GROUP				getGroup() { return d_group; };

		// Get the constant pool for this group property object. (Used by all property objects below it.)
		PVOID					getConPool() { return d_conpool; };

		// Creates a new or overwrites an existing class properties object.
		POB_CLASS_PROPERTIES	createClassProperties(OB_CLASS_ID classID);

		// Get the POB_CLASS_PROPERTIES object for a given class.
		POB_CLASS_PROPERTIES 	getClassProperties(OB_CLASS_ID classID);

		// Methods for streaming this structure to the current object file.
		PBRESULT				write(POB_THIS obthis);
		PBRESULT				read(POB_THIS obthis);
	};


	// Class properties.
	class OB_CLASS_PROPERTIES
	{
	private:
		POB_THIS				d_obthis;
		POB_GROUP_PROPERTIES	d_group_prop;			// The group properties object this belongs to.
		OB_CLASS_ID				d_classID;
		POB_PROPERTY_LIST		d_properties;
		PSH_GROWBLOCK			d_routine_properties;
		PSH_GROWBLOCK			d_field_properties;

	public:
		OB_CLASS_PROPERTIES(POB_GROUP_PROPERTIES groupProp, OB_CLASS_ID classID);
		~OB_CLASS_PROPERTIES();

		// This constructor creates a new OB_CLASS_PROPERTIES object. It will add it to the 
		// groups class properties list or replace the existing entry for this class. This 
		// constructor is similar to the one above but doesn the lookup and creation 
		// (if necessary) of the OB_GROUP_PROPERTIES object.
		static POB_CLASS_PROPERTIES fetch(POB_THIS obthis, POB_GROUP group, OB_CLASS_ID classID, BOOL create = FALSE);

		POB_THIS				getObthis() { return d_obthis; };
		POB_GROUP_PROPERTIES	getGroupProperties() { return d_group_prop; };
		OB_CLASS_ID 			getClassID() { return d_classID; };
		POB_PROPERTY_LIST		getProperties() { return d_properties; };
		PBRESULT				setProperty(LPTSTR name, LPTSTR value) { return d_properties->setProperty(name, value); };
		LPTSTR					getProperty(LPTSTR name) { return d_properties->getProperty(name); };

		POB_ROUTINE_PROPERTIES	createRoutineProperties(OB_VTABLE_ID vtableID);
		POB_ROUTINE_PROPERTIES	getRoutineProperties(OB_VTABLE_ID vtableID);

		POB_FIELD_PROPERTIES	createFieldProperties(ULONG fieldID);
		POB_FIELD_PROPERTIES	getFieldProperties(ULONG fieldID);

		// Methods for streaming this structure to the current object file.
		PBRESULT	write(POB_THIS obthis);
		PBRESULT	read(POB_THIS obthis);
	};

	// Field properties. Maintained by class properties.
	class OB_FIELD_PROPERTIES
	{
	private:
		POB_THIS				d_obthis;
		POB_CLASS_PROPERTIES	d_classProp;	// The OB_CLASS_PROPERTIES object this belongs to.
		ULONG					d_fieldID;
		POB_PROPERTY_LIST		d_properties;

	public:
		OB_FIELD_PROPERTIES(POB_CLASS_PROPERTIES classProp, ULONG fieldID);
		~OB_FIELD_PROPERTIES() { delete d_properties; };

		// Creates a new field property object, adding it to the classes field property list
		// or replacing the existing entry for this field.
		static POB_FIELD_PROPERTIES fetch(POB_THIS obthis, POB_GROUP group, OB_CLASS_ID classID, ULONG fieldID, BOOL create = FALSE);

		POB_THIS				getObthis() { return d_obthis; };
		POB_CLASS_PROPERTIES	getClassProperties() { return d_classProp; };
		ULONG 					getFieldID() { return d_fieldID; };
		POB_PROPERTY_LIST		getProperties() { return d_properties; };
		PBRESULT				setProperty(LPTSTR name, LPTSTR value) { return d_properties->setProperty(name, value); };
		LPTSTR					getProperty(LPTSTR name) { return ((d_properties == NULL) ? NULL : d_properties->getProperty(name)); };

		// Methods for streaming this structure to the current object file.
		PBRESULT	write(POB_THIS obthis);
		PBRESULT	read(POB_THIS obthis);
	};


	class OB_ROUTINE_PROPERTIES
	{
	private:
		POB_THIS					d_obthis;
		POB_CLASS_PROPERTIES		d_classProp;	// The OB_CLASS_PROPERTIES object this belongs to.
		OB_VTABLE_ID				d_vtableID;
		POB_PROPERTY_LIST			d_properties;
		PSH_GROWBLOCK				d_arg_properties;

	public:
		// This constructor does not add the newly created object to it's class's routine properties list.
		// It should only be used to create a standalone routine properties object not associated with a class.
		OB_ROUTINE_PROPERTIES(POB_CLASS_PROPERTIES classProp, OB_VTABLE_ID vtableID);
		~OB_ROUTINE_PROPERTIES();

		// Creates a new routine property object, adding it to the classes routine property list
		// or replacing the existing entry for this routine.
		static POB_ROUTINE_PROPERTIES fetch(POB_THIS obthis, POB_GROUP group, OB_CLASS_ID classID, OB_VTABLE_ID vtableID, BOOL create = FALSE);

		POB_THIS				getObthis() { return d_obthis; };
		POB_CLASS_PROPERTIES 	getClassProperties() { return d_classProp; };
		OB_VTABLE_ID			getVtableID() { return d_vtableID; };
		POB_PROPERTY_LIST		getProperties() { return d_properties; };
		PBRESULT				setProperty(LPTSTR name, LPTSTR value) { return d_properties->setProperty(name, value); };
		LPTSTR					getProperty(LPTSTR name) { return ((d_properties == NULL) ? NULL : d_properties->getProperty(name)); };

		POB_ROUTINE_ARG_PROPERTIES	createArgProperties(UINT argID);
		POB_ROUTINE_ARG_PROPERTIES	getArgProperties(UINT argID);

		// Methods for streaming this structure to the current object file.
		PBRESULT	write(POB_THIS obthis);
		PBRESULT	read(POB_THIS obthis);
	};

	class OB_ROUTINE_ARG_PROPERTIES
	{
	private:
		POB_THIS				d_obthis;
		POB_ROUTINE_PROPERTIES	d_routine_props; 	// The routine properties object this belongs to.
		UINT					d_argID;
		POB_PROPERTY_LIST		d_properties;

	public:
		// This constructor does not add the newly created object to it's routine's arg properties list.
		// It should only be used to create a standalone arg properties object not associated with a routine.
		OB_ROUTINE_ARG_PROPERTIES(POB_ROUTINE_PROPERTIES routineProps, UINT argID);
		~OB_ROUTINE_ARG_PROPERTIES() { delete d_properties; };

		// Creates a new routine arg propert object, adding it to the routine's arg property list
		// or replacing the existing entry for this argument.
		static POB_ROUTINE_ARG_PROPERTIES fetch(POB_THIS obthis, POB_GROUP group, OB_CLASS_ID classID, OB_VTABLE_ID vtableID, UINT argID, BOOL create = FALSE);

		POB_THIS				getObthis() { return d_obthis; };
		UINT 					getArgID() { return d_argID; };
		POB_PROPERTY_LIST		getProperties() { return d_properties; };
		PBRESULT				setProperty(LPTSTR name, LPTSTR value) { return d_properties->setProperty(name, value); };
		LPTSTR					getProperty(LPTSTR name) { return ((d_properties == NULL) ? NULL : d_properties->getProperty(name)); };

		// Methods for streaming this structure to the current object file.
		PBRESULT	write(POB_THIS obthis);
		PBRESULT	read(POB_THIS obthis);
	};

#endif // __cplusplus

	// C interface to above routines.

#ifdef __cplusplus
	extern "C" {
#endif

		// Returns the value of a classes property if defined, NULL otherwise.
		// The string returned is owned by the routine and should be duplicated by the user if necessary.
		PBWINAPI(LPTSTR, ob_get_class_property)
			(
				POB_THIS		obthis,
				OB_CLASS_HNDL	classHndl,
				LPTSTR			property
				);

		// Returns the value of the field's property if defined, NULL otherwise.
		// The string returned is owned by the routine and should be duplicated by the user if necessary.
		PBWINAPI(LPTSTR, ob_get_field_property)
			(
				POB_THIS		obthis,
				OB_CLASS_HNDL	classHndl,
				ULONG			fieldId,
				LPTSTR			property
				);

		// Returns the value of the routine's property if defined, NULL otherwise.
		// The string returned is owned by the routine and should be duplicated by the user if necessary.
		PBWINAPI(LPTSTR, ob_get_routine_property)
			(
				POB_THIS		obthis,
				OB_CLASS_HNDL	classHndl,
				OB_VTABLE_ID	vtableID,
				LPTSTR			property
				);

		// Returns the value of the routine arguments's property if defined, NULL otherwise.
		// The string returned is owned by the routine and should be duplicated by the user if necessary.
		PBWINAPI(LPTSTR, ob_get_routine_arg_property)
			(
				POB_THIS		obthis,
				OB_CLASS_HNDL	classHndl,
				OB_VTABLE_ID	vtableID,
				UINT			argID,
				LPTSTR			property
				);


#ifdef __cplusplus
		PBWINAPI(POB_CLASS_PROPERTIES, ob_create_class_properties)
			(
				POB_THIS obthis,
				POB_GROUP group,
				OB_CLASS_ID classID
				);

		PBWINAPI(POB_FIELD_PROPERTIES, ob_create_field_properties)
			(
				POB_THIS obthis,
				POB_GROUP group,
				OB_CLASS_ID classID,
				ULONG fieldID
				);

		PBWINAPI(POB_ROUTINE_PROPERTIES, ob_create_routine_properties)
			(
				POB_THIS obthis,
				POB_GROUP group,
				OB_CLASS_ID classID,
				OB_VTABLE_ID vtableID
				);

		PBWINAPI(POB_ROUTINE_ARG_PROPERTIES, ob_create_routine_arg_properties)
			(
				POB_THIS obthis,
				POB_GROUP group,
				OB_CLASS_ID classID,
				OB_VTABLE_ID vtableID,
				UINT argID
				);

		PBWINAPI(HRESULT, ob_get_class_property_set)
			(
				POB_THIS 			obthis,
				OB_CLASS_HNDL		classHndl,
				IPB_PropertySet* pPropertySet
				);

		PBWINAPI(HRESULT, ob_get_field_property_set)
			(
				POB_THIS			obthis,
				OB_CLASS_HNDL		classHndl,
				ULONG				fieldId,
				IPB_PropertySet* pPropertySet
				);

		PBWINAPI(HRESULT, ob_get_routine_property_set)
			(
				POB_THIS			obthis,
				OB_CLASS_HNDL		classHndl,
				OB_VTABLE_ID		vtableID,
				IPB_PropertySet* pPropertySet
				);

		PBWINAPI(HRESULT, ob_get_routine_arg_property_set)
			(
				POB_THIS			obthis,
				OB_CLASS_HNDL		classHndl,
				OB_VTABLE_ID		vtableID,
				UINT				argID,
				IPB_PropertySet* pPropertySet
				);

#endif // __cplusplus

#ifdef __cplusplus
	} // extern "C" {
#endif
#else
#define OB_GROUP_PROPERTIES VOID
	typedef OB_GROUP_PROPERTIES FAR* POB_GROUP_PROPERTIES;
#endif // GENERATED_CODE_BUILD

#endif // OBPROPER_H
	// DOINC popped back into header 'obgroup.h'
#endif

//****************************************************************************
//	Sizes of initial object manager structures
//****************************************************************************

#define OB_SHR_SYMTAB_SLOTS  		8
#define OB_SHR_LOOKUP_SLOTS 		16
#define OB_SHR_CONPOOL_SIZE 		50
#define OB_CONPOOL_SIZE 			200
#define OB_TYPEDEF_SLOTS 			10
#define OB_ENUM_ENTRY_SLOTS 		20
#define OB_GLOBSYM_SLOTS 			10
//****************************************************************************
// Group condition enums
//****************************************************************************

	typedef enum ob_group_comp_state
	{
		OB_NEVER_COMPILED,
		OB_TYPEDEFS_COMPILED,
		OB_ALL_COMPILED

	} OB_GROUP_COMP_STATE, FAR* POB_GROUP_COMP_STATE;

	//****************************************************************************
	// Data flags masks and shifts
	//****************************************************************************

#define OB_GROUP_USES_EXCEPTIONS_MASK	0x0001				// 1 bit
#define OB_GROUP_COMPSTATE_MASK			0x001c				// 3 bits

#define OB_GROUP_COMPSTATE_SHIFT		2
#define OB_GROUP_USES_EXCEPTIONS_SHIFT		0

//cr 340943 , For Window group, use 1 bit in OB_PERM_GROUP.info
#define OB_GROUP_NORMALIZED_WINDOW_MASK		0x0002			//use bit 1
#define OB_GROUP_NORMALIZED_WINDOW_SHIFT	1				
//end  CR 340943
//****************************************************************************
// Object group typedef
//****************************************************************************

	typedef struct ob_group_header
	{
		LONG			   	version;
		OB_CLASS_ID			primary_system_class;
		SHORT			   	reserved;

	} OB_GROUP_HEADER, FAR* POB_GROUP_HEADER;

	typedef struct ob_perm_group
	{
		OB_CONST_REF	   	name;			   	// Name of object group
		TIME_T			   	modify_time;	 	// Modification time
		TIME_T			   	compile_time;	 	// Time of compile
		USHORT				info;				// Group info flags. Contains:
		SHORT				padding;			// Pad for alignment.
	//	BOOL              	uses_exceptions : 1;// Any exception handling references in code
	//	UINT              	unused 	      : 2; 	// Unused bits
	//	OB_GROUP_COMP_STATE	compile_state : 3;	// Group compilation state.

	} OB_PERM_GROUP;

	struct IOB_PsppDll;

	typedef struct ob_temp_group
	{
		OB_GROUP_HNDL	   	id;					// Object group id.
		OB_LOOK_SYMTAB	   	shared_symtab;		// Group shared data symbol table
		POB_CONPOOL		   	conpool;			// Group constant pool
		POB_TYPEDEF		   	typdef;				// Group typedef table
		POB_GLOBSYM		   	globsym;			// Group global symbol table
		OB_SUBPOOL		   	subpool;			// Group subpool id
		LONG			   	version;			// Group version
		BOOL			   	copy_sym_table;		// Should we copy the shared symbol table?
		BOOL			   	is_dirty;			// TRUE if different from disk
		OB_CLASS_ID			primary_system_class;	// aystem ancestor class of the group primary class
		POB_GROUP_PROPERTIES group_properties;	// Group properties object.
		IOB_PsppDll* psppdll;
		BOOL				updated_preprocessor_symbols;	//Init: false.  
		PSHLIST				preprocessor_symbols;			//all defined preprocessor symbols(including local && global) will be saved here.
	} OB_TEMP_GROUP;

	typedef struct ob_group
	{
		OB_PERM_GROUP	   	ps;
		OB_TEMP_GROUP	   	ts;

		LPTSTR				lpszGroupName;
	} OB_GROUP;


	//****************************************************************************
	// GROUP HEADER FORMAT
	// The group binary format is used to identify if the group is stored
	// in an ANSI or UNICODE format.
	//****************************************************************************

	typedef enum ob_group_binary_format
	{
		OB_GROUP_BINARY_FORMAT_ANSI = 0,
		OB_GROUP_BINARY_FORMAT_UNICODE = 1

	} OB_GROUP_BINARY_FORMAT;

#ifdef UNICODE
#define OB_GROUP_BINARY_FORMAT_NATIVE OB_GROUP_BINARY_FORMAT_UNICODE
#else
#define OB_GROUP_BINARY_FORMAT_NATIVE OB_GROUP_BINARY_FORMAT_ANSI
#endif

#define OB_GROUP_BINARY_FORMAT_MASK		0x0001				// 1 bit

#define OB_GROUP_BINARY_FORMAT_SHIFT	0

#define ob_get_group_binary_format(groupHeader) 											\
	((OB_GROUP_BINARY_FORMAT)(((groupHeader).reserved & OB_GROUP_BINARY_FORMAT_MASK) >>		\
				OB_GROUP_BINARY_FORMAT_SHIFT))

#define ob_set_group_binary_format(groupHeader,format)									\
	((groupHeader).reserved = (SHORT)(((format) << OB_GROUP_BINARY_FORMAT_SHIFT) |	\
				((groupHeader).reserved & ~OB_GROUP_BINARY_FORMAT_MASK)))

#define ob_set_preprocessor_symbol_update_flag(group, flag)	\
			(group->ts.updated_preprocessor_symbols = flag)

#define ob_get_preprocessor_symbol_update_flag(group)	\
			(group->ts.updated_preprocessor_symbols)												

	//****************************************************************************
	// Current object group access
	//****************************************************************************
#define ob_get_curr_obj_group(obthis)  \
				((POB_GROUP) ((obthis)->curr_obj_group))

#define ob_get_curr_obj_group_id(obthis)  \
				(((POB_GROUP) ((obthis)->curr_obj_group))->ts.id)

#define ob_set_curr_obj_group(obthis,group)  \
				((obthis)->curr_obj_group = group)


//****************************************************************************
// Old group structure. Maintained for compatibility with libraries older 
// than 4.0. This is necessary since the group header is read before migration
// takes place.
//****************************************************************************

	typedef struct ob_old_perm_group
	{
		USHORT			   	name;			   	// Name of object group
		TIME_T			   	modify_time;	 	// Modification time
		TIME_T			   	compile_time;	 	// Time of compile
		USHORT				info;				// Group info flags. Contains:

	} OB_OLD_PERM_GROUP, FAR* POB_OLD_PERM_GROUP;

	//****************************************************************************
	// Group structure during 4.0 beta. Maintained for compatibility with libraries 
	// created during 4.0 beta. This is necessary since the group header is read before 
	// migration takes place.
	//****************************************************************************

	typedef struct ob_old_perm_group_chg
	{
		OB_CONST_REF	   	name;			   	// Name of object group
		TIME_T			   	modify_time;	 	// Modification time
		TIME_T			   	compile_time;	 	// Time of compile
		USHORT				info;				// Group info flags. Contains:

	} OB_OLD_PERM_GROUP_CHG, FAR* POB_OLD_PERM_GROUP_CHG;

	//****************************************************************************
	// Group locking state
	//****************************************************************************

	typedef enum ob_group_lock_state
	{

		OB_READLOCKED_GROUP,
		OB_SYSTEM_GROUP,
		OB_UNLOCKED_GROUP,
		OB_WRITELOCKED_GROUP

	} OB_GROUP_LOCK_STATE, FAR* POB_GROUP_LOCK_STATE;

	//****************************************************************************
	// Group load state
	//****************************************************************************

	typedef enum ob_group_load_state
	{

		OB_GROUP_NOT_LOADED = 0,
		OB_GROUP_GLOBSYM_LOADED = 1,
		OB_GROUP_TYPEDEFS_LOADED = 2,
		OB_GROUP_ALL_LOADED = 3

	} OB_GROUP_LOAD_STATE, FAR* POB_GROUP_LOAD_STATE;


	//****************************************************************************
	// Group link state
	//****************************************************************************

	typedef enum ob_group_link_state
	{
		OB_NEVER_LINKED,
		OB_LINKED

	} OB_GROUP_LINK_STATE, FAR* POB_GROUP_LINK_STATE;

	//****************************************************************************
	//	Runtime instance list 
	//****************************************************************************

#define OB_GROUP_INSTLIST_INCR 20

	typedef struct ob_inst_list_node
	{
		POB_RUNTIME_INST		rtinst;

	} OB_INSTLIST_NODE, FAR* POB_INSTLIST_NODE;

	typedef SH_GROWBLOCK	OB_INST_LIST, FAR* POB_INST_LIST;

	//****************************************************************************
	// Group list node structure
	//****************************************************************************
#ifdef GENERATED_CODE_BUILD
	class OB_GroupReference;
	typedef OB_GroupReference FAR* POB_GroupReference;
#else
// ***** DOINC including obgrpldr.h *****
//		Copyright Sybase, Inc. 1998
//
//	Sybase, Inc. ("Sybase") claims copyright in this
//	program and documentation as an unpublished work, versions of
//	which were first licensed on the date indicated in the foregoing
//	notice.  Claim of copyright does not imply waiver of Sybase's
//	other rights.
//
//      Filename :	obgrpldr.h
//
//      Author   :	Jim Ducharme
//
//      Purpose  : 	Definitions for Object manager group loader

// Because of circular reference to types, we need to
// inlcude obgroup.h before this header.
#ifndef OBGROUP_H
// ***** DOINC including obgroup.h *****
	// DOINC skipping duplicate include
#endif

#ifndef OBGRPLDR_H
#define OBGRPLDR_H

#ifndef PBCOM_H
// ***** DOINC including pbcom.h *****
	// DOINC skipping duplicate include
#endif

#ifndef OBTHIS_H
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
#endif

#ifndef OBDEFINE_H
// ***** DOINC including obdefine.h *****
	// DOINC skipping duplicate include
#endif

#ifndef PBASSERT_H
// ***** DOINC including pbassert.h *****
	// DOINC skipping duplicate include
#endif

// ***** DOINC including shlock.h *****
//		Copyright Sybase, Inc. 2004
//
//	Sybase, Inc. ("Sybase") claims copyright in this
//	program and documentation as an unpublished work, versions of
//	which were first licensed on the date indicated in the foregoing
//	notice.  Claim of copyright does not imply waiver of Sybase's
//	other rights.
//
//      Filename :	shlock.cpp
//
//      Author   :	Roy Shang, Xue-song Wu
//
//      Purpose  : 	Definition of class CriticalSectionHelper

#ifndef SH_LOCK_H
#define SH_LOCK_H

	class CriticalSectionHelper
	{
	private:

		PBOS_CRITICAL_SECTION& m_CriticalSection;
		bool m_bLeft;

	public:
		CriticalSectionHelper(PBOS_CRITICAL_SECTION& x_CriticalSection)
			: m_CriticalSection(x_CriticalSection), m_bLeft(false)
		{
			PBOS_EXCLUSIVE_LOCK_BEGIN_OWNERSHIP(m_CriticalSection);
		}

		~CriticalSectionHelper()
		{
			Leave();
		}

		void Leave()
		{
			if (!m_bLeft)
			{
				m_bLeft = true;
				PBOS_EXCLUSIVE_LOCK_END_OWNERSHIP(m_CriticalSection);
			}
		}

	private:
		CriticalSectionHelper();
		CriticalSectionHelper(const CriticalSectionHelper&);
		CriticalSectionHelper& operator=(const CriticalSectionHelper&);
	};

#endif
	// DOINC popped back into header 'obgrpldr.h'

	class OB_GroupReference;
	typedef OB_GroupReference FAR* POB_GroupReference;
	typedef POB_GroupReference FAR* PPOB_GroupReference;

	class OB_GroupLoaderFactory;

	// create a dynamic array of reference structures
#define SHDYNARR_TYPE 			POB_GroupReference
#define SHDYNARR_CLASS_NAME		OB_GroupRefPtrArray
// ***** DOINC including shdynarr.h *****
	// DOINC skipping duplicate include
#undef SHDYNARR_TYPE
#undef SHDYNARR_CLASS_NAME

	class OB_Library
	{
	private:
		LPTSTR					m_pLibraryName;
		USHORT					m_NumGroups;
		OB_GroupRefPtrArray		m_GroupRefArray;
		PBOS_CRITICAL_SECTION	m_CriticalSection;

		OB_Library();

	public:

		// bluo
		// OB_Library( LPTSTR pLibName )
		OB_Library(LPTSTR pLibName, ppbstg_anchor pAnchor)
			: m_GroupRefArray(pAnchor)
		{
			PBOS_EXCLUSIVE_LOCK_INIT(m_CriticalSection);
			// Fortify SCA: (False Positive)
			// Not an issue. Result is used to 
			// determine size required for destination buffer 
			m_pLibraryName = new TCHAR[pbstg_strlen_fp(pLibName) + 1];
			// Fortify SCA: (False Positive)
			// Buffer is allocated the exact amount of memory required
			pbstg_strcpy_fp(m_pLibraryName, pLibName);
			m_NumGroups = 0;
		};

		~OB_Library()
		{
			delete[] m_pLibraryName;
			m_NumGroups = 0;
			m_GroupRefArray.reset();
			PBOS_EXCLUSIVE_LOCK_FREE(m_CriticalSection);
		};

		LPTSTR GetLibraryName() { return m_pLibraryName; };

		HRESULT AddGroup(POB_GroupReference pGroupRef);

		HRESULT RemoveGroup(POB_GroupReference pGroupRef);

		HRESULT
			FindGroup
			(
				POB_THIS			obthis,
				USHORT				startingAt,			// Group id to start searching from
				LPTSTR				lpszGroupName,
				PPOB_GroupReference	ppGroupRef
			);

		HRESULT
			FindGroup
			(
				POB_THIS			obthis,
				LPTSTR				lpszGroupName,
				PPOB_GroupReference	ppGroupRef
			)
		{
			return FindGroup(obthis, 0, lpszGroupName, ppGroupRef);
		};

		PBOS_CRITICAL_SECTION& getCriticalSection()
		{
			return m_CriticalSection;
		}

	};

	typedef OB_Library FAR* POB_Library;
	typedef POB_Library FAR* PPOB_Library;

	// Class : OB_GroupReference
	// This is the equivilent to the old group list entry
	class OB_GroupReference : public IUnknown
	{
	private:
		OB_GROUP_ID			m_GroupID;
		LPTSTR				m_GroupName;
		LONG				m_RefCount;
		POB_GROUP			m_pGroup;
		OB_GROUP_LOAD_STATE	m_LoadState;
		OB_GROUP_LOCK_STATE	m_LockState;
		POB_Library			m_pLibrary;
		BOOL				m_bHasSource;

	public:

		OB_GroupReference() :
			m_GroupID(OB_SYM_NOT_DEFINED),
			m_GroupName(NULL),
			m_RefCount(0),
			m_pGroup(NULL),
			m_LoadState(OB_GROUP_NOT_LOADED),
			m_LockState(OB_UNLOCKED_GROUP),
			m_pLibrary(NULL),
			m_bHasSource(FALSE) {};

		~OB_GroupReference();

		VOID Initialize
		(
			OB_GROUP_ID			groupID,
			LPTSTR 				name,
			POB_Library 		pLibrary,
			POB_GROUP 			pGroup,
			OB_GROUP_LOAD_STATE loadState,
			OB_GROUP_LOCK_STATE lockState,
			BOOL				hasSource = FALSE
		);

		VOID Initialize
		(
			POB_GROUP 			pGroup,
			OB_GROUP_LOAD_STATE loadState,
			BOOL				hasSource = FALSE
		)
		{
			m_pGroup = pGroup;
			m_LoadState = loadState;
			m_bHasSource = hasSource;
		};

		VOID Clear();

		POB_GROUP 	GetGroup() { return m_pGroup; };

		OB_GROUP_ID	GetGroupId() { return m_GroupID; };

		LPTSTR 		GetGroupName() { return m_GroupName; };

		VOID		SetGroupName(LPTSTR newName);

		POB_Library GetLibrary() { return m_pLibrary; };

		VOID		SetLibrary(POB_Library pNewLib) { m_pLibrary = pNewLib; };

		LPTSTR 		GetLibraryName();

		OB_GROUP_LOAD_STATE GetGroupLoadState() { return m_LoadState; };

		BOOL		HasSource() { return m_bHasSource; };

		STDMETHODIMP			QueryInterface(REFIID riid, LPVOID FAR* ppObject)
		{
			*ppObject = NULL; return E_NOINTERFACE;
		};

		STDMETHODIMP_(ULONG)	AddRef(POB_THIS obthis)
		{
			if (m_pLibrary)
			{
				CriticalSectionHelper csHelper(m_pLibrary->getCriticalSection());
				InterlockedIncrement(&m_RefCount);
			}
			else
			{
				InterlockedIncrement(&m_RefCount);
			}

			return m_RefCount;
		};

		STDMETHODIMP_(ULONG)	Release(POB_THIS obthis);

		STDMETHODIMP_(ULONG)	AddRef(void)
		{
			if (m_pLibrary)
			{
				CriticalSectionHelper csHelper(m_pLibrary->getCriticalSection());
				InterlockedIncrement(&m_RefCount);
			}
			else
			{
				InterlockedIncrement(&m_RefCount);
			}

			return m_RefCount;
		};

		STDMETHODIMP_(ULONG)	Release(void)
		{
			// The only routines that may call this are ones who
			// know for a fact that their release will NOT cause
			// the group reference to be destroyed.
			PB_ASSERT(FALSE && PBTEXT("Error - Wrong Release called. Must pass current obthis"));
			return 0;
		};
	};


	// create a dynamic array of reference structures
#define SHDYNARR_TYPE 			POB_GroupReference
#define SHDYNARR_CLASS_NAME		POB_GroupRefArray
// ***** DOINC including shdynarr.h *****
	// DOINC skipping duplicate include
#undef SHDYNARR_TYPE
#undef SHDYNARR_CLASS_NAME

	class ObPsppDll;
	class ObPsppMgr;

	class OB_GroupLoader : public IUnknown
	{
		friend class ObPsppDll;	// allows ObPsppDll class to call GetNewGroupID

	private:	// Instance variables
		ppbstg_anchor			m_StgThis;
		USHORT					m_NumLibs;		// Number of libraries.
		PPOB_Library			m_pLibraryList;	// List of libraries
		POB_GroupRefArray		m_GroupList;	// The master group list
		OB_GROUP_ID				m_NextGroupId;	// Number of known groups
		LONG					m_RefCount;
		PBOS_CRITICAL_SECTION	m_CriticalSection;
		ObPsppMgr* m_psppMgr;		//One GroupLoader can only has one PsppManager.

	private: 	// Methods
		HRESULT 	RemoveFromFactory();

		OB_GROUP_ID GetNewGroupID(LPTSTR groupName, BOOL* bIncremented);

		POB_GroupReference	GetGroupRef(OB_GROUP_HNDL iGroupID)
		{
			CriticalSectionHelper csHelper(getCriticalSection());

			if (m_GroupList[iGroupID] == NULL)
				m_GroupList[iGroupID] = (POB_GroupReference)new OB_GroupReference();


			return m_GroupList[iGroupID];
		};

	public:		// Methods

		OB_GroupLoader
		(
			ppbstg_anchor	stgThis,
			POB_THIS		obthis,
			LPTSTR			lpstrTypdefPblName,
			LPTSTR			libraryList[],
			USHORT			numLibs
		);

		~OB_GroupLoader();

		USHORT GetNumLibs() { return m_NumLibs; };

		HRESULT
			FindGroup
			(
				POB_THIS			obthis,
				USHORT				startingAt,			// Group id to start searching from
				LPTSTR				lpszLibraryName,
				LPTSTR				lpszGroupName,
				PPOB_GroupReference	ppGroupRef
			);

		HRESULT
			FindGroup
			(
				POB_THIS			obthis,
				LPTSTR				lpszLibraryName,
				LPTSTR				lpszGroupName,
				PPOB_GroupReference	ppGroupRef
			)
		{
			return (FindGroup(obthis, 0, lpszLibraryName, lpszGroupName, ppGroupRef));
		};

		HRESULT
			FindGroup
			(
				POB_THIS			obthis,
				LPTSTR				lpszGroupName,
				PPOB_GroupReference	ppGroupRef
			);

		HRESULT GetGroup
		(
			POB_THIS			obthis,
			LPTSTR				lpszLibraryName,
			LPTSTR				lpszGroupName,
			OB_GROUP_LOCK_STATE	obGroupLockState,
			BOOL               	bCreateIfNotFound,
			POB_GROUP* ppGroup
		);

		HRESULT GetGroup
		(
			POB_THIS			obthis,
			OB_GROUP_HNDL  		iGroupID,
			POB_GROUP* ppGroup,
			BOOL				bForceLoad = FALSE
		);

		HRESULT NewGroup
		(
			POB_THIS			obthis,
			LPTSTR				lpszLibraryName,
			LPTSTR				lpszGroupName,
			OB_GROUP_LOCK_STATE	obGroupLockState,
			OB_GROUP_LOAD_STATE	obGroupLoadState,
			POB_GROUP* ppGroup
		);

		HRESULT AddGroup
		(
			POB_THIS			obthis,
			POB_GROUP			pGroup,
			LPTSTR				lpszLibraryName,
			LPTSTR				lpszGroupName,
			OB_GROUP_LOCK_STATE	obGroupLockState,
			OB_GROUP_LOAD_STATE	obGroupLoadState,	   	// Group load state
			BOOL				bSourceLoaded,		   	// Source loaded state
			OB_GROUP_ID			addAsGroupID = OB_SYM_NOT_DEFINED
		);

		HRESULT GetLibrary
		(
			LPTSTR				lpszLibraryName,
			PPOB_Library		ppLibrary,
			BOOL				bCreateIfNotFound
		);

		LPTSTR GetLibraryName
		(
			USHORT				index
		)
		{
			if (index >= m_NumLibs)
				return NULL;
			else
				return m_pLibraryList[index]->GetLibraryName();
		};

		LONG GetRefCount() { return m_RefCount; };

		HRESULT	PrimeGroupList
		(
			POB_THIS	obthis,
			LPBYTE		groupNames,
			UINT		numGroups
		);

		HRESULT Flush
		(
			POB_THIS 	obthis,
			BOOL 		bClearSystem = FALSE,
			OB_GROUP_ID iAppGroup = OB_SYM_NOT_DEFINED,
			BOOL		bIgnoreLockedGroups = FALSE
		);

		STDMETHODIMP			QueryInterface(REFIID riid, LPVOID FAR* ppObject)
		{
			*ppObject = NULL; return E_NOINTERFACE;
		};

		STDMETHODIMP_(ULONG)	AddRef(void)
		{
			InterlockedIncrement(&m_RefCount);
			return m_RefCount;
		};

		STDMETHODIMP_(ULONG)	Release(void);

		ObPsppMgr* GetPsppMgr()
		{
			return m_psppMgr;
		}

		PBOS_CRITICAL_SECTION& getCriticalSection()
		{
			return m_CriticalSection;
		}

	};

	typedef OB_GroupLoader FAR* POB_GroupLoader;
	typedef POB_GroupLoader FAR* PPOB_GroupLoader;

	class OB_GroupLoaderFactory;
	typedef OB_GroupLoaderFactory FAR* POB_GroupLoaderFactory;
	typedef POB_GroupLoaderFactory FAR* PPOB_GroupLoaderFactory;

	// create a dynamic array of reference structures
#define SHDYNARR_TYPE 			POB_GroupLoader
#define SHDYNARR_CLASS_NAME		OB_GroupLoaderArray
// ***** DOINC including shdynarr.h *****
	// DOINC skipping duplicate include
#undef SHDYNARR_TYPE
#undef SHDYNARR_CLASS_NAME

	class OB_GroupLoaderFactory : public IUnknown
	{
	private:
		static POB_GroupLoaderFactory	s_Factory;
		ppbstg_anchor			m_StgThis;
		OB_GroupLoaderArray		m_GroupLoaders;
		USHORT					m_NumGroupLoaders;
		PBOS_CRITICAL_SECTION	m_CriticalSection;
		POB_GROUP				m_DefaultSystemGroup;
		LPTSTR					m_DefaultSystemLibrary;
		LPTSTR					m_DefaultSystemGroupName;
		HRESULT GetGroupLoader
		(
			POB_THIS			callingOBThis,
			LPTSTR* libraryList,
			USHORT				numLibs,
			BOOL				bFromObthis,
			BOOL				bCreateIfNotFound,
			BOOL				bCreateNew,
			PPOB_GroupLoader	ppNewLoader
		);
		HRESULT FindGroupLoader
		(
			POB_THIS			callingOBThis,
			LPTSTR				lpstrTypdefPblName,
			LPTSTR* libraryList,
			USHORT				numLibs,
			PPOB_GroupLoader	ppNewLoader
		);

		HRESULT AddGroupLoader
		(
			POB_GroupLoader		pNewLoader
		)
		{
			m_GroupLoaders[m_NumGroupLoaders++] = pNewLoader;
			return S_OK;
		};

	public:
		static HRESULT GetGroupLoaderFactory(PPOB_GroupLoaderFactory ppFactory);
		static void DestroyGroupLoaderFactory();

		// bluo
		/*OB_GroupLoaderFactory() :
			m_StgThis(NULL),
			m_NumGroupLoaders(0),
			m_DefaultSystemGroup(NULL),
			m_DefaultSystemLibrary(NULL),
			m_DefaultSystemGroupName(NULL)
			{ PBOS_EXCLUSIVE_LOCK_INIT(m_CriticalSection); };*/
		OB_GroupLoaderFactory();


		~OB_GroupLoaderFactory();

		inline static
			ppbstg_anchor GetGroupStorage() { return s_Factory->m_StgThis; };

		inline static
			POB_GroupLoader GetGroupLoader
			(
				POB_THIS            callingOBThis,
				LPTSTR* libraryList = NULL,
				USHORT              numLibs = 0,
				BOOL				bFromObthis = TRUE,
				BOOL				bCreateIfNotFound = TRUE,
				BOOL                bCreateNew = FALSE
			);




		HRESULT RemoveGroupLoader
		(
			POB_GroupLoader		pGroupLoader
		);


		HRESULT SetDefaultSystemGroup
		(
			POB_THIS	obthis,					// This pointer
			LPTSTR		lpszLibraryName,		// Pointer to library name
			LPTSTR		lpszGroupName,			// Pointer to group name
			BOOL		bCreateIfNotFound		// Create if not found flag
		);

		STDMETHODIMP			QueryInterface(REFIID riid, LPVOID FAR* ppObject)
		{
			*ppObject = NULL; return E_NOINTERFACE;
		};

		STDMETHODIMP_(ULONG)	AddRef(void)
		{
			return 1;
		};

		STDMETHODIMP_(ULONG)	Release(void)
		{
			return 1;
		};

		PBOS_CRITICAL_SECTION& getCriticalSection()
		{
			return m_CriticalSection;
		}

	};

	// Inline methods
	inline LPTSTR
		OB_GroupReference::GetLibraryName()
	{
		return m_pLibrary->GetLibraryName();
	};

	inline POB_GroupLoader
		OB_GroupLoaderFactory::GetGroupLoader
		(
			POB_THIS            callingOBThis,
			LPTSTR* libraryList,
			USHORT              numLibs,
			BOOL				bFromObthis,
			BOOL				bCreateIfNotFound,
			BOOL				bCreateNew
		)
	{
		POB_GroupLoader		pGroupLoader = NULL;
		POB_GroupLoaderFactory	pFactory;
		HRESULT					result;

		result = OB_GroupLoaderFactory::GetGroupLoaderFactory(&pFactory);

		if (SUCCEEDED(result))
		{
			result = pFactory->GetGroupLoader(callingOBThis, libraryList, numLibs, bFromObthis, bCreateIfNotFound, bCreateNew, &pGroupLoader);
		}


		return pGroupLoader;
	};

	VOID ob_copy_group_shared_symbol_table
	(
		POB_THIS				obthis,
		POB_GROUP				group,
		BOOL					bInitialize
	);

#endif

	// DOINC popped back into header 'obgroup.h'
#endif

	typedef struct ob_grouplist
	{

		LPTSTR              lpszGroupName;      // Pointer to group name
		POB_GroupReference	m_GroupRef;				// Group reference
		PVOID               pLibListNode;       // Pointer to parent liblist
		TIME_T			   	modify_time;	   	// Modification time
		OB_GROUP_LINK_STATE link_state;          // Used in create_executable
		OB_GROUP_LOCK_STATE obGroupLockState;   // Locking State of group
		BOOL				hasSource;		   	// TRUE if source loaded.
		UINT                iReadLockCount;     // Read lock count
		BOOL				isValid;		   	// TRUE if group is validated.
		BOOL				isDynamicLib;		// TRUE if group lives in PBD.
		POB_GLOBSYM_ENTRY	temp_glbsym;		// Used in create_executable
		POB_LOOK_SYMTAB		grp_shared_symtab;	// This obthis' copy of the shared sym tab

		OB_INST_LIST		inst_list;			// List of instances
		POB_INSTLIST_NODE	inst_free_list;		// List of free instance slots
		UINT				no_insts;			// Number of instances
		BOOL				IsGroupBusy;		// TRUE if group is busy, FALSE if free, used only during garbage collection

	} OB_GROUPLIST, FAR* POB_GROUPLIST;

	//
	// Keeps track of last edited script by class entry when group being compiled
	//
	typedef struct ob_src_last_edit
	{
		LPTSTR	pEntry;
		USHORT	usLastScript;
	}	OB_SRC_LAST_EDIT, FAR* POB_SRC_LAST_EDIT;


	//****************************************************************************
	// Wrapper for ob_group fields
	//****************************************************************************

#define ob_get_groupid_link_state(obthis,groupid)  							\
	(ob_get_grouplist_node (obthis, groupid)->link_state)

#define ob_get_group_link_state(obthis,group) 								\
	ob_get_groupid_link_state(obthis,ob_get_group_id(obthis,group))

#define ob_set_group_link_state(obthis,group,lkstate)						\
	(ob_get_grouplist_node (obthis, 										\
							ob_get_group_id (obthis, group))				\
			->link_state													\
		= (lkstate)															\
	)

	inline IOB_PsppDll* ob_get_group_pspp_dll(POB_GROUP group)
	{
		return group->ts.psppdll;
	}

	inline VOID ob_set_group_pspp_dll(POB_GROUP group, IOB_PsppDll* dll)
	{
		group->ts.psppdll = dll;
	}

#define ob_mark_group_dirty(obthis,group)  								\
	((group)->ts.is_dirty = TRUE)

#define ob_mark_group_clean(obthis,group)  								\
	((group)->ts.is_dirty = FALSE)

#define ob_copy_group_dirty_flag(obthis,trg_group,src_group)			\
	((trg_group)->ts.is_dirty = (src_group)->ts.is_dirty)

#define ob_is_group_dirty(obthis,group)									\
	((group)->ts.is_dirty)

#define ob_get_group_globsym(obthis,group)								\
	((group)->ts.globsym)

#define ob_get_group_conpool(obthis,group)								\
	((group)->ts.conpool)

#define ob_get_group_typdef(obthis,group)								\
	((group)->ts.typdef)

#define ob_set_group_typdef(obthis,group,tpdef)							\
	((group)->ts.typdef = (tpdef))

#define ob_get_group_shr_symtab(obthis,group)							\
	((ob_get_grouplist_node((obthis), ob_get_group_id((obthis), (group)))->grp_shared_symtab))

#define ob_get_group_subpool(obthis,group)								\
	((group)->ts.subpool)

	// NOTE: The instance list has been moved to the GroupList so we can
	//       share the pGroup for typdef in distributed.
#define ob_get_group_instlist(obthis,group)	   							\
	(&(ob_get_grouplist_node (obthis, 									\
							ob_get_group_id (obthis, group))->inst_list))

#define ob_get_group_inst_freelist(obthis,group)	   					\
	(ob_get_grouplist_node (obthis, 										\
							ob_get_group_id (obthis, group))->inst_free_list)

#define ob_set_group_inst_freelist(obthis,group,free_list)				\
	(ob_get_grouplist_node (obthis, 										\
							ob_get_group_id (obthis, group))->inst_free_list = free_list)

#define ob_get_group_no_insts(obthis,group)								\
	(ob_get_grouplist_node (obthis, 										\
							ob_get_group_id (obthis, group))->no_insts)

#define ob_incr_group_instances(obthis,group)							\
	(ob_get_grouplist_node (obthis, 										\
							ob_get_group_id (obthis, group))->no_insts++)

#define ob_decr_group_instances(obthis,group)							\
	(ob_get_grouplist_node (obthis, 										\
							ob_get_group_id (obthis, group))->no_insts--)

#define ob_get_group_id(obthis,group)									\
	((group)->ts.id)

#define ob_set_group_id(obthis,group,group_id)							\
	((group)->ts.id = (OB_GROUP_HNDL)(group_id))

#define ob_get_group_compile_state(obthis,group) 	  						\
	((OB_GROUP_COMP_STATE) (((group)->ps.info & OB_GROUP_COMPSTATE_MASK) >>	\
				OB_GROUP_COMPSTATE_SHIFT))

#define ob_set_group_compile_state(obthis,group,compstate)					\
	((group)->ps.info = (USHORT)(((compstate) << OB_GROUP_COMPSTATE_SHIFT) |\
				((group)->ps.info & ~OB_GROUP_COMPSTATE_MASK)))

#define ob_get_group_uses_exceptions(obthis,group) 	  						\
	((BOOL) (((group)->ps.info & OB_GROUP_USES_EXCEPTIONS_MASK) >>	\
				OB_GROUP_USES_EXCEPTIONS_SHIFT))

#define ob_set_group_uses_exceptions(obthis,group,bUses)					\
	((group)->ps.info = (USHORT)(((bUses) << OB_GROUP_USES_EXCEPTIONS_SHIFT) |\
				((group)->ps.info & ~OB_GROUP_USES_EXCEPTIONS_MASK)))
// cr 340943
#define ob_get_group_normalized_window(obthis,group) 	  						\
	((BOOL) (((group)->ps.info & OB_GROUP_NORMALIZED_WINDOW_MASK) >>	\
				OB_GROUP_NORMALIZED_WINDOW_SHIFT))

#define ob_set_group_normalized_window(obthis,group,bUses)					\
	((group)->ps.info = (USHORT)(((bUses) << OB_GROUP_NORMALIZED_WINDOW_SHIFT) |\
				((group)->ps.info & ~OB_GROUP_NORMALIZED_WINDOW_MASK)))
//END cr 340943

#define ob_copy_group_modify_time(obthis,trg_group,src_group)			\
	((trg_group)->ps.modify_time = (src_group)->ps.modify_time)

#define ob_get_group_modify_time(obthis,group)							\
	((group)->ps.modify_time)

#define ob_set_group_modify_time(obthis,group,modtime)					\
	((group)->ps.modify_time = (modtime))

#define ob_get_group_compile_time(obthis,group)							\
	((group)->ps.compile_time)

#define ob_set_group_compile_time(obthis,group,comptime)				\
	((group)->ps.compile_time = (comptime))

#define ob_get_group_version(obthis,group)								\
	((group)->ts.version)

#define ob_set_group_primary_system_class(obthis,group,id)				\
	((group)->ts.primary_system_class = (id))

#define ob_get_group_primary_system_class(obthis,group)					\
	((group)->ts.primary_system_class)

#define ob_get_group_orig_symtab(obthis,group)							\
	(&(group)->ts.shared_symtab)

#define ob_get_group_properties(obthis, group)							\
	((group)->ts.group_properties)

#define ob_set_group_properties(obthis, group, prop)							\
	((group)->ts.group_properties = prop)

//****************************************************************************
// Wrapper for group->typdef fields 
//****************************************************************************

#define ob_get_group_enum_symtab(obthis,group)							\
			(&(ob_get_group_typdef(obthis,group)->enum_symtab))

#define ob_get_group_type_symtab(obthis,group)							\
			(&(ob_get_group_typdef(obthis,group)->type_symtab))

#define ob_get_group_typdef_conpool(obthis,group)						\
			(ob_get_group_typdef(obthis,group)->conpool)

#define ob_get_group_typdef_arg_conpool(obthis,group)						\
			(ob_get_group_typdef(obthis,group)->arg_conpool)

#define ob_get_group_typdef_descript(obthis,group)						\
			(ob_get_group_typdef(obthis,group)->descript)


//****************************************************************************
// Other macros
//****************************************************************************

#define ob_group_name(obthis,group)										\
			((LPTSTR) ob_get_const_data (obthis, 						\
				((POB_GROUP)(group))->ts.conpool,						\
				 ((POB_GROUP)(group))->ps.name))

#define ob_group_locked(obthis,group_id)								\
			((ob_get_grouplist_node(obthis,group_id)->obGroupLockState 	\
								== OB_READLOCKED_GROUP) ||				\
		 	 (ob_get_grouplist_node(obthis,group_id)->obGroupLockState 	\
				 				== OB_WRITELOCKED_GROUP ) )

// These are needed for machine code only
#ifdef    __cplusplus
	extern "C" {
#endif

		PBWINAPI(OB_GROUP_LOAD_STATE, ob_get_group_load_state)
			(
				PVOID			pGroupReference
				);

		PBWINAPI(POB_GROUP, ob_get_groupref_group)
			(
				PVOID			pGroupReference
				);
#ifdef    __cplusplus
	}
#endif

#ifdef GENERATED_CODE_BUILD
#define ob_group_data(obthis, iGroupID)	\
(ob_set_error(obthis, OB_SUCCESS), (POB_GROUP) 												\
	((iGroupID)==OB_SYM_NOT_DEFINED ? NULL : 												\
		(																					\
			(((obthis)->iGroupListSize <= (OB_GROUP_HNDL)(iGroupID)) || 						\
			((ob_get_grouplist_node(obthis, (iGroupID)))->m_GroupRef == NULL) || 			\
			(ob_get_group_load_state((ob_get_grouplist_node(obthis, 												\
				(iGroupID)))->m_GroupRef) == 							\
				OB_GROUP_GLOBSYM_LOADED)) 													\
			? 																				\
				ob_group_data_srch(obthis, (OB_GROUP_HNDL)(iGroupID)) 						\
			: 																				\
				(ob_get_groupref_group((ob_get_grouplist_node(obthis, (iGroupID)))->m_GroupRef))		\
		)																					\
	)																						\
)
#else
#define ob_group_data(obthis, iGroupID)	\
(ob_set_error(obthis, OB_SUCCESS), (POB_GROUP) 												\
	((iGroupID)==OB_SYM_NOT_DEFINED ? NULL : 												\
		(																					\
			(((obthis)->iGroupListSize <= (OB_GROUP_HNDL)(iGroupID)) || 						\
			((ob_get_grouplist_node(obthis, (iGroupID)))->m_GroupRef == NULL) || 			\
			((ob_get_grouplist_node(obthis, 												\
				(iGroupID)))->m_GroupRef->GetGroupLoadState() == 							\
				OB_GROUP_GLOBSYM_LOADED)) 													\
			? 																				\
				ob_group_data_srch(obthis, (OB_GROUP_HNDL)(iGroupID)) 						\
			: 																				\
				((ob_get_grouplist_node(obthis, (iGroupID)))->m_GroupRef->GetGroup())		\
		)																					\
	)																						\
)							
#endif
#define ob_get_indexed_groupid(obthis, index) \
	(*(sh_get_grwblk_item((obthis)->pGroupIdArray,index,POB_GROUP_ID)))

#define ob_set_indexed_groupid(obthis, index, pvalue) \
	sh_set_grwblk_item ((obthis)->stgthis, (obthis)->pGroupIdArray, (index), (pvalue), PBSTG_DEFAULT)

#define ob_get_num_indexed_groupids(obthis) \
	sh_grwblk_no_entries((obthis)->pGroupIdArray)

	//****************************************************************************
	// Grouplist instance list manipulation
	//****************************************************************************

#define ob_init_instlist(obthis,instlist)								\
	sh_grwblk_init ((PSH_GROWBLOCK)(instlist), OB_GROUP_INSTLIST_INCR, 	\
				sizeof (OB_INSTLIST_NODE))

#ifdef PBWIN16
// JDucharme - 10/28/97 - Put in hard coded limit for 16 bit. 
// We are limited to a little over 16000 objects per group in 16 bit 
// because of the growblock limitations. There is a "block" inside of a
// growblock that is allocated to the size of the structure times the number
// of things. This size is limited to 64k and each item we have is 4 bytes
// therefore the limit is about 16k.
#define ob_add_to_instlist(obthis,instlist,node,subpool)				\
	((ob_get_instlist_count(obthis,instlist) >= 16000) 								\
			? rt_error(obthis->rtthis, IDS_RT_R0045)					\
			: sh_add_to_grwblk (obthis->stgthis, (PSH_GROWBLOCK)instlist, node, subpool))

#else
#define ob_add_to_instlist(obthis,instlist,node,subpool)				\
	sh_add_to_grwblk (obthis->stgthis, (PSH_GROWBLOCK)instlist, node, subpool)
#endif

#define ob_get_instlist_item_pos(obthis,instlist,item)					\
	sh_grwblk_pos ((PSH_GROWBLOCK)instlist, item)

#define ob_get_instlist_item(obthis,instlist,pos)						\
	((POB_INSTLIST_NODE) (sh_grwblk_loc ((PSH_GROWBLOCK)instlist, pos)))

#define ob_get_instlist_count(obthis,instlist)							\
	sh_grwblk_no_entries ((PSH_GROWBLOCK)instlist)

#define ob_set_instlist_count(obthis,instlist,count)							\
	sh_grwblk_set_no_entries ((PSH_GROWBLOCK)instlist,count)

#define ob_clear_instlist(obthis,instlist)								\
	sh_grwblk_clear (obthis->stgthis,(PSH_GROWBLOCK)instlist)

//****************************************************************************
// Function prototypes
//****************************************************************************

#ifdef    __cplusplus
	extern "C" {
#endif    /* __cplusplus */

		PBWINAPI(ULONG, ob_group_get_next_index)
			(
				POB_THIS		obthis
				);

		VOID             		   	ob_add_group
		(
			POB_THIS      		   		obThis,
			POB_GROUP              		pGroup,
			LPTSTR                  		lpszLibraryName,
			LPTSTR                  		lpszGroupName,
			OB_GROUP_LOCK_STATE  		obGroupLockState,
			OB_GROUP_LOAD_STATE			obGroupLoadState,
			BOOL				   		SourceLoaded
		);

		PBWINAPI(VOID, ob_close_typedef_group)
			(
				POB_THIS 			   		obThis
				);

		PBWINAPI(POB_GROUP, ob_create_group_structure)
			(
				POB_THIS 			   		obThis,
				LPTSTR    			   		lpszGroupName
				);

		PBWINAPI(POB_GROUP, ob_new_group)
			(
				POB_THIS			   		obthis,
				LPTSTR				   		lib_name,
				LPTSTR				   		qual_group_name,
				OB_GROUP_LOCK_STATE    		group_lock_state,
				OB_GROUP_LOAD_STATE			group_load_state
				);

		VOID ob_remove_group
		(
			POB_THIS  			   		obThis,
			POB_GROUP 			   		pGroup
		);

		PBWINAPI(VOID, ob_del_group_structure)
			(
				POB_THIS  			   		obThis,
				POB_GROUP 			   		pGroup
				);

		VOID             		   	ob_group_init
		(
			POB_THIS  			   		obThis
		);

		POB_GROUP        		   	ob_internal_group_search
		(
			POB_THIS 			   		obThis,
			LPTSTR    			   		lpszLibraryName,
			LPTSTR    			   		lpszGroupName
		);

		VOID             		   	ob_group_terminate
		(
			POB_THIS 			   		obThis
		);

		PBWINAPI(POB_GROUP, ob_group_data_srch)
			(
				POB_THIS      		   		obThis,
				OB_GROUP_HNDL 		   		obGroupHandle
				);

		POB_GROUP 				   	ob_glbsym_group_data
		(
			POB_THIS      		   		obThis,
			OB_GROUP_HNDL 		   		obGroupHandle
		);

		POB_GROUP        		   	ob_load_group
		(
			POB_THIS           	   		obThis,
			LPTSTR              			lpszLibraryName,
			LPTSTR              			lpszGroupName,
			OB_GROUP_LOCK_STATE 		obGroupListState,
			BOOL               			bCreateIfNotFound
		);

		POB_GROUP 					ob_load_glbsym_group
		(
			POB_THIS           			obThis,                 // This pointer
			LPTSTR              			lpszLibraryName,        // Pointer to library name
			LPTSTR              			lpszGroupName           // Pointer to group name
		);

		PBWINAPI(VOID, ob_replace_group)
			(
				POB_THIS  					obThis,
				OB_GROUP_ID      			obGroupID,
				POB_GROUP 					pNewGroup
				);

		INT              			ob_resolve_group_glbsym
		(
			POB_THIS          			obThis,
			POB_GROUP         			pGroup,
			POB_GLOBSYM_ENTRY 			pGlobalSymbol
		);

		VOID 						ob_set_modify_time_to_now
		(
			POB_THIS					obthis,
			POB_GROUP					group
		);

		BOOL 						ob_make_group_copy
		(
			POB_THIS 					obthis,
			POB_GROUP					new_group,
			POB_GROUP 					old_group
		);

		PBWINAPI(VOID, ob_copy_group_shrsym_data)
			(
				POB_THIS					obthis,
				POB_GROUP					group
				);

		VOID ob_clear_group_instances
		(
			POB_THIS 			obthis,
			POB_GROUP			group
		);

		VOID 		   				ob_clear_group_function_pointers
		(
			POB_THIS 					obthis,
			POB_GROUP					group
		);


		VOID 		   				ob_mark_group_instances_as_unused
		(
			POB_THIS 					obthis,
			POB_GROUP					group
		);

		VOID 						ob_mark_used_group_instances
		(
			POB_THIS 			obthis,
			POB_GROUP			group
		);

		VOID 		   				ob_sweep_group_instances
		(
			POB_THIS 					obthis,
			POB_GROUP					group
		);

		VOID 		   				ob_sweep_allgroup_instances
		(
			POB_THIS 					obthis
		);

		VOID 						ob_mark_group_busy
		(
			POB_THIS 			obthis,
			POB_GROUP			group
		);

		//****************************************************************************
		// Prototypes from obgrpstk.c
		//****************************************************************************

		VOID       					ob_set_current_group
		(
			POB_THIS  					obThis,
			POB_GROUP 					pGroup
		);

		VOID       					ob_unset_current_group
		(
			POB_THIS  					obThis,
			BOOL						freeNode
		);

		//****************************************************************************
		// Prototypes from obgrpio.c
		//****************************************************************************

		INT        					ob_copy_group_on_disk
		(
			POB_THIS 					obThis,
			LPTSTR    					lpszGroupName,
			LPTSTR    					lpszOldLibraryName,
			LPTSTR    					lpszNewLibraryName
		);

		INT        					ob_delete_group_on_disk
		(
			POB_THIS 					obThis,
			LPTSTR    					lpszLibraryName,
			LPTSTR    					lpszGroupName
		);

		INT        					ob_move_group_on_disk
		(
			POB_THIS 					obThis,
			LPTSTR    					lpszGroupName,
			LPTSTR    					lpszOldLibraryName,
			LPTSTR    					lpszNewLibraryName
		);

		// PB11 language enhancement -- namespace
		PBWINAPI(LPTSTR, ob_get_qualified_name_with_namespace)
			(
				POB_THIS	obThis,
				POB_GROUP	pGroup,
				LPTSTR		lpszNamespace
				);

		OB_ERROR   					ob_put_group_to_disk
		(
			POB_THIS 					obThis,
			LPTSTR    					lpszLibraryName,
			OB_GROUP_ID					obGroupID,
			BOOL     					bWriteSourceEntry,
			LPTSTR	 					comment
		);

		POB_GROUP  					ob_read_entry_from_lib
		(
			POB_THIS					obThis,
			LPTSTR              		lpszLibraryName,
			LPTSTR              		lpszGroupName,
			OB_GROUP_HNDL				groupID,
			POB_ERROR		    		error
		);

		BOOL 						ob_read_source_from_lib
		(
			POB_THIS           			obThis,                 // This pointer
			LPTSTR              			lpszLibraryName,        // Pointer to library name
			LPTSTR              			lpszEntryName,          // Pointer to group name
			POB_GROUP		  			pGroup,			   		// Pointer to group
			POB_ERROR		   			pError			   		// Read error
		);

		POB_GROUP 		  			ob_read_glbsym_entry_from_lib
		(
			POB_THIS           			obThis,                 // This pointer
			LPTSTR              			lpszLibraryName,        // Pointer to library name
			LPTSTR              			lpszEntryName,          // Pointer to group name
			POB_ERROR	  				pError	  				// Read error
		);

		INT 						ob_delete_group_pcode
		(
			POB_THIS        			obthis,
			POB_GROUP					group
		);

		PBWINAPI(LPTSTR FAR*, ob_get_source_from_group)
			(
				POB_THIS                  	obthis,
				POB_GROUP                 	group,
				POB_SOURCE_BLK_TYPE FAR* src_type,
				PUINT                     	no_blocks,
				OB_SUBPOOL					subpool,
				POB_SRC_LAST_EDIT FAR* ppSrcLastEdit,
				PUINT						pNoSrcLastEdit
				);

		PBWINAPI(VOID, obUpdateSrcLastEdit)
			(
				POB_THIS              obThis,
				POB_GROUP             pGroup,
				POB_SRC_LAST_EDIT	  pSrcLastEdit,
				UINT				  NoSrcLastEdit
				);

		POB_GROUP 					ob_read_group_header
		(
			POB_THIS           			obThis,
			LPTSTR              			lpszLibraryName,
			LPTSTR              			lpszEntryName,
			POB_ERROR			   		pError
		);

		POB_GROUP ob_read_group_header
		(
			POB_THIS           obThis,              // This pointer
			LPTSTR              lpszLibraryName,     // Pointer to library name
			LPTSTR              lpszEntryName,       // Pointer to group name
			POB_ERROR          pError               // Read error
		);

		LONG 						ob_read_entry_version
		(
			POB_THIS             		obThis,
			LPTSTR                		lpszLibraryName,
			LPTSTR                		lpszEntryName,
			POB_GROUP_COMP_STATE 		comp_state,
			POB_ERROR		   			pError
		);

		//****************************************************************************
		// Prototypes from obgrplst.c
		//****************************************************************************

		POB_GROUPLIST 				ob_init_grouplist
		(
			POB_THIS           			obThis,
			UINT							iGroupListIncr,
			PUINT						pGroupListSize,
			PSHLIST						pLibList,
			POB_GROUP          			pSystemGroup
		);

		VOID		 				ob_grouplist_grow
		(
			POB_THIS        	obthis                      // This pointer
		);

		VOID             			ob_add_grouplist_node
		(
			POB_THIS           			obThis,
			POB_GROUP          			pGroup,
			LPTSTR              			lpszLibraryName,
			LPTSTR              			lpszGroupName,
			OB_GROUP_LOCK_STATE  		obGroupLockState,
			OB_GROUP_LOAD_STATE			obGroupLoadState,
			BOOL				 		SourceLoaded
		);

		OB_GROUP_ID ob_add_new_group_id
		(
			POB_THIS           			obthis,
			LPTSTR              			lpszGroupName,
			LPTSTR						lpszLibraryName
		);

		VOID             		 	ob_clear_function_groups
		(
			POB_THIS  			 		obThis
		);

		VOID             		 	ob_del_node_from_grouplist
		(
			POB_THIS 			 		obThis,
			POB_GROUPLIST		 		pGroupList,
			OB_GROUP_ID			 		obGroupID
		);

		VOID 						ob_reset_locked_groups
		(
			POB_THIS					obthis
		);

		VOID 						ob_init_locked_groups
		(
			POB_THIS					obthis
		);

#define ob_del_grouplist_node(obthis,iGroupID)							\
	   		ob_del_node_from_grouplist (obthis, 					   	\
  				(POB_GROUPLIST)((obthis)->pGroupList), (OB_GROUP_ID)iGroupID)

#define ob_get_node_from_grouplist(obthis,pGroupList,groupid)			\
			(& ((POB_GROUPLIST)(pGroupList)) [groupid])

#define ob_get_grouplist_node(obthis,groupid)							\
			ob_get_node_from_grouplist (obthis,							\
				(obthis)->pGroupList,groupid)

#define ob_validate_group(obthis,groupid)								\
			(ob_get_grouplist_node(obthis,groupid)->isValid=TRUE)

#define ob_is_group_valid(obthis,groupid)								\
			(ob_get_grouplist_node(obthis,groupid)->isValid)

		OB_GROUP_HNDL   			ob_internal_grouplist_search
		(
			POB_THIS 					obThis,
			LPTSTR    					lpszLibraryName,
			LPTSTR    					lpszGroupName
		);

		POB_GROUP	 				ob_search_grouplist
		(
			POB_THIS       				obThis,
			LPTSTR          				lpszGroupName
		);

		INT ob_lock_group_readwrite
		(
			POB_THIS       obthis,                     // This pointer
			OB_GROUP_HNDL  obGroupHandle               // Group handle
		);

		INT ob_unlock_group_readwrite
		(
			POB_THIS       obthis,                     // This pointer
			OB_GROUP_HNDL  obGroupHandle               // Group handle
		);

		//****************************************************************************
		// Prototypes from obscnsrc.c
		//****************************************************************************

		VOID 						ob_rebuild_prototype_source
		(
			POB_THIS 					obthis,
			POB_GROUP 					group,
			POB_CLASS_ENTRY 			class_entry
		);

#define ob_alloc_source_block(obthis,bytes,subpool)						\
			((POB_SOURCE_BLOCK) obAlloc (obthis, bytes, subpool))

#define ob_realloc_source_block(obthis,block,bytes,subpool)				\
			((POB_SOURCE_BLOCK) obReAlloc (obthis, block, bytes, subpool))

#define	ob_source_block_copy(obthis,target,source,bytes)					\
			(pbstg_huge_memcpy (target, source, bytes))

		// Prototypes from obcurent.cpp
		VOID ob_init_group_shr_symtab
		(
			POB_THIS 				obthis,
			POB_GROUP				pGroup
		);

		VOID ob_init_group
		(
			POB_THIS 				obthis,
			POB_GROUP				pGroup,
			LPTSTR					lpszGroupName,
			LPTSTR					lpszLibraryName,
			OB_GROUP_LOAD_STATE		GroupLoadState
		);

		INT ob_build_virtual_tables
		(
			POB_THIS     		obthis,                    // This pointer
			POB_GROUP	 		pGroup,						// Group pointer
			BOOL				free_perm
		);

#ifdef    __cplusplus
	}	// extern "C" {
#endif    /* __cplusplus */


#endif // OBGROUP_H

// DOINC popped back into header 'obglobal.h'
#endif
#ifndef OBVAR_H
// ***** DOINC including obvar.h *****
	// DOINC skipping duplicate include
#endif

#ifdef    __cplusplus
	extern "C" {
#endif    /* __cplusplus */

		//****************************************************************************
		// Get var macros
		//****************************************************************************

#define ob_get_local_rout_symtab(obthis)									\
	(&(ob_get_curr_routnode(obthis)->rout_symtab))

#define ob_get_local_var(obthis,pgroup,var_id)								\
	ob_get_var (obthis, pgroup, 											\
				ob_get_local_rout_symtab(obthis), var_id)

#define ob_get_shared_var(obthis,pgroup,var_id)								\
	ob_get_var (obthis, pgroup, 											\
				ob_get_group_shr_symtab (obthis, *pgroup), var_id)

#define ob_get_local_dirref(obthis,var_id)									\
	ob_looksym_data (ob_get_local_rout_symtab(obthis), var_id)

#define ob_get_local_globref(obthis,pgroup,pglob_id)	 				   	\
	(														   				\
	 ob_global_indirect 													\
					(													 	\
					obthis, 											 	\
					pgroup, 												\
					pglob_id	   											\
					)														\
	)

#define ob_get_local_refpak(obthis,var_id)									\
	ot_access_refarg_refpak (obthis, ob_get_local_dirref (obthis, var_id))

		POB_DATA ob_get_local_argref
		(
			POB_THIS 			obthis,
			POB_GROUP_ID 		group_id,
			OB_SYM_ID 			var_id
		);

#define ob_get_shared_dirref(obthis,group,var_id)							\
	ob_looksym_data (ob_get_group_shr_symtab(obthis,group), var_id)

#define ob_get_shared_globref(obthis,pgroup,pvar_id)						\
	(																		\
	 ob_global_indirect 													\
					(														\
					obthis, 												\
					pgroup, 												\
					pvar_id													\
					)														\
	)


		//****************************************************************************
		// Object manager prototypes.
		//****************************************************************************


		PBWINAPI(POB_DATA, ob_get_var)
			(
				POB_THIS 			obthis,
				POB_GROUP FAR* group,
				POB_LOOK_SYMTAB 	look_symtab,
				OB_SYM_ID 			var_id
				);

		PBWINAPI(VOID, ob_init_var_data)
			(
				POB_THIS 			obthis,
				POB_DATA			var_data,
				POB_GROUP  			group
				);

		PBWINAPI(POB_DATA, ob_global_indirect)
			(
				POB_THIS 			obthis,
				POB_GROUP FAR* group,
				POB_SYM_ID			glob_id
				);

		PBWINAPI(OB_SYM_ID, ob_global_var_declare)
			(
				POB_THIS 			obthis,
				POB_GROUP 			group,
				LPTSTR 				varname,
				OB_INFO_FLAGS		varinfo,
				OB_LOOKUP_INFO		lookup_info,
				OB_CLASS_ID			type,
				PINT		 		error
				);

		PBWINAPI(OB_SYM_ID, ob_global_array_declare)
			(
				POB_THIS 			obthis,
				POB_GROUP 			group,
				LPTSTR 				var,
				OB_INFO_FLAGS		varinfo,
				OB_LOOKUP_INFO		lookup_info,
				OB_CLASS_ID			type,
				POB_ARRAYDEF 		arrdef,
				PINT				error
				);

		PBWINAPI(OB_SYM_ID, ob_shared_var_reference)
			(
				POB_THIS 			obthis,
				POB_GROUP 			group,
				LPTSTR 				varname,
				POB_CLASS_ID		type,
				POB_INFO_FLAGS		varinfo,
				POB_LOOKUP_INFO		lookup_info,
				POB_DATA FAR* init_value,
				POB_ARRAYDEF FAR* array_def
				);

		PBWINAPI(VOID, ob_global_set_var)
			(
				POB_THIS 			obthis,
				POB_GROUP 			group,
				OB_SYM_ID 			var_id,
				OB_CONST_REF		value
				);

		PBWINAPI(VOID, ob_global_set_id_var)
			(
				POB_THIS 			obthis,
				POB_GROUP			group,
				OB_SYM_ID 			var_id,
				UINT				value
				);

		INT							 	ob_var_indirect
		(
			POB_THIS 			obthis,
			POB_GROUP FAR* group,
			POB_SYM_ID			var_id
		);

		POB_DATA						ob_get_shared_unupdated_var
		(
			POB_THIS 			obthis,
			POB_GROUP FAR* group,
			OB_SYM_ID 			var
		);

		POB_DATA ob_get_local_unupdated_var
		(
			POB_THIS 			obthis,
			POB_GROUP FAR* group,
			OB_SYM_ID 			var
		);

		PBWINAPI(POB_LOOK_SYMTAB, ob_get_local_symtab)
			(
				POB_THIS 			obthis,
				POB_GROUP FAR* group,
				POB_SYM_ID 			var_id
				);

		POB_DATA 						ob_get_unupdated_global_var
		(
			POB_THIS 	  		obthis,
			POB_GROUP FAR* group,
			OB_SYM_ID	  		glob_id
		);

		PBWINAPI(POB_DATA, ob_get_unconverted_var)
			(
				POB_THIS 			obthis,
				POB_GROUP FAR* group,
				OB_SYM_ID 			var,
				UINT  				level
				);

		PBWINAPI(INT, ob_lookup_shared_var_info)
			(
				POB_THIS      		obThis,
				OB_GROUP_ID   		iGroupID,
				OB_SYM_ID     		iSymbolID,
				POB_CLASS_ID  		pType,
				POB_INFO_FLAGS		varinfo,
				POB_LOOKUP_INFO		lookup_info,
				POB_DATA FAR* init_value,
				POB_ARRAYDEF FAR* array_def
				);

		PBWINAPI(VOID, ob_clear_shared_vars)
			(
				POB_THIS 			obthis,
				POB_GROUP 			group,
				INT					level
				);

		POB_GROUP ob_global_group_indirect
		(
			POB_THIS 				obthis,
			POB_GROUP  				sourceGroup,
			OB_SYM_ID				glob_id
		);

#ifdef    __cplusplus
	}	// extern "C" {
#endif    /* __cplusplus */


#endif // OBGLOBAL_H

// DOINC popped back into header 'rtccode.h'
// ***** DOINC including obgroup.h *****
	// DOINC skipping duplicate include
// ***** DOINC including otdefine.h *****
// $RCSfile: otdefine.h $;$Revision: 4.57 $
//**************************************************************************
//
//                            Copyright 1989
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :	otdefine.h
//
//    Author   :	Jim Kosko
//
//    Purpose  : 	Definitions for PB runtime system.
//
//****************************************************************************

#ifndef OTDEFINE_H
#define OTDEFINE_H

#ifndef OBTHIS_H
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBDATA_H
// ***** DOINC including obdata.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBCONST_H
// ***** DOINC including obconst.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBARRAY_H
// ***** DOINC including obarray.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBGROUP_H
// ***** DOINC including obgroup.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OTEXPR_H
// ***** DOINC including otexpr.h *****
//**************************************************************************
//
//                        Copyright 1989 - 1994
//                        Powersoft Corporation
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM POWERSOFT CORPORATION.
//
// ------------------------------------------------------------------------
//
//	Filename	:	otexpr.h
//
//	Author		:	Jim Kosko
//
//	Purpose		: 	Definitions for PB runtime expressions
//
//****************************************************************************

#ifndef OTEXPR_H
#define OTEXPR_H

//****************************************************************************
//	Includes
//****************************************************************************

#ifndef SHDEC_H
// ***** DOINC including shdec.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBDATA_H
// ***** DOINC including obdata.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBTHIS_H
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBGROUP_H
// ***** DOINC including obgroup.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBOBJECT_H
// ***** DOINC including obobject.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OTPUBLIC_H
// ***** DOINC including otpublic.h *****
	// DOINC skipping duplicate include
#endif

// DOINC told to skip 7 lines...

//****************************************************************************
//	Expression evaluation structure
//****************************************************************************

	typedef union
	{
		DOUBLE	double_buffer;
		SH_DEC	dec_buffer;
		LONGLONG	longlong_buffer;

	} NUMERIC_VALS;

	typedef struct ot_eval_node
	{
		OB_DATA				data;
		NUMERIC_VALS		v;
		OB_GROUP_ID			group_id;
		SHORT				lvalue_flags;

	} OT_EVAL_NODE, FAR* POT_EVAL_NODE;

#define IS_EVAL_LVALUE_SHIPT 0
#define IS_EVAL_LVALUE_MASK 0x1
#define IS_EVAL_REFPCK_CREATER_SHIPT 1
#define IS_EVAL_REFPCK_CREATER_MASK 0x2
#define OT_ROUND_DOUBLE(double_value) ((double_value < 0) ? \
		 		ceil (double_value - 0.5) : floor (double_value + 0.5))

	//****************************************************************************
	//	Evaluation node macros
	//****************************************************************************

#define ot_get_eval_lvalue(eval_node) 							   		\
		((POB_DATA) ob_get_data_ptr (&(eval_node)->data))

#define ot_get_eval_ref_packet(eval_node) 								\
		((POT_REF_PAK) ob_get_data_ptr (&(eval_node)->data))

#define ot_get_eval_rvalue(eval_node) 	 								\
		(&(eval_node)->data)

#define ot_get_eval_data(eval_node) 									\
		((POB_DATA) ot_get_eval_rvalue (eval_node) )

#define ot_copy_eval_data(target,eval_node) 							\
		(ob_copy_data_node (target, ot_get_eval_data (eval_node) ) )

#define ot_get_eval_group(eval_node) 									\
		((eval_node)->group_id)

#define ot_set_eval_group(eval_node,grp_id) 							\
		((eval_node)->group_id = (grp_id))

#define ot_set_eval_double(eval_node,doub_val)					 		\
		( (eval_node)->v.double_buffer = doub_val )

#define ot_get_eval_double(eval_node)							 		\
		( (eval_node)->v.double_buffer )

#define ot_set_eval_longlong(eval_node,longl_val)					 		\
		( (eval_node)->v.longlong_buffer = longl_val )

#define ot_get_eval_longlong(eval_node)							 		\
		( (eval_node)->v.longlong_buffer )

#define ot_set_eval_dec(eval_node,dec_val)					 			\
		( (eval_node)->v.dec_buffer = dec_val )

#define ot_get_eval_dec(eval_node)							 			\
		( (eval_node)->v.dec_buffer )

#define ot_set_eval_is_lvalue(eval_node, islvalue)							\
		(ob_set_bitfield((eval_node)->lvalue_flags,BOOL,islvalue,IS_EVAL_LVALUE_SHIPT,IS_EVAL_LVALUE_MASK))	

#define ot_get_eval_is_lvalue(eval_node)							\
		(ob_get_bitfield((eval_node)->lvalue_flags,BOOL,IS_EVAL_LVALUE_SHIPT,IS_EVAL_LVALUE_MASK))

#define ot_is_eval_lvalue(eval_node)		\
		(ob_get_bitfield((eval_node)->lvalue_flags,BOOL,IS_EVAL_LVALUE_SHIPT,IS_EVAL_LVALUE_MASK) ==TRUE)

#define ot_set_eval_is_refpack_creater(eval_node,is_refpack_creater)		\
	(ob_set_bitfield((eval_node)->lvalue_flags,BOOL,is_refpack_creater,IS_EVAL_REFPCK_CREATER_SHIPT,IS_EVAL_REFPCK_CREATER_MASK))

#define ot_get_eval_is_refpack_creater(eval_node)							\
		(ob_get_bitfield((eval_node)->lvalue_flags,BOOL,IS_EVAL_REFPCK_CREATER_SHIPT,IS_EVAL_REFPCK_CREATER_MASK))


//****************************************************************************
// Tuning parameters
//****************************************************************************

#define OT_EXPR_STACK_INCR		20

//****************************************************************************
//	Other Macros
//****************************************************************************

#define ot_get_stack_pos(obthis,pos)		 							\
  			((obthis)->expr_stack +	(pos) )

#define ot_pop_stack(obthis)											\
			(--(obthis)->expr_stack_ptr)

#define ot_pop_stack_data(obthis)										\
			(&(ot_pop_stack(obthis)->data))

#define ot_get_rel_stack_pos(obthis,item_no)			  				\
			( ((obthis)->expr_stack_ptr -								\
			   (obthis)->expr_stack)    - (item_no))

#define ot_get_stack_item(obthis,item_no)   							\
			((obthis)->expr_stack_ptr - (item_no))

#define ot_get_stack_item_data(obthis,item_no)							\
			(&(ot_get_stack_item (obthis, item_no)->data))

#define ot_push_stack(obthis)					  				 		\
			((obthis)->expr_stack_ptr++)

#define ot_get_stacked_group_id(obthis,pos)								\
			(ot_get_stack_pos (obthis, pos) -> group_id)

#define ot_get_stacked_data_node(obthis,pos)	  						\
			( &(ot_get_stack_pos (obthis, pos) -> data) )

#define ot_clear_val_ptr(obthis,eval_node)		 					   	\
			{														   	\
			 ot_free_val_ptr (obthis, ot_get_eval_rvalue (eval_node)); 	\
			}

// ot_field_update(POB_THIS,POB_DATA)
//
// POB_DATA contains a pointer to a fldupdate_ref
//			style ref packet.  The ref packet is
//			destroyed by this call.
//
#define ot_field_update(obthis,refpak)										\
		{																	\
		(refpak)->ref.fldupdate.field_update_func 							\
							 ((PRT_THIS)((obthis)->rtthis), 		 		\
							  (refpak)->ref.fldupdate.obinst,				\
							  (refpak)->ref.fldupdate.field_id,				\
							  (refpak)->ref.fldupdate.item_index);			\
		ot_free_fldupdate_refpak( obthis, refpak );							\
		}

//****************************************************************************
// Stack popping
//****************************************************************************

#define ot_pop_lvalue(obthis)		   										\
 			 ot_get_eval_lvalue (ot_pop_stack (obthis))

#define ot_pop_ref_packet(obthis)		   									\
 			 ot_get_eval_ref_packet (ot_pop_stack (obthis))

#define ot_pop_rvalue(obthis)		   										\
 			 ot_get_eval_rvalue (ot_pop_stack (obthis))

#define ot_get_lvalue_from_stack(obthis,stack_item_no)						\
	 		ot_get_eval_lvalue (ot_get_stack_item (obthis, stack_item_no))


//****************************************************************************
// Value pushing macros
//****************************************************************************

#define ot_push_stack_node(obthis,node,group_id)							\
	{																		\
	POT_EVAL_NODE	eval_node;												\
	eval_node = ot_get_stack_item (obthis, 0);								\
	ob_copy_data_node (&eval_node->data, node);								\
	ot_set_eval_group (eval_node, group_id);								\
	ot_set_eval_is_lvalue(eval_node, FALSE);										\
	ot_push_stack (obthis);													\
	}

#define ot_push_stack_node_copy(obthis,node,group_id)					   	\
	{																		\
	POT_EVAL_NODE	eval_node;												\
	eval_node = ot_get_stack_item (obthis, 0);								\
	ob_copy_data_node (&eval_node->data, node);								\
	ot_set_eval_group (eval_node, group_id);								\
	ot_set_eval_is_lvalue(eval_node, FALSE);										\
	ot_push_stack (obthis);													\
	}

#define ot_push_stack_int(obthis,int_val,null_val)							\
	{																		\
	ob_set_data_int_nv (ot_get_stack_item_data (obthis, 0), 				\
						int_val, INT_TYPE, null_val);  						\
	ot_set_eval_is_lvalue(ot_get_stack_item (obthis, 0), FALSE);					\
	ot_push_stack (obthis);													\
	}

#define ot_push_stack_uint(obthis,uint_val,null_val)						\
	{																		\
	ob_set_data_uint_nv (ot_get_stack_item_data (obthis, 0), 				\
						 uint_val, UINT_TYPE, null_val);					\
	ot_set_eval_is_lvalue(ot_get_stack_item (obthis, 0), FALSE);					\
	ot_push_stack (obthis);													\
	}

//**********************************************************
// Begin of the new type BYTE
//**********************************************************
#define ot_push_stack_byte(obthis,byte_val,null_val)						\
	{																		\
	ob_set_data_byte_nv (ot_get_stack_item_data (obthis, 0), 				\
						 byte_val, BYTE_TYPE, null_val);					\
	ot_set_eval_is_lvalue(ot_get_stack_item (obthis, 0), FALSE);					\
	ot_push_stack (obthis);													\
	}
//**********************************************************
// End of the new type BYTE
//**********************************************************

#define ot_push_stack_long(obthis,long_val,null_val)						\
	{																		\
	ob_set_data_long_nv (ot_get_stack_item_data (obthis, 0), 				\
						 long_val, LONG_TYPE, null_val);					\
	ot_set_eval_is_lvalue(ot_get_stack_item (obthis, 0), FALSE);					\
	ot_push_stack (obthis);													\
	}

#define ot_push_stack_ulong(obthis,ulong_val,null_val)						\
	{																		\
	ob_set_data_ulong_nv (ot_get_stack_item_data (obthis, 0), 				\
						 ulong_val, ULONG_TYPE, null_val);					\
	ot_set_eval_is_lvalue(ot_get_stack_item (obthis, 0), FALSE);					\
	ot_push_stack (obthis);													\
	}

#define ot_push_stack_float(obthis,flt_val,null_val)						\
	{																		\
	ob_set_data_float_nv (ot_get_stack_item_data (obthis, 0), 				\
						  flt_val, FLOAT_TYPE, null_val);					\
	ot_set_eval_is_lvalue(ot_get_stack_item (obthis, 0), FALSE);					\
	ot_push_stack (obthis);													\
	}

#define ot_push_stack_double(obthis,doub_val,null_val)						\
	{																		\
	POT_EVAL_NODE	eval_node;												\
	eval_node = ot_get_stack_item (obthis, 0);								\
	ot_set_eval_double (eval_node, doub_val);								\
	ob_set_data_double_nv(&eval_node->data, 								\
							&ot_get_eval_double (eval_node), 				\
							DOUBLE_TYPE, null_val)							\
	ot_set_eval_is_lvalue(eval_node, FALSE);										\
	ot_push_stack (obthis);													\
	}

#define ot_push_stack_longlong(obthis,longl_val,null_val)						\
	{																		\
	POT_EVAL_NODE	eval_node;												\
	eval_node = ot_get_stack_item (obthis, 0);								\
	ot_set_eval_longlong (eval_node, longl_val);								\
	ob_set_data_longlong_nv(&eval_node->data, 								\
							&ot_get_eval_longlong (eval_node), 				\
							LONGLONG_TYPE, null_val)						\
	ot_set_eval_is_lvalue(eval_node, FALSE);										\
	ot_push_stack (obthis);													\
	}

#define ot_push_stack_dec(obthis,dec_val,null_val)							\
	{																		\
	POT_EVAL_NODE	eval_node;												\
	eval_node = ot_get_stack_item (obthis, 0);								\
	ot_set_eval_dec (eval_node, dec_val);									\
	ob_set_data_dec_nv(&eval_node->data, 								\
							&ot_get_eval_dec (eval_node), 				\
							DEC_TYPE, null_val)							\
	ot_set_eval_is_lvalue(eval_node, FALSE);										\
	ot_push_stack (obthis);													\
	}

//#define ot_push_stack_ptr(obthis,ptr_val,type,null_val)						\
//	{																		\
//	ob_set_data_ptr_nv (ot_get_stack_item_data (obthis, 0), 				\
//						ptr_val, type, null_val);			   				\
//	ot_push_stack (obthis);													\
//	}

#define ot_push_stack_time(obthis,ptr_val,type,null_val)					\
	{																		\
	ob_set_data_ptr_nv (ot_get_stack_item_data (obthis, 0), 				\
						ptr_val, type, null_val);			   				\
	ot_set_eval_is_lvalue(ot_get_stack_item (obthis, 0), FALSE);					\
	ot_push_stack (obthis);													\
	}

#define ot_push_stack_date(obthis,ptr_val,type,null_val)					\
	{																		\
	ob_set_data_ptr_nv (ot_get_stack_item_data (obthis, 0), 				\
						ptr_val, type, null_val);			   				\
	ot_set_eval_is_lvalue(ot_get_stack_item (obthis, 0), FALSE);					\
	ot_push_stack (obthis);													\
	}

#define ot_push_stack_string(obthis,ptr_val,type,null_val)					\
	{																		\
	ob_set_data_ptr_nv (ot_get_stack_item_data (obthis, 0), 				\
						ptr_val, type, null_val);			   				\
	ot_set_eval_is_lvalue(ot_get_stack_item (obthis, 0), FALSE);					\
	ot_push_stack (obthis);													\
	}

#define ot_push_stack_class_entry(obthis,ptr_val,type,null_val)				\
	{																		\
	ob_set_data_ptr_nv (ot_get_stack_item_data (obthis, 0), 				\
						ptr_val, type, null_val);			   				\
	ot_set_eval_is_lvalue(ot_get_stack_item (obthis, 0), FALSE);					\
	ot_push_stack (obthis);													\
	}

#define ot_push_stack_bool(obthis,bool_val,null_val)						\
	{																		\
	ob_set_data_int_nv (ot_get_stack_item_data (obthis, 0), 				\
						(bool_val), BOOL_TYPE, (null_val));	  				\
	ot_set_eval_is_lvalue(ot_get_stack_item (obthis, 0), FALSE);					\
	ot_push_stack (obthis);													\
	}

//****************************************************************************
// LValue pushing macros
//****************************************************************************

#define ot_push_stack_reference(obthis,refpak) 								\
	{																		\
	POT_EVAL_NODE	eval_node;												\
	eval_node = ot_get_stack_item (obthis, 0);								\
	ob_set_data_type (&eval_node->data, refpak->type);						\
	ob_set_data_flags (&eval_node->data, refpak->flags);					\
	ob_set_data_ptr_val (&eval_node->data, refpak);							\
	ot_set_eval_group (eval_node, 											\
		(OB_GROUP_ID)refpak->group_hndl);									\
	ob_set_data_reftype (&eval_node->data, OB_ARGUMENT_REF);				\
	ot_set_eval_is_lvalue(eval_node, TRUE);										\
	ot_set_eval_is_refpack_creater(eval_node, TRUE);										\
	ot_push_stack (obthis);													\
	}

#define ot_push_stack_reference_nonoriginal(obthis,refpak) 								\
	{																		\
	POT_EVAL_NODE	eval_node;												\
	eval_node = ot_get_stack_item (obthis, 0);								\
	ob_set_data_type (&eval_node->data, refpak->type);						\
	ob_set_data_flags (&eval_node->data, refpak->flags);					\
	ob_set_data_ptr_val (&eval_node->data, refpak);							\
	ot_set_eval_group (eval_node, 											\
		(OB_GROUP_ID)refpak->group_hndl);									\
	ob_set_data_reftype (&eval_node->data, OB_ARGUMENT_REF);				\
	ot_set_eval_is_lvalue(eval_node, TRUE);									\
	ot_set_eval_is_refpack_creater(eval_node, FALSE);		\
	ot_push_stack (obthis);													\
	}


#define ot_push_stack_lvalue(obthis,lvalue,group_id) 						\
	{																		\
	POT_EVAL_NODE	eval_node;												\
	eval_node = ot_get_stack_item (obthis, 0);								\
	ob_copy_data_node (&eval_node->data, lvalue);							\
	ob_set_data_ptr_val (&eval_node->data, lvalue);							\
	ot_set_eval_group (eval_node, group_id);								\
	ot_set_eval_is_lvalue(eval_node, TRUE);										\
	ot_push_stack (obthis);													\
	}

#define	ot_push_stack_lvalue_copy(obthis,lvalue,stack_pos)	   				\
	{																		\
	POT_EVAL_NODE	eval_node;												\
	eval_node = ot_get_stack_item (obthis, 0);								\
	ob_copy_data_node (&eval_node->data, lvalue);							\
	ob_set_data_ptr_val (&eval_node->data, lvalue);							\
	ot_set_eval_group (eval_node, 											\
				ot_get_eval_group (ot_get_stack_pos (obthis, stack_pos)));	\
	ot_set_eval_is_lvalue(eval_node, TRUE);											\
	ot_push_stack (obthis);													\
	}

#define	ot_push_stack_const(obthis,const_ref,type)							\
	{																		\
	POT_EVAL_NODE	eval_node;												\
	eval_node = ot_get_stack_item (obthis, 0);								\
	ob_set_data_const (&eval_node->data, const_ref, type, 0);				\
	ot_set_eval_group (eval_node, ob_get_curr_obj_group_id (obthis));		\
	ot_set_eval_is_lvalue(eval_node, FALSE);											\
	ot_push_stack (obthis);													\
	}

#define	ot_push_stack_enum(obthis,enum_val,type)							\
	{																		\
	POT_EVAL_NODE	eval_node;												\
	eval_node = ot_get_stack_item (obthis, 0);								\
	ob_set_data_int (&eval_node->data, enum_val, type, 0);					\
	ob_set_data_objtype(&eval_node->data, OB_NON_OBJECT_TYPE);				\
	ot_set_eval_group (eval_node, ob_get_sys_typedef_group_id (obthis));	\
	ot_set_eval_is_lvalue(eval_node, FALSE);											\
	ot_push_stack (obthis);													\
	}


//***************************************************************************
//POB_RUNTIME_INST
//	OT_IS_CALL_xxx MACROS
//
//	Support macros for evaluating the call style info flags used by
//	ot_process_dotfunccall and ot_process_class_call
//
//***************************************************************************

// Bit 0: 1 == POSTED | 0 == TRIGGERED
#define OT_IS_CALL_POSTED(flag_word)										\
	((BOOL)(flag_word & 1))

// Bit 1: 1 == DYNAMIC | 0 == STATIC
#define OT_IS_CALL_DYNAMIC(flag_word)										\
	((BOOL)((flag_word >> 1) & 1))

// Bit 2: 1 == EVENT | 0 == FUNCTION
#define OT_IS_CALL_EVENT(flag_word)											\
	((BOOL)((flag_word >> 2) & 1))


//****************************************************************************
//	Function Prototypes
//****************************************************************************

#ifdef    __cplusplus
	extern "C" {
#endif    /* __cplusplus */

		VOID 								ot_push_stack_node_with_check
		(
			POB_THIS 			obthis,
			POB_DATA			data,
			OB_GROUP_ID			group_id,
			BOOL				nullval = FALSE
		);

		VOID 							  	ot_expr_init
		(
			POB_THIS       		obthis
		);

		VOID 							  	ot_expr_term
		(
			POB_THIS       		obthis
		);


		POB_DATA 							ot_process_stacked_rvalue
		(
			POB_THIS 			obthis,
			POT_EVAL_NODE		evaled_expr,
			POB_DATA			expr_result_buf,
			POB_GROUP_ID		group_id
		);

		POB_DATA 					  		ot_pop_rvalue_string
		(
			POB_THIS 			obthis,
			POB_DATA			expr_result_buf
		);

		PBWINAPI(POB_DATA, ot_eval_expr)
			(
				POB_THIS 			obthis,
				POB_GROUP			group,
				POB_CLASS_ENTRY		class_entry,
				POB_PCODE_BLK		pcode_blk,
				POB_DATA			expr_result_buf
				);

		POB_ACT_ARG FAR* ot_get_eval_funcarg_info
		(
			POB_THIS 			obthis,
			UINT				no_items
		);

		VOID 								ot_copy_any_lvalue
		(
			POB_THIS			obthis,
			UINT				stack_item
		);

		//****************************************************************************
		//	Prototypes from otcall.c
		//****************************************************************************

		PBWINAPI(VOID, ot_dbg_funccall)
			(
				POB_THIS 			obthis,
				LPTSTR 				call_label,
				POB_GROUP 			group,
				OB_CLASS_ID		 	class_entry,
				LPTSTR				name
				);

		VOID							  	ot_set_return_val_grp
		(
			POB_THIS			obthis,
			POB_DATA			data_node,
			OB_GROUP_ID			group_id
		);

		POB_DATA						  	ot_get_return_val
		(
			POB_THIS 			obthis,
			POB_GROUP_ID		group_id
		);

		OB_CLASS_ID						  	ot_get_return_val_type
		(
			POB_THIS 			obthis
		);

		POB_DATA						  	ot_get_return_double
		(
			POB_THIS 			obthis,
			PDOUBLE				doub_val,
			POB_GROUP_ID		group_id
		);

		POB_DATA						  	ot_get_return_longlong
		(
			POB_THIS 			obthis,
			PLONGLONG			longl_val,
			POB_GROUP_ID		group_id
		);

		POB_DATA						  	ot_get_return_dec
		(
			POB_THIS 			obthis,
			PSH_DEC				dec_val,
			POB_GROUP_ID		group_id
		);

		INT							  		ot_process_dotfunccall
		(
			POB_THIS 			obthis,
			OB_CONST_REF		rout_nameid_ref,
			UINT				no_args,
			USHORT				usFlags
		);

		INT									ot_process_class_call
		(
			POB_THIS			obthis,
			OB_GROUP_ID			idGroup,
			POB_CLASS_ENTRY		pClassEntry,
			OB_MODULE_ID		idModule,
			OB_PROTO_ID			idPrototype,
			UINT		 		no_args,
			USHORT				usFlags
		);

		PBWINAPI(INT, ot_run_dllfunccall)
			(
				POB_THIS			obthis,
				POB_GROUP			group,
				OB_CLASS_ID			class_id,
				LPTSTR				funcname,
				POB_DATA			evaled_arglist,
				UINT				no_args,
				POB_PROTOTYPE		funcproto
				);

		PBWINAPI(INT, ot_run_rpcfunccall)
			(
				POB_THIS			obthis,
				POB_RUNTIME_INST	rtinst,
				POB_GROUP			group,
				OB_CLASS_ID			class_id,
				LPTSTR				funcname,
				POB_DATA			evaled_arglist,
				UINT				no_args,
				POB_PROTOTYPE		funcproto,
				LPTSTR				rpc_funcname
				);

		INT ot_process_eventcall
		(
			POB_THIS			obthis,
			OB_VTABLE_ID		vtable_id,
			UINT				no_args,
			OB_CLASS_ID			class_id,
			OB_CONST_REF		const_ref
		);

		OS_CALLC_FUNC 						ot_get_dll_funcptr
		(
			POB_THIS            obthis,
			POB_GROUP           group,
			POB_PROTOTYPE       funcproto,
			LPTSTR               funcname
		);

		HINSTANCE 							ot_get_dll_handle
		(
			POB_THIS                obthis,
			LPTSTR		            dllname,
			PINT                    ret
		);

		PBWINAPI(OS_CALLC_FUNC, ot_get_dll_funcptr_by_name)
			(
				POB_THIS                obthis,
				LPTSTR		            dllname,
				LPTSTR                   funcname
				);


		//****************************************************************************
		// Prototypes for instance creation
		//****************************************************************************

		INT 								ot_find_new_class
		(
			POB_THIS 			obthis,
			POB_GROUP			obinst_group,
			OB_CLASS_ID			obinst_class_id,
			LPTSTR				class_name,
			POB_GROUP			FAR* found_group,
			POB_CLASS_ID		found_class_id
		);

		//****************************************************************************
		// Prototypes for posted class calls in code gen.
		//****************************************************************************


		PBWINAPI(INT, ot_post_call)
			(
				POB_THIS			obthis,
				POB_RUNTIME_CLASS	pRuntimeClass,
				OB_VTABLE_ID		vtableId,
				UINT				uiNoArgs,
				POB_DATA			args
				);

		void ot_del_pointer_stack_item
		(
			POB_THIS	obthis,
			POB_DATA	arg
		);

#ifdef    __cplusplus
	}	// extern "C" {
#endif    /* __cplusplus */


#endif // OTEXPR_H
// DOINC popped back into header 'otdefine.h'
#endif
#ifndef OTPUBLIC_H
// ***** DOINC including otpublic.h *****
	// DOINC skipping duplicate include
#endif


//****************************************************************************
// Type location enum definition.
//****************************************************************************

	typedef enum
	{
		OT_IN_DATA_NODE,
		OT_OUT_DATA_NODE

	} OT_TYPE_LOC;


	//****************************************************************************
	// Prototype and definitions for ot_check_types
	//****************************************************************************

#ifdef    __cplusplus
	extern "C" {
#endif    /* __cplusplus */


		typedef enum
		{
			OT_TYPCHECK_SUCCESS,
			OT_TYPCHECK_BAD_ARRAY_TYPES,
			OT_TYPCHECK_BAD_TYPES,
			OT_TYPCHECK_MIXED_GROUPING,
			OT_TYPCHECK_UNDECLARED

		} OT_TYPE_CHECK_ERROR, FAR* POT_TYPE_CHECK_ERROR;

		PBWINAPI(OT_TYPE_CHECK_ERROR, ot_check_types)
			(
				POB_THIS 					obthis,
				POB_GROUP 					group1,
				OB_CLASS_ID					type1,
				OB_GROUPTYPE				grouping1,
				POB_GROUP 					group2,
				OB_CLASS_ID					type2,
				OB_GROUPTYPE				grouping2,
				PUINT						ancestor_flag
				);

		PBWINAPI(INT, ot_strict_type_check)
			(
				POB_THIS 		     		obthis,
				POB_GROUP					group1,
				OB_CLASS_ID					type1,
				POB_GROUP					group2,
				OB_CLASS_ID					type2
				);

		BOOL 								ot_exact_type_match
		(
			POB_THIS					obthis,
			POB_GROUP					group1,
			OB_CLASS_ID					class_id1,
			POB_GROUP					group2,
			OB_CLASS_ID					class_id2
		);


		//****************************************************************************
		// Macros for spliting and splicing floats
		//****************************************************************************

#define ot_get_float_hiword(float_val)									\
	((WORD) (( (*(LPDWORD) &(float_val)) >> 16) & 0xFFFF))

#define ot_get_float_loword(float_val)									\
	((WORD) (*(LPDWORD) &(float_val)) )

#define ot_make_float(fl_val,loword,hiword)							  	\
	{																	\
	DWORD d = (((loword) | (((DWORD)(hiword)) << 16)));					\
	PFLOAT fl_mid_val=(PFLOAT)&d;										\
	fl_val = *fl_mid_val;												\
	}

//****************************************************************************
// Function prototypes.
//****************************************************************************
		OB_DATASTYLE ot_get_style(POB_THIS, POB_GROUP, OB_CLASS_ID);

		//	set up info field for arrays from class handle.
		PBWINAPI(USHORT, ot_generateVarInfo)
			(
				POB_THIS		obthis,
				OB_CLASS_HNDL	obClassHndl
				);

		PBWINAPI(OT_TYPE_LOC, ot_type_loc)
			(
				POB_THIS					obthis,
				POB_DATA					data_node
				);

		VOID ot_set_data_typeinfo(POB_THIS pobThis, POB_DATA data, OB_CLASS_ID type);

		PBWINAPI(VOID, ot_init_data_node)
			(
				POB_THIS					obthis,
				POB_DATA 					data_node,
				OB_CLASS_ID					type,
				OB_INFO_FLAGS				varinfo
				);

		VOID								ot_init_out_node
		(
			POB_THIS					obthis,
			POB_DATA					data_node,
			POB_GROUP					group,
			OB_SUBPOOL					subpool
		);

		VOID 								ot_init_data
		(
			POB_THIS            		obthis,
			POB_GROUP					group,
			POB_DATA            		data
		);

		BOOL 								ot_data_ptr_compare
		(
			POB_THIS 					obthis,
			POB_DATA 					data_node1,
			POB_DATA					data_node2
		);

		PVOID								ot_convert_const_node
		(
			POB_THIS					obthis,
			POB_GROUP					group,
			POB_DATA					data_node
		);

		PVOID								ot_convert_const_node_no_copy
		(
			POB_THIS					obthis,
			POB_GROUP					group,
			POB_DATA					data_node
		);

		OB_CONST_REF 						ot_convert_ptr_node
		(
			POB_THIS					obthis,
			POB_DATA					data_node,
			PINT						ret
		);

		OB_CONST_REF 						ot_convert_ptr_node_no_free
		(
			POB_THIS					obthis,
			POB_DATA					data_node,
			PINT						ret
		);

		OB_CONST_REF 						ot_ancestor_db_statement_indirect
		(
			POB_THIS                obthis,
			POB_DATA                node,
			OB_GROUP_ID				source_group_id,
			PINT                    ret
		);

		PVOID 								ot_ancestor_db_statement_fixup
		(
			POB_THIS                obthis,
			POB_DATA                node,
			OB_GROUP_ID				source_group_id
		);

		PVOID								ot_get_valptr_grp
		(
			POB_THIS 					obthis,
			POB_DATA 					data,
			OB_GROUP_ID					group_id
		);

		VOID 								ot_make_value_copy
		(
			POB_THIS 					obthis,
			OB_GROUP_ID 				group_id,
			POB_DATA					node,
			BOOL 						freedata,
			BOOL						is_external_refrence,
			BOOL						add_reference = TRUE
		);

		INT 								ot_assign_lvalue_ancestor
		(
			POB_THIS					obthis,
			POB_DATA					lvalue_data,
			POB_RUNTIME_INST			rtinst,
			BOOL						is_null,
			OB_GROUP_ID					group_hndl
		);

		PBWINAPI(INT, ot_set_lvalue)
			(
				POB_THIS					obthis,
				OB_GROUP_ID					group_id,
				POB_DATA					lvalue_data,
				POB_DATA					rvalue_data,
				BOOL						do_error_check
				);

		INT 								ot_assign_lvalue
		(
			POB_THIS 					obthis,
			POB_DATA					lvalue_data,
			POB_DATA 					rvalue_data
		);

		PBWINAPI(VOID, ot_free_out_node)
			(
				POB_THIS					obthis,
				POB_DATA					data_node
				);

		PBWINAPI(INT, ot_free_inv_meth_args)
			(
				POB_THIS					obthis,
				POB_DATA					pArrayDataNode,
				LPTSTR						pFreeFlags
				);

#define ot_get_next_expr_arg(obthis,arglst,pos)  				\
			ob_get_data_const(&arglst[pos])

		VOID 					  			ot_set_evaled_arglist
		(
			POB_THIS			  		obthis,
			POB_DATA			  		evaled_arglist,
			POT_LVALUE_INFO				lvalue_info
		);

		PBWINAPI(POB_ARRAY_INST, ot_copy_array)
			(
				POB_THIS                	obthis,
				POB_ARRAY_INST          	old_array_inst
				);

		VOID 								ot_copy_ptr_node_contents
		(
			POB_THIS 					obthis,
			POB_DATA    				node
		);

		PBWINAPI(LPTSTR, ot_get_string_from_chararray)
			(
				POB_THIS					obthis,
				POB_ARRAY_INST				arrayinst
				);

		PBWINAPI(POB_DATA, ot_create_chararray_from_string)
			(
				POB_THIS					obthis,
				LPTSTR						string_val,
				POB_DATA					target_data_node
				);

		PBWINAPI(POB_DATA, ot_create_bounded_chararray_from_string)
			(
				POB_THIS					obthis,
				LPTSTR						string_val,
				PLONG						bounds,
				POB_DATA					target_data_node
				);

		PBWINAPI(TCHAR, ot_get_char_value)
			(
				POB_THIS				obthis,
				POB_DATA		  		data_node
				);

		PBWINAPI(LPTSTR, ot_get_string_value)
			(
				POB_THIS				obthis,
				POB_DATA		  		data_node
				);

		PBWINAPI(LPTSTR, ot_get_string_from_char)
			(
				POB_THIS					obthis,
				TCHAR						char_val
				);

		PBWINAPI(LPTSTR, ot_string_cat)
			(
				POB_THIS                                obthis,
				LPTSTR                                   string1,
				LPTSTR                                   string2
				);

		PBWINAPI(PSH_BINARY, ot_binary_cat)
			(
				POB_THIS                                obthis,
				PSH_BINARY                              bin1,
				PSH_BINARY                              bin2
				);

		PBWINAPI(INT, ot_halt)
			(
				POB_THIS            obthis,
				BOOL				send_close_event
				);

		PBWINAPI(POB_ARRAY_INST, ot_convert_bounded_to_bounded)
			(
				POB_THIS					obthis,
				POB_ARRAY_INST				old_array_inst,
				OB_CLASS_ID					new_class_id,
				ULONG						new_nitems,
				INT							new_ndims,
				LONG						bounds[],
				BOOL						free_old_array
				);

		PBWINAPI(POB_ARRAY_INST, ot_convert_bounded_to_unbounded)
			(
				POB_THIS					obthis,
				POB_ARRAY_INST				old_array_inst,
				OB_CLASS_ID					new_class_id
				);

		PBWINAPI(POB_ARRAY_INST, ot_convert_unbounded_to_bounded)
			(
				POB_THIS					obthis,
				POB_ARRAY_INST				old_array_inst,
				OB_CLASS_ID					new_class_id,
				ULONG						new_nitems,
				INT							new_ndims,
				LONG						bounds[]
				);

		PBWINAPI(POB_ARRAY_INST, ot_convert_unbounded_to_unbounded)
			(
				POB_THIS					obthis,
				POB_ARRAY_INST				old_array_inst,
				OB_CLASS_ID					new_class_id
				);

		PBWINAPI(POB_ARRAY_INST, ot_convert_any_to_bounded)
			(
				POB_THIS					obthis,
				POB_DATA					any_node,
				OB_CLASS_ID					new_class_id,
				ULONG						new_nitems,
				INT							new_ndims,
				LONG						bounds[]
				);

		PBWINAPI(POB_ARRAY_INST, ot_convert_any_to_unbounded)
			(
				POB_THIS					obthis,
				POB_DATA					any_node,
				OB_CLASS_ID					new_class_id
				);

		PBWINAPI(POB_RUNTIME_INST, ot_convert_array_to_object)
			(
				POB_THIS					obthis,
				POB_ARRAY_INST				any_array_inst,
				OB_CLASS_ID					new_class_id
				);

		//****************************************************************************
		// Reference packet creation methods
		//****************************************************************************

		PBWINAPI(POT_REF_PAK, ot_build_simple_refpak)
			(
				POB_THIS					obthis,
				POB_DATA					lvalue_data,
				OB_GROUP_ID					group_id
				);

		PBWINAPI(POT_REF_PAK, ot_build_field_refpak)
			(
				POB_THIS					obthis,
				OB_GROUP_ID					group_id,
				POB_RUNTIME_INST			rtinst,
				UINT						field_id,
				ULONG						item_index,
				BOOL						bTriggerFieldUpdate
				);

		PBWINAPI(POT_REF_PAK, ot_build_flditemupdate_refpak)
			(
				POB_THIS					obthis,
				POB_DATA					lvalue_data,
				OB_GROUP_ID					group_id,
				POB_RUNTIME_INST			rtinst,
				UINT						field_id,
				ULONG						item_index
				);


#define ot_free_fldupdate_refpak(obthis,refpak)  					  		\
	ot_free_refpak(obthis,refpak)

#define ot_free_refpak(obthis,refpak)											\
	{																			\
	if ((OB_INST_DEFINED((((POT_REF_PAK)refpak)->ref.field.obinst))) && ((((POT_REF_PAK)refpak)->style == OT_FIELD_ITEM_REF) || (((POT_REF_PAK)refpak)->style == OT_FIELD_REF)))\
		ob_clear_instance_ref(obthis, &(((POT_REF_PAK)refpak)->ref.field.obinst));				\
	obFree(obthis,(refpak));														\
	}

		//****************************************************************************
		// internal reference packet utilities
		//****************************************************************************

		OB_CLASS_ID ot_get_ref_class_id
		(
			POB_THIS			obthis,
			POT_REF_PAK 		refpak,
			POB_GROUP_ID		group_id
		);

#define ot_process_refpak_assignment(obthis,refpak)							\
	(((refpak)->style != OT_SIMPLE_REF) && ((refpak)->ref.field.field_update_func != NULL) ?	\
		(refpak)->ref.field.field_update_func 							\
							 (obthis,						 		 		\
							  (refpak)->ref.field.obinst,				\
							  (refpak)->ref.field.field_id,				\
							  (refpak)->ref.field.item_index) :			\
		0																	\
	)

		//****************************************************************************
		// Reference argument utilities
		//****************************************************************************

#define ot_set_reference_argument(obthis,PobData,refpak) 			   		\
	{																		\
		ob_set_simple_ptr (PobData, refpak);								\
		ob_set_data_reftype (PobData, OB_ARGUMENT_REF);						\
	}

#define ot_process_refarg_assignment(obthis,PobData) 						\
	ot_process_refpak_assignment(obthis,ot_access_refarg_refpak(obthis,PobData))

//****************************************************************************
// Reference argument creation methods
//****************************************************************************

#define ot_build_simple_refarg(obthis,PobData,lvalue,groupid)				\
	ot_set_reference_argument												\
	(																		\
		obthis,																\
		PobData,															\
		ot_build_simple_refpak(obthis,lvalue,groupid)						\
	)

#define ot_build_field_refarg(obthis,PobData,groupid,inst,fldid,indx,isFieldUpdate) \
	ot_set_reference_argument												\
	(																		\
		obthis,																\
		PobData,															\
		ot_build_field_refpak(obthis,groupid,inst,fldid,indx,isFieldUpdate)	\
	)

#define ot_build_flditemupdate_refarg(obthis,PobData,lvalue,groupid,inst,fldid,indx) \
	ot_set_reference_argument												\
	(																		\
		obthis,																\
		PobData,															\
		ot_build_flditemupdate_refpak(obthis,lvalue,groupid,inst,fldid,indx)	\
	)


#define ot_free_refarg(obthis,refarg)										\
	ot_free_refpak(obthis,(POT_REF_PAK)ob_get_data_ptr(refarg))

//****************************************************************************
// ANY Datatype Support methods
//****************************************************************************

		PBWINAPI(INT, ot_add_any)
			(
				PRT_THIS 	prtThis,
				POB_DATA	pResult,
				POB_DATA	pAny1,
				POB_DATA	pAny2
				);

		PBWINAPI(INT, ot_sub_any)
			(
				PRT_THIS 	prtThis,
				POB_DATA	pResult,
				POB_DATA	pAny1,
				POB_DATA	pAny2
				);

		PBWINAPI(INT, ot_mul_any)
			(
				PRT_THIS 	prtThis,
				POB_DATA	pResult,
				POB_DATA	pAny1,
				POB_DATA	pAny2
				);

		PBWINAPI(INT, ot_div_any)
			(
				PRT_THIS 	prtThis,
				POB_DATA	pResult,
				POB_DATA	pAny1,
				POB_DATA	pAny2
				);

		PBWINAPI(INT, ot_pow_any)
			(
				PRT_THIS 	prtThis,
				POB_DATA	pResult,
				POB_DATA	pAny1,
				POB_DATA	pAny2
				);

		PBWINAPI(INT, ot_neg_any)
			(
				PRT_THIS 	prtThis,
				POB_DATA	pResult,
				POB_DATA	pAny1
				);

		PBWINAPI(INT, ot_eq_any)
			(
				PRT_THIS 	prtThis,
				POB_DATA	pResult,
				POB_DATA	pAny1,
				POB_DATA	pAny2
				);

		PBWINAPI(INT, ot_ne_any)
			(
				PRT_THIS 	prtThis,
				POB_DATA	pResult,
				POB_DATA	pAny1,
				POB_DATA	pAny2
				);

		PBWINAPI(INT, ot_gt_any)
			(
				PRT_THIS 	prtThis,
				POB_DATA	pResult,
				POB_DATA	pAny1,
				POB_DATA	pAny2
				);

		PBWINAPI(INT, ot_lt_any)
			(
				PRT_THIS 	prtThis,
				POB_DATA	pResult,
				POB_DATA	pAny1,
				POB_DATA	pAny2
				);

		PBWINAPI(INT, ot_ge_any)
			(
				PRT_THIS 	prtThis,
				POB_DATA	pResult,
				POB_DATA	pAny1,
				POB_DATA	pAny2
				);

		PBWINAPI(INT, ot_le_any)
			(
				PRT_THIS 	prtThis,
				POB_DATA	pResult,
				POB_DATA	pAny1,
				POB_DATA	pAny2
				);

		PBWINAPI(INT, ot_and_any)
			(
				PRT_THIS 	prtThis,
				POB_DATA	pResult,
				POB_DATA	pAny1,
				POB_DATA	pAny2
				);

		PBWINAPI(INT, ot_or_any)
			(
				PRT_THIS 	prtThis,
				POB_DATA	pResult,
				POB_DATA	pAny1,
				POB_DATA	pAny2
				);

		PBWINAPI(INT, ot_not_any)
			(
				PRT_THIS 	prtThis,
				POB_DATA	pResult,
				POB_DATA	pAny
				);

		PBWINAPI(INT, ot_incr_any)
			(
				PRT_THIS 	prtThis,
				POB_DATA	pAny
				);

		PBWINAPI(INT, ot_decr_any)
			(
				PRT_THIS 	prtThis,
				POB_DATA	pAny
				);

		PBWINAPI(INT, ot_mod_any)
			(
				PRT_THIS 	prtThis,
				POB_DATA	pResult,
				POB_DATA	pAny1,
				POB_DATA	pAny2
				);

		PBWINAPI(INT, ot_min_any)
			(
				PRT_THIS 	prtThis,
				POB_DATA	pResult,
				POB_DATA	pAny1,
				POB_DATA	pAny2
				);

		PBWINAPI(INT, ot_max_any)
			(
				PRT_THIS 	prtThis,
				POB_DATA	pResult,
				POB_DATA	pAny1,
				POB_DATA	pAny2
				);

		PBWINAPI(INT, ot_check_any_exact_type)
			(
				POB_THIS	obthis,
				POB_DATA	any_var,
				OB_CLASS_ID	expected_type
				);

		PBWINAPI(INT, ot_check_any_string_type)
			(
				POB_THIS	obthis,
				POB_DATA	any_var,
				OB_CLASS_ID	expected_type
				);

		PBWINAPI(INT, ot_check_any_binary_type)
			(
				POB_THIS	obthis,
				POB_DATA	any_var,
				OB_CLASS_ID	expected_type
				);

		PBWINAPI(INT, ot_check_any_math_type)
			(
				POB_THIS	obthis,
				POB_DATA	any_var,
				OB_CLASS_ID	expected_type
				);

		PBWINAPI(INT, ot_check_any_enum_type)
			(
				POB_THIS	obthis,
				POB_DATA	any_var,
				POB_GROUP	current_group,
				OB_CLASS_ID	expected_type
				);

		PBWINAPI(INT, ot_check_any_object_type)
			(
				POB_THIS	obthis,
				POB_DATA	any_var,
				POB_GROUP	current_group,
				OB_CLASS_ID	expected_type
				);

		PBWINAPI(INT, ot_duplicate_any)
			(
				POB_THIS 	pobThis,
				POB_DATA	pAny
				);

		PBWINAPI(INT, ot_abs_any)
			(
				PRT_THIS 	prtThis,
				POB_DATA	pResult,
				POB_DATA	pAny1
				);

		PBWINAPI(INT, ot_ceiling_any)
			(
				PRT_THIS 	prtThis,
				POB_DATA	pResult,
				POB_DATA	pAny1
				);

		PBWINAPI(PSH_BINARY, ot_string_to_binary)
			(
				PRT_THIS       rtThis,        /* Ptr to runtime this */
				LPTSTR         lpStr,         /* Ptr to binary arg */
				int            EncodingType,  // Encoding Type
				BOOL           bNullTerminated = FALSE // is the binary null terminated?
				);

		PBWINAPI(PSH_BINARY, ot_bytearray_to_binary)
			(
				PRT_THIS       rtThis,        /* Ptr to runtime this */
				POB_ARRAY_INST array_inst     /* Ptr to the byte array */
				);

		PBWINAPI(PSH_BINARY, ot_any_to_binary)
			(
				PRT_THIS       rtThis,        /* Ptr to runtime this */
				POB_DATA	   obData     	  /* Ptr to the byte array */
				);
		//****************************************************************************
		// Convert Datatype Support methods
		//****************************************************************************

		INT otitol(POB_THIS obThis, POB_DATA data_node);
		INT otitof(POB_THIS obThis, POB_DATA data_node);
		INT otitod(POB_THIS obThis, POB_DATA data_node);
		INT otitodec(POB_THIS obThis, POB_DATA data_node);
		INT otitoui(POB_THIS obThis, POB_DATA data_node);
		INT otitob(POB_THIS obThis, POB_DATA data_node);
		INT otitoul(POB_THIS obThis, POB_DATA data_node);
		INT otitoll(POB_THIS obThis, POB_DATA data_node);
		INT otltoi(POB_THIS obThis, POB_DATA data_node);
		INT otltof(POB_THIS obThis, POB_DATA data_node);
		INT otltod(POB_THIS obThis, POB_DATA data_node);
		INT otltodec(POB_THIS obThis, POB_DATA data_node);
		INT otltoui(POB_THIS obThis, POB_DATA data_node);
		INT otltob(POB_THIS obThis, POB_DATA data_node);
		INT otltoul(POB_THIS obThis, POB_DATA data_node);
		INT otltoll(POB_THIS obThis, POB_DATA data_node);
		INT otftoi(POB_THIS obThis, POB_DATA data_node);
		INT otftol(POB_THIS obThis, POB_DATA data_node);
		INT otftod(POB_THIS obThis, POB_DATA data_node);
		INT otftodec(POB_THIS obThis, POB_DATA data_node);
		INT otftoui(POB_THIS obThis, POB_DATA data_node);
		INT otftob(POB_THIS obThis, POB_DATA data_node);
		INT otftoul(POB_THIS obThis, POB_DATA data_node);
		INT otftoll(POB_THIS obThis, POB_DATA data_node);
		INT otdtoi(POB_THIS obThis, POB_DATA data_node);
		INT otdtol(POB_THIS obThis, POB_DATA data_node);
		INT otdtof(POB_THIS obThis, POB_DATA data_node);
		INT otdtodec(POB_THIS obThis, POB_DATA data_node);
		INT otdtoui(POB_THIS obThis, POB_DATA data_node);
		INT otdtob(POB_THIS obThis, POB_DATA data_node);
		INT otdtoul(POB_THIS obThis, POB_DATA data_node);
		INT otdtoll(POB_THIS obThis, POB_DATA data_node);
		INT otdectoi(POB_THIS obThis, POB_DATA data_node);
		INT otdectol(POB_THIS obThis, POB_DATA data_node);
		INT otdectof(POB_THIS obThis, POB_DATA data_node);
		INT otdectod(POB_THIS obThis, POB_DATA data_node);
		INT otdectoui(POB_THIS obThis, POB_DATA data_node);
		INT otdectob(POB_THIS obThis, POB_DATA data_node);
		INT otdectoul(POB_THIS obThis, POB_DATA data_node);
		INT otdectoll(POB_THIS obThis, POB_DATA data_node);
		INT otuitoi(POB_THIS obThis, POB_DATA data_node);
		INT otuitob(POB_THIS obThis, POB_DATA data_node);
		INT otuitol(POB_THIS obThis, POB_DATA data_node);
		INT otuitof(POB_THIS obThis, POB_DATA data_node);
		INT otuitod(POB_THIS obThis, POB_DATA data_node);
		INT otuitodec(POB_THIS obThis, POB_DATA data_node);
		INT otuitoul(POB_THIS obThis, POB_DATA data_node);
		INT otuitoll(POB_THIS obThis, POB_DATA data_node);
		INT otultoi(POB_THIS obThis, POB_DATA data_node);
		INT otultol(POB_THIS obThis, POB_DATA data_node);
		INT otultof(POB_THIS obThis, POB_DATA data_node);
		INT otultod(POB_THIS obThis, POB_DATA data_node);
		INT otultodec(POB_THIS obThis, POB_DATA data_node);
		INT otultoui(POB_THIS obThis, POB_DATA data_node);
		INT otultob(POB_THIS obThis, POB_DATA data_node);
		INT otultoll(POB_THIS obThis, POB_DATA data_node);
		INT otlltoi(POB_THIS obThis, POB_DATA data_node);
		INT otlltol(POB_THIS obThis, POB_DATA data_node);
		INT otlltof(POB_THIS obThis, POB_DATA data_node);
		INT otlltod(POB_THIS obThis, POB_DATA data_node);
		INT otlltodec(POB_THIS obThis, POB_DATA data_node);
		INT otlltoui(POB_THIS obThis, POB_DATA data_node);
		INT otlltob(POB_THIS obThis, POB_DATA data_node);
		INT otlltoul(POB_THIS obThis, POB_DATA data_node);
		INT	otctos(POB_THIS obThis, POB_DATA pobData);
		INT	otstoc(POB_THIS obThis, POB_DATA pobData);
		INT	otstocarr(POB_THIS obThis, POB_DATA pobData);
		INT	otcarrtos(POB_THIS obThis, POB_DATA pobData);
		INT otbtoi(POB_THIS obThis, POB_DATA data_node);
		INT otbtoui(POB_THIS obThis, POB_DATA data_node);
		INT otbtol(POB_THIS obThis, POB_DATA data_node);
		INT otbtof(POB_THIS obThis, POB_DATA data_node);
		INT otbtod(POB_THIS obThis, POB_DATA data_node);
		INT otbtodec(POB_THIS obThis, POB_DATA data_node);
		INT otbtoul(POB_THIS obThis, POB_DATA data_node);
		INT otbtoll(POB_THIS obThis, POB_DATA data_node);

		// Miscellaneous

		// Set return value to particular type and set it NULL
		VOID ot_set_null_return
		(
			POB_THIS		obthis,
			OB_CLASS_ID		return_type
		);

		PVOID ot_get_valptr_grp
		(
			POB_THIS                obthis,
			POB_DATA                node,
			OB_GROUP_ID             group_id
		);

		int EndianExchange
		(
			LPTSTR pStr
		);

#ifdef    __cplusplus
	}	// extern "C" {
#endif    /* __cplusplus */


#endif // OTDEFINE_H

// DOINC popped back into header 'rtccode.h'
// ***** DOINC including rtdef.h *****
// **************************************************************************
//
//                            Copyright 1990
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// --------------------------------------------------------------------------
//
//    Filename :    rtdef.h
//
//    Author   :    Jim Kosko
//
//    Purpose  :    #defines for runtime.
//
// **************************************************************************

#ifndef   RTDEF_H
#define   RTDEF_H

#define RT_MAXERROR         250*4              // Maximum error text

// **************************************************************************
//   Error string IDs
// **************************************************************************
#define IDS_RT__BASE_SYSTEM			20000
#define IDS_RT_CAPTION      		IDS_RT__BASE_SYSTEM + 100
#define IDS_RT_FATAL_CAPTION     	IDS_RT__BASE_SYSTEM + 101
#define IDS_RT_FATAL_ERROR     		IDS_RT__BASE_SYSTEM + 102
#define IDS_RT_APPL_ERROR     		IDS_RT__BASE_SYSTEM + 103
#define IDS_RT_EVENT_SUFFIX     	IDS_RT__BASE_SYSTEM + 104
#define IDS_RT_FUNC_SUFFIX			IDS_RT__BASE_SYSTEM + 105
#define IDS_RT_OBJ_SUFFIX	    	IDS_RT__BASE_SYSTEM + 106
#define IDS_RT_OBJ_SUFFIX2	    	IDS_RT__BASE_SYSTEM + 107
#define IDS_RT_CANT_CONTINUE    	IDS_RT__BASE_SYSTEM + 108
#define IDS_RT_R0001        		IDS_RT__BASE_SYSTEM + 501
#define IDS_RT_R0002        		IDS_RT__BASE_SYSTEM + 502
#define IDS_RT_R0003        		IDS_RT__BASE_SYSTEM + 503
#define IDS_RT_R0004        		IDS_RT__BASE_SYSTEM + 504
#define IDS_RT_R0005        		IDS_RT__BASE_SYSTEM + 505
#define IDS_RT_R0006        		IDS_RT__BASE_SYSTEM + 506
#define IDS_RT_R0007        		IDS_RT__BASE_SYSTEM + 507
#define IDS_RT_R0008        		IDS_RT__BASE_SYSTEM + 508
#define IDS_RT_R0009        		IDS_RT__BASE_SYSTEM + 509
#define IDS_RT_R0010        		IDS_RT__BASE_SYSTEM + 510
#define IDS_RT_R0011        		IDS_RT__BASE_SYSTEM + 511
#define IDS_RT_R0012        		IDS_RT__BASE_SYSTEM + 512
#define IDS_RT_R0013        		IDS_RT__BASE_SYSTEM + 513
#define IDS_RT_R0014        		IDS_RT__BASE_SYSTEM + 514
#define IDS_RT_R0015        		IDS_RT__BASE_SYSTEM + 515
#define IDS_RT_R0016        		IDS_RT__BASE_SYSTEM + 516
#define IDS_RT_R0017        		IDS_RT__BASE_SYSTEM + 517
#define IDS_RT_R0018        		IDS_RT__BASE_SYSTEM + 518
#define IDS_RT_R0019        		IDS_RT__BASE_SYSTEM + 519
#define IDS_RT_R0020        		IDS_RT__BASE_SYSTEM + 520
#define IDS_RT_R0021        		IDS_RT__BASE_SYSTEM + 521
#define IDS_RT_R0022        		IDS_RT__BASE_SYSTEM + 522
#define IDS_RT_R0023        		IDS_RT__BASE_SYSTEM + 523
#define IDS_RT_R0024        		IDS_RT__BASE_SYSTEM + 524
#define IDS_RT_R0025        		IDS_RT__BASE_SYSTEM + 525
#define IDS_RT_R0026        		IDS_RT__BASE_SYSTEM + 526
#define IDS_RT_R0027        		IDS_RT__BASE_SYSTEM + 527
#define IDS_RT_R0028        		IDS_RT__BASE_SYSTEM + 528
#define IDS_RT_R0029        		IDS_RT__BASE_SYSTEM + 529
#define IDS_RT_R0030        		IDS_RT__BASE_SYSTEM + 530
#define IDS_RT_R0031        		IDS_RT__BASE_SYSTEM + 531
#define IDS_RT_R0032        		IDS_RT__BASE_SYSTEM + 532
#define IDS_RT_R0033        		IDS_RT__BASE_SYSTEM + 533
#define IDS_RT_R0034        		IDS_RT__BASE_SYSTEM + 534
#define IDS_RT_R0035        		IDS_RT__BASE_SYSTEM + 535
#define IDS_RT_R0036        		IDS_RT__BASE_SYSTEM + 536
#define IDS_RT_R0037        		IDS_RT__BASE_SYSTEM + 537
#define IDS_RT_R0038        		IDS_RT__BASE_SYSTEM + 538
#define IDS_RT_R0039        		IDS_RT__BASE_SYSTEM + 539
#define IDS_RT_R0040        		IDS_RT__BASE_SYSTEM + 540
#define IDS_RT_R0041        		IDS_RT__BASE_SYSTEM + 541
#define IDS_RT_R0042        		IDS_RT__BASE_SYSTEM + 542
#define IDS_RT_R0043        		IDS_RT__BASE_SYSTEM + 543
#define IDS_RT_R0044        		IDS_RT__BASE_SYSTEM + 544
#define IDS_RT_R0045        		IDS_RT__BASE_SYSTEM + 545
#define IDS_RT_R0046        		IDS_RT__BASE_SYSTEM + 546
#define IDS_RT_R0047        		IDS_RT__BASE_SYSTEM + 547
#define IDS_RT_R0048        		IDS_RT__BASE_SYSTEM + 548
#define IDS_RT_R0049        		IDS_RT__BASE_SYSTEM + 549
#define IDS_RT_R0050        		IDS_RT__BASE_SYSTEM + 550
#define IDS_RT_R0051        		IDS_RT__BASE_SYSTEM + 551
#define IDS_RT_R0052        		IDS_RT__BASE_SYSTEM + 552
#define IDS_RT_R0053        		IDS_RT__BASE_SYSTEM + 553
#define IDS_RT_R0054        		IDS_RT__BASE_SYSTEM + 554
#define IDS_RT_R0055        		IDS_RT__BASE_SYSTEM + 555
#define IDS_RT_R0056        		IDS_RT__BASE_SYSTEM + 556
#define IDS_RT_R0057        		IDS_RT__BASE_SYSTEM + 557
#define IDS_RT_R0058        		IDS_RT__BASE_SYSTEM + 558
#define IDS_RT_R0059        		IDS_RT__BASE_SYSTEM + 559
#define IDS_RT_R0060        		IDS_RT__BASE_SYSTEM + 560
#define IDS_RT_R0061        		IDS_RT__BASE_SYSTEM + 561
#define IDS_RT_R0062        		IDS_RT__BASE_SYSTEM + 562
#define IDS_RT_R0063        		IDS_RT__BASE_SYSTEM + 563
#define IDS_RT_R0064        		IDS_RT__BASE_SYSTEM + 564
#define IDS_RT_R0065        		IDS_RT__BASE_SYSTEM + 565
#define IDS_RT_R0066        		IDS_RT__BASE_SYSTEM + 566
#define IDS_RT_R0067        		IDS_RT__BASE_SYSTEM + 567
#define IDS_RT_R0068        		IDS_RT__BASE_SYSTEM + 568
#define IDS_RT_R0069        		IDS_RT__BASE_SYSTEM + 569
#define IDS_RT_R0070        		IDS_RT__BASE_SYSTEM + 570
#define IDS_RT_R0071        		IDS_RT__BASE_SYSTEM + 571
#define IDS_RT_R0072        		IDS_RT__BASE_SYSTEM + 572
#define IDS_RT_R0073        		IDS_RT__BASE_SYSTEM + 573
#define IDS_RT_R0074        		IDS_RT__BASE_SYSTEM + 574
#define IDS_RT_R0075        		IDS_RT__BASE_SYSTEM + 575
#define IDS_RT_R0076        		IDS_RT__BASE_SYSTEM + 576
#define IDS_RT_R0077        		IDS_RT__BASE_SYSTEM + 577
#define IDS_RT_R0078        		IDS_RT__BASE_SYSTEM + 578
#define IDS_RT_R0079        		IDS_RT__BASE_SYSTEM + 579
#define IDS_RT_R0080        		IDS_RT__BASE_SYSTEM + 580
#define IDS_RT_R0081        		IDS_RT__BASE_SYSTEM + 581
#define IDS_RT_R0082        		IDS_RT__BASE_SYSTEM + 582
#define IDS_RT_R0083        		IDS_RT__BASE_SYSTEM + 583
#define IDS_RT_R0084        		IDS_RT__BASE_SYSTEM + 584
#define IDS_RT_R0085        		IDS_RT__BASE_SYSTEM + 585
#define IDS_RT_R0086        		IDS_RT__BASE_SYSTEM + 586
#define IDS_RT_R0087        		IDS_RT__BASE_SYSTEM + 587
#define IDS_RT_R0088        		IDS_RT__BASE_SYSTEM + 588
#define IDS_RT_R0089        		IDS_RT__BASE_SYSTEM + 589
#define IDS_RT_R0090        		IDS_RT__BASE_SYSTEM + 590
#define IDS_RT_R0091        		IDS_RT__BASE_SYSTEM + 591
#define IDS_RT_R0092        		IDS_RT__BASE_SYSTEM + 592
#define IDS_RT_R0093        		IDS_RT__BASE_SYSTEM + 593
#define IDS_RT_R0094        		IDS_RT__BASE_SYSTEM + 594
#define IDS_RT_R0095        		IDS_RT__BASE_SYSTEM + 595
#define IDS_RT_R0096        		IDS_RT__BASE_SYSTEM + 596
#define IDS_RT_R0097        		IDS_RT__BASE_SYSTEM + 597
#define IDS_RT_R0098        		IDS_RT__BASE_SYSTEM + 598
#define IDS_RT_R0099        		IDS_RT__BASE_SYSTEM + 599
#define IDS_RT_R0100        		IDS_RT__BASE_SYSTEM + 600
#define IDS_RT_R0101        		IDS_RT__BASE_SYSTEM + 601
#define IDS_RT_R0102        		IDS_RT__BASE_SYSTEM + 602
#define IDS_RT_R0103        		IDS_RT__BASE_SYSTEM + 603
#define IDS_RT_R0104				IDS_RT__BASE_SYSTEM + 604
#define IDS_RT_R0105				IDS_RT__BASE_SYSTEM + 605
#define IDS_RT_R0106				IDS_RT__BASE_SYSTEM + 606
#define IDS_RT_R0107                IDS_RT__BASE_SYSTEM + 607
#define IDS_RT_R0108                IDS_RT__BASE_SYSTEM + 608  //CR387060, out of memory error
#define IDS_RT_R0109				IDS_RT__BASE_SYSTEM + 609
// **************************************************************************
//   Start of system errors
// **************************************************************************
#define IDS_FRT_SYSTEM       		25000
#define IDS_FRT_R000                IDS_FRT_SYSTEM + 0
#define IDS_FRT_R001                IDS_FRT_SYSTEM + 1
#define IDS_FRT_R002                IDS_FRT_SYSTEM + 2
#define IDS_FRT_R003                IDS_FRT_SYSTEM + 3
#define IDS_FRT_R004                IDS_FRT_SYSTEM + 4
#define IDS_FRT_R005                IDS_FRT_SYSTEM + 5
#define IDS_FRT_R006                IDS_FRT_SYSTEM + 6
#define IDS_FRT_R007                IDS_FRT_SYSTEM + 7
#define IDS_FRT_R008                IDS_FRT_SYSTEM + 8
#define IDS_FRT_R009                IDS_FRT_SYSTEM + 9
#define IDS_FRT_R0010               IDS_FRT_SYSTEM + 10

#define IDS_RTDB_ERRNULL    		IDS_FRT_SYSTEM + 11
#define IDS_RTDB_ERR001     		IDS_FRT_SYSTEM + 12
#define IDS_RTDB_ERR002     		IDS_FRT_SYSTEM + 13

#define	IDS_FRT_R0011				IDS_FRT_SYSTEM + 14
#define	IDS_FRT_R0012				IDS_FRT_SYSTEM + 15

#define IDS_RTDB_ERR003     		IDS_FRT_SYSTEM + 703
#define IDS_RTDB_ERR004     		IDS_FRT_SYSTEM + 704
#define IDS_RTDB_ERR005     		IDS_FRT_SYSTEM + 705
#define IDS_RTDB_ERR006     		IDS_FRT_SYSTEM + 706
#define IDS_RTDB_ERR007     		IDS_FRT_SYSTEM + 707
#define IDS_RTDB_ERR008     		IDS_FRT_SYSTEM + 708
#define IDS_RTDB_ERR009     		IDS_FRT_SYSTEM + 709
#define IDS_RTDB_ERR010     		IDS_FRT_SYSTEM + 710
#define IDS_RTDB_ERR011     		IDS_FRT_SYSTEM + 711
#define IDS_RTDB_ERR012     		IDS_FRT_SYSTEM + 712
#define IDS_RTDB_ERR013     		IDS_FRT_SYSTEM + 713
#define IDS_RTDB_ERR014     		IDS_FRT_SYSTEM + 714
#define IDS_RTDB_ERR015          	IDS_FRT_SYSTEM + 715
#define IDS_RTDB_ERR016          	IDS_FRT_SYSTEM + 716
#define IDS_RTDB_ERR017          	IDS_FRT_SYSTEM + 717
#define IDS_RTDB_ERR018          	IDS_FRT_SYSTEM + 718
#define IDS_RTDB_ERR019          	IDS_FRT_SYSTEM + 719
#define IDS_RTDB_ERR020          	IDS_FRT_SYSTEM + 720

#define IDS_LK_OBJ_SUFFIX			IDS_FRT_SYSTEM + 800
#define IDS_LK_R0001				IDS_FRT_SYSTEM + 901
#define IDS_LK_R0002				IDS_FRT_SYSTEM + 902
#define IDS_LK_R0003				IDS_FRT_SYSTEM + 903
#define IDS_LK_R0004				IDS_FRT_SYSTEM + 904
#define IDS_LK_R0005				IDS_FRT_SYSTEM + 905
#define IDS_LK_R0006				IDS_FRT_SYSTEM + 906
#define IDS_LK_R0007				IDS_FRT_SYSTEM + 907
#define IDS_LK_R0008				IDS_FRT_SYSTEM + 908
#define IDS_LK_R0009				IDS_FRT_SYSTEM + 909
#define IDS_LK_R0010				IDS_FRT_SYSTEM + 910

#define IDS_LK_SYSTEM       		IDS_FRT_SYSTEM + 951
#define IDS_LK_R0051				IDS_FRT_SYSTEM + 951
#define IDS_LK_R0052				IDS_FRT_SYSTEM + 952
#define IDS_LK_R0053				IDS_FRT_SYSTEM + 953
#define IDS_LK_R0054				IDS_FRT_SYSTEM + 954
#define IDS_LK_R0055				IDS_FRT_SYSTEM + 955
#define IDS_LK_R0056				IDS_FRT_SYSTEM + 956
#define IDS_LK_R0057				IDS_FRT_SYSTEM + 957
#define IDS_LK_R0058				IDS_FRT_SYSTEM + 958
#define IDS_LK_R0059				IDS_FRT_SYSTEM + 959
#define IDS_LK_R0060				IDS_FRT_SYSTEM + 960
#define IDS_LK_R0061				IDS_FRT_SYSTEM + 961
#define IDS_ERR_EVENT				IDS_FRT_SYSTEM + 962

#endif    // RTDEF_H
// DOINC popped back into header 'rtccode.h'
// ***** DOINC including rtpublic.h *****
	// DOINC skipping duplicate include
// ***** DOINC including rtdbsem.h *****
// $RCSfile: rtdbsem.h $;$Revision: 4.24 $
// **************************************************************************
//
//                 Copyright Powersoft Corporation 1992
//
//       Powersoft Corporation ("Powersoft") claims copyright in this
//     program and documentation as an unpublished work, versions of
//     which were first licensed on the date indicated in the foregoing
//     notice. Claim of copyright does not imply waiver of Powersoft's
//     other rights. See Notice of Proprietary Rights.
//
//                 NOTICE OF PROPRIETARY RIGHTS
//
//       This program and documentation are confidential trade
//     secrets and the property of Powersoft.  Use, examination,
//     reproduction, copying, disassembly, decompilation, transfer
//     and/or disclosure to others are strictly prohibited except by
//     express written agreement with Powersoft.
//
// ---------------------------------------------------------------------------
//
//    Filename :  rtdbsem.h
//
//    Author   :  Jack Lull
//
//    Purpose  :  Header file for DB runtime.
//
//***************************************************************************

#ifndef   RTDB_DEF_H
#define   RTDB_DEF_H

#ifndef PBSTG_H
// ***** DOINC including pbstg.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OSTIME_H
// ***** DOINC including ostime.h *****
	// DOINC skipping duplicate include
#endif
#ifndef SHLIST_H
// ***** DOINC including shlist.h *****
	// DOINC skipping duplicate include
#endif

// If we are generating C code then do NOT include this header!!!!
// DOINC told to skip 4 lines...

#ifndef RTTHREAD_H
// ***** DOINC including rtthread.h *****
//**************************************************************************
//
//                    Copyright 1989 - 1994 Powersoft Corporation
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM POWERSOFT CORPORATION.
//
// ------------------------------------------------------------------------
//
//    Filename :	rtthread.h
//
//    Author   :	Jordan Olin
//
//    Purpose  : 	Private definitions for threaded p-code engine
//
//****************************************************************************

#ifndef RTTHREAD_H
#define RTTHREAD_H

//****************************************************************************
// Assume C declarations for C++
//****************************************************************************

#ifndef OBDEFINE_H
// ***** DOINC including obdefine.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBTYPDEF_H
// ***** DOINC including obtypdef.h *****
	// DOINC skipping duplicate include
#endif
#ifndef RTPUBLIC_H
// ***** DOINC including rtpublic.h *****
	// DOINC skipping duplicate include
#endif
#ifndef RTTHIS_H
// ***** DOINC including rtthis.h *****
	// DOINC skipping duplicate include
#endif
#ifndef   RTDEF_H
// ***** DOINC including rtdef.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OTEXPR_H
// ***** DOINC including otexpr.h *****
	// DOINC skipping duplicate include
#endif

#ifdef __cplusplus
	extern "C" {
#endif	/* __cplusplus */

#define PPSHLIST PSHLIST FAR *
		//
		// Define CATCH/THROW Macros for either mode
		// (Threaded or non-Threaded)
		//
#ifdef PBOS_LINUX
#define	RT_THROW_NONTHREAD( rtcatbuf ) Throw( (jmp_buf&)(rtcatbuf), -1 )
#else
#define	RT_THROW_NONTHREAD( rtcatbuf ) Throw( (LPCATCHBUF) (rtcatbuf), -1 )
#endif

#if defined(PBWIN32) && !defined(PBOS_MAC)

#include <setjmp.h>

#ifdef __WATCOMC__
		typedef unsigned int _JBTYPE;
#endif /* __WATCOMC__ */

#ifndef CATCHBUF_DEFINED
#define CATCHBUF_DEFINED
		typedef jmp_buf CATCHBUF;
		typedef _JBTYPE FAR* LPCATCHBUF;
#endif // CATCHBUF_DEFINED

#define Catch(env) setjmp(env)
#define Throw(env,res) longjmp(env,res)

#else /* !PBWIN32 */

#if !defined(_INC_WINDOWS)
#ifndef CATCHBUF_DEFINED
#define CATCHBUF_DEFINED
		typedef int CATCHBUF[9];
		typedef int FAR* LPCATCHBUF;
#endif // CATCHBUF_DEFINED

		PBWINAPI(INT, Catch)
			(int FAR*);
		PBWINAPI(VOID, Throw)
			(const int FAR*, int);
#endif /* _INC_WINDOWS */
#endif /* PBWIN32 */

		/****************************************************************************/
		/*                                                                          */
		/* If we are building for the non-threaded engine, than the semantic        */
		/* functions should have the "this" pointer and pcode stream as arguments.  */
		/*                                                                          */
		/****************************************************************************/

#define RT_SF_DECL(func_name) \
INT FAR_DECL func_name

#define RT_SEMFUN_ARGS 	\
	PRT_THIS		semThis, \
	POB_PCODE_NODE	semPCode, \
	POB_THIS semOBThis, \
	POT_EVAL_NODE semRegs, \
	BOOL semTrace

#define RT_SEMFUN_RESULT	INT

#define RT_DEFINE_RET(varname, init) \
	RT_SEMFUN_RESULT	varname	=	init

#ifndef RT_ENGINE

/****************************************************************************/
/*																			*/
/* Structure and array used to hold address of semantic functions			*/
/*																			*/
/****************************************************************************/

		typedef	RT_SEMFUN_RESULT(FAR_DECL* prt_semfun_PROC) (RT_SEMFUN_ARGS);

		typedef struct prt_semfun_struc_tag {
			prt_semfun_PROC	semFunc;			// pointer to the semantic function
			UINT	semArgs;
			INT		semStackEffect;
		}	rt_semfun_struc, FAR_DECL* Prt_semfun_struc;
#define	rt_semfun_POW2	3
		extern	rt_semfun_struc	rt_semfun_array[];

#endif /* RT_ENGINE */

#define	semPCodeOp1		ob_get_pcode_op1(semOBThis, semPCode)
#define	semPCodeOp2		ob_get_pcode_op2(semOBThis, semPCode)
#define	semPCodeOp3		ob_get_pcode_op3(semPBThis, semPCode)
#define	semPCodeOp4		ob_get_pcode_op4(semPBThis, semPCode)
#define	semPCodeOp5		ob_get_pcode_op5(semPBThis, semPCode)
#define	semRet			ret
#define semReg(rtthis, rgnum)	(POT_EVAL_NODE) semRegs
#define	semPCodeArgs	rt_semfun_array.semArgs
#define	semFunArray		rt_semfun_array.semFunc

#define RT_ENTER_THREAD( pcode_id )

#define RT_NEXT_PCODE(retcode, no_args) return (retcode)

#define RT_JUMP_PCODE

#define RT_JUMP_BP_FUNC(bpnode)

#define	RT_THROW_THREAD( rtcatbuf, resvar, rescode )	\
			{ \
			return rescode;\
			}

#ifdef PBOS_LINUX
#define	RT_CATCH_NONTHREAD( rtcatbuf ) Catch( rtcatbuf )
#else
#define	RT_CATCH_NONTHREAD( rtcatbuf ) Catch( (LPCATCHBUF) rtcatbuf )
#endif


		/****************************************************************************/
		/*                                                                          */
		/* Register handling macros													*/
		/*                                                                          */
		/****************************************************************************/

		// we need to ensure that decimals doubles and longlongs are moved correctly
#define rt_get_node_from_reg(rtthis, rgnum, value) \
		{ \
		*((POT_EVAL_NODE) (value)) = *((POT_EVAL_NODE) (semReg(rtthis, rgnum))); \
		if (ob_get_data_group (&((value)->data)) != OB_ARRAY)	\
			{	\
			switch(ob_get_data_type (&((value)->data))) \
				{ \
				case DOUBLE_TYPE: \
					ob_set_data_ptr_val (&((value)->data), &ot_get_eval_double (value)); \
					break; \
				case LONGLONG_TYPE: \
					ob_set_data_ptr_val (&((value)->data), &ot_get_eval_longlong (value)); \
					break; \
				case DEC_TYPE: \
					ob_set_data_ptr_val (&((value)->data), &ot_get_eval_dec (value)); \
					break; \
				} \
			}	\
		}

#ifdef __cplusplus
	}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif /* RTTHREAD_H */


// DOINC popped back into header 'rtdbsem.h'
#endif
#ifndef   RTDB_PUB_DEF_H
// ***** DOINC including rtdbpub.h *****
//
// **************************************************************************
//
//                 Copyright Powersoft Corporation 1991
//
//       Powersoft Corporation ("Powersoft") claims copyright in this
//     program and documentation as an unpublished work, versions of
//     which were first licensed on the date indicated in the foregoing
//     notice. Claim of copyright does not imply waiver of Powersoft's
//     other rights. See Notice of Proprietary Rights.
//
//                 NOTICE OF PROPRIETARY RIGHTS
//
//       This program and documentation are confidential trade
//     secrets and the property of Powersoft.  Use, examination,
//     reproduction, copying, disassembly, decompilation, transfer
//     and/or disclosure to others are strictly prohibited except by
//     express written agreement with Powersoft.
//
// ---------------------------------------------------------------------------
//
//    Filename :  rtdbpub.h
//
//    Author   :  Jack Lull
//
//    Purpose  :  Public header file for DB runtime.
//
//***************************************************************************

#ifndef   RTDB_PUB_DEF_H
#define   RTDB_PUB_DEF_H

//***************************************************************************
//  Includes
//***************************************************************************
// ***** DOINC including pbglue.h *****
// $Header
/////////////////////////////////////////////////////////////////////////////// 
//
//
//   COPYRIGHT POWERSOFT CORPORATION 1990-1993
//
//   POWERSOFT CORPORATION ("POWERSOFT") CLAIMS COPYRIGHT IN THIS
//   PROGRAM AND DOCUMENTATION AS AN UNPUBLISHED WORK, VERSIONS OF
//   WHICH WERE FIRST LICENSED ON THE DATE INDICATED IN THE FOREGOING
//   NOTICE.   CLAIM OF COPYRIGHT DOES NOT IMPLY WAIVER OF POWERSOFT'S
//   OTHER RIGHTS.
//
// --------------------------------------------------------------------------
//
//   Filename  : pbglue.h
//
//   Author    : Scott Marlow
//
//   Purpose   : Contains macros that help make it easier to write code that is
//               portable to the Windows Portable win32 api.
//               Note that these macros assume common variables names
//               for wParam + lParam of wParam + lParam within a window proc.
//
/////////////////////////////////////////////////////////////////////////////// 

#ifndef _PB_ELMERS_GLUE_h_
#define _PB_ELMERS_GLUE_h_

#ifdef PBOS_WIN       // Need fixup code for calling C++ methods in a
					  // separate DLL under Win16. Winsock and OpenServer
					  // drivers operate this way.
#define PBEXPORT      __export
#else
#define PBEXPORT 
#endif

#ifdef PBOS_UNIX
#define PBGETWINDOWDC(h) GetDC(h)
#else
#define PBGETWINDOWDC(h) GetWindowDC(h)
#endif

// allow for interlocked calls on these cooperatively multi-tasking OS's
//#if defined(PBOS_WIN) || defined(PBOS_MAC)
//#define InterlockedIncrement(pLong)	(++(*(pLong)))
//#define InterlockedDecrement(pLong) (--(*(pLong)))
//#endif

// define the following def if the operating system can support our ThreadLocal Storage macros (written against win32)
#if defined(PBOS_NT) || defined(PBOS_UNIX) // gmoison -added unix
#define PBOS_PROPERTY_THREADLOCALSTORAGE        // can use thread local storage
#endif


// move these tls macros to pbglue.h
#ifdef PBOS_PROPERTY_THREADLOCALSTORAGE
#if defined(PBOS_NT) || defined(PBOS_UNIX) // gmoison -added unix

// this macro declares the thread local storage work variable that will be used
// to reference a particular thread local storage value.
//
// warning:  Thread local storage is a limited resource and in the case of distributed PB the threads are used with different
//           rtThis's which means that thread storage will not persist longer then a distributed pb method call.
// 
// example of using thread local storage macros;
// // this is outside of c code (block level 0)
// PBOS_TLS_DECLARE_VARIABLE(tls_glob_pRTThis)
// dll_init() 
// {
// bool bflag;
// PBOS_TLS_ALLOC_VARIABLE(tls_glob_pRTThis,bflag) if(!bflag) exit();
// }
//
// thread_init()
// {
// PRTTHIS rtthis = new runtime;
// PBOS_TLS_SETVALUE_VARIABLE(tls_glob_pRTThis,rthis)
// }
//
// action()
// {
// PRTTHIS rrthis;
// PBOS_TLS_GETVALUE_VARIABLE(tls_glob_pRTThis,rthis)
// }
//
// dll_uninit()
// {
// bool bflag;
// PBOS_TLS_FREE_VARIABLE(tls_glob_pRTThis,bflag) 
// }
#ifndef PS_WINFREE
#define PBOS_TLS_DECLARE_VARIABLE(name)  DWORD name;

#define PBOS_TLS_ALLOC_VARIABLE(name,bFlagSetToTRUEIfSuccess)\
    { (name) = TlsAlloc();(bFlagSetToTRUEIfSuccess) = (TLS_OUT_OF_INDEXES != (name));}

#define PBOS_TLS_FREE_VARIABLE(name,bFlagSetToTRUEIfSuccess)\
    { bFlagSetToTRUEIfSuccess = TlsFree( (name)); }

#define PBOS_TLS_SETVALUE_VARIABLE(name,lpValue)\
    { TlsSetValue( (name), (LPVOID) (lpValue) ); }

#define PBOS_TLS_GETVALUE_VARIABLE(name,lpValue)\
    { (lpValue) = TlsGetValue( (name) ); }
#else
	void pb_winfree_tls_setvalue_variable(DWORD name, LPVOID lpValue);
	void pb_winfree_tls_getvalue_variable(DWORD name, LPVOID* lpValue);
	void pb_winfree_tls_free_variable(DWORD name, BOOL* bFlagSetToTRUEIfSuccess);
	void pb_winfree_tls_alloc_variable(DWORD* name, BOOL* bFlagSetToTRUEIfSuccess);

#define PBOS_TLS_DECLARE_VARIABLE(name)  DWORD name;
#define PBOS_TLS_ALLOC_VARIABLE(name,bFlagSetToTRUEIfSuccess) pb_winfree_tls_alloc_variable(&name,&bFlagSetToTRUEIfSuccess);
#define PBOS_TLS_FREE_VARIABLE(name,bFlagSetToTRUEIfSuccess) pb_winfree_tls_free_variable(name,&bFlagSetToTRUEIfSuccess);
#define PBOS_TLS_SETVALUE_VARIABLE(name,lpValue) pb_winfree_tls_setvalue_variable(name,lpValue);
#define PBOS_TLS_GETVALUE_VARIABLE(name,lpValue) pb_winfree_tls_getvalue_variable(name,&lpValue);
#endif
#endif
	// PBOS_NT -END

#else   // PBOS_PROPERTY_THREADLOCALSTORAGE
#define PBOS_TLS_DECLARE_VARIABLE(name)
#define PBOS_TLS_ALLOC_VARIABLE(name,bFlagSetToTRUEIfSuccess)
#define PBOS_TLS_FREE_VARIABLE(name,bFlagSetToTRUEIfSuccess)
#define PBOS_TLS_SETVALUE_VARIABLE(name,lpValue) 
#define PBOS_TLS_GETVALUE_VARIABLE(name,lpValue)
#endif // PBOS_PROPERTY_THREADLOCALSTORAGE

#ifdef PBWIN32
// The following macros are for locking a resource within a single process
// (multiple threads are assumed or else the locking would be unneccesary)
#define PBOS_SEMAPHORE_ACQUIRED 0
#define PBOS_CRITICAL_SECTION CRITICAL_SECTION
#define PBOS_EXCLUSIVE_LOCK_DECLARE_VARIABLE(name) PBOS_CRITICAL_SECTION name;
#define PBOS_EXCLUSIVE_LOCK_DECLAREEXTERNAL_VARIABLE(name) extern PBOS_CRITICAL_SECTION name;
#define PBOS_EXCLUSIVE_LOCK_INIT(ref)  InitializeCriticalSection(&ref)
#define PBOS_EXCLUSIVE_LOCK_FREE(ref)  DeleteCriticalSection(&ref)
#define PBOS_EXCLUSIVE_LOCK_BEGIN_OWNERSHIP(ref) EnterCriticalSection(&ref)
#define PBOS_EXCLUSIVE_LOCK_END_OWNERSHIP(ref) LeaveCriticalSection(&ref)
#define PBOS_SEMAPHORE_INIT(handle,security,initcount,maxcount,name) \
                            handle = CreateSemaphore(security,initcount,maxcount,name)
#define PBOS_SEMAPHORE_ACQUIRE_LOCK(handle,wait_time) WaitForSingleObject(handle,wait_time)
#define PBOS_SEMAPHORE_RELEASE_LOCK(handle,count,prev_count) ReleaseSemaphore(handle,count,prev_count)
#define PBOS_SEMAPHORE_FREE(handle) CloseHandle(handle)
#else
// Dummy struct sizeof(NT CRITICAL_SECTION) to maintain same size across platforms
	typedef struct PBOS_CRITICAL_SECTION
	{
		long DebugWord;            // roughly speaking...what's inside a critical_section object
		long LockCount;
		long RecursionCount;
		long OwningThread;        // from the thread's ClientId->UniqueThread
		long LockSemaphore;
		long Reserved;
	} PBOS_CRITICAL_SECTION;
#define PBOS_SEMAPHORE_ACQUIRED 0
#define PBOS_EXCLUSIVE_LOCK_DECLARE_VARIABLE(name)
#define PBOS_EXCLUSIVE_LOCK_DECLAREEXTERNAL_VARIABLE(name)
#define PBOS_EXCLUSIVE_LOCK_INIT(ref)
#define PBOS_EXCLUSIVE_LOCK_FREE(ref)
#define PBOS_EXCLUSIVE_LOCK_BEGIN_OWNERSHIP(ref)
#define PBOS_EXCLUSIVE_LOCK_END_OWNERSHIP(ref)
#define PBOS_SEMAPHORE_INIT(handle,security,initcount,maxcount,name) 
#define PBOS_SEMAPHORE_ACQUIRE_LOCK(handle,wait_time) (DWORD) 0;
#define PBOS_SEMAPHORE_RELEASE_LOCK(handle,count,prev_count) 
#define PBOS_SEMAPHORE_FREE(handle)
#endif


#ifdef PBWIN32

#if defined(PSVER_D)
#define OSOpenDebugConsole() AllocConsole()
#define OSCloseDebugConsole() FreeConsole()
#define OSDeclareOUTPUTVariable()  HANDLE consoleStdOut = GetStdHandle(STD_OUTPUT_HANDLE)
#define OSWriteDebugConsole(lpszMessage) { DWORD cnt; WriteFile(consoleStdOut,lpszMessage,pbstg_strlen(lpszMessage),&cnt,0);}
#else
#define OSOpenDebugConsole() 
#define OSCloseDebugConsole() 
#define OSDeclareOUTPUTVariable()  
#define OSWriteDebugConsole(lpszMessage)
#endif

	// The following DDE macros should only be used if the message at hand
	// has been Posted, since Powerbuilder internally uses SendMessage, these
	// macros shouldn't be used for internal DDE communications through painters.
	// define some DDE helper macros
	typedef struct         // the values in this structure correspond to the parameters
	{                   // that are required to pack/unpack the lparam parameter
						// on Posted DDE messages.  This structure is used
						// in the macros below for dealing with DDE.
		unsigned int uMsg,  // DDE message that is/was posted (see SDK PackDDElParam()).
			uLow,          // lower order word of lParam
			uHigh;         // high order word of lParam
	}
	PBWM_DDE_PACKING_INFO, * pPBWM_DDE_PACKING_INFO;
	// stick this macro in your function with other local auto variables.
	// ie;  myproc(...) { int x; PBDEFINE_DDEHELPER_STORAGE(packedlParam);...}
#define PBDEFINE_DDEHELPER_STORAGE(var_name_will_be) PBWM_DDE_PACKING_INFO var_name_will_be;
// pass in the variable name as defined with 'PBDEFINE_DDEHELPER_STORAGE'
// and the message at hand (WM_DDE_POKE,...) and if you are going to
// do a postmessage fill in the low and high values with whatever you
// want sent for lParam
#define DO_PREPARE_DDEHELPER_STORAGE(var_name_will_be,msg,low,high) \
     {var_name_will_be.uMsg = msg;   \
      var_name_will_be.uLow = low;   \
      var_name_will_be.uHigh = high; \
     }      

   // makes the call to the Windows UnpackDDElParam api call to unpack
   // the lparam value into the PBWM_DDE_PACKING_INFO (var_name_will_be)
   // storage.
#define DO_UNPACK_DDEHELPER_STORAGE(var_name_will_be,lparam) \
      UnpackDDElParam(var_name_will_be.uMsg,    \
                      lparam,                   \
                      &var_name_will_be.uLow,   \
                      &var_name_will_be.uHigh );

#define DO_FREE_DDELPARAM(var_name_will_be, lparam) \
      FreeDDElParam(var_name_will_be.uMsg, lParam);

   // These macros are used for dissecting lParam + wParam arguments received
   // inside of a Window Callback Procedure for the indicated message.
#define PBWM_COMMAND_NOTIFY_CODE           (HIWORD(wParam))
#define PBWM_COMMAND_CONTROL_HANDLE        (HWND)(lParam)
#define PBWM_COMMAND_CONTROL_ID            (LOWORD(wParam))
#define PBWM_ACTIVATEAPP_ACTIVE            (wParam)
#define PBWM_ACTIVATEAPP_TASK              (lParam)
#define PBWM_VSCROLL_SCROLLCODE            (LOWORD(wParam))
#define PBWM_VSCROLL_POS                   (HIWORD(wParam))
#define PBWM_VSCROLL_CONTROL_HANDLE        (HWND)(lParam)
#define PBWM_HSCROLL_SCROLLCODE            (LOWORD(wParam))
#define PBWM_HSCROLL_POS                   (HIWORD(wParam))
#define PBWM_HSCROLL_CONTROL_HANDLE        (HWND)(lParam)
#define PBWM_PARENTNOTIFY_EVENTFLAGS       (LOWORD(wParam))
#define PBWM_PARENTNOTIFY_CHILD_HANDLE     (lParam)
#define PBWM_PARENTNOTIFY_CHILD_ID         (HIWORD(wParam))
#define PBWM_PARENTNOTIFY_CURSOR_X         (LOWORD(lParam))
#define PBWM_PARENTNOTIFY_CURSOR_Y         (HIWORD(lParam))
#define PBWM_DDE_POKE_WND_HANDLE           (wParam)
#define PBWM_DDE_POKE_DATA_HANDLE(var_name_will_be)   (var_name_will_be.uLow)
#define PBWM_DDE_POKE_DATA_ITEMNAME(var_name_will_be) (var_name_will_be.uHigh)
#define PBWM_MDIACTIVATE_HWNDACT           ((HWND)lParam)
#define PBWM_MDIACTIVATE_HWNDDEACT         ((HWND)wParam)
#define PBWM_MENUSELECT_ID                 ((UINT)LOWORD(wParam))
#define PBWM_MENUSELECT_POPUP_HMENU        (GetSubMenu((HMENU)lParam, LOWORD(wParam)))
#define PBWM_MENUSELECT_FLAGS              ((UINT)HIWORD(wParam))
#define PBWM_MENUSELECT_HMENU              ((HMENU)lParam)
#define PBWM_CTL_COLOR_HANDLE        	  (HWND)(lParam)
#define PBWM_ACTIVATE_ACTFLAG			  (LOWORD(wParam))
#define PBWM_ACTIVATE_MINFLAG			  (HIWORD(wParam))
#define PBWM_ACTIVATE_HWNPREV              (lParam)

// The DO_* macros are replacements for function calls
// or macros that are not portable to NT.
#define DO_EM_LINESCROLL(hWnd, cxScroll, cyScroll) \
			SendMessage(hWnd,EM_LINESCROLL,cxScroll,cyScroll)

#define DO_EM_GETSEL(hWnd, lpdwStart, lpdwEnd) \
   			SendMessage(hWnd, EM_GETSEL, (WPARAM)(LPDWORD)(lpdwStart), (LPARAM)(LPDWORD)(lpdwEnd))

#define DO_EM_SETSEL(hWnd, fScroll, iStart, iEnd) \
                  { \
                  SendMessage(hWnd,EM_SETSEL,iStart,iEnd); \
                  if(!fScroll) \
                     SendMessage(hWnd,EM_SCROLLCARET,0,0); \
                  }

#define DO_LB_SETSEL(hWnd, bState, wIndex) \
               SendMessage(hWnd,LB_SETSEL,(WPARAM)bState,(LPARAM)wIndex)

#define DO_WM_VSCROLL(hWnd, wScrollCode, nPos) \
               SendMessage(hWnd, WM_VSCROLL, MAKELONG(wScrollCode,nPos), 0)

#define DO_WM_HSCROLL(hWnd, wScrollCode, nPos) \
               SendMessage(hWnd, WM_HSCROLL, MAKELONG(wScrollCode,nPos), 0)

#define DO_MAKEPOINT(ptGuy,lValue) {ptGuy.x = LOWORD(lValue);ptGuy.y = HIWORD(lValue);}

#define DO_GETWINDOW_ID(hwnd)  (GetWindowLong (hwnd, GWL_ID))

#define DO_SETCLASS_CURSOR(hwnd,hcursor) (SetClassLong(hwnd,GCL_HCURSOR,(LONG)(hcursor)))

#define DO_GETCLASS_CURSOR(hwnd) (GetClassLong(hwnd,GCL_HCURSOR))

#define DO_SETCLASS_ICON(hwnd,hicon) (SetClassLong(hwnd,GCL_HICON,(LONG)(hicon)))

#define DO_GETCLASS_ICON(hwnd) (GetClassLong(hwnd,GCL_HICON))

#define DO_WM_COMMAND(hWnd,NotifyCode,CtrlHdl,CtrlId) \
               SendMessage(hWnd,WM_COMMAND,MAKELONG((WORD)(CtrlId),(WORD)(NotifyCode)),(LPARAM)(CtrlHdl))

#define DO_WM_COMMANDPost(hWnd,NotifyCode,CtrlHdl,CtrlId) \
               PostMessage(hWnd,WM_COMMAND,MAKELONG((WORD)(CtrlId),(WORD)(NotifyCode)),(LPARAM)(CtrlHdl))

#define DO_COMMAND(hWnd,MsgId,NotifyCode,CtrlHdl,CtrlId) \
               SendMessage(hWnd,MsgId,MAKELONG(CtrlId,NotifyCode),CtrlHdl)

#define DO_COMMANDPost(hWnd,MsgId,NotifyCode,CtrlHdl,CtrlId) \
               PostMessage(hWnd,MsgId,MAKELONG(CtrlId,NotifyCode),(LPARAM)CtrlHdl)

#define DO_WM_MENUSELECT(hWnd,uID,uFlags,hMenu) \
               SendMessage(hWnd,WM_MENUSELECT,MAKEWPARAM(uID,uFlags),(LPARAM)(hMenu));

#define DO_WM_MENUSELECT_POPUP(hWnd,uPopupIndex,uFlags,hMenu)\
               SendMessage(hWnd,WM_MENUSELECT,MAKEWPARAM(uPopupIndex,(uFlags)|MF_POPUP),(LPARAM)hMenu);

#define DO_WM_MENUSELECT_CANCEL(hWnd)\
               SendMessage(hWnd,WM_MENUSELECT,MAKEWPARAM(0,0xFFFF),0);

#define PBGETCLASSBACKGROUND(hwnd) ((HBRUSH)GetClassLong(hwnd,GCL_HBRBACKGROUND))
#define PBGETCLASSICON(hwnd) (GetClassLong(hwnd,GCL_HICON))
#define PBGETWINDOWCURSOR(hWnd) ((HCURSOR) GetClassLong((hWnd), GCL_HCURSOR))
#define PBGETWINDOWID(h) ((short) GetWindowLong((HWND) (h), GWL_ID))
#define PBGETWINDOWINSTANCE(h) ((HINSTANCE) GetWindowLong((h), GWL_HINSTANCE))
#define PBGETWINDOWMODULE(h) ((HANDLE) GetClassLong((h), GCL_HMODULE))
#define PBGETWINDOWPARENT(h) ((HWND) GetWindowLong((h), GWL_HWNDPARENT ))

#define PBSETCLASSBACKGROUND(hwnd,hbrush) (SetClassLong(hwnd,GCL_HBRBACKGROUND,(LONG)hbrush))
#define PBSETCLASSICON(hwnd,hicon) (SetClassLong(hwnd,GCL_HICON,(LONG)(hicon)))
#define PBSETWINDOWCURSOR(hWnd,hcursor) (SetClassLong(hWnd,GCL_HCURSOR,(LONG)hCursor))
#define PBSETWINDOWID(h, i) (SetWindowLong((HWND) (h), GWL_ID, (LONG) i))

// Post message to current thread
#define PBPOSTAPPMESSAGE(m,w,l) (PostThreadMessage(GetCurrentThreadId(),m,w,l))

// Create Temporary file, name is save in passed filename buffer.
// lpszNamePrefix will be used to form the temporary file name,
// lpszNameBuffer will contain the temporary file name,
// iErrorCode will be zero for success.
// The Temporary file will be created.
#define PBGETTEMPFILENAME(lpszNamePrefix,lpszNameBuffer,iErrorCode)\
    {DWORD lLen;\
     TCHAR cTempDevice[PBMAXFILE];\
     iErrorCode = 1;\
     lLen = GetTempPath(PBSIZE(cTempDevice),cTempDevice);\
     if(lLen && lLen < PBSIZE(cTempDevice))\
        iErrorCode = (0 == GetTempFileName(cTempDevice,lpszNamePrefix,0,lpszNameBuffer));\
     }

#define PBOS_SetEndOfFile(hFile) SetEndOfFile(hFile)
#else // Windows 3.1 support

	// console debugging macros for Windows NT
#define OSOpenDebugConsole() 
#define OSCloseDebugConsole() 
#define OSDeclareOUTPUTVariable()  
#define OSWriteDebugConsole(lpszMessage)

// see nt support up above for a description of these DDE macros
#define PBDEFINE_DDEHELPER_STORAGE(var_name_will_be) 
#define DO_PREPARE_DDEHELPER_STORAGE(var_name_will_be,msg,low,high)
#define DO_UNPACK_DDEHELPER_STORAGE(var_name_will_be,lparam)
#define DO_FREE_DDELPARAM(var_name_will_be, lparam) 


#define PBWM_COMMAND_NOTIFY_CODE           (HIWORD(lParam))
#define PBWM_COMMAND_CONTROL_HANDLE        (HWND)(LOWORD(lParam))
#define PBWM_COMMAND_CONTROL_ID            (wParam)
#define PBWM_ACTIVATEAPP_ACTIVE            (wParam)
#define PBWM_ACTIVATEAPP_TASK              ((LOWORD(lParam))
#define PBWM_VSCROLL_SCROLLCODE            (wParam)   
#define PBWM_VSCROLL_POS                   (LOWORD(lParam))
#define PBWM_VSCROLL_CONTROL_HANDLE        (HWND)(HIWORD(lParam))
#define PBWM_HSCROLL_SCROLLCODE            (wParam)   
#define PBWM_HSCROLL_POS                   (LOWORD(lParam))
#define PBWM_HSCROLL_CONTROL_HANDLE        (HWND)(HIWORD(lParam))
#define PBWM_PARENTNOTIFY_EVENTFLAGS       (wParam)
#define PBWM_PARENTNOTIFY_CHILD_HANDLE     (LOWORD(lParam))
#define PBWM_PARENTNOTIFY_CHILD_ID         (HIWORD(lParam))
#define PBWM_PARENTNOTIFY_CURSOR_X         (LOWORD(lParam))
#define PBWM_PARENTNOTIFY_CURSOR_Y         (HIWORD(lParam))
#define PBWM_DDE_POKE_WND_HANDLE           (wParam)
#define PBWM_DDE_POKE_DATA_HANDLE(var_name_will_be)   (LOWORD(lParam))
#define PBWM_DDE_POKE_DATA_ITEMNAME(var_name_will_be) (HIWORD(lParam))
#define PBWM_MDIACTIVATE_HWNDACT           ((HWND)LOWORD(lParam))
#define PBWM_MDIACTIVATE_HWNDDEACT         ((HWND)HIWORD(lParam))
#define PBWM_MENUSELECT_ID                 ((UINT)wParam)
#define PBWM_MENUSELECT_POPUP_HMENU        ((HMENU)wParam)
#define PBWM_MENUSELECT_FLAGS              ((UINT)LOWORD(lParam))
#define PBWM_MENUSELECT_HMENU              ((HMENU)HIWORD(lParam))
#define PBWM_CTL_COLOR_HANDLE              (HWND)(LOWORD(lParam))
#define PBWM_ACTIVATE_ACTFLAG			  (wParam)
#define PBWM_ACTIVATE_MINFLAG			  (HIWORD(lParam))
#define PBWM_ACTIVATE_HWNPREV              (LOWORD(lParam))

#define DO_EM_LINESCROLL(hWnd, cxScroll, cyScroll) \
			SendMessage(hWnd,EM_LINESCROLL,0,MAKELPARAM(cyScroll,cxScroll))

#define DO_EM_GETSEL(hWnd, lpdwStart, lpdwEnd) \
   			{ \
				LONG lReturn = SendMessage(hWnd, EM_GETSEL, 0, 0); \
				*(lpdwStart) = (DWORD)LOWORD(lReturn); \
				*(lpdwEnd) = (DWORD)HIWORD(lReturn); \
			}

#define DO_EM_SETSEL(hWnd, fScroll, iStart, iEnd) \
               { SendMessage(hWnd,EM_SETSEL,fScroll,MAKELONG(iStart, iEnd));}

#define DO_LB_SETSEL(hWnd, bState, wIndex) \
               SendMessage(hWnd,LB_SETSEL,(WPARAM)bState,MAKELPARAM((WORD)wIndex, 0))

#define DO_WM_VSCROLL(hWnd, wScrollCode, nPos) \
               SendMessage(hWnd, WM_VSCROLL, wScrollCode, nPos)

#define DO_WM_HSCROLL(hWnd, wScrollCode, nPos) \
               SendMessage(hWnd, WM_HSCROLL, wScrollCode, nPos)

#define DO_MAKEPOINT(ptGuy,lValue) {ptGuy = MAKEPOINT(lValue);}

#define DO_GETWINDOW_ID(hwnd)  (GetWindowWord (hwnd, GWW_ID))

#define DO_SETCLASS_CURSOR(hwnd,hcursor) (SetClassWord(hwnd,GCW_HCURSOR,(WORD)(hcursor)))

#define DO_GETCLASS_CURSOR(hwnd) (GetClassWord(hwnd,GCW_HCURSOR))

#define DO_SETCLASS_ICON(hwnd,hicon) (SetClassWord(hwnd,GCW_HICON,(WORD)(hicon)))

#define DO_GETCLASS_ICON(hwnd) (GetClassWord(hwnd,GCW_HICON))

#define DO_WM_COMMAND(hWnd,NotifyCode,CtrlHdl,CtrlId) \
               SendMessage(hWnd,WM_COMMAND,CtrlId, MAKELPARAM(CtrlHdl,NotifyCode))

#define DO_WM_COMMANDPost(hWnd,NotifyCode,CtrlHdl,CtrlId) \
               PostMessage(hWnd,WM_COMMAND,CtrlId, MAKELPARAM(CtrlHdl,NotifyCode))

#define DO_COMMAND(hWnd,MsgId,NotifyCode,CtrlHdl,CtrlId) \
               SendMessage(hWnd,MsgId,CtrlId, MAKELPARAM(CtrlHdl,NotifyCode))

#define DO_COMMANDPost(hWnd,MsgId,NotifyCode,CtrlHdl,CtrlId) \
               PostMessage(hWnd,MsgId,CtrlId, MAKELPARAM(CtrlHdl,NotifyCode))

   // WIN32 requires the index to the popup menu whereas WIN16 requires the popup menu handle.
   // DO_WM_MENUSELECT_POPUP accepts a popup menu index and changes it to a popup menu handle so it match WIN32.

#define DO_WM_MENUSELECT(hWnd,uID,uFlags,hMenu) \
               SendMessage(hWnd,WM_MENUSELECT,uID,MAKELPARAM(uFlags,hMenu));

#define DO_WM_MENUSELECT_POPUP(hWnd,uPopupIndex,uFlags,hMenu)\
               SendMessage(hWnd,WM_MENUSELECT,(WPARAM)GetSubMenu(hMenu,uPopupIndex),MAKELPARAM((uFlags)|MF_POPUP),hMenu));

#define DO_WM_MENUSELECT_CANCEL(hWnd)\
               SendMessage(hWnd,WM_MENUSELECT,0,MAKELPARAM(0xFFFF,NULL));

#define PBGETCLASSBACKGROUND(hwnd) ((HBRUSH)GetClassWord(hwnd,GCW_HBRBACKGROUND))
#define PBGETCLASSICON(hwnd) (GetClassWord(hwnd,GCW_HICON))
#define PBGETWINDOWCURSOR(hWnd) ((HCURSOR) GetClassWord((hWnd), GCW_HCURSOR))
#define PBGETWINDOWID(h) GetWindowWord((HWND) (h), GWW_ID)
#define PBGETWINDOWMODULE(h) ((HANDLE) GetClassWord((h), GCW_HMODULE))
#define PBGETWINDOWPARENT(h) ((HWND) GetWindowWord((h), GWW_HWNDPARENT ))

#define PBSETCLASSBACKGROUND(hwnd,hbrush) (SetClassWord(hwnd,GCW_HBRBACKGROUND,(WORD)hbrush))
#define PBSETCLASSICON(hwnd,hicon) (SetClassWord(hwnd,GCW_HICON,(WORD)(hicon)))
#define PBSETWINDOWCURSOR(hWnd,hcursor) (SetClassWord(hWnd,GCW_HCURSOR,(WORD)hCursor))

#ifdef PBOS_UNIX
#define PBGETWINDOWINSTANCE(h) GetWindowInstance(h)
#else
#define PBGETWINDOWINSTANCE(h) ((HINSTANCE) GetWindowWord((h), GWW_HINSTANCE))
#endif

#define PBSETWINDOWID(h, i) (SetWindowWord((HWND) (h), GWW_ID, (WORD) i))

// Post message to current task
#define PBPOSTAPPMESSAGE(m,w,l) (PostAppMessage(GetCurrentTask(),m,w,l))

// Create Temporary file, name is save in passed filename buffer.
// lpszNamePrefix will be used to form the temporary file name,
// lpszNameBuffer will contain the temporary file name,
// iErrorCode will be zero for success.
// The Temporary file will be created.
#define PBGETTEMPFILENAME(lpszNamePrefix,lpszNameBuffer,iErrorCode)\
    {iErrorCode = 0;\
    GetTempFileName(0,lpszNamePrefix,0,lpszNameBuffer);\
    }
// wlg PT 291351 - Changed back to use _llseek for PB050
#ifdef PBOS_UNIX_40
#define PBOS_SetEndOfFile(hFile) lseek(hFile,0 , 2)
#else
#define PBOS_SetEndOfFile(hFile) _llseek((HFILE)hFile,0 , 2)
#endif


#endif // Windows 3.1 support

#endif // _PB_ELMERS_GLUE_h_
// DOINC popped back into header 'rtdbpub.h'
#ifndef IPB_DSI_INCL
// ***** DOINC including pbdsi.h *****
//___________________________________________________________________________
//
//								Copyright 2005
//						Sybase, Inc. and its subsidiaries.
//	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-
//	Sybase, Inc.("Sybase") claims copyright in this program and documentation
//	as an unpublished work, versions of which were first licensed on the date
//	indicated in the foregoing notice. This claim of copyright does not imply
//	waiver of Sybase's other rights.
//	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-
//						*  Notice of Proprietary Rights  *
//	This program  and documentation  are confidential  trade secrets  and the
//	property of Sybase.  Use, examination, reproduction, copying, disassembly,
//	decompilation, or transfer or disclosure to others is strictly prohibited
//	except by express written agreement with Sybase.
//___________________________________________________________________________
//
//	File Name : pbdsi.h
//
//	Author	  : PowerBuilder DB Engineering Team
//
//	Purpose	  : Declaration of the interface to the generic datasource object
//___________________________________________________________________________
//

#ifndef __PB_DBI_H_INCL__
// ***** DOINC including pbdbi.h *****
/*                                                                         */
/* *********************************************************************** */
/*                                                                         */
/*                 Copyright Powersoft Corporation 1991-1994               */
/*                                                                         */
/*       Powersoft Corporation ("Powersoft") claims copyright in this      */
/*     program and documentation as an unpublished work, versions of       */
/*     which were first licensed on the date indicated in the foregoing    */
/*     notice. Claim of copyright does not imply waiver of Powersoft's     */
/*     other rights. See Notice of Proprietary Rights.                     */
/*                                                                         */
/*                 NOTICE OF PROPRIETARY RIGHTS                            */
/*                                                                         */
/*       This program and documentation are confidential trade             */
/*     secrets and the property of Powersoft.  Use, examination,           */
/*     reproduction, copying, disassembly, decompilation, transfer         */
/*     and/or disclosure to others are strictly prohibited except by       */
/*     express written agreement with Powersoft.                           */
/*                                                                         */
/* ----------------------------------------------------------------------- */
/*                                                                         */
/*    Filename :    pbdbi.h                                                 */
/*                                                                         */
/*    Author   :    Irina Shishov                                           */
/*                                                                         */
/*    Purpose  :    Header file for DLL utilities prototype                 */
/*                                                                         */
/* *********************************************************************** */

#ifndef __PB_DBI_H_INCL__
#define __PB_DBI_H_INCL__

#ifdef __cplusplus
	extern "C" {
#endif

		// COM defines
#ifndef PBCOM_H
// ***** DOINC including pbcom.h *****
	// DOINC skipping duplicate include
#endif

// Hash Lists
#ifndef SHHASH_H
// ***** DOINC including shhash.h *****
	// DOINC skipping duplicate include
#endif

#ifndef  DWH
// ***** DOINC including pbdw.h *****
//**************************************************************************
//
//                            Copyright 1989-1994
//                        Powersoft
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM POWERSOFT
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :        pbdw.h
//
//    Author   :        Kim Sheffield
//
//    Purpose  :        User include file for DataWindows
//
//****************************************************************************

#ifndef  DWH                             // Already included?
#define  DWH                             // Make sure for next time

// We use the date/time structures
#ifndef RC_INVOKED
// ***** DOINC including shdt.h *****
	// DOINC skipping duplicate include
#endif

#ifndef PBSTG_H
// ***** DOINC including pbstg.h *****
	// DOINC skipping duplicate include
#endif

#ifndef SHLIST_H
// ***** DOINC including shlist.h *****
	// DOINC skipping duplicate include
#endif

/* DataWindow Control Styles */
// ***** DOINC including pbdws.h *****
//**************************************************************************
//
//                            Copyright 1989-1994
//                        Powersoft
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM POWERSOFT
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :        pbdws.h
//
//    Author   :        Kim Sheffield
//
//    Purpose  :        User include file for DataWindows resource files
//
//****************************************************************************

#ifndef  PBDWS_H                             // Already included?
#define  PBDWS_H                             // Make sure for next time

/* DataWindow Control Styles */
#define DWS_SPLITHSCROLL     0x00000001L
#define DWS_LIVESCROLL	     0x00000002L
#define DWS_LBS			     0x00000004L
#define DWS_LBS_MULTIPLESEL	 0x00000008L
#define DWS_DDDW		     0x00000010L
#define DWS_DDDW_ALWAYSSHOW	 0x00000020L
#define DWS_NEST 		     0x00000040L
#define DWS_DIALOG 		     0x00000080L
#define DWS_EMBEDDING        0x00000100L
#define DWS_NOHSCROLL        0x00000200L
#define DWS_DATASTORE        0x00000400L
#define DWS_DDDW_RTOL      	 0x00000800L
#define DWS_NATIVECREATE     0x00001000L

#endif
// DOINC popped back into header 'pbdw.h'

#ifndef PBDWTMPL_H
// ***** DOINC including pbdwtmpl.h *****
//    Copyright Sybase, Inc. 2001
//
//    Sybase, Inc. ("Sybase") claims copyright in this
//    program and documentation as an unpublished work, versions of
//    which were first licensed on the date indicated in the foregoing
//    notice.  Claim of copyright does not imply waiver of Sybase's
//    other rights. See Notice of Proprietary Rights.
//
//    NOTICE OF PROPRIETARY RIGHTS
//
//    This program and documentation are confidential trade
//    secrets and the property of Sybase.  Use, examination,
//    reproduction, copying, disassembly, decompilation, transfer
//    and/or disclosure to others are strictly prohibited except by
//    express written agreement with Sybase.
//
//    Filename :    pbdwtmpl.h
//
//    Author   :    Angelo Scipione
//
//    Purpose  :    interface IDW_DataTemplateList
//                  interface IDW_ExportDataXMLTemplate
//                  interface IDW_ImportDataXMLTemplate
//                  interface IDW_ExportDataXMLTemplateListProp
//                  interface IDW_ExportDataXHTMLTemplate
//                  interface IDW_ExportDataPDFProperties
//                  class CDW_ExportDataList_Factory
//                  class CDW_ExportDataXMLTemplate_Factory
//                  class CDW_ImportDataList_Factory
//                  class CDW_ExportDataXHTMLTemplate_Factory
//
#ifndef PBDWTMPL_H
#define PBDWTMPL_H

#ifdef __cplusplus
		extern "C" {
#endif

#ifndef OSWINDOW_H
			// ***** DOINC including oswindow.h *****
				// DOINC skipping duplicate include
#endif

#ifdef GENERATED_CODE_BUILD

			typedef struct _IPB_String {} IPB_String;

#else

#ifndef __pbtypes_h__
// ***** DOINC including pbtypes.h *****
	// DOINC skipping duplicate include
#endif

#endif

			enum DWPortDataFormat {
				DW_XML = 0,
				DW_PDF = 1,
				DW_XHTML = 2
				/* more to be added */
			};

			/* *********************************************************************** */
			//  Interface:      IDW_DataTemplateList
			//  Synopsis:       Pure abstract base class for DW data export and import,
			//                  format-specific template lists.
			//  Implemented by: \dw
			//  Used by:        \painters\pdw passed via DWOPTIONS
			/* *********************************************************************** */
			class IDW_DataTemplateList
			{
			public:
				virtual IDW_DataTemplateList* STDMETHODCALLTYPE getFormat(enum DWPortDataFormat formatType) = 0;
				virtual void* STDMETHODCALLTYPE getTemplateList() = 0;
				virtual void STDMETHODCALLTYPE setTemplateList(void* pTemplate) = 0;

				virtual IPB_String* STDMETHODCALLTYPE getUseTemplateAsString() = 0;
				virtual IPB_String* STDMETHODCALLTYPE getUseTemplateExprAsString() = 0;
				virtual void STDMETHODCALLTYPE setUseTemplateAsString(IPB_String* sUseTemplate) = 0;
				virtual void STDMETHODCALLTYPE setUseTemplateExprAsString(IPB_String* sExprUseTemplate) = 0;

				virtual IDW_DataTemplateList* STDMETHODCALLTYPE getNext() = 0;
				virtual IDW_DataTemplateList* STDMETHODCALLTYPE getPrior() = 0;

				virtual void* STDMETHODCALLTYPE getPropertyInterface() = 0;

				virtual ULONG STDMETHODCALLTYPE AddRef() = 0;
				virtual ULONG STDMETHODCALLTYPE Release() = 0;
			};


			/* *********************************************************************** */
			//  Interface:  IDW_ImportDataXMLTemplate
			//  Synopsis:   Pure abstract class for DW data import XML-specific template.
			//              Restricted subset of Export.
			/* *********************************************************************** */
			class IDW_ImportDataXMLTemplate
			{
			public:
				virtual void STDMETHODCALLTYPE getTemplate(IPB_String* sName, IDW_ImportDataXMLTemplate** ppTemp) = 0;
				virtual void STDMETHODCALLTYPE getNext(IDW_ImportDataXMLTemplate** ppTemp) = 0;
				virtual void STDMETHODCALLTYPE getPrior(IDW_ImportDataXMLTemplate** ppTemp) = 0;

				virtual IPB_String* STDMETHODCALLTYPE getName() = 0;
				virtual IPB_String* STDMETHODCALLTYPE getComment() = 0;
				virtual IPB_String* STDMETHODCALLTYPE getXML() = 0;
				virtual IPB_String* STDMETHODCALLTYPE getEncoding() = 0;
				virtual IPB_String* STDMETHODCALLTYPE getPublicId() = 0;
				virtual IPB_String* STDMETHODCALLTYPE getSystemId() = 0;
				virtual IPB_String* STDMETHODCALLTYPE getInternalSubset() = 0;
				virtual IPB_String* STDMETHODCALLTYPE getOptions() = 0;
			};

			/* *********************************************************************** */
			//  Interface:  IDW_ExportDataXMLTemplate
			//  Synopsis:   Pure abstract class for DW data export XML-specific template.
			/* *********************************************************************** */
			class IDW_ExportDataXMLTemplate
			{
				friend class CDW_ExportDataXMLTemplate;
			public:
				virtual void STDMETHODCALLTYPE getTemplate(IPB_String* sName, IDW_ExportDataXMLTemplate** ppTemp) = 0;
				virtual void STDMETHODCALLTYPE getNext(IDW_ExportDataXMLTemplate** ppTemp) = 0;
				virtual void STDMETHODCALLTYPE getPrior(IDW_ExportDataXMLTemplate** ppTemp) = 0;
				virtual void STDMETHODCALLTYPE add(IDW_ExportDataXMLTemplate* pINew) = 0;
				virtual void STDMETHODCALLTYPE insertBefore(IDW_ExportDataXMLTemplate* pINew) = 0;
				virtual void STDMETHODCALLTYPE remove() = 0;

				virtual IPB_String* STDMETHODCALLTYPE getName() = 0;
				virtual void STDMETHODCALLTYPE setName(IPB_String* sName) = 0;
				virtual IPB_String* STDMETHODCALLTYPE getComment() = 0;
				virtual void STDMETHODCALLTYPE setComment(IPB_String* sComment) = 0;
				virtual IPB_String* STDMETHODCALLTYPE getXML() = 0;
				virtual void STDMETHODCALLTYPE setXML(IPB_String* sXML) = 0;
				virtual IPB_String* STDMETHODCALLTYPE getEncoding() = 0;
				virtual void STDMETHODCALLTYPE setEncoding(IPB_String* sEncoding) = 0;
				virtual IPB_String* STDMETHODCALLTYPE getPublicId() = 0;
				virtual void STDMETHODCALLTYPE setPublicId(IPB_String* sPublicId) = 0;
				virtual IPB_String* STDMETHODCALLTYPE getSystemId() = 0;
				virtual void STDMETHODCALLTYPE setSystemId(IPB_String* sSystemId) = 0;
				virtual IPB_String* STDMETHODCALLTYPE getInternalSubset() = 0;
				virtual void STDMETHODCALLTYPE setInternalSubset(IPB_String* sInternalSubset) = 0;
				virtual IPB_String* STDMETHODCALLTYPE getOptions() = 0;
				virtual void STDMETHODCALLTYPE setOptions(IPB_String* sOptions) = 0;

				virtual IDW_ImportDataXMLTemplate* getImportTemplate() = 0;
			protected:
				virtual void setNext(IDW_ExportDataXMLTemplate* pINext) = 0;
				virtual void setPrior(IDW_ExportDataXMLTemplate* pIPrior) = 0;
			};

			/* *********************************************************************** */
			//  Interface:  IDW_ExportDataXMLTemplateListProp
			//  Synopsis:   Pure abstract class for DW data export XML template list properties.
			/* *********************************************************************** */
			class IDW_ExportDataXMLTemplateListProp
			{
			public:
				virtual BOOL STDMETHODCALLTYPE getHeadGroupsAsBOOL() = 0;
				virtual IPB_String* STDMETHODCALLTYPE getHeadGroupsExprAsString() = 0;
				virtual void STDMETHODCALLTYPE setHeadGroupsAsBOOL(BOOL bHeadGroups) = 0;
				virtual void STDMETHODCALLTYPE setHeadGroupsExprAsString(IPB_String* sExprHeadGroups) = 0;

				virtual BOOL STDMETHODCALLTYPE getIncludeWhitespaceAsBOOL() = 0;
				virtual IPB_String* STDMETHODCALLTYPE getIncludeWhitespaceExprAsString() = 0;
				virtual void STDMETHODCALLTYPE setIncludeWhitespaceAsBOOL(BOOL bIncludeWhitespace) = 0;
				virtual void STDMETHODCALLTYPE setIncludeWhitespaceExprAsString(IPB_String* sExprIncludeWhitespace) = 0;

				virtual int STDMETHODCALLTYPE getMetaDataTypeAsNumber() = 0;
				virtual void STDMETHODCALLTYPE setMetaDataTypeAsNumber(int iMetaDataType) = 0;

				virtual int STDMETHODCALLTYPE getSaveMetaDataAsNumber() = 0;
				virtual void STDMETHODCALLTYPE setSaveMetaDataAsNumber(int iSaveMetaData) = 0;
			};

			/* ************************************************************************* */
			//  Interface:  IDW_ExportDataXHTMLTemplate
			//  Synopsis:   Pure abstract class for DW data export XHTML-specific template.
			/* ************************************************************************* */
			class IDW_ExportDataXHTMLTemplate
			{
				friend class CDW_ExportDataXHTMLTemplate;
			public:
				virtual void STDMETHODCALLTYPE getTemplate(IPB_String* sName, IDW_ExportDataXHTMLTemplate** ppTemp) = 0;
				virtual void STDMETHODCALLTYPE getNext(IDW_ExportDataXHTMLTemplate** ppTemp) = 0;
				virtual void STDMETHODCALLTYPE getPrior(IDW_ExportDataXHTMLTemplate** ppTemp) = 0;
				virtual void STDMETHODCALLTYPE add(IDW_ExportDataXHTMLTemplate* pINew) = 0;
				virtual void STDMETHODCALLTYPE insertBefore(IDW_ExportDataXHTMLTemplate* pINew) = 0;
				virtual void STDMETHODCALLTYPE remove() = 0;

				virtual IPB_String* STDMETHODCALLTYPE getName() = 0;
				virtual void STDMETHODCALLTYPE setName(IPB_String* sName) = 0;
				virtual IPB_String* STDMETHODCALLTYPE getComment() = 0;
				virtual void STDMETHODCALLTYPE setComment(IPB_String* sComment) = 0;
				virtual IPB_String* STDMETHODCALLTYPE getXHTML() = 0;
				virtual void STDMETHODCALLTYPE setXHTML(IPB_String* sXHTML) = 0;

			protected:
				virtual void setNext(IDW_ExportDataXHTMLTemplate* pINext) = 0;
				virtual void setPrior(IDW_ExportDataXHTMLTemplate* pIPrior) = 0;
			};

			/* *********************************************************************** */
			//  Factory:    CDW_ExportDataList_Factory
			//  Synopsis:   Factory for constructing CDW_ExportDataXMLTemplateList, etc.
			/* *********************************************************************** */
			class CDW_ExportDataList_Factory
			{
			public:
				static IDW_DataTemplateList* STDMETHODCALLTYPE CreateExportDataList();
			};

			/* *********************************************************************** */
			//  Factory:    CDW_ExportDataXMLTemplate_Factory
			//  Synopsis:   Factory for constructing CDW_ExportDataXMLTemplate's
			/* *********************************************************************** */
			class CDW_ExportDataXMLTemplate_Factory
			{
			public:
				static IDW_ExportDataXMLTemplate* STDMETHODCALLTYPE CreateXMLTemplate();
			};

			/* *********************************************************************** */
			//  Factory:    CDW_ImportDataList_Factory
			//  Synopsis:   Factory for constructing CDW_ImportDataXMLTemplateList, etc.
			/* *********************************************************************** */
			class CDW_ImportDataList_Factory
			{
			public:
				static IDW_DataTemplateList* STDMETHODCALLTYPE CreateImportDataList();
			};

			/* *********************************************************************** */
			//  Factory:    CDW_ExportDataXHTMLTemplate_Factory
			//  Synopsis:   Factory for constructing CDW_ExportDataXHTMLTemplate's
			/* *********************************************************************** */
			class CDW_ExportDataXHTMLTemplate_Factory
			{
			public:
				static IDW_ExportDataXHTMLTemplate* STDMETHODCALLTYPE CreateXHTMLTemplate();
			};

			/* *********************************************************************** */
			//  Interface:  IDW_ExportDataPDFProperties
			//  Synopsis:   Pure abstract class for DW data export PDF properties.
			/* *********************************************************************** */
			class IDW_ExportDataPDFProperties
			{
			public:
				virtual int STDMETHODCALLTYPE getMethodAsNumber() = 0;
				virtual void STDMETHODCALLTYPE setMethodAsNumber(int iMethod) = 0;

				virtual BOOL STDMETHODCALLTYPE getCustomPostScriptAsBOOL() = 0;
				virtual IPB_String* STDMETHODCALLTYPE getCustomPostScriptExprAsString() = 0;
				virtual void STDMETHODCALLTYPE setCustomPostScriptAsBOOL(BOOL bCustomPostScript) = 0;
				virtual void STDMETHODCALLTYPE setCustomPostScriptExprAsString(IPB_String* sExprCustomPostScript) = 0;

				virtual BOOL STDMETHODCALLTYPE getFOPrintAsBOOL() = 0;
				virtual IPB_String* STDMETHODCALLTYPE getFOPrintExprAsString() = 0;
				virtual void STDMETHODCALLTYPE setFOPrintAsBOOL(BOOL bFOPrint) = 0;
				virtual void STDMETHODCALLTYPE setFOPrintExprAsString(IPB_String* sExprFOPrint) = 0;
			};

#ifdef __cplusplus
		} // extern "C"
#endif

#endif //PBDWTMPL_H

// DOINC popped back into header 'pbdw.h'
#endif

#ifndef OSFILLS
// ***** DOINC including osfills.h *****
#ifndef OSFILLS
#define OSFILLS

// ***** DOINC including windows.h *****
	// DOINC skipping duplicate include
#ifdef __cplusplus
		extern "C" {
#endif

			typedef enum
			{
				OSFILL_NONE,
				OSFILL_GRADIENT_LINEAR_HORIZONTAL,
				OSFILL_GRADIENT_LINEAR_VERTICAL,
				OSFILL_GRADIENT_ANGLE,
				OSFILL_GRADIENT_SCALED_ANGLE,
				OSFILL_GRADIENT_RADIAL,
				OSFILL_PICTURE,
			} OSFILL_MODE_T;

			typedef enum
			{
				OSFILL_PICTURE_ORIGINAL_SIZE,
				OSFILL_PICTURE_FIT_TO_WIDTH,
				OSFILL_PICTURE_FIT_TO_HEIGHT,
				OSFILL_PICTURE_FIT_TO_WIDTH_AND_HEIGHT,
				OSFILL_PICTURE_STRECTH_TO_FIT,
				OSFILL_PICTURE_TILE,
				OSFILL_PICTURE_TILE_X,
				OSFILL_PICTURE_TILE_Y,
				OSFILL_PICTURE_TILE_XY
			} OSFILL_PICTURE_MODE_T;

			typedef enum
			{
				OSFILL_SHAPE_RECTANGLE,
				OSFILL_SHAPE_ROUND_RECTANGLE,
				OSFILL_SHAPE_ELLIPSE,
			} OSFILL_SHAPE_T;

			typedef struct
			{
				SHORT brushmode; // enumerated: horizontal, vertical, forwarddiagonal, backwarddiagonal, angle, anglescaled

				LONG   color;	//	number
				SHORT  transparency;	//	number (percentage) (0 to 100) 0 = opaque
				LONG   gradientcolor;  //second color for gradient
				SHORT  gradienttransparency;	//	number (percentage) (0 to 100) 0 = opaque
				SHORT  gradientangle;  //number: gradient directional angle
				SHORT  gradientrepetitionmode;
				LONG   gradientrepetitioncount;	//	number 
				LONG   gradientrepetitionlength;
				SHORT  gradientfocus;
				SHORT  gradientscale;
				SHORT  gradientspread;
				LPTSTR picturefile;
				SHORT  picturemode;
				SHORT  picturescalex;
				SHORT  picturescaley;
				SHORT  pictureclipleft;
				SHORT  pictureclipright;
				SHORT  picturecliptop;
				SHORT  pictureclipbottom;
				SHORT  pictureblur;
				SHORT  picturetransparency;

				PVOID pIA;
			} fillBrushInfo, * pfillBrushInfo;

			typedef struct
			{
				LONG backcolor;
				LONG delay_initial;
				LONG delay_visible;
				LONG enabled;
				LONG hasclosebutton;
				LONG icon;
				LONG isbubble;
				LONG maxwidth;
				LONG textcolor;
				LPTSTR tip;
				LPTSTR title;
				LONG transparency;
			} tooltipInfo, FAR* ptooltipInfo;

			typedef struct
			{
				SHORT blur;
				SHORT transparency;
			} effectsInfo, FAR* peffectsInfo;

#ifdef __cplusplus
		}
#endif

#endif
		// DOINC popped back into header 'pbdw.h'
#endif

#ifdef GENERATED_CODE_BUILD
		/*
		typedef struct _OLESTR {} *LPOLESTR;
		typedef struct _HMETAFILE {} *HMETAFILE;
		typedef struct _HENHMETAFILE {} *HENHMETAFILE;
		
		typedef struct _RECT {} *LPRECT;
		*/
		typedef struct _IPB_XMLDOMDocument {} IPB_XMLDOMDocument;
#else

#ifndef __pbxml_h__
// ***** DOINC including pbxml.h *****


/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* at Tue Apr 29 21:01:33 2014
 */
 /* Compiler settings for pbxml.idl:
	 Oicf, W1, Zp8, env=Win32 (32b run)
	 protocol : dce , ms_ext, c_ext, robust
	 error checks: allocation ref bounds_check enum stub_data
	 VC __declspec() decoration level:
		  __declspec(uuid()), __declspec(selectany), __declspec(novtable)
		  DECLSPEC_UUID(), MIDL_INTERFACE()
 */
 //@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

// ***** DOINC including rpc.h *****
	// DOINC skipping duplicate include
// ***** DOINC including rpcndr.h *****
	// DOINC skipping duplicate include

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
// ***** DOINC including windows.h *****
	// DOINC skipping duplicate include
// ***** DOINC including ole2.h *****
	// DOINC skipping duplicate include
#endif /*COM_NO_WINDOWS_H*/

#ifndef __pbxml_h__
#define __pbxml_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */

#ifndef __IPB_XMLDOMNode_FWD_DEFINED__
#define __IPB_XMLDOMNode_FWD_DEFINED__
		typedef interface IPB_XMLDOMNode IPB_XMLDOMNode;
#endif 	/* __IPB_XMLDOMNode_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMNamedNodeMap_FWD_DEFINED__
#define __IPB_XMLDOMNamedNodeMap_FWD_DEFINED__
		typedef interface IPB_XMLDOMNamedNodeMap IPB_XMLDOMNamedNodeMap;
#endif 	/* __IPB_XMLDOMNamedNodeMap_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMNodeList_FWD_DEFINED__
#define __IPB_XMLDOMNodeList_FWD_DEFINED__
		typedef interface IPB_XMLDOMNodeList IPB_XMLDOMNodeList;
#endif 	/* __IPB_XMLDOMNodeList_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMCharacterData_FWD_DEFINED__
#define __IPB_XMLDOMCharacterData_FWD_DEFINED__
		typedef interface IPB_XMLDOMCharacterData IPB_XMLDOMCharacterData;
#endif 	/* __IPB_XMLDOMCharacterData_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMComment_FWD_DEFINED__
#define __IPB_XMLDOMComment_FWD_DEFINED__
		typedef interface IPB_XMLDOMComment IPB_XMLDOMComment;
#endif 	/* __IPB_XMLDOMComment_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMText_FWD_DEFINED__
#define __IPB_XMLDOMText_FWD_DEFINED__
		typedef interface IPB_XMLDOMText IPB_XMLDOMText;
#endif 	/* __IPB_XMLDOMText_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMCDATASection_FWD_DEFINED__
#define __IPB_XMLDOMCDATASection_FWD_DEFINED__
		typedef interface IPB_XMLDOMCDATASection IPB_XMLDOMCDATASection;
#endif 	/* __IPB_XMLDOMCDATASection_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMElement_FWD_DEFINED__
#define __IPB_XMLDOMElement_FWD_DEFINED__
		typedef interface IPB_XMLDOMElement IPB_XMLDOMElement;
#endif 	/* __IPB_XMLDOMElement_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMDocumentType_FWD_DEFINED__
#define __IPB_XMLDOMDocumentType_FWD_DEFINED__
		typedef interface IPB_XMLDOMDocumentType IPB_XMLDOMDocumentType;
#endif 	/* __IPB_XMLDOMDocumentType_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMXMLDecl_FWD_DEFINED__
#define __IPB_XMLDOMXMLDecl_FWD_DEFINED__
		typedef interface IPB_XMLDOMXMLDecl IPB_XMLDOMXMLDecl;
#endif 	/* __IPB_XMLDOMXMLDecl_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMProcessingInstruction_FWD_DEFINED__
#define __IPB_XMLDOMProcessingInstruction_FWD_DEFINED__
		typedef interface IPB_XMLDOMProcessingInstruction IPB_XMLDOMProcessingInstruction;
#endif 	/* __IPB_XMLDOMProcessingInstruction_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMAttr_FWD_DEFINED__
#define __IPB_XMLDOMAttr_FWD_DEFINED__
		typedef interface IPB_XMLDOMAttr IPB_XMLDOMAttr;
#endif 	/* __IPB_XMLDOMAttr_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMEntity_FWD_DEFINED__
#define __IPB_XMLDOMEntity_FWD_DEFINED__
		typedef interface IPB_XMLDOMEntity IPB_XMLDOMEntity;
#endif 	/* __IPB_XMLDOMEntity_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMEntityReference_FWD_DEFINED__
#define __IPB_XMLDOMEntityReference_FWD_DEFINED__
		typedef interface IPB_XMLDOMEntityReference IPB_XMLDOMEntityReference;
#endif 	/* __IPB_XMLDOMEntityReference_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMNotation_FWD_DEFINED__
#define __IPB_XMLDOMNotation_FWD_DEFINED__
		typedef interface IPB_XMLDOMNotation IPB_XMLDOMNotation;
#endif 	/* __IPB_XMLDOMNotation_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMDocumentFragment_FWD_DEFINED__
#define __IPB_XMLDOMDocumentFragment_FWD_DEFINED__
		typedef interface IPB_XMLDOMDocumentFragment IPB_XMLDOMDocumentFragment;
#endif 	/* __IPB_XMLDOMDocumentFragment_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMImplementation_FWD_DEFINED__
#define __IPB_XMLDOMImplementation_FWD_DEFINED__
		typedef interface IPB_XMLDOMImplementation IPB_XMLDOMImplementation;
#endif 	/* __IPB_XMLDOMImplementation_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMDocument_FWD_DEFINED__
#define __IPB_XMLDOMDocument_FWD_DEFINED__
		typedef interface IPB_XMLDOMDocument IPB_XMLDOMDocument;
#endif 	/* __IPB_XMLDOMDocument_FWD_DEFINED__ */


#ifndef __IPB_XMLServiceProvider_FWD_DEFINED__
#define __IPB_XMLServiceProvider_FWD_DEFINED__
		typedef interface IPB_XMLServiceProvider IPB_XMLServiceProvider;
#endif 	/* __IPB_XMLServiceProvider_FWD_DEFINED__ */


#ifndef __IPB_ObjectFactory_FWD_DEFINED__
#define __IPB_ObjectFactory_FWD_DEFINED__
		typedef interface IPB_ObjectFactory IPB_ObjectFactory;
#endif 	/* __IPB_ObjectFactory_FWD_DEFINED__ */


#ifndef __IPB_XMLSAXParser_FWD_DEFINED__
#define __IPB_XMLSAXParser_FWD_DEFINED__
		typedef interface IPB_XMLSAXParser IPB_XMLSAXParser;
#endif 	/* __IPB_XMLSAXParser_FWD_DEFINED__ */


#ifndef __IPB_XMLSAXHandler_FWD_DEFINED__
#define __IPB_XMLSAXHandler_FWD_DEFINED__
		typedef interface IPB_XMLSAXHandler IPB_XMLSAXHandler;
#endif 	/* __IPB_XMLSAXHandler_FWD_DEFINED__ */


#ifndef __IPB_XMLTrace_FWD_DEFINED__
#define __IPB_XMLTrace_FWD_DEFINED__
		typedef interface IPB_XMLTrace IPB_XMLTrace;
#endif 	/* __IPB_XMLTrace_FWD_DEFINED__ */


#ifndef __IPB_XMLSAXError_FWD_DEFINED__
#define __IPB_XMLSAXError_FWD_DEFINED__
		typedef interface IPB_XMLSAXError IPB_XMLSAXError;
#endif 	/* __IPB_XMLSAXError_FWD_DEFINED__ */


#ifndef __IPB_XMLParseCallBack_FWD_DEFINED__
#define __IPB_XMLParseCallBack_FWD_DEFINED__
		typedef interface IPB_XMLParseCallBack IPB_XMLParseCallBack;
#endif 	/* __IPB_XMLParseCallBack_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMNode_FWD_DEFINED__
#define __IPB_XMLDOMNode_FWD_DEFINED__
		typedef interface IPB_XMLDOMNode IPB_XMLDOMNode;
#endif 	/* __IPB_XMLDOMNode_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMNamedNodeMap_FWD_DEFINED__
#define __IPB_XMLDOMNamedNodeMap_FWD_DEFINED__
		typedef interface IPB_XMLDOMNamedNodeMap IPB_XMLDOMNamedNodeMap;
#endif 	/* __IPB_XMLDOMNamedNodeMap_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMNodeList_FWD_DEFINED__
#define __IPB_XMLDOMNodeList_FWD_DEFINED__
		typedef interface IPB_XMLDOMNodeList IPB_XMLDOMNodeList;
#endif 	/* __IPB_XMLDOMNodeList_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMCharacterData_FWD_DEFINED__
#define __IPB_XMLDOMCharacterData_FWD_DEFINED__
		typedef interface IPB_XMLDOMCharacterData IPB_XMLDOMCharacterData;
#endif 	/* __IPB_XMLDOMCharacterData_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMComment_FWD_DEFINED__
#define __IPB_XMLDOMComment_FWD_DEFINED__
		typedef interface IPB_XMLDOMComment IPB_XMLDOMComment;
#endif 	/* __IPB_XMLDOMComment_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMText_FWD_DEFINED__
#define __IPB_XMLDOMText_FWD_DEFINED__
		typedef interface IPB_XMLDOMText IPB_XMLDOMText;
#endif 	/* __IPB_XMLDOMText_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMCDATASection_FWD_DEFINED__
#define __IPB_XMLDOMCDATASection_FWD_DEFINED__
		typedef interface IPB_XMLDOMCDATASection IPB_XMLDOMCDATASection;
#endif 	/* __IPB_XMLDOMCDATASection_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMElement_FWD_DEFINED__
#define __IPB_XMLDOMElement_FWD_DEFINED__
		typedef interface IPB_XMLDOMElement IPB_XMLDOMElement;
#endif 	/* __IPB_XMLDOMElement_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMDocumentType_FWD_DEFINED__
#define __IPB_XMLDOMDocumentType_FWD_DEFINED__
		typedef interface IPB_XMLDOMDocumentType IPB_XMLDOMDocumentType;
#endif 	/* __IPB_XMLDOMDocumentType_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMXMLDecl_FWD_DEFINED__
#define __IPB_XMLDOMXMLDecl_FWD_DEFINED__
		typedef interface IPB_XMLDOMXMLDecl IPB_XMLDOMXMLDecl;
#endif 	/* __IPB_XMLDOMXMLDecl_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMProcessingInstruction_FWD_DEFINED__
#define __IPB_XMLDOMProcessingInstruction_FWD_DEFINED__
		typedef interface IPB_XMLDOMProcessingInstruction IPB_XMLDOMProcessingInstruction;
#endif 	/* __IPB_XMLDOMProcessingInstruction_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMAttr_FWD_DEFINED__
#define __IPB_XMLDOMAttr_FWD_DEFINED__
		typedef interface IPB_XMLDOMAttr IPB_XMLDOMAttr;
#endif 	/* __IPB_XMLDOMAttr_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMEntity_FWD_DEFINED__
#define __IPB_XMLDOMEntity_FWD_DEFINED__
		typedef interface IPB_XMLDOMEntity IPB_XMLDOMEntity;
#endif 	/* __IPB_XMLDOMEntity_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMEntityReference_FWD_DEFINED__
#define __IPB_XMLDOMEntityReference_FWD_DEFINED__
		typedef interface IPB_XMLDOMEntityReference IPB_XMLDOMEntityReference;
#endif 	/* __IPB_XMLDOMEntityReference_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMNotation_FWD_DEFINED__
#define __IPB_XMLDOMNotation_FWD_DEFINED__
		typedef interface IPB_XMLDOMNotation IPB_XMLDOMNotation;
#endif 	/* __IPB_XMLDOMNotation_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMDocumentFragment_FWD_DEFINED__
#define __IPB_XMLDOMDocumentFragment_FWD_DEFINED__
		typedef interface IPB_XMLDOMDocumentFragment IPB_XMLDOMDocumentFragment;
#endif 	/* __IPB_XMLDOMDocumentFragment_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMImplementation_FWD_DEFINED__
#define __IPB_XMLDOMImplementation_FWD_DEFINED__
		typedef interface IPB_XMLDOMImplementation IPB_XMLDOMImplementation;
#endif 	/* __IPB_XMLDOMImplementation_FWD_DEFINED__ */


#ifndef __IPB_XMLDOMDocument_FWD_DEFINED__
#define __IPB_XMLDOMDocument_FWD_DEFINED__
		typedef interface IPB_XMLDOMDocument IPB_XMLDOMDocument;
#endif 	/* __IPB_XMLDOMDocument_FWD_DEFINED__ */


		/* header files for imported files */
		// ***** DOINC including unknwn.h *****
			// DOINC skipping duplicate include
		// ***** DOINC including pbtypes.h *****
			// DOINC skipping duplicate include
		// ***** DOINC including contners.h *****


		/* this ALWAYS GENERATED file contains the definitions for the interfaces */


		 /* File created by MIDL compiler version 6.00.0361 */
		/* at Tue Apr 29 21:01:13 2014
		 */
		 /* Compiler settings for contners.idl:
			 Oicf, W1, Zp8, env=Win32 (32b run)
			 protocol : dce , ms_ext, c_ext, robust
			 error checks: allocation ref bounds_check enum stub_data
			 VC __declspec() decoration level:
				  __declspec(uuid()), __declspec(selectany), __declspec(novtable)
				  DECLSPEC_UUID(), MIDL_INTERFACE()
		 */
		 //@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

// ***** DOINC including rpc.h *****
	// DOINC skipping duplicate include
// ***** DOINC including rpcndr.h *****
	// DOINC skipping duplicate include

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
// ***** DOINC including windows.h *****
	// DOINC skipping duplicate include
// ***** DOINC including ole2.h *****
	// DOINC skipping duplicate include
#endif /*COM_NO_WINDOWS_H*/

#ifndef __contners_h__
#define __contners_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */

#ifndef __IPB_DynamicVector_FWD_DEFINED__
#define __IPB_DynamicVector_FWD_DEFINED__
		typedef interface IPB_DynamicVector IPB_DynamicVector;
#endif 	/* __IPB_DynamicVector_FWD_DEFINED__ */


#ifndef __IPB_List_FWD_DEFINED__
#define __IPB_List_FWD_DEFINED__
		typedef interface IPB_List IPB_List;
#endif 	/* __IPB_List_FWD_DEFINED__ */


#ifndef __IPB_UlongDictionary_FWD_DEFINED__
#define __IPB_UlongDictionary_FWD_DEFINED__
		typedef interface IPB_UlongDictionary IPB_UlongDictionary;
#endif 	/* __IPB_UlongDictionary_FWD_DEFINED__ */


#ifndef __IPB_StringDictionary_FWD_DEFINED__
#define __IPB_StringDictionary_FWD_DEFINED__
		typedef interface IPB_StringDictionary IPB_StringDictionary;
#endif 	/* __IPB_StringDictionary_FWD_DEFINED__ */


		/* header files for imported files */
		// ***** DOINC including unknwn.h *****
			// DOINC skipping duplicate include
		// ***** DOINC including objidl.h *****
			// DOINC skipping duplicate include
		// ***** DOINC including pbtypes.h *****
			// DOINC skipping duplicate include

#ifdef __cplusplus
		extern "C" {
#endif 

			void* __RPC_USER MIDL_user_allocate(size_t);
			void __RPC_USER MIDL_user_free(void*);

			/* interface __MIDL_itf_contners_0000 */
			/* [local] */

			//   Copyright Sybase, Inc. 1998
			//
			//   Sybase, Inc. ("Sybase") claims copyright in this
			//   program and documentation as an unpublished work, versions of
			//   which were first licensed on the date indicated in the foregoing
			//   notice.  Claim of copyright does not imply waiver of Sybase's
			//   other rights. See Notice of Proprietary Rights.
			//
			//   NOTICE OF PROPRIETARY RIGHTS
			//
			//   This program and documentation are confidential trade
			//   secrets and the property of Sybase.  Use, examination,
			//   reproduction, copying, disassembly, decompilation, transfer
			//   and/or disclosure to others are strictly prohibited except by
			//   express written agreement with Sybase.
			//
			//      Filename :   contners.h
			//
			//      Author   :   Chris McLaren
			//
			//      Purpose  :   COM Definition of interfaces to IUnknown* containers
			//
			//Common includes for containers

#ifndef OSWINDOW_H
// ***** DOINC including oswindow.h *****
	// DOINC skipping duplicate include
#endif
#ifndef SHRESULT_H
// ***** DOINC including shresult.h *****
	// DOINC skipping duplicate include
#endif
#ifndef PBSTG_H
// ***** DOINC including pbstg.h *****
	// DOINC skipping duplicate include
#endif
#ifndef PBASSERT_H
// ***** DOINC including pbassert.h *****
	// DOINC skipping duplicate include
#endif



			extern RPC_IF_HANDLE __MIDL_itf_contners_0000_v0_0_c_ifspec;
			extern RPC_IF_HANDLE __MIDL_itf_contners_0000_v0_0_s_ifspec;

#ifndef __IPB_DynamicVector_INTERFACE_DEFINED__
#define __IPB_DynamicVector_INTERFACE_DEFINED__

			/* interface IPB_DynamicVector */
			/* [unique][uuid][object][local] */


			EXTERN_C const IID IID_IPB_DynamicVector;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("2F381EB4-728A-11d1-9EA4-0000F8778DC6")
				IPB_DynamicVector : public IUnknown
			{
			public:
				virtual HRESULT STDMETHODCALLTYPE GetLength(
					/* [out] */ ULONG * pulLength) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetLength(
					/* [in] */ ULONG ulGrowTo) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetElementAt(
					/* [in] */ ULONG ulIndex,
					/* [out] */ IUnknown** ppValue) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetElementAt(
					/* [in] */ ULONG ulIndex,
					/* [in] */ IUnknown* pValue) = 0;

				virtual HRESULT STDMETHODCALLTYPE IsEmpty(
					/* [out] */ BOOL* plRes) = 0;

				virtual HRESULT STDMETHODCALLTYPE Clone(
					/* [out] */ IPB_DynamicVector** ppNewArray) = 0;

			};

#else 	/* C style interface */

			typedef struct IPB_DynamicVectorVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_DynamicVector* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_DynamicVector* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_DynamicVector* This);

				HRESULT(STDMETHODCALLTYPE* GetLength)(
					IPB_DynamicVector* This,
					/* [out] */ ULONG* pulLength);

				HRESULT(STDMETHODCALLTYPE* SetLength)(
					IPB_DynamicVector* This,
					/* [in] */ ULONG ulGrowTo);

				HRESULT(STDMETHODCALLTYPE* GetElementAt)(
					IPB_DynamicVector* This,
					/* [in] */ ULONG ulIndex,
					/* [out] */ IUnknown** ppValue);

				HRESULT(STDMETHODCALLTYPE* SetElementAt)(
					IPB_DynamicVector* This,
					/* [in] */ ULONG ulIndex,
					/* [in] */ IUnknown* pValue);

				HRESULT(STDMETHODCALLTYPE* IsEmpty)(
					IPB_DynamicVector* This,
					/* [out] */ BOOL* plRes);

				HRESULT(STDMETHODCALLTYPE* Clone)(
					IPB_DynamicVector* This,
					/* [out] */ IPB_DynamicVector** ppNewArray);

				END_INTERFACE
			} IPB_DynamicVectorVtbl;

			interface IPB_DynamicVector
			{
				CONST_VTBL struct IPB_DynamicVectorVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_DynamicVector_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_DynamicVector_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_DynamicVector_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_DynamicVector_GetLength(This,pulLength)	\
    (This)->lpVtbl -> GetLength(This,pulLength)

#define IPB_DynamicVector_SetLength(This,ulGrowTo)	\
    (This)->lpVtbl -> SetLength(This,ulGrowTo)

#define IPB_DynamicVector_GetElementAt(This,ulIndex,ppValue)	\
    (This)->lpVtbl -> GetElementAt(This,ulIndex,ppValue)

#define IPB_DynamicVector_SetElementAt(This,ulIndex,pValue)	\
    (This)->lpVtbl -> SetElementAt(This,ulIndex,pValue)

#define IPB_DynamicVector_IsEmpty(This,plRes)	\
    (This)->lpVtbl -> IsEmpty(This,plRes)

#define IPB_DynamicVector_Clone(This,ppNewArray)	\
    (This)->lpVtbl -> Clone(This,ppNewArray)

#endif /* COBJMACROS */


#endif 	/* C style interface */



			HRESULT STDMETHODCALLTYPE IPB_DynamicVector_GetLength_Proxy(
				IPB_DynamicVector* This,
				/* [out] */ ULONG* pulLength);


			void __RPC_STUB IPB_DynamicVector_GetLength_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_DynamicVector_SetLength_Proxy(
				IPB_DynamicVector* This,
				/* [in] */ ULONG ulGrowTo);


			void __RPC_STUB IPB_DynamicVector_SetLength_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_DynamicVector_GetElementAt_Proxy(
				IPB_DynamicVector* This,
				/* [in] */ ULONG ulIndex,
				/* [out] */ IUnknown** ppValue);


			void __RPC_STUB IPB_DynamicVector_GetElementAt_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_DynamicVector_SetElementAt_Proxy(
				IPB_DynamicVector* This,
				/* [in] */ ULONG ulIndex,
				/* [in] */ IUnknown* pValue);


			void __RPC_STUB IPB_DynamicVector_SetElementAt_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_DynamicVector_IsEmpty_Proxy(
				IPB_DynamicVector* This,
				/* [out] */ BOOL* plRes);


			void __RPC_STUB IPB_DynamicVector_IsEmpty_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_DynamicVector_Clone_Proxy(
				IPB_DynamicVector* This,
				/* [out] */ IPB_DynamicVector** ppNewArray);


			void __RPC_STUB IPB_DynamicVector_Clone_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);



#endif 	/* __IPB_DynamicVector_INTERFACE_DEFINED__ */


#ifndef __IPB_List_INTERFACE_DEFINED__
#define __IPB_List_INTERFACE_DEFINED__

			/* interface IPB_List */
			/* [unique][uuid][object][local] */


			EXTERN_C const IID IID_IPB_List;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("2F381EB5-728A-11d1-9EA4-0000F8778DC6")
				IPB_List : public IUnknown
			{
			public:
				virtual HRESULT STDMETHODCALLTYPE AddHead(
					/* [in] */ IUnknown * pValue) = 0;

				virtual HRESULT STDMETHODCALLTYPE AddTail(
					/* [in] */ IUnknown* pValue) = 0;

				virtual HRESULT STDMETHODCALLTYPE RemoveHead(
					/* [out] */ IUnknown** ppOldHead) = 0;

				virtual HRESULT STDMETHODCALLTYPE RemoveTail(
					/* [out] */ IUnknown** ppOldTail) = 0;

				virtual HRESULT STDMETHODCALLTYPE InsertAfter(
					/* [in] */ IUnknown* pTarget,
					/* [in] */ IUnknown* pValue) = 0;

				virtual HRESULT STDMETHODCALLTYPE InsertBefore(
					/* [in] */ IUnknown* pTarget,
					/* [in] */ IUnknown* pValue) = 0;

				virtual HRESULT STDMETHODCALLTYPE RemoveAfter(
					/* [in] */ IUnknown* pTarget,
					/* [out] */ IUnknown** ppValue) = 0;

				virtual HRESULT STDMETHODCALLTYPE RemoveBefore(
					/* [in] */ IUnknown* pTarget,
					/* [out] */ IUnknown** pValue) = 0;

				virtual HRESULT STDMETHODCALLTYPE Remove(
					/* [in] */ IUnknown* pValue) = 0;

				virtual HRESULT STDMETHODCALLTYPE Query(
					/* [in] */ IUnknown* pValue) = 0;

				virtual HRESULT STDMETHODCALLTYPE Enumerate(
					/* [out] */ IEnumUnknown** ppIterator) = 0;

				virtual HRESULT STDMETHODCALLTYPE Count(
					/* [out] */ ULONG* pulCount) = 0;

				virtual HRESULT STDMETHODCALLTYPE IsEmpty(
					/* [out] */ BOOL* plRes) = 0;

				virtual HRESULT STDMETHODCALLTYPE Clear(void) = 0;

				virtual HRESULT STDMETHODCALLTYPE Clone(
					/* [out] */ IPB_List** ppNewArray) = 0;

			};

#else 	/* C style interface */

			typedef struct IPB_ListVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_List* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_List* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_List* This);

				HRESULT(STDMETHODCALLTYPE* AddHead)(
					IPB_List* This,
					/* [in] */ IUnknown* pValue);

				HRESULT(STDMETHODCALLTYPE* AddTail)(
					IPB_List* This,
					/* [in] */ IUnknown* pValue);

				HRESULT(STDMETHODCALLTYPE* RemoveHead)(
					IPB_List* This,
					/* [out] */ IUnknown** ppOldHead);

				HRESULT(STDMETHODCALLTYPE* RemoveTail)(
					IPB_List* This,
					/* [out] */ IUnknown** ppOldTail);

				HRESULT(STDMETHODCALLTYPE* InsertAfter)(
					IPB_List* This,
					/* [in] */ IUnknown* pTarget,
					/* [in] */ IUnknown* pValue);

				HRESULT(STDMETHODCALLTYPE* InsertBefore)(
					IPB_List* This,
					/* [in] */ IUnknown* pTarget,
					/* [in] */ IUnknown* pValue);

				HRESULT(STDMETHODCALLTYPE* RemoveAfter)(
					IPB_List* This,
					/* [in] */ IUnknown* pTarget,
					/* [out] */ IUnknown** ppValue);

				HRESULT(STDMETHODCALLTYPE* RemoveBefore)(
					IPB_List* This,
					/* [in] */ IUnknown* pTarget,
					/* [out] */ IUnknown** pValue);

				HRESULT(STDMETHODCALLTYPE* Remove)(
					IPB_List* This,
					/* [in] */ IUnknown* pValue);

				HRESULT(STDMETHODCALLTYPE* Query)(
					IPB_List* This,
					/* [in] */ IUnknown* pValue);

				HRESULT(STDMETHODCALLTYPE* Enumerate)(
					IPB_List* This,
					/* [out] */ IEnumUnknown** ppIterator);

				HRESULT(STDMETHODCALLTYPE* Count)(
					IPB_List* This,
					/* [out] */ ULONG* pulCount);

				HRESULT(STDMETHODCALLTYPE* IsEmpty)(
					IPB_List* This,
					/* [out] */ BOOL* plRes);

				HRESULT(STDMETHODCALLTYPE* Clear)(
					IPB_List* This);

				HRESULT(STDMETHODCALLTYPE* Clone)(
					IPB_List* This,
					/* [out] */ IPB_List** ppNewArray);

				END_INTERFACE
			} IPB_ListVtbl;

			interface IPB_List
			{
				CONST_VTBL struct IPB_ListVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_List_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_List_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_List_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_List_AddHead(This,pValue)	\
    (This)->lpVtbl -> AddHead(This,pValue)

#define IPB_List_AddTail(This,pValue)	\
    (This)->lpVtbl -> AddTail(This,pValue)

#define IPB_List_RemoveHead(This,ppOldHead)	\
    (This)->lpVtbl -> RemoveHead(This,ppOldHead)

#define IPB_List_RemoveTail(This,ppOldTail)	\
    (This)->lpVtbl -> RemoveTail(This,ppOldTail)

#define IPB_List_InsertAfter(This,pTarget,pValue)	\
    (This)->lpVtbl -> InsertAfter(This,pTarget,pValue)

#define IPB_List_InsertBefore(This,pTarget,pValue)	\
    (This)->lpVtbl -> InsertBefore(This,pTarget,pValue)

#define IPB_List_RemoveAfter(This,pTarget,ppValue)	\
    (This)->lpVtbl -> RemoveAfter(This,pTarget,ppValue)

#define IPB_List_RemoveBefore(This,pTarget,pValue)	\
    (This)->lpVtbl -> RemoveBefore(This,pTarget,pValue)

#define IPB_List_Remove(This,pValue)	\
    (This)->lpVtbl -> Remove(This,pValue)

#define IPB_List_Query(This,pValue)	\
    (This)->lpVtbl -> Query(This,pValue)

#define IPB_List_Enumerate(This,ppIterator)	\
    (This)->lpVtbl -> Enumerate(This,ppIterator)

#define IPB_List_Count(This,pulCount)	\
    (This)->lpVtbl -> Count(This,pulCount)

#define IPB_List_IsEmpty(This,plRes)	\
    (This)->lpVtbl -> IsEmpty(This,plRes)

#define IPB_List_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define IPB_List_Clone(This,ppNewArray)	\
    (This)->lpVtbl -> Clone(This,ppNewArray)

#endif /* COBJMACROS */


#endif 	/* C style interface */



			HRESULT STDMETHODCALLTYPE IPB_List_AddHead_Proxy(
				IPB_List* This,
				/* [in] */ IUnknown* pValue);


			void __RPC_STUB IPB_List_AddHead_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_List_AddTail_Proxy(
				IPB_List* This,
				/* [in] */ IUnknown* pValue);


			void __RPC_STUB IPB_List_AddTail_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_List_RemoveHead_Proxy(
				IPB_List* This,
				/* [out] */ IUnknown** ppOldHead);


			void __RPC_STUB IPB_List_RemoveHead_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_List_RemoveTail_Proxy(
				IPB_List* This,
				/* [out] */ IUnknown** ppOldTail);


			void __RPC_STUB IPB_List_RemoveTail_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_List_InsertAfter_Proxy(
				IPB_List* This,
				/* [in] */ IUnknown* pTarget,
				/* [in] */ IUnknown* pValue);


			void __RPC_STUB IPB_List_InsertAfter_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_List_InsertBefore_Proxy(
				IPB_List* This,
				/* [in] */ IUnknown* pTarget,
				/* [in] */ IUnknown* pValue);


			void __RPC_STUB IPB_List_InsertBefore_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_List_RemoveAfter_Proxy(
				IPB_List* This,
				/* [in] */ IUnknown* pTarget,
				/* [out] */ IUnknown** ppValue);


			void __RPC_STUB IPB_List_RemoveAfter_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_List_RemoveBefore_Proxy(
				IPB_List* This,
				/* [in] */ IUnknown* pTarget,
				/* [out] */ IUnknown** pValue);


			void __RPC_STUB IPB_List_RemoveBefore_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_List_Remove_Proxy(
				IPB_List* This,
				/* [in] */ IUnknown* pValue);


			void __RPC_STUB IPB_List_Remove_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_List_Query_Proxy(
				IPB_List* This,
				/* [in] */ IUnknown* pValue);


			void __RPC_STUB IPB_List_Query_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_List_Enumerate_Proxy(
				IPB_List* This,
				/* [out] */ IEnumUnknown** ppIterator);


			void __RPC_STUB IPB_List_Enumerate_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_List_Count_Proxy(
				IPB_List* This,
				/* [out] */ ULONG* pulCount);


			void __RPC_STUB IPB_List_Count_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_List_IsEmpty_Proxy(
				IPB_List* This,
				/* [out] */ BOOL* plRes);


			void __RPC_STUB IPB_List_IsEmpty_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_List_Clear_Proxy(
				IPB_List* This);


			void __RPC_STUB IPB_List_Clear_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_List_Clone_Proxy(
				IPB_List* This,
				/* [out] */ IPB_List** ppNewArray);


			void __RPC_STUB IPB_List_Clone_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);



#endif 	/* __IPB_List_INTERFACE_DEFINED__ */


#ifndef __IPB_UlongDictionary_INTERFACE_DEFINED__
#define __IPB_UlongDictionary_INTERFACE_DEFINED__

			/* interface IPB_UlongDictionary */
			/* [unique][uuid][object][local] */


			EXTERN_C const IID IID_IPB_UlongDictionary;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("2F381EB7-728A-11d1-9EA4-0000F8778DC6")
				IPB_UlongDictionary : public IUnknown
			{
			public:
				virtual HRESULT STDMETHODCALLTYPE Add(
					/* [in] */ ULONG ulKey,
					/* [in] */ IUnknown * pValue) = 0;

				virtual HRESULT STDMETHODCALLTYPE Remove(
					/* [in] */ ULONG ulKey,
					/* [in] */ IUnknown* pValue) = 0;

				virtual HRESULT STDMETHODCALLTYPE RemoveKey(
					/* [in] */ ULONG ulKey) = 0;

				virtual HRESULT STDMETHODCALLTYPE Lookup(
					/* [in] */ ULONG ulKey,
					/* [out] */ IUnknown** ppValue) = 0;

				virtual HRESULT STDMETHODCALLTYPE LookupMulti(
					/* [in] */ ULONG ulKey,
					/* [out] */ IEnumUnknown** ppValue) = 0;

				virtual HRESULT STDMETHODCALLTYPE EnumerateKeys(
					/* [out] */ IEnumUnknown** ppIterator) = 0;

				virtual HRESULT STDMETHODCALLTYPE Enumerate(
					/* [out] */ IEnumUnknown** ppIterator) = 0;

				virtual HRESULT STDMETHODCALLTYPE Count(
					/* [out] */ ULONG* pulCount) = 0;

				virtual HRESULT STDMETHODCALLTYPE IsEmpty(
					/* [out] */ BOOL* plRes) = 0;

				virtual HRESULT STDMETHODCALLTYPE Clear(void) = 0;

				virtual HRESULT STDMETHODCALLTYPE Clone(
					/* [out] */ IPB_UlongDictionary** ppNewDict) = 0;

				virtual HRESULT STDMETHODCALLTYPE CheckFlag(
					/* [in] */ ULONG ulFlag) = 0;

			};

#else 	/* C style interface */

			typedef struct IPB_UlongDictionaryVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_UlongDictionary* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_UlongDictionary* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_UlongDictionary* This);

				HRESULT(STDMETHODCALLTYPE* Add)(
					IPB_UlongDictionary* This,
					/* [in] */ ULONG ulKey,
					/* [in] */ IUnknown* pValue);

				HRESULT(STDMETHODCALLTYPE* Remove)(
					IPB_UlongDictionary* This,
					/* [in] */ ULONG ulKey,
					/* [in] */ IUnknown* pValue);

				HRESULT(STDMETHODCALLTYPE* RemoveKey)(
					IPB_UlongDictionary* This,
					/* [in] */ ULONG ulKey);

				HRESULT(STDMETHODCALLTYPE* Lookup)(
					IPB_UlongDictionary* This,
					/* [in] */ ULONG ulKey,
					/* [out] */ IUnknown** ppValue);

				HRESULT(STDMETHODCALLTYPE* LookupMulti)(
					IPB_UlongDictionary* This,
					/* [in] */ ULONG ulKey,
					/* [out] */ IEnumUnknown** ppValue);

				HRESULT(STDMETHODCALLTYPE* EnumerateKeys)(
					IPB_UlongDictionary* This,
					/* [out] */ IEnumUnknown** ppIterator);

				HRESULT(STDMETHODCALLTYPE* Enumerate)(
					IPB_UlongDictionary* This,
					/* [out] */ IEnumUnknown** ppIterator);

				HRESULT(STDMETHODCALLTYPE* Count)(
					IPB_UlongDictionary* This,
					/* [out] */ ULONG* pulCount);

				HRESULT(STDMETHODCALLTYPE* IsEmpty)(
					IPB_UlongDictionary* This,
					/* [out] */ BOOL* plRes);

				HRESULT(STDMETHODCALLTYPE* Clear)(
					IPB_UlongDictionary* This);

				HRESULT(STDMETHODCALLTYPE* Clone)(
					IPB_UlongDictionary* This,
					/* [out] */ IPB_UlongDictionary** ppNewDict);

				HRESULT(STDMETHODCALLTYPE* CheckFlag)(
					IPB_UlongDictionary* This,
					/* [in] */ ULONG ulFlag);

				END_INTERFACE
			} IPB_UlongDictionaryVtbl;

			interface IPB_UlongDictionary
			{
				CONST_VTBL struct IPB_UlongDictionaryVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_UlongDictionary_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_UlongDictionary_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_UlongDictionary_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_UlongDictionary_Add(This,ulKey,pValue)	\
    (This)->lpVtbl -> Add(This,ulKey,pValue)

#define IPB_UlongDictionary_Remove(This,ulKey,pValue)	\
    (This)->lpVtbl -> Remove(This,ulKey,pValue)

#define IPB_UlongDictionary_RemoveKey(This,ulKey)	\
    (This)->lpVtbl -> RemoveKey(This,ulKey)

#define IPB_UlongDictionary_Lookup(This,ulKey,ppValue)	\
    (This)->lpVtbl -> Lookup(This,ulKey,ppValue)

#define IPB_UlongDictionary_LookupMulti(This,ulKey,ppValue)	\
    (This)->lpVtbl -> LookupMulti(This,ulKey,ppValue)

#define IPB_UlongDictionary_EnumerateKeys(This,ppIterator)	\
    (This)->lpVtbl -> EnumerateKeys(This,ppIterator)

#define IPB_UlongDictionary_Enumerate(This,ppIterator)	\
    (This)->lpVtbl -> Enumerate(This,ppIterator)

#define IPB_UlongDictionary_Count(This,pulCount)	\
    (This)->lpVtbl -> Count(This,pulCount)

#define IPB_UlongDictionary_IsEmpty(This,plRes)	\
    (This)->lpVtbl -> IsEmpty(This,plRes)

#define IPB_UlongDictionary_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define IPB_UlongDictionary_Clone(This,ppNewDict)	\
    (This)->lpVtbl -> Clone(This,ppNewDict)

#define IPB_UlongDictionary_CheckFlag(This,ulFlag)	\
    (This)->lpVtbl -> CheckFlag(This,ulFlag)

#endif /* COBJMACROS */


#endif 	/* C style interface */



			HRESULT STDMETHODCALLTYPE IPB_UlongDictionary_Add_Proxy(
				IPB_UlongDictionary* This,
				/* [in] */ ULONG ulKey,
				/* [in] */ IUnknown* pValue);


			void __RPC_STUB IPB_UlongDictionary_Add_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_UlongDictionary_Remove_Proxy(
				IPB_UlongDictionary* This,
				/* [in] */ ULONG ulKey,
				/* [in] */ IUnknown* pValue);


			void __RPC_STUB IPB_UlongDictionary_Remove_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_UlongDictionary_RemoveKey_Proxy(
				IPB_UlongDictionary* This,
				/* [in] */ ULONG ulKey);


			void __RPC_STUB IPB_UlongDictionary_RemoveKey_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_UlongDictionary_Lookup_Proxy(
				IPB_UlongDictionary* This,
				/* [in] */ ULONG ulKey,
				/* [out] */ IUnknown** ppValue);


			void __RPC_STUB IPB_UlongDictionary_Lookup_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_UlongDictionary_LookupMulti_Proxy(
				IPB_UlongDictionary* This,
				/* [in] */ ULONG ulKey,
				/* [out] */ IEnumUnknown** ppValue);


			void __RPC_STUB IPB_UlongDictionary_LookupMulti_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_UlongDictionary_EnumerateKeys_Proxy(
				IPB_UlongDictionary* This,
				/* [out] */ IEnumUnknown** ppIterator);


			void __RPC_STUB IPB_UlongDictionary_EnumerateKeys_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_UlongDictionary_Enumerate_Proxy(
				IPB_UlongDictionary* This,
				/* [out] */ IEnumUnknown** ppIterator);


			void __RPC_STUB IPB_UlongDictionary_Enumerate_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_UlongDictionary_Count_Proxy(
				IPB_UlongDictionary* This,
				/* [out] */ ULONG* pulCount);


			void __RPC_STUB IPB_UlongDictionary_Count_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_UlongDictionary_IsEmpty_Proxy(
				IPB_UlongDictionary* This,
				/* [out] */ BOOL* plRes);


			void __RPC_STUB IPB_UlongDictionary_IsEmpty_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_UlongDictionary_Clear_Proxy(
				IPB_UlongDictionary* This);


			void __RPC_STUB IPB_UlongDictionary_Clear_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_UlongDictionary_Clone_Proxy(
				IPB_UlongDictionary* This,
				/* [out] */ IPB_UlongDictionary** ppNewDict);


			void __RPC_STUB IPB_UlongDictionary_Clone_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_UlongDictionary_CheckFlag_Proxy(
				IPB_UlongDictionary* This,
				/* [in] */ ULONG ulFlag);


			void __RPC_STUB IPB_UlongDictionary_CheckFlag_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);



#endif 	/* __IPB_UlongDictionary_INTERFACE_DEFINED__ */


#ifndef __IPB_StringDictionary_INTERFACE_DEFINED__
#define __IPB_StringDictionary_INTERFACE_DEFINED__

			/* interface IPB_StringDictionary */
			/* [unique][uuid][object][local] */


			EXTERN_C const IID IID_IPB_StringDictionary;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("2F381EB8-728A-11d1-9EA4-0000F8778DC6")
				IPB_StringDictionary : public IUnknown
			{
			public:
				virtual HRESULT STDMETHODCALLTYPE Add(
					/* [in] */ IPB_String * pKey,
					/* [in] */ IUnknown * pValue) = 0;

				virtual HRESULT STDMETHODCALLTYPE Remove(
					/* [in] */ IPB_String* pKey,
					/* [in] */ IUnknown* pValue) = 0;

				virtual HRESULT STDMETHODCALLTYPE RemoveKey(
					/* [in] */ IPB_String* pKey) = 0;

				virtual HRESULT STDMETHODCALLTYPE LookupTStr(
					/* [in] */ LPTSTR pKey,
					/* [out] */ IUnknown** ppValue) = 0;

				virtual HRESULT STDMETHODCALLTYPE LookupTStrMulti(
					/* [in] */ LPTSTR pKey,
					/* [out] */ IEnumUnknown** ppValue) = 0;

				virtual HRESULT STDMETHODCALLTYPE Lookup(
					/* [in] */ IPB_String* pKey,
					/* [out] */ IUnknown** ppValue) = 0;

				virtual HRESULT STDMETHODCALLTYPE LookupMulti(
					/* [in] */ IPB_String* pKey,
					/* [out] */ IEnumUnknown** ppValue) = 0;

				virtual HRESULT STDMETHODCALLTYPE Enumerate(
					/* [out] */ IEnumUnknown** ppIterator) = 0;

				virtual HRESULT STDMETHODCALLTYPE EnumerateKeys(
					/* [out] */ IEnumUnknown** ppIterator) = 0;

				virtual HRESULT STDMETHODCALLTYPE Count(
					/* [out] */ ULONG* pulCount) = 0;

				virtual HRESULT STDMETHODCALLTYPE IsEmpty(
					/* [out] */ BOOL* plRes) = 0;

				virtual HRESULT STDMETHODCALLTYPE Clear(void) = 0;

				virtual HRESULT STDMETHODCALLTYPE Clone(
					/* [out] */ IPB_StringDictionary** ppNewDict) = 0;

				virtual HRESULT STDMETHODCALLTYPE CheckFlag(
					/* [in] */ ULONG ulFlag) = 0;

			};

#else 	/* C style interface */

			typedef struct IPB_StringDictionaryVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_StringDictionary* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_StringDictionary* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_StringDictionary* This);

				HRESULT(STDMETHODCALLTYPE* Add)(
					IPB_StringDictionary* This,
					/* [in] */ IPB_String* pKey,
					/* [in] */ IUnknown* pValue);

				HRESULT(STDMETHODCALLTYPE* Remove)(
					IPB_StringDictionary* This,
					/* [in] */ IPB_String* pKey,
					/* [in] */ IUnknown* pValue);

				HRESULT(STDMETHODCALLTYPE* RemoveKey)(
					IPB_StringDictionary* This,
					/* [in] */ IPB_String* pKey);

				HRESULT(STDMETHODCALLTYPE* LookupTStr)(
					IPB_StringDictionary* This,
					/* [in] */ LPTSTR pKey,
					/* [out] */ IUnknown** ppValue);

				HRESULT(STDMETHODCALLTYPE* LookupTStrMulti)(
					IPB_StringDictionary* This,
					/* [in] */ LPTSTR pKey,
					/* [out] */ IEnumUnknown** ppValue);

				HRESULT(STDMETHODCALLTYPE* Lookup)(
					IPB_StringDictionary* This,
					/* [in] */ IPB_String* pKey,
					/* [out] */ IUnknown** ppValue);

				HRESULT(STDMETHODCALLTYPE* LookupMulti)(
					IPB_StringDictionary* This,
					/* [in] */ IPB_String* pKey,
					/* [out] */ IEnumUnknown** ppValue);

				HRESULT(STDMETHODCALLTYPE* Enumerate)(
					IPB_StringDictionary* This,
					/* [out] */ IEnumUnknown** ppIterator);

				HRESULT(STDMETHODCALLTYPE* EnumerateKeys)(
					IPB_StringDictionary* This,
					/* [out] */ IEnumUnknown** ppIterator);

				HRESULT(STDMETHODCALLTYPE* Count)(
					IPB_StringDictionary* This,
					/* [out] */ ULONG* pulCount);

				HRESULT(STDMETHODCALLTYPE* IsEmpty)(
					IPB_StringDictionary* This,
					/* [out] */ BOOL* plRes);

				HRESULT(STDMETHODCALLTYPE* Clear)(
					IPB_StringDictionary* This);

				HRESULT(STDMETHODCALLTYPE* Clone)(
					IPB_StringDictionary* This,
					/* [out] */ IPB_StringDictionary** ppNewDict);

				HRESULT(STDMETHODCALLTYPE* CheckFlag)(
					IPB_StringDictionary* This,
					/* [in] */ ULONG ulFlag);

				END_INTERFACE
			} IPB_StringDictionaryVtbl;

			interface IPB_StringDictionary
			{
				CONST_VTBL struct IPB_StringDictionaryVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_StringDictionary_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_StringDictionary_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_StringDictionary_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_StringDictionary_Add(This,pKey,pValue)	\
    (This)->lpVtbl -> Add(This,pKey,pValue)

#define IPB_StringDictionary_Remove(This,pKey,pValue)	\
    (This)->lpVtbl -> Remove(This,pKey,pValue)

#define IPB_StringDictionary_RemoveKey(This,pKey)	\
    (This)->lpVtbl -> RemoveKey(This,pKey)

#define IPB_StringDictionary_LookupTStr(This,pKey,ppValue)	\
    (This)->lpVtbl -> LookupTStr(This,pKey,ppValue)

#define IPB_StringDictionary_LookupTStrMulti(This,pKey,ppValue)	\
    (This)->lpVtbl -> LookupTStrMulti(This,pKey,ppValue)

#define IPB_StringDictionary_Lookup(This,pKey,ppValue)	\
    (This)->lpVtbl -> Lookup(This,pKey,ppValue)

#define IPB_StringDictionary_LookupMulti(This,pKey,ppValue)	\
    (This)->lpVtbl -> LookupMulti(This,pKey,ppValue)

#define IPB_StringDictionary_Enumerate(This,ppIterator)	\
    (This)->lpVtbl -> Enumerate(This,ppIterator)

#define IPB_StringDictionary_EnumerateKeys(This,ppIterator)	\
    (This)->lpVtbl -> EnumerateKeys(This,ppIterator)

#define IPB_StringDictionary_Count(This,pulCount)	\
    (This)->lpVtbl -> Count(This,pulCount)

#define IPB_StringDictionary_IsEmpty(This,plRes)	\
    (This)->lpVtbl -> IsEmpty(This,plRes)

#define IPB_StringDictionary_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define IPB_StringDictionary_Clone(This,ppNewDict)	\
    (This)->lpVtbl -> Clone(This,ppNewDict)

#define IPB_StringDictionary_CheckFlag(This,ulFlag)	\
    (This)->lpVtbl -> CheckFlag(This,ulFlag)

#endif /* COBJMACROS */


#endif 	/* C style interface */



			HRESULT STDMETHODCALLTYPE IPB_StringDictionary_Add_Proxy(
				IPB_StringDictionary* This,
				/* [in] */ IPB_String* pKey,
				/* [in] */ IUnknown* pValue);


			void __RPC_STUB IPB_StringDictionary_Add_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_StringDictionary_Remove_Proxy(
				IPB_StringDictionary* This,
				/* [in] */ IPB_String* pKey,
				/* [in] */ IUnknown* pValue);


			void __RPC_STUB IPB_StringDictionary_Remove_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_StringDictionary_RemoveKey_Proxy(
				IPB_StringDictionary* This,
				/* [in] */ IPB_String* pKey);


			void __RPC_STUB IPB_StringDictionary_RemoveKey_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_StringDictionary_LookupTStr_Proxy(
				IPB_StringDictionary* This,
				/* [in] */ LPTSTR pKey,
				/* [out] */ IUnknown** ppValue);


			void __RPC_STUB IPB_StringDictionary_LookupTStr_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_StringDictionary_LookupTStrMulti_Proxy(
				IPB_StringDictionary* This,
				/* [in] */ LPTSTR pKey,
				/* [out] */ IEnumUnknown** ppValue);


			void __RPC_STUB IPB_StringDictionary_LookupTStrMulti_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_StringDictionary_Lookup_Proxy(
				IPB_StringDictionary* This,
				/* [in] */ IPB_String* pKey,
				/* [out] */ IUnknown** ppValue);


			void __RPC_STUB IPB_StringDictionary_Lookup_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_StringDictionary_LookupMulti_Proxy(
				IPB_StringDictionary* This,
				/* [in] */ IPB_String* pKey,
				/* [out] */ IEnumUnknown** ppValue);


			void __RPC_STUB IPB_StringDictionary_LookupMulti_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_StringDictionary_Enumerate_Proxy(
				IPB_StringDictionary* This,
				/* [out] */ IEnumUnknown** ppIterator);


			void __RPC_STUB IPB_StringDictionary_Enumerate_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_StringDictionary_EnumerateKeys_Proxy(
				IPB_StringDictionary* This,
				/* [out] */ IEnumUnknown** ppIterator);


			void __RPC_STUB IPB_StringDictionary_EnumerateKeys_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_StringDictionary_Count_Proxy(
				IPB_StringDictionary* This,
				/* [out] */ ULONG* pulCount);


			void __RPC_STUB IPB_StringDictionary_Count_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_StringDictionary_IsEmpty_Proxy(
				IPB_StringDictionary* This,
				/* [out] */ BOOL* plRes);


			void __RPC_STUB IPB_StringDictionary_IsEmpty_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_StringDictionary_Clear_Proxy(
				IPB_StringDictionary* This);


			void __RPC_STUB IPB_StringDictionary_Clear_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_StringDictionary_Clone_Proxy(
				IPB_StringDictionary* This,
				/* [out] */ IPB_StringDictionary** ppNewDict);


			void __RPC_STUB IPB_StringDictionary_Clone_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_StringDictionary_CheckFlag_Proxy(
				IPB_StringDictionary* This,
				/* [in] */ ULONG ulFlag);


			void __RPC_STUB IPB_StringDictionary_CheckFlag_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);



#endif 	/* __IPB_StringDictionary_INTERFACE_DEFINED__ */


			/* interface __MIDL_itf_contners_0108 */
			/* [local] */


#define PB_DYNVEC_DEF_SIZE 10uL

#define PB_DICT_DEFAULT_SIZE 101uL

//dictionary creation flags
#define PB_DICT_CASEINS 0x01ul
#define PB_DICT_GROWHT 0x02uL

#ifdef __cplusplus
			extern "C" {
#endif

				PBWINAPI(HRESULT, CreateList)(IPB_List**);
				PBWINAPI(HRESULT, CreateListFromArray)(IUnknown** pData, ULONG ulSize, IPB_List**);

				PBWINAPI(HRESULT, CreateDynamicVector)(IPB_DynamicVector**);
				PBWINAPI(HRESULT, CreateDynamicVectorWithSize)(ULONG ulSizeHint, IPB_DynamicVector**);
				PBWINAPI(HRESULT, CreateDynamicVectorFromArray)(IUnknown** ppStart, ULONG ulStartLength, ULONG ulSizeHint, IPB_DynamicVector**);

				PBWINAPI(HRESULT, CreateStringDictionary)(IPB_StringDictionary**);
				PBWINAPI(HRESULT, CreateStringDictionaryWithSize)(ULONG ulSize, IPB_StringDictionary**);
				PBWINAPI(HRESULT, CreateStringDictionaryWithFlags)(ULONG ulSize, ULONG ulFlags, IPB_StringDictionary**);

				PBWINAPI(HRESULT, CreateUlongDictionary)(IPB_UlongDictionary**);
				PBWINAPI(HRESULT, CreateUlongDictionaryWithSize)(ULONG ulSize, IPB_UlongDictionary**);
				PBWINAPI(HRESULT, CreateUlongDictionaryWithFlags)(ULONG ulSize, ULONG ulFlags, IPB_UlongDictionary**);

				PBWINAPI(HRESULT, CreateEnumUnknown)(IUnknown** ppArrayFrom, ULONG ulCount, ULONG ulCurrent, IEnumUnknown** ppNewEU);

#ifdef __cplusplus
			}; // extern "C"
#endif


			extern RPC_IF_HANDLE __MIDL_itf_contners_0108_v0_0_c_ifspec;
			extern RPC_IF_HANDLE __MIDL_itf_contners_0108_v0_0_s_ifspec;

			/* Additional Prototypes for ALL interfaces */

			/* end of Additional Prototypes */

#ifdef __cplusplus
		}
#endif

#endif


		// DOINC popped back into header 'pbxml.h'

#ifdef __cplusplus
		extern "C" {
#endif 

			void* __RPC_USER MIDL_user_allocate(size_t);
			void __RPC_USER MIDL_user_free(void*);

			/* interface __MIDL_itf_pbxml_0000 */
			/* [local] */

			//       Copyright Sybase, Inc. 1998
			//
			//   Sybase, Inc. ("Sybase") claims copyright in this
			//   program and documentation as an unpublished work, versions of
			//   which were first licensed on the date indicated in the foregoing
			//   notice.  Claim of copyright does not imply waiver of Sybase's
			//   other rights.
			//
			//   Author: Angelo Scipione, Lim Bio Liong, Elke Blankenstein.
#ifndef PBCOM_H
// ***** DOINC including pbcom.h *****
	// DOINC skipping duplicate include
#endif











			enum PBXML_ExceptionCode
			{
				PBXML_EXCEPTION_NO_EXCEPTION = 0,
				PBXML_EXCEPTION_DOM_INDEX_SIZE_ERR = 1,
				PBXML_EXCEPTION_DOM_DOMSTRING_SIZE_ERR = 2,
				PBXML_EXCEPTION_DOM_HIERARCHY_REQUEST_ERR = 3,
				PBXML_EXCEPTION_DOM_WRONG_DOCUMENT_ERR = 4,
				PBXML_EXCEPTION_DOM_INVALID_CHARACTER_ERR = 5,
				PBXML_EXCEPTION_DOM_NO_DATA_ALLOWED_ERR = 6,
				PBXML_EXCEPTION_DOM_NO_MODIFICATION_ALLOWED_ERR = 7,
				PBXML_EXCEPTION_DOM_NOT_FOUND_ERR = 8,
				PBXML_EXCEPTION_DOM_NOT_SUPPORTED_ERR = 9,
				PBXML_EXCEPTION_DOM_INUSE_ATTRIBUTE_ERR = 10,
				PBXML_EXCEPTION_DOM_INVALID_STATE_ERR = 11,
				PBXML_EXCEPTION_DOM_SYNTAX_ERR = 12,
				PBXML_EXCEPTION_DOM_INVALID_MODIFICATION_ERR = 13,
				PBXML_EXCEPTION_DOM_NAMESPACE_ERR = 14,
				PBXML_EXCEPTION_DOM_INVALID_ACCESS_ERR = 15,
				PBXML_EXCEPTION_INVALID_PB_STRING = 2000,
				PBXML_EXCEPTION_NO_MEMORY = 2001,
				PBXML_EXCEPTION_CREATE_STRING_FAIL = 2002,
				PBXML_EXCEPTION_INVALID_POINTER = 2003,
				PBXML_EXCEPTION_CREATE_TEMP_FILE_FAIL = 2004,
				PBXML_EXCEPTION_CREATE_NAMED_NODE_MAP_FAIL = 2005,
				PBXML_EXCEPTION_NULL_IMPLEMENTATION = 2006,
				PBXML_EXCEPTION_CREATE_NODE_LIST_FAIL = 2007,
				PBXML_EXCEPTION_OBJECT_ALREADY_IN_USE = 2008,
				PBXML_EXCEPTION_GENERAL_EXCEPTION = 2009,
				PBXML_EXCEPTION_WHILE_GETTING_EXCEPTION_INFO = 2010
			};
#define PBXML_DOM_PARSER_OPTION_VALIDATION_ON            0x00000001
#define PBXML_DOM_PARSER_OPTION_CHECK_WELLFORMEDNESS     0x00000002
#define PBXML_DOM_PARSER_OPTION_PROCESS_NAMESPACES       0x00000004
#define PBXML_DOM_PARSER_OPTION_SET_ERROR_CHECKING       0x00000008
#define PBXML_DOM_PARSER_OPTION_PARSETIME_EXPAND_ENTREF  0x00000010
#define PBXML_DOM_PARSER_OPTION_SERIALIZATION_USE_NO_ESC 0x00000020
#define PBXML_DOM_PARSER_OPTION_EXIT_ON_FIRST_FATAL_ERR  0x00000040
#define PBXML_DOM_PARSER_OPTION_SERIALIZATION_EXPAND_EMPTY 0x00000080
#define PBXML_DOM_PARSER_OPTION_SERIALIZATION_USE_CHAR_ESC 0x00000100
#define PBXML_DOM_PARSER_OPTION_SERIALIZATION_NO_WHITESPACE 0x00000200
#define PBXML_PARSE_ERROR_OPTION_WARNING                 0x00000001
#define PBXML_PARSE_ERROR_OPTION_ERROR                   0x00000002
#define PBXML_PARSE_ERROR_OPTION_FATALERROR              0x00000004


			extern RPC_IF_HANDLE __MIDL_itf_pbxml_0000_v0_0_c_ifspec;
			extern RPC_IF_HANDLE __MIDL_itf_pbxml_0000_v0_0_s_ifspec;

#ifndef __IPB_XMLDOMNode_INTERFACE_DEFINED__
#define __IPB_XMLDOMNode_INTERFACE_DEFINED__

			/* interface IPB_XMLDOMNode */
			/* [unique][uuid][object][local] */


			enum NodeType
			{
				ELEMENT_NODE = 1,
				ATTRIBUTE_NODE = 2,
				TEXT_NODE = 3,
				CDATA_SECTION_NODE = 4,
				ENTITY_REFERENCE_NODE = 5,
				ENTITY_NODE = 6,
				PROCESSING_INSTRUCTION_NODE = 7,
				COMMENT_NODE = 8,
				DOCUMENT_NODE = 9,
				DOCUMENT_TYPE_NODE = 10,
				DOCUMENT_FRAGMENT_NODE = 11,
				NOTATION_NODE = 12,
				XML_DECL_NODE = 13
			};

			EXTERN_C const IID IID_IPB_XMLDOMNode;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("4BB2BC11-D38A-11d5-959D-00B0D024631C")
				IPB_XMLDOMNode : public IUnknown
			{
			public:
				virtual HRESULT STDMETHODCALLTYPE GetNodeName(
					/* [out] */ IPB_String * *ppNodeNameReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetNodeValue(
					/* [out] */ IPB_String** ppNodeValueReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetNodeType(
					/* [out] */ long* pNodeTypeReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetParentNode(
					/* [out] */ IPB_XMLDOMNode** ppParentNodeReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetChildNodes(
					/* [out] */ IPB_XMLDOMNodeList** ppChildNodesListReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetFirstChild(
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetLastChild(
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetNextSibling(
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetPreviousSibling(
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetAttributes(
					/* [out] */ IPB_XMLDOMNamedNodeMap** ppAttrNamedNodeMapReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetOwnerDocument(
					/* [out] */ IPB_XMLDOMDocument** ppOwnerDocumentReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetNamespaceURI(
					/* [out] */ IPB_String** ppNamespaceURIReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetPrefix(
					/* [out] */ IPB_String** ppPrefixReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetLocalName(
					/* [out] */ IPB_String** ppLocalNameReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE InsertBefore(
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeRefChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE ReplaceChild(
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE RemoveChild(
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE AppendChild(
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE HasChildNodes(
					/* [out] */ BOOL* pBoolReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE CloneNode(
					/* [in] */ BOOL bDeep,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMCloneNodeReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetNodeName(
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeChild,
					/* [in] */ const IPB_String* pNodeName) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetNodeValue(
					/* [in] */ const IPB_String* pNodeValue) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetPrefix(
					/* [in] */ const IPB_String* pPrefix) = 0;

				virtual HRESULT STDMETHODCALLTYPE Normalize(void) = 0;

				virtual HRESULT STDMETHODCALLTYPE IsSupported(
					/* [in] */ const IPB_String* pFeature,
					/* [in] */ const IPB_String* pVersion,
					/* [out] */ BOOL* pBoolReceiver) = 0;

				virtual ULONG STDMETHODCALLTYPE GetLastErrorCode(void) = 0;

				virtual ULONG STDMETHODCALLTYPE GetLastErrorString(
					/* [out] */ IPB_String** ppErrorStringReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetUserDefinedData(
					/* [out] */ void** ppVoidUserDefinedDataReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetUserDefinedData(
					/* [in] */ void* pVoidUserDefinedData) = 0;

			};

#else 	/* C style interface */

			typedef struct IPB_XMLDOMNodeVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_XMLDOMNode* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_XMLDOMNode* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_XMLDOMNode* This);

				HRESULT(STDMETHODCALLTYPE* GetNodeName)(
					IPB_XMLDOMNode* This,
					/* [out] */ IPB_String** ppNodeNameReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeValue)(
					IPB_XMLDOMNode* This,
					/* [out] */ IPB_String** ppNodeValueReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeType)(
					IPB_XMLDOMNode* This,
					/* [out] */ long* pNodeTypeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetParentNode)(
					IPB_XMLDOMNode* This,
					/* [out] */ IPB_XMLDOMNode** ppParentNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetChildNodes)(
					IPB_XMLDOMNode* This,
					/* [out] */ IPB_XMLDOMNodeList** ppChildNodesListReceiver);

				HRESULT(STDMETHODCALLTYPE* GetFirstChild)(
					IPB_XMLDOMNode* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetLastChild)(
					IPB_XMLDOMNode* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetNextSibling)(
					IPB_XMLDOMNode* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetPreviousSibling)(
					IPB_XMLDOMNode* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetAttributes)(
					IPB_XMLDOMNode* This,
					/* [out] */ IPB_XMLDOMNamedNodeMap** ppAttrNamedNodeMapReceiver);

				HRESULT(STDMETHODCALLTYPE* GetOwnerDocument)(
					IPB_XMLDOMNode* This,
					/* [out] */ IPB_XMLDOMDocument** ppOwnerDocumentReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNamespaceURI)(
					IPB_XMLDOMNode* This,
					/* [out] */ IPB_String** ppNamespaceURIReceiver);

				HRESULT(STDMETHODCALLTYPE* GetPrefix)(
					IPB_XMLDOMNode* This,
					/* [out] */ IPB_String** ppPrefixReceiver);

				HRESULT(STDMETHODCALLTYPE* GetLocalName)(
					IPB_XMLDOMNode* This,
					/* [out] */ IPB_String** ppLocalNameReceiver);

				HRESULT(STDMETHODCALLTYPE* InsertBefore)(
					IPB_XMLDOMNode* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeRefChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* ReplaceChild)(
					IPB_XMLDOMNode* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* RemoveChild)(
					IPB_XMLDOMNode* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* AppendChild)(
					IPB_XMLDOMNode* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* HasChildNodes)(
					IPB_XMLDOMNode* This,
					/* [out] */ BOOL* pBoolReceiver);

				HRESULT(STDMETHODCALLTYPE* CloneNode)(
					IPB_XMLDOMNode* This,
					/* [in] */ BOOL bDeep,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMCloneNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* SetNodeName)(
					IPB_XMLDOMNode* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeChild,
					/* [in] */ const IPB_String* pNodeName);

				HRESULT(STDMETHODCALLTYPE* SetNodeValue)(
					IPB_XMLDOMNode* This,
					/* [in] */ const IPB_String* pNodeValue);

				HRESULT(STDMETHODCALLTYPE* SetPrefix)(
					IPB_XMLDOMNode* This,
					/* [in] */ const IPB_String* pPrefix);

				HRESULT(STDMETHODCALLTYPE* Normalize)(
					IPB_XMLDOMNode* This);

				HRESULT(STDMETHODCALLTYPE* IsSupported)(
					IPB_XMLDOMNode* This,
					/* [in] */ const IPB_String* pFeature,
					/* [in] */ const IPB_String* pVersion,
					/* [out] */ BOOL* pBoolReceiver);

				ULONG(STDMETHODCALLTYPE* GetLastErrorCode)(
					IPB_XMLDOMNode* This);

				ULONG(STDMETHODCALLTYPE* GetLastErrorString)(
					IPB_XMLDOMNode* This,
					/* [out] */ IPB_String** ppErrorStringReceiver);

				HRESULT(STDMETHODCALLTYPE* GetUserDefinedData)(
					IPB_XMLDOMNode* This,
					/* [out] */ void** ppVoidUserDefinedDataReceiver);

				HRESULT(STDMETHODCALLTYPE* SetUserDefinedData)(
					IPB_XMLDOMNode* This,
					/* [in] */ void* pVoidUserDefinedData);

				END_INTERFACE
			} IPB_XMLDOMNodeVtbl;

			interface IPB_XMLDOMNode
			{
				CONST_VTBL struct IPB_XMLDOMNodeVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_XMLDOMNode_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_XMLDOMNode_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_XMLDOMNode_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_XMLDOMNode_GetNodeName(This,ppNodeNameReceiver)	\
    (This)->lpVtbl -> GetNodeName(This,ppNodeNameReceiver)

#define IPB_XMLDOMNode_GetNodeValue(This,ppNodeValueReceiver)	\
    (This)->lpVtbl -> GetNodeValue(This,ppNodeValueReceiver)

#define IPB_XMLDOMNode_GetNodeType(This,pNodeTypeReceiver)	\
    (This)->lpVtbl -> GetNodeType(This,pNodeTypeReceiver)

#define IPB_XMLDOMNode_GetParentNode(This,ppParentNodeReceiver)	\
    (This)->lpVtbl -> GetParentNode(This,ppParentNodeReceiver)

#define IPB_XMLDOMNode_GetChildNodes(This,ppChildNodesListReceiver)	\
    (This)->lpVtbl -> GetChildNodes(This,ppChildNodesListReceiver)

#define IPB_XMLDOMNode_GetFirstChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetFirstChild(This,ppXMLDOMNode)

#define IPB_XMLDOMNode_GetLastChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetLastChild(This,ppXMLDOMNode)

#define IPB_XMLDOMNode_GetNextSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetNextSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMNode_GetPreviousSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetPreviousSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMNode_GetAttributes(This,ppAttrNamedNodeMapReceiver)	\
    (This)->lpVtbl -> GetAttributes(This,ppAttrNamedNodeMapReceiver)

#define IPB_XMLDOMNode_GetOwnerDocument(This,ppOwnerDocumentReceiver)	\
    (This)->lpVtbl -> GetOwnerDocument(This,ppOwnerDocumentReceiver)

#define IPB_XMLDOMNode_GetNamespaceURI(This,ppNamespaceURIReceiver)	\
    (This)->lpVtbl -> GetNamespaceURI(This,ppNamespaceURIReceiver)

#define IPB_XMLDOMNode_GetPrefix(This,ppPrefixReceiver)	\
    (This)->lpVtbl -> GetPrefix(This,ppPrefixReceiver)

#define IPB_XMLDOMNode_GetLocalName(This,ppLocalNameReceiver)	\
    (This)->lpVtbl -> GetLocalName(This,ppLocalNameReceiver)

#define IPB_XMLDOMNode_InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMNode_ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMNode_RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMNode_AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMNode_HasChildNodes(This,pBoolReceiver)	\
    (This)->lpVtbl -> HasChildNodes(This,pBoolReceiver)

#define IPB_XMLDOMNode_CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)	\
    (This)->lpVtbl -> CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)

#define IPB_XMLDOMNode_SetNodeName(This,pXMLDOMNodeChild,pNodeName)	\
    (This)->lpVtbl -> SetNodeName(This,pXMLDOMNodeChild,pNodeName)

#define IPB_XMLDOMNode_SetNodeValue(This,pNodeValue)	\
    (This)->lpVtbl -> SetNodeValue(This,pNodeValue)

#define IPB_XMLDOMNode_SetPrefix(This,pPrefix)	\
    (This)->lpVtbl -> SetPrefix(This,pPrefix)

#define IPB_XMLDOMNode_Normalize(This)	\
    (This)->lpVtbl -> Normalize(This)

#define IPB_XMLDOMNode_IsSupported(This,pFeature,pVersion,pBoolReceiver)	\
    (This)->lpVtbl -> IsSupported(This,pFeature,pVersion,pBoolReceiver)

#define IPB_XMLDOMNode_GetLastErrorCode(This)	\
    (This)->lpVtbl -> GetLastErrorCode(This)

#define IPB_XMLDOMNode_GetLastErrorString(This,ppErrorStringReceiver)	\
    (This)->lpVtbl -> GetLastErrorString(This,ppErrorStringReceiver)

#define IPB_XMLDOMNode_GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)	\
    (This)->lpVtbl -> GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)

#define IPB_XMLDOMNode_SetUserDefinedData(This,pVoidUserDefinedData)	\
    (This)->lpVtbl -> SetUserDefinedData(This,pVoidUserDefinedData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNode_GetNodeName_Proxy(
				IPB_XMLDOMNode* This,
				/* [out] */ IPB_String** ppNodeNameReceiver);


			void __RPC_STUB IPB_XMLDOMNode_GetNodeName_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNode_GetNodeValue_Proxy(
				IPB_XMLDOMNode* This,
				/* [out] */ IPB_String** ppNodeValueReceiver);


			void __RPC_STUB IPB_XMLDOMNode_GetNodeValue_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNode_GetNodeType_Proxy(
				IPB_XMLDOMNode* This,
				/* [out] */ long* pNodeTypeReceiver);


			void __RPC_STUB IPB_XMLDOMNode_GetNodeType_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNode_GetParentNode_Proxy(
				IPB_XMLDOMNode* This,
				/* [out] */ IPB_XMLDOMNode** ppParentNodeReceiver);


			void __RPC_STUB IPB_XMLDOMNode_GetParentNode_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNode_GetChildNodes_Proxy(
				IPB_XMLDOMNode* This,
				/* [out] */ IPB_XMLDOMNodeList** ppChildNodesListReceiver);


			void __RPC_STUB IPB_XMLDOMNode_GetChildNodes_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNode_GetFirstChild_Proxy(
				IPB_XMLDOMNode* This,
				/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);


			void __RPC_STUB IPB_XMLDOMNode_GetFirstChild_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNode_GetLastChild_Proxy(
				IPB_XMLDOMNode* This,
				/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);


			void __RPC_STUB IPB_XMLDOMNode_GetLastChild_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNode_GetNextSibling_Proxy(
				IPB_XMLDOMNode* This,
				/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);


			void __RPC_STUB IPB_XMLDOMNode_GetNextSibling_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNode_GetPreviousSibling_Proxy(
				IPB_XMLDOMNode* This,
				/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);


			void __RPC_STUB IPB_XMLDOMNode_GetPreviousSibling_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNode_GetAttributes_Proxy(
				IPB_XMLDOMNode* This,
				/* [out] */ IPB_XMLDOMNamedNodeMap** ppAttrNamedNodeMapReceiver);


			void __RPC_STUB IPB_XMLDOMNode_GetAttributes_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNode_GetOwnerDocument_Proxy(
				IPB_XMLDOMNode* This,
				/* [out] */ IPB_XMLDOMDocument** ppOwnerDocumentReceiver);


			void __RPC_STUB IPB_XMLDOMNode_GetOwnerDocument_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNode_GetNamespaceURI_Proxy(
				IPB_XMLDOMNode* This,
				/* [out] */ IPB_String** ppNamespaceURIReceiver);


			void __RPC_STUB IPB_XMLDOMNode_GetNamespaceURI_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNode_GetPrefix_Proxy(
				IPB_XMLDOMNode* This,
				/* [out] */ IPB_String** ppPrefixReceiver);


			void __RPC_STUB IPB_XMLDOMNode_GetPrefix_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNode_GetLocalName_Proxy(
				IPB_XMLDOMNode* This,
				/* [out] */ IPB_String** ppLocalNameReceiver);


			void __RPC_STUB IPB_XMLDOMNode_GetLocalName_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNode_InsertBefore_Proxy(
				IPB_XMLDOMNode* This,
				/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
				/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeRefChild,
				/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);


			void __RPC_STUB IPB_XMLDOMNode_InsertBefore_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNode_ReplaceChild_Proxy(
				IPB_XMLDOMNode* This,
				/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
				/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
				/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);


			void __RPC_STUB IPB_XMLDOMNode_ReplaceChild_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNode_RemoveChild_Proxy(
				IPB_XMLDOMNode* This,
				/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
				/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);


			void __RPC_STUB IPB_XMLDOMNode_RemoveChild_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNode_AppendChild_Proxy(
				IPB_XMLDOMNode* This,
				/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
				/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);


			void __RPC_STUB IPB_XMLDOMNode_AppendChild_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNode_HasChildNodes_Proxy(
				IPB_XMLDOMNode* This,
				/* [out] */ BOOL* pBoolReceiver);


			void __RPC_STUB IPB_XMLDOMNode_HasChildNodes_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNode_CloneNode_Proxy(
				IPB_XMLDOMNode* This,
				/* [in] */ BOOL bDeep,
				/* [out] */ IPB_XMLDOMNode** ppXMLDOMCloneNodeReceiver);


			void __RPC_STUB IPB_XMLDOMNode_CloneNode_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNode_SetNodeName_Proxy(
				IPB_XMLDOMNode* This,
				/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeChild,
				/* [in] */ const IPB_String* pNodeName);


			void __RPC_STUB IPB_XMLDOMNode_SetNodeName_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNode_SetNodeValue_Proxy(
				IPB_XMLDOMNode* This,
				/* [in] */ const IPB_String* pNodeValue);


			void __RPC_STUB IPB_XMLDOMNode_SetNodeValue_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNode_SetPrefix_Proxy(
				IPB_XMLDOMNode* This,
				/* [in] */ const IPB_String* pPrefix);


			void __RPC_STUB IPB_XMLDOMNode_SetPrefix_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNode_Normalize_Proxy(
				IPB_XMLDOMNode* This);


			void __RPC_STUB IPB_XMLDOMNode_Normalize_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNode_IsSupported_Proxy(
				IPB_XMLDOMNode* This,
				/* [in] */ const IPB_String* pFeature,
				/* [in] */ const IPB_String* pVersion,
				/* [out] */ BOOL* pBoolReceiver);


			void __RPC_STUB IPB_XMLDOMNode_IsSupported_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			ULONG STDMETHODCALLTYPE IPB_XMLDOMNode_GetLastErrorCode_Proxy(
				IPB_XMLDOMNode* This);


			void __RPC_STUB IPB_XMLDOMNode_GetLastErrorCode_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			ULONG STDMETHODCALLTYPE IPB_XMLDOMNode_GetLastErrorString_Proxy(
				IPB_XMLDOMNode* This,
				/* [out] */ IPB_String** ppErrorStringReceiver);


			void __RPC_STUB IPB_XMLDOMNode_GetLastErrorString_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNode_GetUserDefinedData_Proxy(
				IPB_XMLDOMNode* This,
				/* [out] */ void** ppVoidUserDefinedDataReceiver);


			void __RPC_STUB IPB_XMLDOMNode_GetUserDefinedData_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNode_SetUserDefinedData_Proxy(
				IPB_XMLDOMNode* This,
				/* [in] */ void* pVoidUserDefinedData);


			void __RPC_STUB IPB_XMLDOMNode_SetUserDefinedData_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);



#endif 	/* __IPB_XMLDOMNode_INTERFACE_DEFINED__ */


#ifndef __IPB_XMLDOMNamedNodeMap_INTERFACE_DEFINED__
#define __IPB_XMLDOMNamedNodeMap_INTERFACE_DEFINED__

			/* interface IPB_XMLDOMNamedNodeMap */
			/* [unique][uuid][object][local] */


			EXTERN_C const IID IID_IPB_XMLDOMNamedNodeMap;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("17561835-FDA3-11d5-95A7-00B0D024631C")
				IPB_XMLDOMNamedNodeMap : public IUnknown
			{
			public:
				virtual HRESULT STDMETHODCALLTYPE SetNamedItem(
					/* [in] */ const IPB_XMLDOMNode * pXMLDOMNode,
					/* [out] */ IPB_XMLDOMNode * *ppReplacedNodeReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE Item(
					/* [in] */ const ULONG ulIndex,
					/* [out] */ IPB_XMLDOMNode** ppNodeReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetNamedItem(
					/* [in] */ const IPB_String* pName,
					/* [out] */ IPB_XMLDOMNode** ppNodeReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetLength(
					/* [out] */ ULONG* pLengthReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE RemoveNamedItem(
					/* [in] */ const IPB_String* pName,
					/* [out] */ IPB_XMLDOMNode** ppRemovedNodeReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetNamedItemNS(
					/* [in] */ const IPB_String* pNamespaceURI,
					/* [in] */ const IPB_String* pLocalName,
					/* [out] */ IPB_XMLDOMNode** ppNodeReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetNamedItemNS(
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNode,
					/* [out] */ IPB_XMLDOMNode** ppReplacedNodeReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE RemoveNamedItemNS(
					/* [in] */ const IPB_String* pNamespaceURI,
					/* [in] */ const IPB_String* pLocalName,
					/* [out] */ IPB_XMLDOMNode** ppRemovedNodeReceiver) = 0;

				virtual ULONG STDMETHODCALLTYPE GetLastErrorCode(void) = 0;

				virtual ULONG STDMETHODCALLTYPE GetLastErrorString(
					/* [out] */ IPB_String** ppErrorStringReceiver) = 0;

			};

#else 	/* C style interface */

			typedef struct IPB_XMLDOMNamedNodeMapVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_XMLDOMNamedNodeMap* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_XMLDOMNamedNodeMap* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_XMLDOMNamedNodeMap* This);

				HRESULT(STDMETHODCALLTYPE* SetNamedItem)(
					IPB_XMLDOMNamedNodeMap* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNode,
					/* [out] */ IPB_XMLDOMNode** ppReplacedNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* Item)(
					IPB_XMLDOMNamedNodeMap* This,
					/* [in] */ const ULONG ulIndex,
					/* [out] */ IPB_XMLDOMNode** ppNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNamedItem)(
					IPB_XMLDOMNamedNodeMap* This,
					/* [in] */ const IPB_String* pName,
					/* [out] */ IPB_XMLDOMNode** ppNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetLength)(
					IPB_XMLDOMNamedNodeMap* This,
					/* [out] */ ULONG* pLengthReceiver);

				HRESULT(STDMETHODCALLTYPE* RemoveNamedItem)(
					IPB_XMLDOMNamedNodeMap* This,
					/* [in] */ const IPB_String* pName,
					/* [out] */ IPB_XMLDOMNode** ppRemovedNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNamedItemNS)(
					IPB_XMLDOMNamedNodeMap* This,
					/* [in] */ const IPB_String* pNamespaceURI,
					/* [in] */ const IPB_String* pLocalName,
					/* [out] */ IPB_XMLDOMNode** ppNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* SetNamedItemNS)(
					IPB_XMLDOMNamedNodeMap* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNode,
					/* [out] */ IPB_XMLDOMNode** ppReplacedNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* RemoveNamedItemNS)(
					IPB_XMLDOMNamedNodeMap* This,
					/* [in] */ const IPB_String* pNamespaceURI,
					/* [in] */ const IPB_String* pLocalName,
					/* [out] */ IPB_XMLDOMNode** ppRemovedNodeReceiver);

				ULONG(STDMETHODCALLTYPE* GetLastErrorCode)(
					IPB_XMLDOMNamedNodeMap* This);

				ULONG(STDMETHODCALLTYPE* GetLastErrorString)(
					IPB_XMLDOMNamedNodeMap* This,
					/* [out] */ IPB_String** ppErrorStringReceiver);

				END_INTERFACE
			} IPB_XMLDOMNamedNodeMapVtbl;

			interface IPB_XMLDOMNamedNodeMap
			{
				CONST_VTBL struct IPB_XMLDOMNamedNodeMapVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_XMLDOMNamedNodeMap_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_XMLDOMNamedNodeMap_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_XMLDOMNamedNodeMap_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_XMLDOMNamedNodeMap_SetNamedItem(This,pXMLDOMNode,ppReplacedNodeReceiver)	\
    (This)->lpVtbl -> SetNamedItem(This,pXMLDOMNode,ppReplacedNodeReceiver)

#define IPB_XMLDOMNamedNodeMap_Item(This,ulIndex,ppNodeReceiver)	\
    (This)->lpVtbl -> Item(This,ulIndex,ppNodeReceiver)

#define IPB_XMLDOMNamedNodeMap_GetNamedItem(This,pName,ppNodeReceiver)	\
    (This)->lpVtbl -> GetNamedItem(This,pName,ppNodeReceiver)

#define IPB_XMLDOMNamedNodeMap_GetLength(This,pLengthReceiver)	\
    (This)->lpVtbl -> GetLength(This,pLengthReceiver)

#define IPB_XMLDOMNamedNodeMap_RemoveNamedItem(This,pName,ppRemovedNodeReceiver)	\
    (This)->lpVtbl -> RemoveNamedItem(This,pName,ppRemovedNodeReceiver)

#define IPB_XMLDOMNamedNodeMap_GetNamedItemNS(This,pNamespaceURI,pLocalName,ppNodeReceiver)	\
    (This)->lpVtbl -> GetNamedItemNS(This,pNamespaceURI,pLocalName,ppNodeReceiver)

#define IPB_XMLDOMNamedNodeMap_SetNamedItemNS(This,pXMLDOMNode,ppReplacedNodeReceiver)	\
    (This)->lpVtbl -> SetNamedItemNS(This,pXMLDOMNode,ppReplacedNodeReceiver)

#define IPB_XMLDOMNamedNodeMap_RemoveNamedItemNS(This,pNamespaceURI,pLocalName,ppRemovedNodeReceiver)	\
    (This)->lpVtbl -> RemoveNamedItemNS(This,pNamespaceURI,pLocalName,ppRemovedNodeReceiver)

#define IPB_XMLDOMNamedNodeMap_GetLastErrorCode(This)	\
    (This)->lpVtbl -> GetLastErrorCode(This)

#define IPB_XMLDOMNamedNodeMap_GetLastErrorString(This,ppErrorStringReceiver)	\
    (This)->lpVtbl -> GetLastErrorString(This,ppErrorStringReceiver)

#endif /* COBJMACROS */


#endif 	/* C style interface */



			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNamedNodeMap_SetNamedItem_Proxy(
				IPB_XMLDOMNamedNodeMap* This,
				/* [in] */ const IPB_XMLDOMNode* pXMLDOMNode,
				/* [out] */ IPB_XMLDOMNode** ppReplacedNodeReceiver);


			void __RPC_STUB IPB_XMLDOMNamedNodeMap_SetNamedItem_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNamedNodeMap_Item_Proxy(
				IPB_XMLDOMNamedNodeMap* This,
				/* [in] */ const ULONG ulIndex,
				/* [out] */ IPB_XMLDOMNode** ppNodeReceiver);


			void __RPC_STUB IPB_XMLDOMNamedNodeMap_Item_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNamedNodeMap_GetNamedItem_Proxy(
				IPB_XMLDOMNamedNodeMap* This,
				/* [in] */ const IPB_String* pName,
				/* [out] */ IPB_XMLDOMNode** ppNodeReceiver);


			void __RPC_STUB IPB_XMLDOMNamedNodeMap_GetNamedItem_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNamedNodeMap_GetLength_Proxy(
				IPB_XMLDOMNamedNodeMap* This,
				/* [out] */ ULONG* pLengthReceiver);


			void __RPC_STUB IPB_XMLDOMNamedNodeMap_GetLength_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNamedNodeMap_RemoveNamedItem_Proxy(
				IPB_XMLDOMNamedNodeMap* This,
				/* [in] */ const IPB_String* pName,
				/* [out] */ IPB_XMLDOMNode** ppRemovedNodeReceiver);


			void __RPC_STUB IPB_XMLDOMNamedNodeMap_RemoveNamedItem_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNamedNodeMap_GetNamedItemNS_Proxy(
				IPB_XMLDOMNamedNodeMap* This,
				/* [in] */ const IPB_String* pNamespaceURI,
				/* [in] */ const IPB_String* pLocalName,
				/* [out] */ IPB_XMLDOMNode** ppNodeReceiver);


			void __RPC_STUB IPB_XMLDOMNamedNodeMap_GetNamedItemNS_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNamedNodeMap_SetNamedItemNS_Proxy(
				IPB_XMLDOMNamedNodeMap* This,
				/* [in] */ const IPB_XMLDOMNode* pXMLDOMNode,
				/* [out] */ IPB_XMLDOMNode** ppReplacedNodeReceiver);


			void __RPC_STUB IPB_XMLDOMNamedNodeMap_SetNamedItemNS_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNamedNodeMap_RemoveNamedItemNS_Proxy(
				IPB_XMLDOMNamedNodeMap* This,
				/* [in] */ const IPB_String* pNamespaceURI,
				/* [in] */ const IPB_String* pLocalName,
				/* [out] */ IPB_XMLDOMNode** ppRemovedNodeReceiver);


			void __RPC_STUB IPB_XMLDOMNamedNodeMap_RemoveNamedItemNS_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			ULONG STDMETHODCALLTYPE IPB_XMLDOMNamedNodeMap_GetLastErrorCode_Proxy(
				IPB_XMLDOMNamedNodeMap* This);


			void __RPC_STUB IPB_XMLDOMNamedNodeMap_GetLastErrorCode_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			ULONG STDMETHODCALLTYPE IPB_XMLDOMNamedNodeMap_GetLastErrorString_Proxy(
				IPB_XMLDOMNamedNodeMap* This,
				/* [out] */ IPB_String** ppErrorStringReceiver);


			void __RPC_STUB IPB_XMLDOMNamedNodeMap_GetLastErrorString_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);



#endif 	/* __IPB_XMLDOMNamedNodeMap_INTERFACE_DEFINED__ */


#ifndef __IPB_XMLDOMNodeList_INTERFACE_DEFINED__
#define __IPB_XMLDOMNodeList_INTERFACE_DEFINED__

			/* interface IPB_XMLDOMNodeList */
			/* [unique][uuid][object][local] */


			EXTERN_C const IID IID_IPB_XMLDOMNodeList;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("979DAD23-0BE0-11d6-95A9-00B0D024631C")
				IPB_XMLDOMNodeList : public IUnknown
			{
			public:
				virtual HRESULT STDMETHODCALLTYPE Item(
					/* [in] */ const ULONG ulIndex,
					/* [out] */ IPB_XMLDOMNode * *ppNodeReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetLength(
					/* [out] */ ULONG* pLengthReceiver) = 0;

				virtual ULONG STDMETHODCALLTYPE GetLastErrorCode(void) = 0;

				virtual ULONG STDMETHODCALLTYPE GetLastErrorString(
					/* [out] */ IPB_String** ppErrorStringReceiver) = 0;

			};

#else 	/* C style interface */

			typedef struct IPB_XMLDOMNodeListVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_XMLDOMNodeList* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_XMLDOMNodeList* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_XMLDOMNodeList* This);

				HRESULT(STDMETHODCALLTYPE* Item)(
					IPB_XMLDOMNodeList* This,
					/* [in] */ const ULONG ulIndex,
					/* [out] */ IPB_XMLDOMNode** ppNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetLength)(
					IPB_XMLDOMNodeList* This,
					/* [out] */ ULONG* pLengthReceiver);

				ULONG(STDMETHODCALLTYPE* GetLastErrorCode)(
					IPB_XMLDOMNodeList* This);

				ULONG(STDMETHODCALLTYPE* GetLastErrorString)(
					IPB_XMLDOMNodeList* This,
					/* [out] */ IPB_String** ppErrorStringReceiver);

				END_INTERFACE
			} IPB_XMLDOMNodeListVtbl;

			interface IPB_XMLDOMNodeList
			{
				CONST_VTBL struct IPB_XMLDOMNodeListVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_XMLDOMNodeList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_XMLDOMNodeList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_XMLDOMNodeList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_XMLDOMNodeList_Item(This,ulIndex,ppNodeReceiver)	\
    (This)->lpVtbl -> Item(This,ulIndex,ppNodeReceiver)

#define IPB_XMLDOMNodeList_GetLength(This,pLengthReceiver)	\
    (This)->lpVtbl -> GetLength(This,pLengthReceiver)

#define IPB_XMLDOMNodeList_GetLastErrorCode(This)	\
    (This)->lpVtbl -> GetLastErrorCode(This)

#define IPB_XMLDOMNodeList_GetLastErrorString(This,ppErrorStringReceiver)	\
    (This)->lpVtbl -> GetLastErrorString(This,ppErrorStringReceiver)

#endif /* COBJMACROS */


#endif 	/* C style interface */



			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNodeList_Item_Proxy(
				IPB_XMLDOMNodeList* This,
				/* [in] */ const ULONG ulIndex,
				/* [out] */ IPB_XMLDOMNode** ppNodeReceiver);


			void __RPC_STUB IPB_XMLDOMNodeList_Item_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNodeList_GetLength_Proxy(
				IPB_XMLDOMNodeList* This,
				/* [out] */ ULONG* pLengthReceiver);


			void __RPC_STUB IPB_XMLDOMNodeList_GetLength_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			ULONG STDMETHODCALLTYPE IPB_XMLDOMNodeList_GetLastErrorCode_Proxy(
				IPB_XMLDOMNodeList* This);


			void __RPC_STUB IPB_XMLDOMNodeList_GetLastErrorCode_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			ULONG STDMETHODCALLTYPE IPB_XMLDOMNodeList_GetLastErrorString_Proxy(
				IPB_XMLDOMNodeList* This,
				/* [out] */ IPB_String** ppErrorStringReceiver);


			void __RPC_STUB IPB_XMLDOMNodeList_GetLastErrorString_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);



#endif 	/* __IPB_XMLDOMNodeList_INTERFACE_DEFINED__ */


#ifndef __IPB_XMLDOMCharacterData_INTERFACE_DEFINED__
#define __IPB_XMLDOMCharacterData_INTERFACE_DEFINED__

			/* interface IPB_XMLDOMCharacterData */
			/* [unique][uuid][object][local] */


			EXTERN_C const IID IID_IPB_XMLDOMCharacterData;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("8231514F-EAD6-11d5-95A4-00B0D024631C")
				IPB_XMLDOMCharacterData : public IPB_XMLDOMNode
			{
			public:
				virtual HRESULT STDMETHODCALLTYPE SetData(
					/* [in] */ IPB_String * pData) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetData(
					/* [out] */ IPB_String** ppDataReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetLength(
					/* [out] */ ULONG* pLengthReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE SubstringData(
					/* [in] */ ULONG ulOffset,
					/* [in] */ ULONG ulCount,
					/* [out] */ IPB_String** ppDataReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE AppendData(
					/* [in] */ IPB_String* pData) = 0;

				virtual HRESULT STDMETHODCALLTYPE InsertData(
					/* [in] */ ULONG ulOffset,
					/* [in] */ IPB_String* pData) = 0;

				virtual HRESULT STDMETHODCALLTYPE DeleteData(
					/* [in] */ ULONG ulOffset,
					/* [in] */ ULONG ulCount) = 0;

				virtual HRESULT STDMETHODCALLTYPE ReplaceData(
					/* [in] */ ULONG ulOffset,
					/* [in] */ ULONG ulCount,
					/* [in] */ IPB_String* pData) = 0;

			};

#else 	/* C style interface */

			typedef struct IPB_XMLDOMCharacterDataVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_XMLDOMCharacterData* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_XMLDOMCharacterData* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_XMLDOMCharacterData* This);

				HRESULT(STDMETHODCALLTYPE* GetNodeName)(
					IPB_XMLDOMCharacterData* This,
					/* [out] */ IPB_String** ppNodeNameReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeValue)(
					IPB_XMLDOMCharacterData* This,
					/* [out] */ IPB_String** ppNodeValueReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeType)(
					IPB_XMLDOMCharacterData* This,
					/* [out] */ long* pNodeTypeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetParentNode)(
					IPB_XMLDOMCharacterData* This,
					/* [out] */ IPB_XMLDOMNode** ppParentNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetChildNodes)(
					IPB_XMLDOMCharacterData* This,
					/* [out] */ IPB_XMLDOMNodeList** ppChildNodesListReceiver);

				HRESULT(STDMETHODCALLTYPE* GetFirstChild)(
					IPB_XMLDOMCharacterData* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetLastChild)(
					IPB_XMLDOMCharacterData* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetNextSibling)(
					IPB_XMLDOMCharacterData* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetPreviousSibling)(
					IPB_XMLDOMCharacterData* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetAttributes)(
					IPB_XMLDOMCharacterData* This,
					/* [out] */ IPB_XMLDOMNamedNodeMap** ppAttrNamedNodeMapReceiver);

				HRESULT(STDMETHODCALLTYPE* GetOwnerDocument)(
					IPB_XMLDOMCharacterData* This,
					/* [out] */ IPB_XMLDOMDocument** ppOwnerDocumentReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNamespaceURI)(
					IPB_XMLDOMCharacterData* This,
					/* [out] */ IPB_String** ppNamespaceURIReceiver);

				HRESULT(STDMETHODCALLTYPE* GetPrefix)(
					IPB_XMLDOMCharacterData* This,
					/* [out] */ IPB_String** ppPrefixReceiver);

				HRESULT(STDMETHODCALLTYPE* GetLocalName)(
					IPB_XMLDOMCharacterData* This,
					/* [out] */ IPB_String** ppLocalNameReceiver);

				HRESULT(STDMETHODCALLTYPE* InsertBefore)(
					IPB_XMLDOMCharacterData* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeRefChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* ReplaceChild)(
					IPB_XMLDOMCharacterData* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* RemoveChild)(
					IPB_XMLDOMCharacterData* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* AppendChild)(
					IPB_XMLDOMCharacterData* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* HasChildNodes)(
					IPB_XMLDOMCharacterData* This,
					/* [out] */ BOOL* pBoolReceiver);

				HRESULT(STDMETHODCALLTYPE* CloneNode)(
					IPB_XMLDOMCharacterData* This,
					/* [in] */ BOOL bDeep,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMCloneNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* SetNodeName)(
					IPB_XMLDOMCharacterData* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeChild,
					/* [in] */ const IPB_String* pNodeName);

				HRESULT(STDMETHODCALLTYPE* SetNodeValue)(
					IPB_XMLDOMCharacterData* This,
					/* [in] */ const IPB_String* pNodeValue);

				HRESULT(STDMETHODCALLTYPE* SetPrefix)(
					IPB_XMLDOMCharacterData* This,
					/* [in] */ const IPB_String* pPrefix);

				HRESULT(STDMETHODCALLTYPE* Normalize)(
					IPB_XMLDOMCharacterData* This);

				HRESULT(STDMETHODCALLTYPE* IsSupported)(
					IPB_XMLDOMCharacterData* This,
					/* [in] */ const IPB_String* pFeature,
					/* [in] */ const IPB_String* pVersion,
					/* [out] */ BOOL* pBoolReceiver);

				ULONG(STDMETHODCALLTYPE* GetLastErrorCode)(
					IPB_XMLDOMCharacterData* This);

				ULONG(STDMETHODCALLTYPE* GetLastErrorString)(
					IPB_XMLDOMCharacterData* This,
					/* [out] */ IPB_String** ppErrorStringReceiver);

				HRESULT(STDMETHODCALLTYPE* GetUserDefinedData)(
					IPB_XMLDOMCharacterData* This,
					/* [out] */ void** ppVoidUserDefinedDataReceiver);

				HRESULT(STDMETHODCALLTYPE* SetUserDefinedData)(
					IPB_XMLDOMCharacterData* This,
					/* [in] */ void* pVoidUserDefinedData);

				HRESULT(STDMETHODCALLTYPE* SetData)(
					IPB_XMLDOMCharacterData* This,
					/* [in] */ IPB_String* pData);

				HRESULT(STDMETHODCALLTYPE* GetData)(
					IPB_XMLDOMCharacterData* This,
					/* [out] */ IPB_String** ppDataReceiver);

				HRESULT(STDMETHODCALLTYPE* GetLength)(
					IPB_XMLDOMCharacterData* This,
					/* [out] */ ULONG* pLengthReceiver);

				HRESULT(STDMETHODCALLTYPE* SubstringData)(
					IPB_XMLDOMCharacterData* This,
					/* [in] */ ULONG ulOffset,
					/* [in] */ ULONG ulCount,
					/* [out] */ IPB_String** ppDataReceiver);

				HRESULT(STDMETHODCALLTYPE* AppendData)(
					IPB_XMLDOMCharacterData* This,
					/* [in] */ IPB_String* pData);

				HRESULT(STDMETHODCALLTYPE* InsertData)(
					IPB_XMLDOMCharacterData* This,
					/* [in] */ ULONG ulOffset,
					/* [in] */ IPB_String* pData);

				HRESULT(STDMETHODCALLTYPE* DeleteData)(
					IPB_XMLDOMCharacterData* This,
					/* [in] */ ULONG ulOffset,
					/* [in] */ ULONG ulCount);

				HRESULT(STDMETHODCALLTYPE* ReplaceData)(
					IPB_XMLDOMCharacterData* This,
					/* [in] */ ULONG ulOffset,
					/* [in] */ ULONG ulCount,
					/* [in] */ IPB_String* pData);

				END_INTERFACE
			} IPB_XMLDOMCharacterDataVtbl;

			interface IPB_XMLDOMCharacterData
			{
				CONST_VTBL struct IPB_XMLDOMCharacterDataVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_XMLDOMCharacterData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_XMLDOMCharacterData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_XMLDOMCharacterData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_XMLDOMCharacterData_GetNodeName(This,ppNodeNameReceiver)	\
    (This)->lpVtbl -> GetNodeName(This,ppNodeNameReceiver)

#define IPB_XMLDOMCharacterData_GetNodeValue(This,ppNodeValueReceiver)	\
    (This)->lpVtbl -> GetNodeValue(This,ppNodeValueReceiver)

#define IPB_XMLDOMCharacterData_GetNodeType(This,pNodeTypeReceiver)	\
    (This)->lpVtbl -> GetNodeType(This,pNodeTypeReceiver)

#define IPB_XMLDOMCharacterData_GetParentNode(This,ppParentNodeReceiver)	\
    (This)->lpVtbl -> GetParentNode(This,ppParentNodeReceiver)

#define IPB_XMLDOMCharacterData_GetChildNodes(This,ppChildNodesListReceiver)	\
    (This)->lpVtbl -> GetChildNodes(This,ppChildNodesListReceiver)

#define IPB_XMLDOMCharacterData_GetFirstChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetFirstChild(This,ppXMLDOMNode)

#define IPB_XMLDOMCharacterData_GetLastChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetLastChild(This,ppXMLDOMNode)

#define IPB_XMLDOMCharacterData_GetNextSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetNextSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMCharacterData_GetPreviousSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetPreviousSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMCharacterData_GetAttributes(This,ppAttrNamedNodeMapReceiver)	\
    (This)->lpVtbl -> GetAttributes(This,ppAttrNamedNodeMapReceiver)

#define IPB_XMLDOMCharacterData_GetOwnerDocument(This,ppOwnerDocumentReceiver)	\
    (This)->lpVtbl -> GetOwnerDocument(This,ppOwnerDocumentReceiver)

#define IPB_XMLDOMCharacterData_GetNamespaceURI(This,ppNamespaceURIReceiver)	\
    (This)->lpVtbl -> GetNamespaceURI(This,ppNamespaceURIReceiver)

#define IPB_XMLDOMCharacterData_GetPrefix(This,ppPrefixReceiver)	\
    (This)->lpVtbl -> GetPrefix(This,ppPrefixReceiver)

#define IPB_XMLDOMCharacterData_GetLocalName(This,ppLocalNameReceiver)	\
    (This)->lpVtbl -> GetLocalName(This,ppLocalNameReceiver)

#define IPB_XMLDOMCharacterData_InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMCharacterData_ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMCharacterData_RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMCharacterData_AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMCharacterData_HasChildNodes(This,pBoolReceiver)	\
    (This)->lpVtbl -> HasChildNodes(This,pBoolReceiver)

#define IPB_XMLDOMCharacterData_CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)	\
    (This)->lpVtbl -> CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)

#define IPB_XMLDOMCharacterData_SetNodeName(This,pXMLDOMNodeChild,pNodeName)	\
    (This)->lpVtbl -> SetNodeName(This,pXMLDOMNodeChild,pNodeName)

#define IPB_XMLDOMCharacterData_SetNodeValue(This,pNodeValue)	\
    (This)->lpVtbl -> SetNodeValue(This,pNodeValue)

#define IPB_XMLDOMCharacterData_SetPrefix(This,pPrefix)	\
    (This)->lpVtbl -> SetPrefix(This,pPrefix)

#define IPB_XMLDOMCharacterData_Normalize(This)	\
    (This)->lpVtbl -> Normalize(This)

#define IPB_XMLDOMCharacterData_IsSupported(This,pFeature,pVersion,pBoolReceiver)	\
    (This)->lpVtbl -> IsSupported(This,pFeature,pVersion,pBoolReceiver)

#define IPB_XMLDOMCharacterData_GetLastErrorCode(This)	\
    (This)->lpVtbl -> GetLastErrorCode(This)

#define IPB_XMLDOMCharacterData_GetLastErrorString(This,ppErrorStringReceiver)	\
    (This)->lpVtbl -> GetLastErrorString(This,ppErrorStringReceiver)

#define IPB_XMLDOMCharacterData_GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)	\
    (This)->lpVtbl -> GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)

#define IPB_XMLDOMCharacterData_SetUserDefinedData(This,pVoidUserDefinedData)	\
    (This)->lpVtbl -> SetUserDefinedData(This,pVoidUserDefinedData)


#define IPB_XMLDOMCharacterData_SetData(This,pData)	\
    (This)->lpVtbl -> SetData(This,pData)

#define IPB_XMLDOMCharacterData_GetData(This,ppDataReceiver)	\
    (This)->lpVtbl -> GetData(This,ppDataReceiver)

#define IPB_XMLDOMCharacterData_GetLength(This,pLengthReceiver)	\
    (This)->lpVtbl -> GetLength(This,pLengthReceiver)

#define IPB_XMLDOMCharacterData_SubstringData(This,ulOffset,ulCount,ppDataReceiver)	\
    (This)->lpVtbl -> SubstringData(This,ulOffset,ulCount,ppDataReceiver)

#define IPB_XMLDOMCharacterData_AppendData(This,pData)	\
    (This)->lpVtbl -> AppendData(This,pData)

#define IPB_XMLDOMCharacterData_InsertData(This,ulOffset,pData)	\
    (This)->lpVtbl -> InsertData(This,ulOffset,pData)

#define IPB_XMLDOMCharacterData_DeleteData(This,ulOffset,ulCount)	\
    (This)->lpVtbl -> DeleteData(This,ulOffset,ulCount)

#define IPB_XMLDOMCharacterData_ReplaceData(This,ulOffset,ulCount,pData)	\
    (This)->lpVtbl -> ReplaceData(This,ulOffset,ulCount,pData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



			HRESULT STDMETHODCALLTYPE IPB_XMLDOMCharacterData_SetData_Proxy(
				IPB_XMLDOMCharacterData* This,
				/* [in] */ IPB_String* pData);


			void __RPC_STUB IPB_XMLDOMCharacterData_SetData_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMCharacterData_GetData_Proxy(
				IPB_XMLDOMCharacterData* This,
				/* [out] */ IPB_String** ppDataReceiver);


			void __RPC_STUB IPB_XMLDOMCharacterData_GetData_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMCharacterData_GetLength_Proxy(
				IPB_XMLDOMCharacterData* This,
				/* [out] */ ULONG* pLengthReceiver);


			void __RPC_STUB IPB_XMLDOMCharacterData_GetLength_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMCharacterData_SubstringData_Proxy(
				IPB_XMLDOMCharacterData* This,
				/* [in] */ ULONG ulOffset,
				/* [in] */ ULONG ulCount,
				/* [out] */ IPB_String** ppDataReceiver);


			void __RPC_STUB IPB_XMLDOMCharacterData_SubstringData_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMCharacterData_AppendData_Proxy(
				IPB_XMLDOMCharacterData* This,
				/* [in] */ IPB_String* pData);


			void __RPC_STUB IPB_XMLDOMCharacterData_AppendData_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMCharacterData_InsertData_Proxy(
				IPB_XMLDOMCharacterData* This,
				/* [in] */ ULONG ulOffset,
				/* [in] */ IPB_String* pData);


			void __RPC_STUB IPB_XMLDOMCharacterData_InsertData_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMCharacterData_DeleteData_Proxy(
				IPB_XMLDOMCharacterData* This,
				/* [in] */ ULONG ulOffset,
				/* [in] */ ULONG ulCount);


			void __RPC_STUB IPB_XMLDOMCharacterData_DeleteData_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMCharacterData_ReplaceData_Proxy(
				IPB_XMLDOMCharacterData* This,
				/* [in] */ ULONG ulOffset,
				/* [in] */ ULONG ulCount,
				/* [in] */ IPB_String* pData);


			void __RPC_STUB IPB_XMLDOMCharacterData_ReplaceData_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);



#endif 	/* __IPB_XMLDOMCharacterData_INTERFACE_DEFINED__ */


#ifndef __IPB_XMLDOMComment_INTERFACE_DEFINED__
#define __IPB_XMLDOMComment_INTERFACE_DEFINED__

			/* interface IPB_XMLDOMComment */
			/* [unique][uuid][object][local] */


			EXTERN_C const IID IID_IPB_XMLDOMComment;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("AFA2FEC5-0E3B-11d6-95AA-00B0D024631C")
				IPB_XMLDOMComment : public IPB_XMLDOMCharacterData
			{
			public:
			};

#else 	/* C style interface */

			typedef struct IPB_XMLDOMCommentVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_XMLDOMComment* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_XMLDOMComment* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_XMLDOMComment* This);

				HRESULT(STDMETHODCALLTYPE* GetNodeName)(
					IPB_XMLDOMComment* This,
					/* [out] */ IPB_String** ppNodeNameReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeValue)(
					IPB_XMLDOMComment* This,
					/* [out] */ IPB_String** ppNodeValueReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeType)(
					IPB_XMLDOMComment* This,
					/* [out] */ long* pNodeTypeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetParentNode)(
					IPB_XMLDOMComment* This,
					/* [out] */ IPB_XMLDOMNode** ppParentNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetChildNodes)(
					IPB_XMLDOMComment* This,
					/* [out] */ IPB_XMLDOMNodeList** ppChildNodesListReceiver);

				HRESULT(STDMETHODCALLTYPE* GetFirstChild)(
					IPB_XMLDOMComment* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetLastChild)(
					IPB_XMLDOMComment* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetNextSibling)(
					IPB_XMLDOMComment* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetPreviousSibling)(
					IPB_XMLDOMComment* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetAttributes)(
					IPB_XMLDOMComment* This,
					/* [out] */ IPB_XMLDOMNamedNodeMap** ppAttrNamedNodeMapReceiver);

				HRESULT(STDMETHODCALLTYPE* GetOwnerDocument)(
					IPB_XMLDOMComment* This,
					/* [out] */ IPB_XMLDOMDocument** ppOwnerDocumentReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNamespaceURI)(
					IPB_XMLDOMComment* This,
					/* [out] */ IPB_String** ppNamespaceURIReceiver);

				HRESULT(STDMETHODCALLTYPE* GetPrefix)(
					IPB_XMLDOMComment* This,
					/* [out] */ IPB_String** ppPrefixReceiver);

				HRESULT(STDMETHODCALLTYPE* GetLocalName)(
					IPB_XMLDOMComment* This,
					/* [out] */ IPB_String** ppLocalNameReceiver);

				HRESULT(STDMETHODCALLTYPE* InsertBefore)(
					IPB_XMLDOMComment* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeRefChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* ReplaceChild)(
					IPB_XMLDOMComment* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* RemoveChild)(
					IPB_XMLDOMComment* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* AppendChild)(
					IPB_XMLDOMComment* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* HasChildNodes)(
					IPB_XMLDOMComment* This,
					/* [out] */ BOOL* pBoolReceiver);

				HRESULT(STDMETHODCALLTYPE* CloneNode)(
					IPB_XMLDOMComment* This,
					/* [in] */ BOOL bDeep,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMCloneNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* SetNodeName)(
					IPB_XMLDOMComment* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeChild,
					/* [in] */ const IPB_String* pNodeName);

				HRESULT(STDMETHODCALLTYPE* SetNodeValue)(
					IPB_XMLDOMComment* This,
					/* [in] */ const IPB_String* pNodeValue);

				HRESULT(STDMETHODCALLTYPE* SetPrefix)(
					IPB_XMLDOMComment* This,
					/* [in] */ const IPB_String* pPrefix);

				HRESULT(STDMETHODCALLTYPE* Normalize)(
					IPB_XMLDOMComment* This);

				HRESULT(STDMETHODCALLTYPE* IsSupported)(
					IPB_XMLDOMComment* This,
					/* [in] */ const IPB_String* pFeature,
					/* [in] */ const IPB_String* pVersion,
					/* [out] */ BOOL* pBoolReceiver);

				ULONG(STDMETHODCALLTYPE* GetLastErrorCode)(
					IPB_XMLDOMComment* This);

				ULONG(STDMETHODCALLTYPE* GetLastErrorString)(
					IPB_XMLDOMComment* This,
					/* [out] */ IPB_String** ppErrorStringReceiver);

				HRESULT(STDMETHODCALLTYPE* GetUserDefinedData)(
					IPB_XMLDOMComment* This,
					/* [out] */ void** ppVoidUserDefinedDataReceiver);

				HRESULT(STDMETHODCALLTYPE* SetUserDefinedData)(
					IPB_XMLDOMComment* This,
					/* [in] */ void* pVoidUserDefinedData);

				HRESULT(STDMETHODCALLTYPE* SetData)(
					IPB_XMLDOMComment* This,
					/* [in] */ IPB_String* pData);

				HRESULT(STDMETHODCALLTYPE* GetData)(
					IPB_XMLDOMComment* This,
					/* [out] */ IPB_String** ppDataReceiver);

				HRESULT(STDMETHODCALLTYPE* GetLength)(
					IPB_XMLDOMComment* This,
					/* [out] */ ULONG* pLengthReceiver);

				HRESULT(STDMETHODCALLTYPE* SubstringData)(
					IPB_XMLDOMComment* This,
					/* [in] */ ULONG ulOffset,
					/* [in] */ ULONG ulCount,
					/* [out] */ IPB_String** ppDataReceiver);

				HRESULT(STDMETHODCALLTYPE* AppendData)(
					IPB_XMLDOMComment* This,
					/* [in] */ IPB_String* pData);

				HRESULT(STDMETHODCALLTYPE* InsertData)(
					IPB_XMLDOMComment* This,
					/* [in] */ ULONG ulOffset,
					/* [in] */ IPB_String* pData);

				HRESULT(STDMETHODCALLTYPE* DeleteData)(
					IPB_XMLDOMComment* This,
					/* [in] */ ULONG ulOffset,
					/* [in] */ ULONG ulCount);

				HRESULT(STDMETHODCALLTYPE* ReplaceData)(
					IPB_XMLDOMComment* This,
					/* [in] */ ULONG ulOffset,
					/* [in] */ ULONG ulCount,
					/* [in] */ IPB_String* pData);

				END_INTERFACE
			} IPB_XMLDOMCommentVtbl;

			interface IPB_XMLDOMComment
			{
				CONST_VTBL struct IPB_XMLDOMCommentVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_XMLDOMComment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_XMLDOMComment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_XMLDOMComment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_XMLDOMComment_GetNodeName(This,ppNodeNameReceiver)	\
    (This)->lpVtbl -> GetNodeName(This,ppNodeNameReceiver)

#define IPB_XMLDOMComment_GetNodeValue(This,ppNodeValueReceiver)	\
    (This)->lpVtbl -> GetNodeValue(This,ppNodeValueReceiver)

#define IPB_XMLDOMComment_GetNodeType(This,pNodeTypeReceiver)	\
    (This)->lpVtbl -> GetNodeType(This,pNodeTypeReceiver)

#define IPB_XMLDOMComment_GetParentNode(This,ppParentNodeReceiver)	\
    (This)->lpVtbl -> GetParentNode(This,ppParentNodeReceiver)

#define IPB_XMLDOMComment_GetChildNodes(This,ppChildNodesListReceiver)	\
    (This)->lpVtbl -> GetChildNodes(This,ppChildNodesListReceiver)

#define IPB_XMLDOMComment_GetFirstChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetFirstChild(This,ppXMLDOMNode)

#define IPB_XMLDOMComment_GetLastChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetLastChild(This,ppXMLDOMNode)

#define IPB_XMLDOMComment_GetNextSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetNextSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMComment_GetPreviousSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetPreviousSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMComment_GetAttributes(This,ppAttrNamedNodeMapReceiver)	\
    (This)->lpVtbl -> GetAttributes(This,ppAttrNamedNodeMapReceiver)

#define IPB_XMLDOMComment_GetOwnerDocument(This,ppOwnerDocumentReceiver)	\
    (This)->lpVtbl -> GetOwnerDocument(This,ppOwnerDocumentReceiver)

#define IPB_XMLDOMComment_GetNamespaceURI(This,ppNamespaceURIReceiver)	\
    (This)->lpVtbl -> GetNamespaceURI(This,ppNamespaceURIReceiver)

#define IPB_XMLDOMComment_GetPrefix(This,ppPrefixReceiver)	\
    (This)->lpVtbl -> GetPrefix(This,ppPrefixReceiver)

#define IPB_XMLDOMComment_GetLocalName(This,ppLocalNameReceiver)	\
    (This)->lpVtbl -> GetLocalName(This,ppLocalNameReceiver)

#define IPB_XMLDOMComment_InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMComment_ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMComment_RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMComment_AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMComment_HasChildNodes(This,pBoolReceiver)	\
    (This)->lpVtbl -> HasChildNodes(This,pBoolReceiver)

#define IPB_XMLDOMComment_CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)	\
    (This)->lpVtbl -> CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)

#define IPB_XMLDOMComment_SetNodeName(This,pXMLDOMNodeChild,pNodeName)	\
    (This)->lpVtbl -> SetNodeName(This,pXMLDOMNodeChild,pNodeName)

#define IPB_XMLDOMComment_SetNodeValue(This,pNodeValue)	\
    (This)->lpVtbl -> SetNodeValue(This,pNodeValue)

#define IPB_XMLDOMComment_SetPrefix(This,pPrefix)	\
    (This)->lpVtbl -> SetPrefix(This,pPrefix)

#define IPB_XMLDOMComment_Normalize(This)	\
    (This)->lpVtbl -> Normalize(This)

#define IPB_XMLDOMComment_IsSupported(This,pFeature,pVersion,pBoolReceiver)	\
    (This)->lpVtbl -> IsSupported(This,pFeature,pVersion,pBoolReceiver)

#define IPB_XMLDOMComment_GetLastErrorCode(This)	\
    (This)->lpVtbl -> GetLastErrorCode(This)

#define IPB_XMLDOMComment_GetLastErrorString(This,ppErrorStringReceiver)	\
    (This)->lpVtbl -> GetLastErrorString(This,ppErrorStringReceiver)

#define IPB_XMLDOMComment_GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)	\
    (This)->lpVtbl -> GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)

#define IPB_XMLDOMComment_SetUserDefinedData(This,pVoidUserDefinedData)	\
    (This)->lpVtbl -> SetUserDefinedData(This,pVoidUserDefinedData)


#define IPB_XMLDOMComment_SetData(This,pData)	\
    (This)->lpVtbl -> SetData(This,pData)

#define IPB_XMLDOMComment_GetData(This,ppDataReceiver)	\
    (This)->lpVtbl -> GetData(This,ppDataReceiver)

#define IPB_XMLDOMComment_GetLength(This,pLengthReceiver)	\
    (This)->lpVtbl -> GetLength(This,pLengthReceiver)

#define IPB_XMLDOMComment_SubstringData(This,ulOffset,ulCount,ppDataReceiver)	\
    (This)->lpVtbl -> SubstringData(This,ulOffset,ulCount,ppDataReceiver)

#define IPB_XMLDOMComment_AppendData(This,pData)	\
    (This)->lpVtbl -> AppendData(This,pData)

#define IPB_XMLDOMComment_InsertData(This,ulOffset,pData)	\
    (This)->lpVtbl -> InsertData(This,ulOffset,pData)

#define IPB_XMLDOMComment_DeleteData(This,ulOffset,ulCount)	\
    (This)->lpVtbl -> DeleteData(This,ulOffset,ulCount)

#define IPB_XMLDOMComment_ReplaceData(This,ulOffset,ulCount,pData)	\
    (This)->lpVtbl -> ReplaceData(This,ulOffset,ulCount,pData)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPB_XMLDOMComment_INTERFACE_DEFINED__ */


#ifndef __IPB_XMLDOMText_INTERFACE_DEFINED__
#define __IPB_XMLDOMText_INTERFACE_DEFINED__

			/* interface IPB_XMLDOMText */
			/* [unique][uuid][object][local] */


			EXTERN_C const IID IID_IPB_XMLDOMText;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("2969FFDD-D723-11d5-959E-00B0D024631C")
				IPB_XMLDOMText : public IPB_XMLDOMCharacterData
			{
			public:
				virtual HRESULT STDMETHODCALLTYPE SplitText(
					/* [in] */ ULONG ulOffset,
					/* [out] */ IPB_XMLDOMText * *ppXMLDOMTextNew) = 0;

			};

#else 	/* C style interface */

			typedef struct IPB_XMLDOMTextVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_XMLDOMText* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_XMLDOMText* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_XMLDOMText* This);

				HRESULT(STDMETHODCALLTYPE* GetNodeName)(
					IPB_XMLDOMText* This,
					/* [out] */ IPB_String** ppNodeNameReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeValue)(
					IPB_XMLDOMText* This,
					/* [out] */ IPB_String** ppNodeValueReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeType)(
					IPB_XMLDOMText* This,
					/* [out] */ long* pNodeTypeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetParentNode)(
					IPB_XMLDOMText* This,
					/* [out] */ IPB_XMLDOMNode** ppParentNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetChildNodes)(
					IPB_XMLDOMText* This,
					/* [out] */ IPB_XMLDOMNodeList** ppChildNodesListReceiver);

				HRESULT(STDMETHODCALLTYPE* GetFirstChild)(
					IPB_XMLDOMText* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetLastChild)(
					IPB_XMLDOMText* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetNextSibling)(
					IPB_XMLDOMText* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetPreviousSibling)(
					IPB_XMLDOMText* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetAttributes)(
					IPB_XMLDOMText* This,
					/* [out] */ IPB_XMLDOMNamedNodeMap** ppAttrNamedNodeMapReceiver);

				HRESULT(STDMETHODCALLTYPE* GetOwnerDocument)(
					IPB_XMLDOMText* This,
					/* [out] */ IPB_XMLDOMDocument** ppOwnerDocumentReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNamespaceURI)(
					IPB_XMLDOMText* This,
					/* [out] */ IPB_String** ppNamespaceURIReceiver);

				HRESULT(STDMETHODCALLTYPE* GetPrefix)(
					IPB_XMLDOMText* This,
					/* [out] */ IPB_String** ppPrefixReceiver);

				HRESULT(STDMETHODCALLTYPE* GetLocalName)(
					IPB_XMLDOMText* This,
					/* [out] */ IPB_String** ppLocalNameReceiver);

				HRESULT(STDMETHODCALLTYPE* InsertBefore)(
					IPB_XMLDOMText* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeRefChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* ReplaceChild)(
					IPB_XMLDOMText* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* RemoveChild)(
					IPB_XMLDOMText* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* AppendChild)(
					IPB_XMLDOMText* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* HasChildNodes)(
					IPB_XMLDOMText* This,
					/* [out] */ BOOL* pBoolReceiver);

				HRESULT(STDMETHODCALLTYPE* CloneNode)(
					IPB_XMLDOMText* This,
					/* [in] */ BOOL bDeep,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMCloneNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* SetNodeName)(
					IPB_XMLDOMText* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeChild,
					/* [in] */ const IPB_String* pNodeName);

				HRESULT(STDMETHODCALLTYPE* SetNodeValue)(
					IPB_XMLDOMText* This,
					/* [in] */ const IPB_String* pNodeValue);

				HRESULT(STDMETHODCALLTYPE* SetPrefix)(
					IPB_XMLDOMText* This,
					/* [in] */ const IPB_String* pPrefix);

				HRESULT(STDMETHODCALLTYPE* Normalize)(
					IPB_XMLDOMText* This);

				HRESULT(STDMETHODCALLTYPE* IsSupported)(
					IPB_XMLDOMText* This,
					/* [in] */ const IPB_String* pFeature,
					/* [in] */ const IPB_String* pVersion,
					/* [out] */ BOOL* pBoolReceiver);

				ULONG(STDMETHODCALLTYPE* GetLastErrorCode)(
					IPB_XMLDOMText* This);

				ULONG(STDMETHODCALLTYPE* GetLastErrorString)(
					IPB_XMLDOMText* This,
					/* [out] */ IPB_String** ppErrorStringReceiver);

				HRESULT(STDMETHODCALLTYPE* GetUserDefinedData)(
					IPB_XMLDOMText* This,
					/* [out] */ void** ppVoidUserDefinedDataReceiver);

				HRESULT(STDMETHODCALLTYPE* SetUserDefinedData)(
					IPB_XMLDOMText* This,
					/* [in] */ void* pVoidUserDefinedData);

				HRESULT(STDMETHODCALLTYPE* SetData)(
					IPB_XMLDOMText* This,
					/* [in] */ IPB_String* pData);

				HRESULT(STDMETHODCALLTYPE* GetData)(
					IPB_XMLDOMText* This,
					/* [out] */ IPB_String** ppDataReceiver);

				HRESULT(STDMETHODCALLTYPE* GetLength)(
					IPB_XMLDOMText* This,
					/* [out] */ ULONG* pLengthReceiver);

				HRESULT(STDMETHODCALLTYPE* SubstringData)(
					IPB_XMLDOMText* This,
					/* [in] */ ULONG ulOffset,
					/* [in] */ ULONG ulCount,
					/* [out] */ IPB_String** ppDataReceiver);

				HRESULT(STDMETHODCALLTYPE* AppendData)(
					IPB_XMLDOMText* This,
					/* [in] */ IPB_String* pData);

				HRESULT(STDMETHODCALLTYPE* InsertData)(
					IPB_XMLDOMText* This,
					/* [in] */ ULONG ulOffset,
					/* [in] */ IPB_String* pData);

				HRESULT(STDMETHODCALLTYPE* DeleteData)(
					IPB_XMLDOMText* This,
					/* [in] */ ULONG ulOffset,
					/* [in] */ ULONG ulCount);

				HRESULT(STDMETHODCALLTYPE* ReplaceData)(
					IPB_XMLDOMText* This,
					/* [in] */ ULONG ulOffset,
					/* [in] */ ULONG ulCount,
					/* [in] */ IPB_String* pData);

				HRESULT(STDMETHODCALLTYPE* SplitText)(
					IPB_XMLDOMText* This,
					/* [in] */ ULONG ulOffset,
					/* [out] */ IPB_XMLDOMText** ppXMLDOMTextNew);

				END_INTERFACE
			} IPB_XMLDOMTextVtbl;

			interface IPB_XMLDOMText
			{
				CONST_VTBL struct IPB_XMLDOMTextVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_XMLDOMText_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_XMLDOMText_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_XMLDOMText_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_XMLDOMText_GetNodeName(This,ppNodeNameReceiver)	\
    (This)->lpVtbl -> GetNodeName(This,ppNodeNameReceiver)

#define IPB_XMLDOMText_GetNodeValue(This,ppNodeValueReceiver)	\
    (This)->lpVtbl -> GetNodeValue(This,ppNodeValueReceiver)

#define IPB_XMLDOMText_GetNodeType(This,pNodeTypeReceiver)	\
    (This)->lpVtbl -> GetNodeType(This,pNodeTypeReceiver)

#define IPB_XMLDOMText_GetParentNode(This,ppParentNodeReceiver)	\
    (This)->lpVtbl -> GetParentNode(This,ppParentNodeReceiver)

#define IPB_XMLDOMText_GetChildNodes(This,ppChildNodesListReceiver)	\
    (This)->lpVtbl -> GetChildNodes(This,ppChildNodesListReceiver)

#define IPB_XMLDOMText_GetFirstChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetFirstChild(This,ppXMLDOMNode)

#define IPB_XMLDOMText_GetLastChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetLastChild(This,ppXMLDOMNode)

#define IPB_XMLDOMText_GetNextSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetNextSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMText_GetPreviousSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetPreviousSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMText_GetAttributes(This,ppAttrNamedNodeMapReceiver)	\
    (This)->lpVtbl -> GetAttributes(This,ppAttrNamedNodeMapReceiver)

#define IPB_XMLDOMText_GetOwnerDocument(This,ppOwnerDocumentReceiver)	\
    (This)->lpVtbl -> GetOwnerDocument(This,ppOwnerDocumentReceiver)

#define IPB_XMLDOMText_GetNamespaceURI(This,ppNamespaceURIReceiver)	\
    (This)->lpVtbl -> GetNamespaceURI(This,ppNamespaceURIReceiver)

#define IPB_XMLDOMText_GetPrefix(This,ppPrefixReceiver)	\
    (This)->lpVtbl -> GetPrefix(This,ppPrefixReceiver)

#define IPB_XMLDOMText_GetLocalName(This,ppLocalNameReceiver)	\
    (This)->lpVtbl -> GetLocalName(This,ppLocalNameReceiver)

#define IPB_XMLDOMText_InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMText_ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMText_RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMText_AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMText_HasChildNodes(This,pBoolReceiver)	\
    (This)->lpVtbl -> HasChildNodes(This,pBoolReceiver)

#define IPB_XMLDOMText_CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)	\
    (This)->lpVtbl -> CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)

#define IPB_XMLDOMText_SetNodeName(This,pXMLDOMNodeChild,pNodeName)	\
    (This)->lpVtbl -> SetNodeName(This,pXMLDOMNodeChild,pNodeName)

#define IPB_XMLDOMText_SetNodeValue(This,pNodeValue)	\
    (This)->lpVtbl -> SetNodeValue(This,pNodeValue)

#define IPB_XMLDOMText_SetPrefix(This,pPrefix)	\
    (This)->lpVtbl -> SetPrefix(This,pPrefix)

#define IPB_XMLDOMText_Normalize(This)	\
    (This)->lpVtbl -> Normalize(This)

#define IPB_XMLDOMText_IsSupported(This,pFeature,pVersion,pBoolReceiver)	\
    (This)->lpVtbl -> IsSupported(This,pFeature,pVersion,pBoolReceiver)

#define IPB_XMLDOMText_GetLastErrorCode(This)	\
    (This)->lpVtbl -> GetLastErrorCode(This)

#define IPB_XMLDOMText_GetLastErrorString(This,ppErrorStringReceiver)	\
    (This)->lpVtbl -> GetLastErrorString(This,ppErrorStringReceiver)

#define IPB_XMLDOMText_GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)	\
    (This)->lpVtbl -> GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)

#define IPB_XMLDOMText_SetUserDefinedData(This,pVoidUserDefinedData)	\
    (This)->lpVtbl -> SetUserDefinedData(This,pVoidUserDefinedData)


#define IPB_XMLDOMText_SetData(This,pData)	\
    (This)->lpVtbl -> SetData(This,pData)

#define IPB_XMLDOMText_GetData(This,ppDataReceiver)	\
    (This)->lpVtbl -> GetData(This,ppDataReceiver)

#define IPB_XMLDOMText_GetLength(This,pLengthReceiver)	\
    (This)->lpVtbl -> GetLength(This,pLengthReceiver)

#define IPB_XMLDOMText_SubstringData(This,ulOffset,ulCount,ppDataReceiver)	\
    (This)->lpVtbl -> SubstringData(This,ulOffset,ulCount,ppDataReceiver)

#define IPB_XMLDOMText_AppendData(This,pData)	\
    (This)->lpVtbl -> AppendData(This,pData)

#define IPB_XMLDOMText_InsertData(This,ulOffset,pData)	\
    (This)->lpVtbl -> InsertData(This,ulOffset,pData)

#define IPB_XMLDOMText_DeleteData(This,ulOffset,ulCount)	\
    (This)->lpVtbl -> DeleteData(This,ulOffset,ulCount)

#define IPB_XMLDOMText_ReplaceData(This,ulOffset,ulCount,pData)	\
    (This)->lpVtbl -> ReplaceData(This,ulOffset,ulCount,pData)


#define IPB_XMLDOMText_SplitText(This,ulOffset,ppXMLDOMTextNew)	\
    (This)->lpVtbl -> SplitText(This,ulOffset,ppXMLDOMTextNew)

#endif /* COBJMACROS */


#endif 	/* C style interface */



			HRESULT STDMETHODCALLTYPE IPB_XMLDOMText_SplitText_Proxy(
				IPB_XMLDOMText* This,
				/* [in] */ ULONG ulOffset,
				/* [out] */ IPB_XMLDOMText** ppXMLDOMTextNew);


			void __RPC_STUB IPB_XMLDOMText_SplitText_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);



#endif 	/* __IPB_XMLDOMText_INTERFACE_DEFINED__ */


#ifndef __IPB_XMLDOMCDATASection_INTERFACE_DEFINED__
#define __IPB_XMLDOMCDATASection_INTERFACE_DEFINED__

			/* interface IPB_XMLDOMCDATASection */
			/* [unique][uuid][object][local] */


			EXTERN_C const IID IID_IPB_XMLDOMCDATASection;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("0D3767C1-0E6C-11d6-95AA-00B0D024631C")
				IPB_XMLDOMCDATASection : public IPB_XMLDOMText
			{
			public:
			};

#else 	/* C style interface */

			typedef struct IPB_XMLDOMCDATASectionVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_XMLDOMCDATASection* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_XMLDOMCDATASection* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_XMLDOMCDATASection* This);

				HRESULT(STDMETHODCALLTYPE* GetNodeName)(
					IPB_XMLDOMCDATASection* This,
					/* [out] */ IPB_String** ppNodeNameReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeValue)(
					IPB_XMLDOMCDATASection* This,
					/* [out] */ IPB_String** ppNodeValueReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeType)(
					IPB_XMLDOMCDATASection* This,
					/* [out] */ long* pNodeTypeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetParentNode)(
					IPB_XMLDOMCDATASection* This,
					/* [out] */ IPB_XMLDOMNode** ppParentNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetChildNodes)(
					IPB_XMLDOMCDATASection* This,
					/* [out] */ IPB_XMLDOMNodeList** ppChildNodesListReceiver);

				HRESULT(STDMETHODCALLTYPE* GetFirstChild)(
					IPB_XMLDOMCDATASection* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetLastChild)(
					IPB_XMLDOMCDATASection* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetNextSibling)(
					IPB_XMLDOMCDATASection* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetPreviousSibling)(
					IPB_XMLDOMCDATASection* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetAttributes)(
					IPB_XMLDOMCDATASection* This,
					/* [out] */ IPB_XMLDOMNamedNodeMap** ppAttrNamedNodeMapReceiver);

				HRESULT(STDMETHODCALLTYPE* GetOwnerDocument)(
					IPB_XMLDOMCDATASection* This,
					/* [out] */ IPB_XMLDOMDocument** ppOwnerDocumentReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNamespaceURI)(
					IPB_XMLDOMCDATASection* This,
					/* [out] */ IPB_String** ppNamespaceURIReceiver);

				HRESULT(STDMETHODCALLTYPE* GetPrefix)(
					IPB_XMLDOMCDATASection* This,
					/* [out] */ IPB_String** ppPrefixReceiver);

				HRESULT(STDMETHODCALLTYPE* GetLocalName)(
					IPB_XMLDOMCDATASection* This,
					/* [out] */ IPB_String** ppLocalNameReceiver);

				HRESULT(STDMETHODCALLTYPE* InsertBefore)(
					IPB_XMLDOMCDATASection* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeRefChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* ReplaceChild)(
					IPB_XMLDOMCDATASection* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* RemoveChild)(
					IPB_XMLDOMCDATASection* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* AppendChild)(
					IPB_XMLDOMCDATASection* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* HasChildNodes)(
					IPB_XMLDOMCDATASection* This,
					/* [out] */ BOOL* pBoolReceiver);

				HRESULT(STDMETHODCALLTYPE* CloneNode)(
					IPB_XMLDOMCDATASection* This,
					/* [in] */ BOOL bDeep,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMCloneNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* SetNodeName)(
					IPB_XMLDOMCDATASection* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeChild,
					/* [in] */ const IPB_String* pNodeName);

				HRESULT(STDMETHODCALLTYPE* SetNodeValue)(
					IPB_XMLDOMCDATASection* This,
					/* [in] */ const IPB_String* pNodeValue);

				HRESULT(STDMETHODCALLTYPE* SetPrefix)(
					IPB_XMLDOMCDATASection* This,
					/* [in] */ const IPB_String* pPrefix);

				HRESULT(STDMETHODCALLTYPE* Normalize)(
					IPB_XMLDOMCDATASection* This);

				HRESULT(STDMETHODCALLTYPE* IsSupported)(
					IPB_XMLDOMCDATASection* This,
					/* [in] */ const IPB_String* pFeature,
					/* [in] */ const IPB_String* pVersion,
					/* [out] */ BOOL* pBoolReceiver);

				ULONG(STDMETHODCALLTYPE* GetLastErrorCode)(
					IPB_XMLDOMCDATASection* This);

				ULONG(STDMETHODCALLTYPE* GetLastErrorString)(
					IPB_XMLDOMCDATASection* This,
					/* [out] */ IPB_String** ppErrorStringReceiver);

				HRESULT(STDMETHODCALLTYPE* GetUserDefinedData)(
					IPB_XMLDOMCDATASection* This,
					/* [out] */ void** ppVoidUserDefinedDataReceiver);

				HRESULT(STDMETHODCALLTYPE* SetUserDefinedData)(
					IPB_XMLDOMCDATASection* This,
					/* [in] */ void* pVoidUserDefinedData);

				HRESULT(STDMETHODCALLTYPE* SetData)(
					IPB_XMLDOMCDATASection* This,
					/* [in] */ IPB_String* pData);

				HRESULT(STDMETHODCALLTYPE* GetData)(
					IPB_XMLDOMCDATASection* This,
					/* [out] */ IPB_String** ppDataReceiver);

				HRESULT(STDMETHODCALLTYPE* GetLength)(
					IPB_XMLDOMCDATASection* This,
					/* [out] */ ULONG* pLengthReceiver);

				HRESULT(STDMETHODCALLTYPE* SubstringData)(
					IPB_XMLDOMCDATASection* This,
					/* [in] */ ULONG ulOffset,
					/* [in] */ ULONG ulCount,
					/* [out] */ IPB_String** ppDataReceiver);

				HRESULT(STDMETHODCALLTYPE* AppendData)(
					IPB_XMLDOMCDATASection* This,
					/* [in] */ IPB_String* pData);

				HRESULT(STDMETHODCALLTYPE* InsertData)(
					IPB_XMLDOMCDATASection* This,
					/* [in] */ ULONG ulOffset,
					/* [in] */ IPB_String* pData);

				HRESULT(STDMETHODCALLTYPE* DeleteData)(
					IPB_XMLDOMCDATASection* This,
					/* [in] */ ULONG ulOffset,
					/* [in] */ ULONG ulCount);

				HRESULT(STDMETHODCALLTYPE* ReplaceData)(
					IPB_XMLDOMCDATASection* This,
					/* [in] */ ULONG ulOffset,
					/* [in] */ ULONG ulCount,
					/* [in] */ IPB_String* pData);

				HRESULT(STDMETHODCALLTYPE* SplitText)(
					IPB_XMLDOMCDATASection* This,
					/* [in] */ ULONG ulOffset,
					/* [out] */ IPB_XMLDOMText** ppXMLDOMTextNew);

				END_INTERFACE
			} IPB_XMLDOMCDATASectionVtbl;

			interface IPB_XMLDOMCDATASection
			{
				CONST_VTBL struct IPB_XMLDOMCDATASectionVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_XMLDOMCDATASection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_XMLDOMCDATASection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_XMLDOMCDATASection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_XMLDOMCDATASection_GetNodeName(This,ppNodeNameReceiver)	\
    (This)->lpVtbl -> GetNodeName(This,ppNodeNameReceiver)

#define IPB_XMLDOMCDATASection_GetNodeValue(This,ppNodeValueReceiver)	\
    (This)->lpVtbl -> GetNodeValue(This,ppNodeValueReceiver)

#define IPB_XMLDOMCDATASection_GetNodeType(This,pNodeTypeReceiver)	\
    (This)->lpVtbl -> GetNodeType(This,pNodeTypeReceiver)

#define IPB_XMLDOMCDATASection_GetParentNode(This,ppParentNodeReceiver)	\
    (This)->lpVtbl -> GetParentNode(This,ppParentNodeReceiver)

#define IPB_XMLDOMCDATASection_GetChildNodes(This,ppChildNodesListReceiver)	\
    (This)->lpVtbl -> GetChildNodes(This,ppChildNodesListReceiver)

#define IPB_XMLDOMCDATASection_GetFirstChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetFirstChild(This,ppXMLDOMNode)

#define IPB_XMLDOMCDATASection_GetLastChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetLastChild(This,ppXMLDOMNode)

#define IPB_XMLDOMCDATASection_GetNextSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetNextSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMCDATASection_GetPreviousSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetPreviousSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMCDATASection_GetAttributes(This,ppAttrNamedNodeMapReceiver)	\
    (This)->lpVtbl -> GetAttributes(This,ppAttrNamedNodeMapReceiver)

#define IPB_XMLDOMCDATASection_GetOwnerDocument(This,ppOwnerDocumentReceiver)	\
    (This)->lpVtbl -> GetOwnerDocument(This,ppOwnerDocumentReceiver)

#define IPB_XMLDOMCDATASection_GetNamespaceURI(This,ppNamespaceURIReceiver)	\
    (This)->lpVtbl -> GetNamespaceURI(This,ppNamespaceURIReceiver)

#define IPB_XMLDOMCDATASection_GetPrefix(This,ppPrefixReceiver)	\
    (This)->lpVtbl -> GetPrefix(This,ppPrefixReceiver)

#define IPB_XMLDOMCDATASection_GetLocalName(This,ppLocalNameReceiver)	\
    (This)->lpVtbl -> GetLocalName(This,ppLocalNameReceiver)

#define IPB_XMLDOMCDATASection_InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMCDATASection_ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMCDATASection_RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMCDATASection_AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMCDATASection_HasChildNodes(This,pBoolReceiver)	\
    (This)->lpVtbl -> HasChildNodes(This,pBoolReceiver)

#define IPB_XMLDOMCDATASection_CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)	\
    (This)->lpVtbl -> CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)

#define IPB_XMLDOMCDATASection_SetNodeName(This,pXMLDOMNodeChild,pNodeName)	\
    (This)->lpVtbl -> SetNodeName(This,pXMLDOMNodeChild,pNodeName)

#define IPB_XMLDOMCDATASection_SetNodeValue(This,pNodeValue)	\
    (This)->lpVtbl -> SetNodeValue(This,pNodeValue)

#define IPB_XMLDOMCDATASection_SetPrefix(This,pPrefix)	\
    (This)->lpVtbl -> SetPrefix(This,pPrefix)

#define IPB_XMLDOMCDATASection_Normalize(This)	\
    (This)->lpVtbl -> Normalize(This)

#define IPB_XMLDOMCDATASection_IsSupported(This,pFeature,pVersion,pBoolReceiver)	\
    (This)->lpVtbl -> IsSupported(This,pFeature,pVersion,pBoolReceiver)

#define IPB_XMLDOMCDATASection_GetLastErrorCode(This)	\
    (This)->lpVtbl -> GetLastErrorCode(This)

#define IPB_XMLDOMCDATASection_GetLastErrorString(This,ppErrorStringReceiver)	\
    (This)->lpVtbl -> GetLastErrorString(This,ppErrorStringReceiver)

#define IPB_XMLDOMCDATASection_GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)	\
    (This)->lpVtbl -> GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)

#define IPB_XMLDOMCDATASection_SetUserDefinedData(This,pVoidUserDefinedData)	\
    (This)->lpVtbl -> SetUserDefinedData(This,pVoidUserDefinedData)


#define IPB_XMLDOMCDATASection_SetData(This,pData)	\
    (This)->lpVtbl -> SetData(This,pData)

#define IPB_XMLDOMCDATASection_GetData(This,ppDataReceiver)	\
    (This)->lpVtbl -> GetData(This,ppDataReceiver)

#define IPB_XMLDOMCDATASection_GetLength(This,pLengthReceiver)	\
    (This)->lpVtbl -> GetLength(This,pLengthReceiver)

#define IPB_XMLDOMCDATASection_SubstringData(This,ulOffset,ulCount,ppDataReceiver)	\
    (This)->lpVtbl -> SubstringData(This,ulOffset,ulCount,ppDataReceiver)

#define IPB_XMLDOMCDATASection_AppendData(This,pData)	\
    (This)->lpVtbl -> AppendData(This,pData)

#define IPB_XMLDOMCDATASection_InsertData(This,ulOffset,pData)	\
    (This)->lpVtbl -> InsertData(This,ulOffset,pData)

#define IPB_XMLDOMCDATASection_DeleteData(This,ulOffset,ulCount)	\
    (This)->lpVtbl -> DeleteData(This,ulOffset,ulCount)

#define IPB_XMLDOMCDATASection_ReplaceData(This,ulOffset,ulCount,pData)	\
    (This)->lpVtbl -> ReplaceData(This,ulOffset,ulCount,pData)


#define IPB_XMLDOMCDATASection_SplitText(This,ulOffset,ppXMLDOMTextNew)	\
    (This)->lpVtbl -> SplitText(This,ulOffset,ppXMLDOMTextNew)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPB_XMLDOMCDATASection_INTERFACE_DEFINED__ */


#ifndef __IPB_XMLDOMElement_INTERFACE_DEFINED__
#define __IPB_XMLDOMElement_INTERFACE_DEFINED__

			/* interface IPB_XMLDOMElement */
			/* [unique][uuid][object][local] */


			EXTERN_C const IID IID_IPB_XMLDOMElement;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("236083F6-C6D7-11d5-959B-00B0D024631C")
				IPB_XMLDOMElement : public IPB_XMLDOMNode
			{
			public:
				virtual HRESULT STDMETHODCALLTYPE GetTagName(
					/* [out] */ IPB_String * *ppTagNameReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetAttribute(
					/* [in] */ const IPB_String* pAttributeName,
					/* [out] */ IPB_String** ppAttributeValueReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetAttributeNode(
					/* [in] */ const IPB_String* pAttributeName,
					/* [out] */ IPB_XMLDOMAttr** ppAttrReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetElementsByTagName(
					/* [in] */ const IPB_String* pTagName,
					/* [out] */ IPB_XMLDOMNodeList** ppElementsListReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetAttribute(
					/* [in] */ const IPB_String* pAttributeName,
					/* [in] */ const IPB_String* pAttributeValue) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetAttributeNode(
					/* [in] */ IPB_XMLDOMAttr* pAttrNode,
					/* [out] */ IPB_XMLDOMAttr** ppReplacedAttrReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE RemoveAttributeNode(
					/* [in] */ const IPB_XMLDOMAttr* pAttrNodeToRemove,
					/* [out] */ IPB_XMLDOMAttr** ppRemovedAttrReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE RemoveAttribute(
					/* [in] */ const IPB_String* pAttributeName) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetAttributeNS(
					/* [in] */ const IPB_String* pNamespaceURI,
					/* [in] */ const IPB_String* pLocalName,
					/* [out] */ IPB_String** ppAttributeValueReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetAttributeNS(
					/* [in] */ const IPB_String* pNamespaceURI,
					/* [in] */ const IPB_String* pQualifiedName,
					/* [in] */ const IPB_String* pAttributeValue) = 0;

				virtual HRESULT STDMETHODCALLTYPE RemoveAttributeNS(
					/* [in] */ const IPB_String* pNamespaceURI,
					/* [in] */ const IPB_String* pLocalName) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetAttributeNodeNS(
					/* [in] */ const IPB_String* pNamespaceURI,
					/* [in] */ const IPB_String* pLocalName,
					/* [out] */ IPB_XMLDOMAttr** ppAttrReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetAttributeNodeNS(
					/* [in] */ const IPB_XMLDOMAttr* pAttrNode,
					/* [out] */ IPB_XMLDOMAttr** ppReplacedAttrReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetElementsByTagNameNS(
					/* [in] */ const IPB_String* pNamespaceURI,
					/* [in] */ const IPB_String* pLocalName,
					/* [out] */ IPB_XMLDOMNodeList** ppElementsListReceiver) = 0;

			};

#else 	/* C style interface */

			typedef struct IPB_XMLDOMElementVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_XMLDOMElement* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_XMLDOMElement* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_XMLDOMElement* This);

				HRESULT(STDMETHODCALLTYPE* GetNodeName)(
					IPB_XMLDOMElement* This,
					/* [out] */ IPB_String** ppNodeNameReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeValue)(
					IPB_XMLDOMElement* This,
					/* [out] */ IPB_String** ppNodeValueReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeType)(
					IPB_XMLDOMElement* This,
					/* [out] */ long* pNodeTypeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetParentNode)(
					IPB_XMLDOMElement* This,
					/* [out] */ IPB_XMLDOMNode** ppParentNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetChildNodes)(
					IPB_XMLDOMElement* This,
					/* [out] */ IPB_XMLDOMNodeList** ppChildNodesListReceiver);

				HRESULT(STDMETHODCALLTYPE* GetFirstChild)(
					IPB_XMLDOMElement* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetLastChild)(
					IPB_XMLDOMElement* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetNextSibling)(
					IPB_XMLDOMElement* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetPreviousSibling)(
					IPB_XMLDOMElement* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetAttributes)(
					IPB_XMLDOMElement* This,
					/* [out] */ IPB_XMLDOMNamedNodeMap** ppAttrNamedNodeMapReceiver);

				HRESULT(STDMETHODCALLTYPE* GetOwnerDocument)(
					IPB_XMLDOMElement* This,
					/* [out] */ IPB_XMLDOMDocument** ppOwnerDocumentReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNamespaceURI)(
					IPB_XMLDOMElement* This,
					/* [out] */ IPB_String** ppNamespaceURIReceiver);

				HRESULT(STDMETHODCALLTYPE* GetPrefix)(
					IPB_XMLDOMElement* This,
					/* [out] */ IPB_String** ppPrefixReceiver);

				HRESULT(STDMETHODCALLTYPE* GetLocalName)(
					IPB_XMLDOMElement* This,
					/* [out] */ IPB_String** ppLocalNameReceiver);

				HRESULT(STDMETHODCALLTYPE* InsertBefore)(
					IPB_XMLDOMElement* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeRefChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* ReplaceChild)(
					IPB_XMLDOMElement* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* RemoveChild)(
					IPB_XMLDOMElement* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* AppendChild)(
					IPB_XMLDOMElement* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* HasChildNodes)(
					IPB_XMLDOMElement* This,
					/* [out] */ BOOL* pBoolReceiver);

				HRESULT(STDMETHODCALLTYPE* CloneNode)(
					IPB_XMLDOMElement* This,
					/* [in] */ BOOL bDeep,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMCloneNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* SetNodeName)(
					IPB_XMLDOMElement* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeChild,
					/* [in] */ const IPB_String* pNodeName);

				HRESULT(STDMETHODCALLTYPE* SetNodeValue)(
					IPB_XMLDOMElement* This,
					/* [in] */ const IPB_String* pNodeValue);

				HRESULT(STDMETHODCALLTYPE* SetPrefix)(
					IPB_XMLDOMElement* This,
					/* [in] */ const IPB_String* pPrefix);

				HRESULT(STDMETHODCALLTYPE* Normalize)(
					IPB_XMLDOMElement* This);

				HRESULT(STDMETHODCALLTYPE* IsSupported)(
					IPB_XMLDOMElement* This,
					/* [in] */ const IPB_String* pFeature,
					/* [in] */ const IPB_String* pVersion,
					/* [out] */ BOOL* pBoolReceiver);

				ULONG(STDMETHODCALLTYPE* GetLastErrorCode)(
					IPB_XMLDOMElement* This);

				ULONG(STDMETHODCALLTYPE* GetLastErrorString)(
					IPB_XMLDOMElement* This,
					/* [out] */ IPB_String** ppErrorStringReceiver);

				HRESULT(STDMETHODCALLTYPE* GetUserDefinedData)(
					IPB_XMLDOMElement* This,
					/* [out] */ void** ppVoidUserDefinedDataReceiver);

				HRESULT(STDMETHODCALLTYPE* SetUserDefinedData)(
					IPB_XMLDOMElement* This,
					/* [in] */ void* pVoidUserDefinedData);

				HRESULT(STDMETHODCALLTYPE* GetTagName)(
					IPB_XMLDOMElement* This,
					/* [out] */ IPB_String** ppTagNameReceiver);

				HRESULT(STDMETHODCALLTYPE* GetAttribute)(
					IPB_XMLDOMElement* This,
					/* [in] */ const IPB_String* pAttributeName,
					/* [out] */ IPB_String** ppAttributeValueReceiver);

				HRESULT(STDMETHODCALLTYPE* GetAttributeNode)(
					IPB_XMLDOMElement* This,
					/* [in] */ const IPB_String* pAttributeName,
					/* [out] */ IPB_XMLDOMAttr** ppAttrReceiver);

				HRESULT(STDMETHODCALLTYPE* GetElementsByTagName)(
					IPB_XMLDOMElement* This,
					/* [in] */ const IPB_String* pTagName,
					/* [out] */ IPB_XMLDOMNodeList** ppElementsListReceiver);

				HRESULT(STDMETHODCALLTYPE* SetAttribute)(
					IPB_XMLDOMElement* This,
					/* [in] */ const IPB_String* pAttributeName,
					/* [in] */ const IPB_String* pAttributeValue);

				HRESULT(STDMETHODCALLTYPE* SetAttributeNode)(
					IPB_XMLDOMElement* This,
					/* [in] */ IPB_XMLDOMAttr* pAttrNode,
					/* [out] */ IPB_XMLDOMAttr** ppReplacedAttrReceiver);

				HRESULT(STDMETHODCALLTYPE* RemoveAttributeNode)(
					IPB_XMLDOMElement* This,
					/* [in] */ const IPB_XMLDOMAttr* pAttrNodeToRemove,
					/* [out] */ IPB_XMLDOMAttr** ppRemovedAttrReceiver);

				HRESULT(STDMETHODCALLTYPE* RemoveAttribute)(
					IPB_XMLDOMElement* This,
					/* [in] */ const IPB_String* pAttributeName);

				HRESULT(STDMETHODCALLTYPE* GetAttributeNS)(
					IPB_XMLDOMElement* This,
					/* [in] */ const IPB_String* pNamespaceURI,
					/* [in] */ const IPB_String* pLocalName,
					/* [out] */ IPB_String** ppAttributeValueReceiver);

				HRESULT(STDMETHODCALLTYPE* SetAttributeNS)(
					IPB_XMLDOMElement* This,
					/* [in] */ const IPB_String* pNamespaceURI,
					/* [in] */ const IPB_String* pQualifiedName,
					/* [in] */ const IPB_String* pAttributeValue);

				HRESULT(STDMETHODCALLTYPE* RemoveAttributeNS)(
					IPB_XMLDOMElement* This,
					/* [in] */ const IPB_String* pNamespaceURI,
					/* [in] */ const IPB_String* pLocalName);

				HRESULT(STDMETHODCALLTYPE* GetAttributeNodeNS)(
					IPB_XMLDOMElement* This,
					/* [in] */ const IPB_String* pNamespaceURI,
					/* [in] */ const IPB_String* pLocalName,
					/* [out] */ IPB_XMLDOMAttr** ppAttrReceiver);

				HRESULT(STDMETHODCALLTYPE* SetAttributeNodeNS)(
					IPB_XMLDOMElement* This,
					/* [in] */ const IPB_XMLDOMAttr* pAttrNode,
					/* [out] */ IPB_XMLDOMAttr** ppReplacedAttrReceiver);

				HRESULT(STDMETHODCALLTYPE* GetElementsByTagNameNS)(
					IPB_XMLDOMElement* This,
					/* [in] */ const IPB_String* pNamespaceURI,
					/* [in] */ const IPB_String* pLocalName,
					/* [out] */ IPB_XMLDOMNodeList** ppElementsListReceiver);

				END_INTERFACE
			} IPB_XMLDOMElementVtbl;

			interface IPB_XMLDOMElement
			{
				CONST_VTBL struct IPB_XMLDOMElementVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_XMLDOMElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_XMLDOMElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_XMLDOMElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_XMLDOMElement_GetNodeName(This,ppNodeNameReceiver)	\
    (This)->lpVtbl -> GetNodeName(This,ppNodeNameReceiver)

#define IPB_XMLDOMElement_GetNodeValue(This,ppNodeValueReceiver)	\
    (This)->lpVtbl -> GetNodeValue(This,ppNodeValueReceiver)

#define IPB_XMLDOMElement_GetNodeType(This,pNodeTypeReceiver)	\
    (This)->lpVtbl -> GetNodeType(This,pNodeTypeReceiver)

#define IPB_XMLDOMElement_GetParentNode(This,ppParentNodeReceiver)	\
    (This)->lpVtbl -> GetParentNode(This,ppParentNodeReceiver)

#define IPB_XMLDOMElement_GetChildNodes(This,ppChildNodesListReceiver)	\
    (This)->lpVtbl -> GetChildNodes(This,ppChildNodesListReceiver)

#define IPB_XMLDOMElement_GetFirstChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetFirstChild(This,ppXMLDOMNode)

#define IPB_XMLDOMElement_GetLastChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetLastChild(This,ppXMLDOMNode)

#define IPB_XMLDOMElement_GetNextSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetNextSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMElement_GetPreviousSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetPreviousSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMElement_GetAttributes(This,ppAttrNamedNodeMapReceiver)	\
    (This)->lpVtbl -> GetAttributes(This,ppAttrNamedNodeMapReceiver)

#define IPB_XMLDOMElement_GetOwnerDocument(This,ppOwnerDocumentReceiver)	\
    (This)->lpVtbl -> GetOwnerDocument(This,ppOwnerDocumentReceiver)

#define IPB_XMLDOMElement_GetNamespaceURI(This,ppNamespaceURIReceiver)	\
    (This)->lpVtbl -> GetNamespaceURI(This,ppNamespaceURIReceiver)

#define IPB_XMLDOMElement_GetPrefix(This,ppPrefixReceiver)	\
    (This)->lpVtbl -> GetPrefix(This,ppPrefixReceiver)

#define IPB_XMLDOMElement_GetLocalName(This,ppLocalNameReceiver)	\
    (This)->lpVtbl -> GetLocalName(This,ppLocalNameReceiver)

#define IPB_XMLDOMElement_InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMElement_ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMElement_RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMElement_AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMElement_HasChildNodes(This,pBoolReceiver)	\
    (This)->lpVtbl -> HasChildNodes(This,pBoolReceiver)

#define IPB_XMLDOMElement_CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)	\
    (This)->lpVtbl -> CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)

#define IPB_XMLDOMElement_SetNodeName(This,pXMLDOMNodeChild,pNodeName)	\
    (This)->lpVtbl -> SetNodeName(This,pXMLDOMNodeChild,pNodeName)

#define IPB_XMLDOMElement_SetNodeValue(This,pNodeValue)	\
    (This)->lpVtbl -> SetNodeValue(This,pNodeValue)

#define IPB_XMLDOMElement_SetPrefix(This,pPrefix)	\
    (This)->lpVtbl -> SetPrefix(This,pPrefix)

#define IPB_XMLDOMElement_Normalize(This)	\
    (This)->lpVtbl -> Normalize(This)

#define IPB_XMLDOMElement_IsSupported(This,pFeature,pVersion,pBoolReceiver)	\
    (This)->lpVtbl -> IsSupported(This,pFeature,pVersion,pBoolReceiver)

#define IPB_XMLDOMElement_GetLastErrorCode(This)	\
    (This)->lpVtbl -> GetLastErrorCode(This)

#define IPB_XMLDOMElement_GetLastErrorString(This,ppErrorStringReceiver)	\
    (This)->lpVtbl -> GetLastErrorString(This,ppErrorStringReceiver)

#define IPB_XMLDOMElement_GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)	\
    (This)->lpVtbl -> GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)

#define IPB_XMLDOMElement_SetUserDefinedData(This,pVoidUserDefinedData)	\
    (This)->lpVtbl -> SetUserDefinedData(This,pVoidUserDefinedData)


#define IPB_XMLDOMElement_GetTagName(This,ppTagNameReceiver)	\
    (This)->lpVtbl -> GetTagName(This,ppTagNameReceiver)

#define IPB_XMLDOMElement_GetAttribute(This,pAttributeName,ppAttributeValueReceiver)	\
    (This)->lpVtbl -> GetAttribute(This,pAttributeName,ppAttributeValueReceiver)

#define IPB_XMLDOMElement_GetAttributeNode(This,pAttributeName,ppAttrReceiver)	\
    (This)->lpVtbl -> GetAttributeNode(This,pAttributeName,ppAttrReceiver)

#define IPB_XMLDOMElement_GetElementsByTagName(This,pTagName,ppElementsListReceiver)	\
    (This)->lpVtbl -> GetElementsByTagName(This,pTagName,ppElementsListReceiver)

#define IPB_XMLDOMElement_SetAttribute(This,pAttributeName,pAttributeValue)	\
    (This)->lpVtbl -> SetAttribute(This,pAttributeName,pAttributeValue)

#define IPB_XMLDOMElement_SetAttributeNode(This,pAttrNode,ppReplacedAttrReceiver)	\
    (This)->lpVtbl -> SetAttributeNode(This,pAttrNode,ppReplacedAttrReceiver)

#define IPB_XMLDOMElement_RemoveAttributeNode(This,pAttrNodeToRemove,ppRemovedAttrReceiver)	\
    (This)->lpVtbl -> RemoveAttributeNode(This,pAttrNodeToRemove,ppRemovedAttrReceiver)

#define IPB_XMLDOMElement_RemoveAttribute(This,pAttributeName)	\
    (This)->lpVtbl -> RemoveAttribute(This,pAttributeName)

#define IPB_XMLDOMElement_GetAttributeNS(This,pNamespaceURI,pLocalName,ppAttributeValueReceiver)	\
    (This)->lpVtbl -> GetAttributeNS(This,pNamespaceURI,pLocalName,ppAttributeValueReceiver)

#define IPB_XMLDOMElement_SetAttributeNS(This,pNamespaceURI,pQualifiedName,pAttributeValue)	\
    (This)->lpVtbl -> SetAttributeNS(This,pNamespaceURI,pQualifiedName,pAttributeValue)

#define IPB_XMLDOMElement_RemoveAttributeNS(This,pNamespaceURI,pLocalName)	\
    (This)->lpVtbl -> RemoveAttributeNS(This,pNamespaceURI,pLocalName)

#define IPB_XMLDOMElement_GetAttributeNodeNS(This,pNamespaceURI,pLocalName,ppAttrReceiver)	\
    (This)->lpVtbl -> GetAttributeNodeNS(This,pNamespaceURI,pLocalName,ppAttrReceiver)

#define IPB_XMLDOMElement_SetAttributeNodeNS(This,pAttrNode,ppReplacedAttrReceiver)	\
    (This)->lpVtbl -> SetAttributeNodeNS(This,pAttrNode,ppReplacedAttrReceiver)

#define IPB_XMLDOMElement_GetElementsByTagNameNS(This,pNamespaceURI,pLocalName,ppElementsListReceiver)	\
    (This)->lpVtbl -> GetElementsByTagNameNS(This,pNamespaceURI,pLocalName,ppElementsListReceiver)

#endif /* COBJMACROS */


#endif 	/* C style interface */



			HRESULT STDMETHODCALLTYPE IPB_XMLDOMElement_GetTagName_Proxy(
				IPB_XMLDOMElement* This,
				/* [out] */ IPB_String** ppTagNameReceiver);


			void __RPC_STUB IPB_XMLDOMElement_GetTagName_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMElement_GetAttribute_Proxy(
				IPB_XMLDOMElement* This,
				/* [in] */ const IPB_String* pAttributeName,
				/* [out] */ IPB_String** ppAttributeValueReceiver);


			void __RPC_STUB IPB_XMLDOMElement_GetAttribute_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMElement_GetAttributeNode_Proxy(
				IPB_XMLDOMElement* This,
				/* [in] */ const IPB_String* pAttributeName,
				/* [out] */ IPB_XMLDOMAttr** ppAttrReceiver);


			void __RPC_STUB IPB_XMLDOMElement_GetAttributeNode_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMElement_GetElementsByTagName_Proxy(
				IPB_XMLDOMElement* This,
				/* [in] */ const IPB_String* pTagName,
				/* [out] */ IPB_XMLDOMNodeList** ppElementsListReceiver);


			void __RPC_STUB IPB_XMLDOMElement_GetElementsByTagName_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMElement_SetAttribute_Proxy(
				IPB_XMLDOMElement* This,
				/* [in] */ const IPB_String* pAttributeName,
				/* [in] */ const IPB_String* pAttributeValue);


			void __RPC_STUB IPB_XMLDOMElement_SetAttribute_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMElement_SetAttributeNode_Proxy(
				IPB_XMLDOMElement* This,
				/* [in] */ IPB_XMLDOMAttr* pAttrNode,
				/* [out] */ IPB_XMLDOMAttr** ppReplacedAttrReceiver);


			void __RPC_STUB IPB_XMLDOMElement_SetAttributeNode_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMElement_RemoveAttributeNode_Proxy(
				IPB_XMLDOMElement* This,
				/* [in] */ const IPB_XMLDOMAttr* pAttrNodeToRemove,
				/* [out] */ IPB_XMLDOMAttr** ppRemovedAttrReceiver);


			void __RPC_STUB IPB_XMLDOMElement_RemoveAttributeNode_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMElement_RemoveAttribute_Proxy(
				IPB_XMLDOMElement* This,
				/* [in] */ const IPB_String* pAttributeName);


			void __RPC_STUB IPB_XMLDOMElement_RemoveAttribute_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMElement_GetAttributeNS_Proxy(
				IPB_XMLDOMElement* This,
				/* [in] */ const IPB_String* pNamespaceURI,
				/* [in] */ const IPB_String* pLocalName,
				/* [out] */ IPB_String** ppAttributeValueReceiver);


			void __RPC_STUB IPB_XMLDOMElement_GetAttributeNS_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMElement_SetAttributeNS_Proxy(
				IPB_XMLDOMElement* This,
				/* [in] */ const IPB_String* pNamespaceURI,
				/* [in] */ const IPB_String* pQualifiedName,
				/* [in] */ const IPB_String* pAttributeValue);


			void __RPC_STUB IPB_XMLDOMElement_SetAttributeNS_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMElement_RemoveAttributeNS_Proxy(
				IPB_XMLDOMElement* This,
				/* [in] */ const IPB_String* pNamespaceURI,
				/* [in] */ const IPB_String* pLocalName);


			void __RPC_STUB IPB_XMLDOMElement_RemoveAttributeNS_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMElement_GetAttributeNodeNS_Proxy(
				IPB_XMLDOMElement* This,
				/* [in] */ const IPB_String* pNamespaceURI,
				/* [in] */ const IPB_String* pLocalName,
				/* [out] */ IPB_XMLDOMAttr** ppAttrReceiver);


			void __RPC_STUB IPB_XMLDOMElement_GetAttributeNodeNS_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMElement_SetAttributeNodeNS_Proxy(
				IPB_XMLDOMElement* This,
				/* [in] */ const IPB_XMLDOMAttr* pAttrNode,
				/* [out] */ IPB_XMLDOMAttr** ppReplacedAttrReceiver);


			void __RPC_STUB IPB_XMLDOMElement_SetAttributeNodeNS_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMElement_GetElementsByTagNameNS_Proxy(
				IPB_XMLDOMElement* This,
				/* [in] */ const IPB_String* pNamespaceURI,
				/* [in] */ const IPB_String* pLocalName,
				/* [out] */ IPB_XMLDOMNodeList** ppElementsListReceiver);


			void __RPC_STUB IPB_XMLDOMElement_GetElementsByTagNameNS_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);



#endif 	/* __IPB_XMLDOMElement_INTERFACE_DEFINED__ */


#ifndef __IPB_XMLDOMDocumentType_INTERFACE_DEFINED__
#define __IPB_XMLDOMDocumentType_INTERFACE_DEFINED__

			/* interface IPB_XMLDOMDocumentType */
			/* [unique][uuid][object][local] */


			EXTERN_C const IID IID_IPB_XMLDOMDocumentType;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("767CD0D3-FA9C-11d5-95A7-00B0D024631C")
				IPB_XMLDOMDocumentType : public IPB_XMLDOMNode
			{
			public:
				virtual HRESULT STDMETHODCALLTYPE GetName(
					/* [out] */ IPB_String * *ppNameReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetEntities(
					/* [out] */ IPB_XMLDOMNamedNodeMap** ppEntitiesNamedNodeMapReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetNotations(
					/* [out] */ IPB_XMLDOMNamedNodeMap** ppNotationsNamedNodeMapReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetPublicId(
					/* [out] */ IPB_String** ppPublicIdReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetSystemId(
					/* [out] */ IPB_String** ppSystemIdReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetInternalSubset(
					/* [out] */ IPB_String** ppInternalSubsetReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetCustomData(
					/* [in] */ const IPB_String* pCustomData) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetCustomData(
					/* [out] */ IPB_String** ppCustomDataReceiver) = 0;

			};

#else 	/* C style interface */

			typedef struct IPB_XMLDOMDocumentTypeVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_XMLDOMDocumentType* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_XMLDOMDocumentType* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_XMLDOMDocumentType* This);

				HRESULT(STDMETHODCALLTYPE* GetNodeName)(
					IPB_XMLDOMDocumentType* This,
					/* [out] */ IPB_String** ppNodeNameReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeValue)(
					IPB_XMLDOMDocumentType* This,
					/* [out] */ IPB_String** ppNodeValueReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeType)(
					IPB_XMLDOMDocumentType* This,
					/* [out] */ long* pNodeTypeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetParentNode)(
					IPB_XMLDOMDocumentType* This,
					/* [out] */ IPB_XMLDOMNode** ppParentNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetChildNodes)(
					IPB_XMLDOMDocumentType* This,
					/* [out] */ IPB_XMLDOMNodeList** ppChildNodesListReceiver);

				HRESULT(STDMETHODCALLTYPE* GetFirstChild)(
					IPB_XMLDOMDocumentType* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetLastChild)(
					IPB_XMLDOMDocumentType* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetNextSibling)(
					IPB_XMLDOMDocumentType* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetPreviousSibling)(
					IPB_XMLDOMDocumentType* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetAttributes)(
					IPB_XMLDOMDocumentType* This,
					/* [out] */ IPB_XMLDOMNamedNodeMap** ppAttrNamedNodeMapReceiver);

				HRESULT(STDMETHODCALLTYPE* GetOwnerDocument)(
					IPB_XMLDOMDocumentType* This,
					/* [out] */ IPB_XMLDOMDocument** ppOwnerDocumentReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNamespaceURI)(
					IPB_XMLDOMDocumentType* This,
					/* [out] */ IPB_String** ppNamespaceURIReceiver);

				HRESULT(STDMETHODCALLTYPE* GetPrefix)(
					IPB_XMLDOMDocumentType* This,
					/* [out] */ IPB_String** ppPrefixReceiver);

				HRESULT(STDMETHODCALLTYPE* GetLocalName)(
					IPB_XMLDOMDocumentType* This,
					/* [out] */ IPB_String** ppLocalNameReceiver);

				HRESULT(STDMETHODCALLTYPE* InsertBefore)(
					IPB_XMLDOMDocumentType* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeRefChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* ReplaceChild)(
					IPB_XMLDOMDocumentType* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* RemoveChild)(
					IPB_XMLDOMDocumentType* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* AppendChild)(
					IPB_XMLDOMDocumentType* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* HasChildNodes)(
					IPB_XMLDOMDocumentType* This,
					/* [out] */ BOOL* pBoolReceiver);

				HRESULT(STDMETHODCALLTYPE* CloneNode)(
					IPB_XMLDOMDocumentType* This,
					/* [in] */ BOOL bDeep,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMCloneNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* SetNodeName)(
					IPB_XMLDOMDocumentType* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeChild,
					/* [in] */ const IPB_String* pNodeName);

				HRESULT(STDMETHODCALLTYPE* SetNodeValue)(
					IPB_XMLDOMDocumentType* This,
					/* [in] */ const IPB_String* pNodeValue);

				HRESULT(STDMETHODCALLTYPE* SetPrefix)(
					IPB_XMLDOMDocumentType* This,
					/* [in] */ const IPB_String* pPrefix);

				HRESULT(STDMETHODCALLTYPE* Normalize)(
					IPB_XMLDOMDocumentType* This);

				HRESULT(STDMETHODCALLTYPE* IsSupported)(
					IPB_XMLDOMDocumentType* This,
					/* [in] */ const IPB_String* pFeature,
					/* [in] */ const IPB_String* pVersion,
					/* [out] */ BOOL* pBoolReceiver);

				ULONG(STDMETHODCALLTYPE* GetLastErrorCode)(
					IPB_XMLDOMDocumentType* This);

				ULONG(STDMETHODCALLTYPE* GetLastErrorString)(
					IPB_XMLDOMDocumentType* This,
					/* [out] */ IPB_String** ppErrorStringReceiver);

				HRESULT(STDMETHODCALLTYPE* GetUserDefinedData)(
					IPB_XMLDOMDocumentType* This,
					/* [out] */ void** ppVoidUserDefinedDataReceiver);

				HRESULT(STDMETHODCALLTYPE* SetUserDefinedData)(
					IPB_XMLDOMDocumentType* This,
					/* [in] */ void* pVoidUserDefinedData);

				HRESULT(STDMETHODCALLTYPE* GetName)(
					IPB_XMLDOMDocumentType* This,
					/* [out] */ IPB_String** ppNameReceiver);

				HRESULT(STDMETHODCALLTYPE* GetEntities)(
					IPB_XMLDOMDocumentType* This,
					/* [out] */ IPB_XMLDOMNamedNodeMap** ppEntitiesNamedNodeMapReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNotations)(
					IPB_XMLDOMDocumentType* This,
					/* [out] */ IPB_XMLDOMNamedNodeMap** ppNotationsNamedNodeMapReceiver);

				HRESULT(STDMETHODCALLTYPE* GetPublicId)(
					IPB_XMLDOMDocumentType* This,
					/* [out] */ IPB_String** ppPublicIdReceiver);

				HRESULT(STDMETHODCALLTYPE* GetSystemId)(
					IPB_XMLDOMDocumentType* This,
					/* [out] */ IPB_String** ppSystemIdReceiver);

				HRESULT(STDMETHODCALLTYPE* GetInternalSubset)(
					IPB_XMLDOMDocumentType* This,
					/* [out] */ IPB_String** ppInternalSubsetReceiver);

				HRESULT(STDMETHODCALLTYPE* SetCustomData)(
					IPB_XMLDOMDocumentType* This,
					/* [in] */ const IPB_String* pCustomData);

				HRESULT(STDMETHODCALLTYPE* GetCustomData)(
					IPB_XMLDOMDocumentType* This,
					/* [out] */ IPB_String** ppCustomDataReceiver);

				END_INTERFACE
			} IPB_XMLDOMDocumentTypeVtbl;

			interface IPB_XMLDOMDocumentType
			{
				CONST_VTBL struct IPB_XMLDOMDocumentTypeVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_XMLDOMDocumentType_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_XMLDOMDocumentType_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_XMLDOMDocumentType_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_XMLDOMDocumentType_GetNodeName(This,ppNodeNameReceiver)	\
    (This)->lpVtbl -> GetNodeName(This,ppNodeNameReceiver)

#define IPB_XMLDOMDocumentType_GetNodeValue(This,ppNodeValueReceiver)	\
    (This)->lpVtbl -> GetNodeValue(This,ppNodeValueReceiver)

#define IPB_XMLDOMDocumentType_GetNodeType(This,pNodeTypeReceiver)	\
    (This)->lpVtbl -> GetNodeType(This,pNodeTypeReceiver)

#define IPB_XMLDOMDocumentType_GetParentNode(This,ppParentNodeReceiver)	\
    (This)->lpVtbl -> GetParentNode(This,ppParentNodeReceiver)

#define IPB_XMLDOMDocumentType_GetChildNodes(This,ppChildNodesListReceiver)	\
    (This)->lpVtbl -> GetChildNodes(This,ppChildNodesListReceiver)

#define IPB_XMLDOMDocumentType_GetFirstChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetFirstChild(This,ppXMLDOMNode)

#define IPB_XMLDOMDocumentType_GetLastChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetLastChild(This,ppXMLDOMNode)

#define IPB_XMLDOMDocumentType_GetNextSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetNextSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMDocumentType_GetPreviousSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetPreviousSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMDocumentType_GetAttributes(This,ppAttrNamedNodeMapReceiver)	\
    (This)->lpVtbl -> GetAttributes(This,ppAttrNamedNodeMapReceiver)

#define IPB_XMLDOMDocumentType_GetOwnerDocument(This,ppOwnerDocumentReceiver)	\
    (This)->lpVtbl -> GetOwnerDocument(This,ppOwnerDocumentReceiver)

#define IPB_XMLDOMDocumentType_GetNamespaceURI(This,ppNamespaceURIReceiver)	\
    (This)->lpVtbl -> GetNamespaceURI(This,ppNamespaceURIReceiver)

#define IPB_XMLDOMDocumentType_GetPrefix(This,ppPrefixReceiver)	\
    (This)->lpVtbl -> GetPrefix(This,ppPrefixReceiver)

#define IPB_XMLDOMDocumentType_GetLocalName(This,ppLocalNameReceiver)	\
    (This)->lpVtbl -> GetLocalName(This,ppLocalNameReceiver)

#define IPB_XMLDOMDocumentType_InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMDocumentType_ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMDocumentType_RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMDocumentType_AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMDocumentType_HasChildNodes(This,pBoolReceiver)	\
    (This)->lpVtbl -> HasChildNodes(This,pBoolReceiver)

#define IPB_XMLDOMDocumentType_CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)	\
    (This)->lpVtbl -> CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)

#define IPB_XMLDOMDocumentType_SetNodeName(This,pXMLDOMNodeChild,pNodeName)	\
    (This)->lpVtbl -> SetNodeName(This,pXMLDOMNodeChild,pNodeName)

#define IPB_XMLDOMDocumentType_SetNodeValue(This,pNodeValue)	\
    (This)->lpVtbl -> SetNodeValue(This,pNodeValue)

#define IPB_XMLDOMDocumentType_SetPrefix(This,pPrefix)	\
    (This)->lpVtbl -> SetPrefix(This,pPrefix)

#define IPB_XMLDOMDocumentType_Normalize(This)	\
    (This)->lpVtbl -> Normalize(This)

#define IPB_XMLDOMDocumentType_IsSupported(This,pFeature,pVersion,pBoolReceiver)	\
    (This)->lpVtbl -> IsSupported(This,pFeature,pVersion,pBoolReceiver)

#define IPB_XMLDOMDocumentType_GetLastErrorCode(This)	\
    (This)->lpVtbl -> GetLastErrorCode(This)

#define IPB_XMLDOMDocumentType_GetLastErrorString(This,ppErrorStringReceiver)	\
    (This)->lpVtbl -> GetLastErrorString(This,ppErrorStringReceiver)

#define IPB_XMLDOMDocumentType_GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)	\
    (This)->lpVtbl -> GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)

#define IPB_XMLDOMDocumentType_SetUserDefinedData(This,pVoidUserDefinedData)	\
    (This)->lpVtbl -> SetUserDefinedData(This,pVoidUserDefinedData)


#define IPB_XMLDOMDocumentType_GetName(This,ppNameReceiver)	\
    (This)->lpVtbl -> GetName(This,ppNameReceiver)

#define IPB_XMLDOMDocumentType_GetEntities(This,ppEntitiesNamedNodeMapReceiver)	\
    (This)->lpVtbl -> GetEntities(This,ppEntitiesNamedNodeMapReceiver)

#define IPB_XMLDOMDocumentType_GetNotations(This,ppNotationsNamedNodeMapReceiver)	\
    (This)->lpVtbl -> GetNotations(This,ppNotationsNamedNodeMapReceiver)

#define IPB_XMLDOMDocumentType_GetPublicId(This,ppPublicIdReceiver)	\
    (This)->lpVtbl -> GetPublicId(This,ppPublicIdReceiver)

#define IPB_XMLDOMDocumentType_GetSystemId(This,ppSystemIdReceiver)	\
    (This)->lpVtbl -> GetSystemId(This,ppSystemIdReceiver)

#define IPB_XMLDOMDocumentType_GetInternalSubset(This,ppInternalSubsetReceiver)	\
    (This)->lpVtbl -> GetInternalSubset(This,ppInternalSubsetReceiver)

#define IPB_XMLDOMDocumentType_SetCustomData(This,pCustomData)	\
    (This)->lpVtbl -> SetCustomData(This,pCustomData)

#define IPB_XMLDOMDocumentType_GetCustomData(This,ppCustomDataReceiver)	\
    (This)->lpVtbl -> GetCustomData(This,ppCustomDataReceiver)

#endif /* COBJMACROS */


#endif 	/* C style interface */



			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocumentType_GetName_Proxy(
				IPB_XMLDOMDocumentType* This,
				/* [out] */ IPB_String** ppNameReceiver);


			void __RPC_STUB IPB_XMLDOMDocumentType_GetName_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocumentType_GetEntities_Proxy(
				IPB_XMLDOMDocumentType* This,
				/* [out] */ IPB_XMLDOMNamedNodeMap** ppEntitiesNamedNodeMapReceiver);


			void __RPC_STUB IPB_XMLDOMDocumentType_GetEntities_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocumentType_GetNotations_Proxy(
				IPB_XMLDOMDocumentType* This,
				/* [out] */ IPB_XMLDOMNamedNodeMap** ppNotationsNamedNodeMapReceiver);


			void __RPC_STUB IPB_XMLDOMDocumentType_GetNotations_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocumentType_GetPublicId_Proxy(
				IPB_XMLDOMDocumentType* This,
				/* [out] */ IPB_String** ppPublicIdReceiver);


			void __RPC_STUB IPB_XMLDOMDocumentType_GetPublicId_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocumentType_GetSystemId_Proxy(
				IPB_XMLDOMDocumentType* This,
				/* [out] */ IPB_String** ppSystemIdReceiver);


			void __RPC_STUB IPB_XMLDOMDocumentType_GetSystemId_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocumentType_GetInternalSubset_Proxy(
				IPB_XMLDOMDocumentType* This,
				/* [out] */ IPB_String** ppInternalSubsetReceiver);


			void __RPC_STUB IPB_XMLDOMDocumentType_GetInternalSubset_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocumentType_SetCustomData_Proxy(
				IPB_XMLDOMDocumentType* This,
				/* [in] */ const IPB_String* pCustomData);


			void __RPC_STUB IPB_XMLDOMDocumentType_SetCustomData_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocumentType_GetCustomData_Proxy(
				IPB_XMLDOMDocumentType* This,
				/* [out] */ IPB_String** ppCustomDataReceiver);


			void __RPC_STUB IPB_XMLDOMDocumentType_GetCustomData_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);



#endif 	/* __IPB_XMLDOMDocumentType_INTERFACE_DEFINED__ */


#ifndef __IPB_XMLDOMXMLDecl_INTERFACE_DEFINED__
#define __IPB_XMLDOMXMLDecl_INTERFACE_DEFINED__

			/* interface IPB_XMLDOMXMLDecl */
			/* [unique][uuid][object][local] */


			EXTERN_C const IID IID_IPB_XMLDOMXMLDecl;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("0A3BB7BF-00C6-11d6-95A7-00B0D024631C")
				IPB_XMLDOMXMLDecl : public IPB_XMLDOMNode
			{
			public:
				virtual HRESULT STDMETHODCALLTYPE GetVersion(
					/* [out] */ IPB_String * *ppVersionReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetEncoding(
					/* [out] */ IPB_String** ppEncodingReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetStandAlone(
					/* [out] */ IPB_String** ppStandAloneReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetCustomData(
					/* [in] */ const IPB_String* pCustomData) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetCustomData(
					/* [out] */ IPB_String** ppCustomDataReceiver) = 0;

			};

#else 	/* C style interface */

			typedef struct IPB_XMLDOMXMLDeclVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_XMLDOMXMLDecl* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_XMLDOMXMLDecl* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_XMLDOMXMLDecl* This);

				HRESULT(STDMETHODCALLTYPE* GetNodeName)(
					IPB_XMLDOMXMLDecl* This,
					/* [out] */ IPB_String** ppNodeNameReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeValue)(
					IPB_XMLDOMXMLDecl* This,
					/* [out] */ IPB_String** ppNodeValueReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeType)(
					IPB_XMLDOMXMLDecl* This,
					/* [out] */ long* pNodeTypeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetParentNode)(
					IPB_XMLDOMXMLDecl* This,
					/* [out] */ IPB_XMLDOMNode** ppParentNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetChildNodes)(
					IPB_XMLDOMXMLDecl* This,
					/* [out] */ IPB_XMLDOMNodeList** ppChildNodesListReceiver);

				HRESULT(STDMETHODCALLTYPE* GetFirstChild)(
					IPB_XMLDOMXMLDecl* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetLastChild)(
					IPB_XMLDOMXMLDecl* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetNextSibling)(
					IPB_XMLDOMXMLDecl* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetPreviousSibling)(
					IPB_XMLDOMXMLDecl* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetAttributes)(
					IPB_XMLDOMXMLDecl* This,
					/* [out] */ IPB_XMLDOMNamedNodeMap** ppAttrNamedNodeMapReceiver);

				HRESULT(STDMETHODCALLTYPE* GetOwnerDocument)(
					IPB_XMLDOMXMLDecl* This,
					/* [out] */ IPB_XMLDOMDocument** ppOwnerDocumentReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNamespaceURI)(
					IPB_XMLDOMXMLDecl* This,
					/* [out] */ IPB_String** ppNamespaceURIReceiver);

				HRESULT(STDMETHODCALLTYPE* GetPrefix)(
					IPB_XMLDOMXMLDecl* This,
					/* [out] */ IPB_String** ppPrefixReceiver);

				HRESULT(STDMETHODCALLTYPE* GetLocalName)(
					IPB_XMLDOMXMLDecl* This,
					/* [out] */ IPB_String** ppLocalNameReceiver);

				HRESULT(STDMETHODCALLTYPE* InsertBefore)(
					IPB_XMLDOMXMLDecl* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeRefChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* ReplaceChild)(
					IPB_XMLDOMXMLDecl* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* RemoveChild)(
					IPB_XMLDOMXMLDecl* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* AppendChild)(
					IPB_XMLDOMXMLDecl* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* HasChildNodes)(
					IPB_XMLDOMXMLDecl* This,
					/* [out] */ BOOL* pBoolReceiver);

				HRESULT(STDMETHODCALLTYPE* CloneNode)(
					IPB_XMLDOMXMLDecl* This,
					/* [in] */ BOOL bDeep,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMCloneNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* SetNodeName)(
					IPB_XMLDOMXMLDecl* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeChild,
					/* [in] */ const IPB_String* pNodeName);

				HRESULT(STDMETHODCALLTYPE* SetNodeValue)(
					IPB_XMLDOMXMLDecl* This,
					/* [in] */ const IPB_String* pNodeValue);

				HRESULT(STDMETHODCALLTYPE* SetPrefix)(
					IPB_XMLDOMXMLDecl* This,
					/* [in] */ const IPB_String* pPrefix);

				HRESULT(STDMETHODCALLTYPE* Normalize)(
					IPB_XMLDOMXMLDecl* This);

				HRESULT(STDMETHODCALLTYPE* IsSupported)(
					IPB_XMLDOMXMLDecl* This,
					/* [in] */ const IPB_String* pFeature,
					/* [in] */ const IPB_String* pVersion,
					/* [out] */ BOOL* pBoolReceiver);

				ULONG(STDMETHODCALLTYPE* GetLastErrorCode)(
					IPB_XMLDOMXMLDecl* This);

				ULONG(STDMETHODCALLTYPE* GetLastErrorString)(
					IPB_XMLDOMXMLDecl* This,
					/* [out] */ IPB_String** ppErrorStringReceiver);

				HRESULT(STDMETHODCALLTYPE* GetUserDefinedData)(
					IPB_XMLDOMXMLDecl* This,
					/* [out] */ void** ppVoidUserDefinedDataReceiver);

				HRESULT(STDMETHODCALLTYPE* SetUserDefinedData)(
					IPB_XMLDOMXMLDecl* This,
					/* [in] */ void* pVoidUserDefinedData);

				HRESULT(STDMETHODCALLTYPE* GetVersion)(
					IPB_XMLDOMXMLDecl* This,
					/* [out] */ IPB_String** ppVersionReceiver);

				HRESULT(STDMETHODCALLTYPE* GetEncoding)(
					IPB_XMLDOMXMLDecl* This,
					/* [out] */ IPB_String** ppEncodingReceiver);

				HRESULT(STDMETHODCALLTYPE* GetStandAlone)(
					IPB_XMLDOMXMLDecl* This,
					/* [out] */ IPB_String** ppStandAloneReceiver);

				HRESULT(STDMETHODCALLTYPE* SetCustomData)(
					IPB_XMLDOMXMLDecl* This,
					/* [in] */ const IPB_String* pCustomData);

				HRESULT(STDMETHODCALLTYPE* GetCustomData)(
					IPB_XMLDOMXMLDecl* This,
					/* [out] */ IPB_String** ppCustomDataReceiver);

				END_INTERFACE
			} IPB_XMLDOMXMLDeclVtbl;

			interface IPB_XMLDOMXMLDecl
			{
				CONST_VTBL struct IPB_XMLDOMXMLDeclVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_XMLDOMXMLDecl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_XMLDOMXMLDecl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_XMLDOMXMLDecl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_XMLDOMXMLDecl_GetNodeName(This,ppNodeNameReceiver)	\
    (This)->lpVtbl -> GetNodeName(This,ppNodeNameReceiver)

#define IPB_XMLDOMXMLDecl_GetNodeValue(This,ppNodeValueReceiver)	\
    (This)->lpVtbl -> GetNodeValue(This,ppNodeValueReceiver)

#define IPB_XMLDOMXMLDecl_GetNodeType(This,pNodeTypeReceiver)	\
    (This)->lpVtbl -> GetNodeType(This,pNodeTypeReceiver)

#define IPB_XMLDOMXMLDecl_GetParentNode(This,ppParentNodeReceiver)	\
    (This)->lpVtbl -> GetParentNode(This,ppParentNodeReceiver)

#define IPB_XMLDOMXMLDecl_GetChildNodes(This,ppChildNodesListReceiver)	\
    (This)->lpVtbl -> GetChildNodes(This,ppChildNodesListReceiver)

#define IPB_XMLDOMXMLDecl_GetFirstChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetFirstChild(This,ppXMLDOMNode)

#define IPB_XMLDOMXMLDecl_GetLastChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetLastChild(This,ppXMLDOMNode)

#define IPB_XMLDOMXMLDecl_GetNextSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetNextSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMXMLDecl_GetPreviousSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetPreviousSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMXMLDecl_GetAttributes(This,ppAttrNamedNodeMapReceiver)	\
    (This)->lpVtbl -> GetAttributes(This,ppAttrNamedNodeMapReceiver)

#define IPB_XMLDOMXMLDecl_GetOwnerDocument(This,ppOwnerDocumentReceiver)	\
    (This)->lpVtbl -> GetOwnerDocument(This,ppOwnerDocumentReceiver)

#define IPB_XMLDOMXMLDecl_GetNamespaceURI(This,ppNamespaceURIReceiver)	\
    (This)->lpVtbl -> GetNamespaceURI(This,ppNamespaceURIReceiver)

#define IPB_XMLDOMXMLDecl_GetPrefix(This,ppPrefixReceiver)	\
    (This)->lpVtbl -> GetPrefix(This,ppPrefixReceiver)

#define IPB_XMLDOMXMLDecl_GetLocalName(This,ppLocalNameReceiver)	\
    (This)->lpVtbl -> GetLocalName(This,ppLocalNameReceiver)

#define IPB_XMLDOMXMLDecl_InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMXMLDecl_ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMXMLDecl_RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMXMLDecl_AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMXMLDecl_HasChildNodes(This,pBoolReceiver)	\
    (This)->lpVtbl -> HasChildNodes(This,pBoolReceiver)

#define IPB_XMLDOMXMLDecl_CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)	\
    (This)->lpVtbl -> CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)

#define IPB_XMLDOMXMLDecl_SetNodeName(This,pXMLDOMNodeChild,pNodeName)	\
    (This)->lpVtbl -> SetNodeName(This,pXMLDOMNodeChild,pNodeName)

#define IPB_XMLDOMXMLDecl_SetNodeValue(This,pNodeValue)	\
    (This)->lpVtbl -> SetNodeValue(This,pNodeValue)

#define IPB_XMLDOMXMLDecl_SetPrefix(This,pPrefix)	\
    (This)->lpVtbl -> SetPrefix(This,pPrefix)

#define IPB_XMLDOMXMLDecl_Normalize(This)	\
    (This)->lpVtbl -> Normalize(This)

#define IPB_XMLDOMXMLDecl_IsSupported(This,pFeature,pVersion,pBoolReceiver)	\
    (This)->lpVtbl -> IsSupported(This,pFeature,pVersion,pBoolReceiver)

#define IPB_XMLDOMXMLDecl_GetLastErrorCode(This)	\
    (This)->lpVtbl -> GetLastErrorCode(This)

#define IPB_XMLDOMXMLDecl_GetLastErrorString(This,ppErrorStringReceiver)	\
    (This)->lpVtbl -> GetLastErrorString(This,ppErrorStringReceiver)

#define IPB_XMLDOMXMLDecl_GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)	\
    (This)->lpVtbl -> GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)

#define IPB_XMLDOMXMLDecl_SetUserDefinedData(This,pVoidUserDefinedData)	\
    (This)->lpVtbl -> SetUserDefinedData(This,pVoidUserDefinedData)


#define IPB_XMLDOMXMLDecl_GetVersion(This,ppVersionReceiver)	\
    (This)->lpVtbl -> GetVersion(This,ppVersionReceiver)

#define IPB_XMLDOMXMLDecl_GetEncoding(This,ppEncodingReceiver)	\
    (This)->lpVtbl -> GetEncoding(This,ppEncodingReceiver)

#define IPB_XMLDOMXMLDecl_GetStandAlone(This,ppStandAloneReceiver)	\
    (This)->lpVtbl -> GetStandAlone(This,ppStandAloneReceiver)

#define IPB_XMLDOMXMLDecl_SetCustomData(This,pCustomData)	\
    (This)->lpVtbl -> SetCustomData(This,pCustomData)

#define IPB_XMLDOMXMLDecl_GetCustomData(This,ppCustomDataReceiver)	\
    (This)->lpVtbl -> GetCustomData(This,ppCustomDataReceiver)

#endif /* COBJMACROS */


#endif 	/* C style interface */



			HRESULT STDMETHODCALLTYPE IPB_XMLDOMXMLDecl_GetVersion_Proxy(
				IPB_XMLDOMXMLDecl* This,
				/* [out] */ IPB_String** ppVersionReceiver);


			void __RPC_STUB IPB_XMLDOMXMLDecl_GetVersion_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMXMLDecl_GetEncoding_Proxy(
				IPB_XMLDOMXMLDecl* This,
				/* [out] */ IPB_String** ppEncodingReceiver);


			void __RPC_STUB IPB_XMLDOMXMLDecl_GetEncoding_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMXMLDecl_GetStandAlone_Proxy(
				IPB_XMLDOMXMLDecl* This,
				/* [out] */ IPB_String** ppStandAloneReceiver);


			void __RPC_STUB IPB_XMLDOMXMLDecl_GetStandAlone_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMXMLDecl_SetCustomData_Proxy(
				IPB_XMLDOMXMLDecl* This,
				/* [in] */ const IPB_String* pCustomData);


			void __RPC_STUB IPB_XMLDOMXMLDecl_SetCustomData_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMXMLDecl_GetCustomData_Proxy(
				IPB_XMLDOMXMLDecl* This,
				/* [out] */ IPB_String** ppCustomDataReceiver);


			void __RPC_STUB IPB_XMLDOMXMLDecl_GetCustomData_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);



#endif 	/* __IPB_XMLDOMXMLDecl_INTERFACE_DEFINED__ */


#ifndef __IPB_XMLDOMProcessingInstruction_INTERFACE_DEFINED__
#define __IPB_XMLDOMProcessingInstruction_INTERFACE_DEFINED__

			/* interface IPB_XMLDOMProcessingInstruction */
			/* [unique][uuid][object][local] */


			EXTERN_C const IID IID_IPB_XMLDOMProcessingInstruction;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("B642834B-00F2-11d6-95A7-00B0D024631C")
				IPB_XMLDOMProcessingInstruction : public IPB_XMLDOMNode
			{
			public:
				virtual HRESULT STDMETHODCALLTYPE GetTarget(
					/* [out] */ IPB_String * *ppTargetReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetData(
					/* [out] */ IPB_String** ppDataReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetData(
					/* [in] */ const IPB_String* pData) = 0;

			};

#else 	/* C style interface */

			typedef struct IPB_XMLDOMProcessingInstructionVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_XMLDOMProcessingInstruction* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_XMLDOMProcessingInstruction* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_XMLDOMProcessingInstruction* This);

				HRESULT(STDMETHODCALLTYPE* GetNodeName)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [out] */ IPB_String** ppNodeNameReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeValue)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [out] */ IPB_String** ppNodeValueReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeType)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [out] */ long* pNodeTypeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetParentNode)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [out] */ IPB_XMLDOMNode** ppParentNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetChildNodes)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [out] */ IPB_XMLDOMNodeList** ppChildNodesListReceiver);

				HRESULT(STDMETHODCALLTYPE* GetFirstChild)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetLastChild)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetNextSibling)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetPreviousSibling)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetAttributes)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [out] */ IPB_XMLDOMNamedNodeMap** ppAttrNamedNodeMapReceiver);

				HRESULT(STDMETHODCALLTYPE* GetOwnerDocument)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [out] */ IPB_XMLDOMDocument** ppOwnerDocumentReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNamespaceURI)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [out] */ IPB_String** ppNamespaceURIReceiver);

				HRESULT(STDMETHODCALLTYPE* GetPrefix)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [out] */ IPB_String** ppPrefixReceiver);

				HRESULT(STDMETHODCALLTYPE* GetLocalName)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [out] */ IPB_String** ppLocalNameReceiver);

				HRESULT(STDMETHODCALLTYPE* InsertBefore)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeRefChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* ReplaceChild)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* RemoveChild)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* AppendChild)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* HasChildNodes)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [out] */ BOOL* pBoolReceiver);

				HRESULT(STDMETHODCALLTYPE* CloneNode)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [in] */ BOOL bDeep,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMCloneNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* SetNodeName)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeChild,
					/* [in] */ const IPB_String* pNodeName);

				HRESULT(STDMETHODCALLTYPE* SetNodeValue)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [in] */ const IPB_String* pNodeValue);

				HRESULT(STDMETHODCALLTYPE* SetPrefix)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [in] */ const IPB_String* pPrefix);

				HRESULT(STDMETHODCALLTYPE* Normalize)(
					IPB_XMLDOMProcessingInstruction* This);

				HRESULT(STDMETHODCALLTYPE* IsSupported)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [in] */ const IPB_String* pFeature,
					/* [in] */ const IPB_String* pVersion,
					/* [out] */ BOOL* pBoolReceiver);

				ULONG(STDMETHODCALLTYPE* GetLastErrorCode)(
					IPB_XMLDOMProcessingInstruction* This);

				ULONG(STDMETHODCALLTYPE* GetLastErrorString)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [out] */ IPB_String** ppErrorStringReceiver);

				HRESULT(STDMETHODCALLTYPE* GetUserDefinedData)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [out] */ void** ppVoidUserDefinedDataReceiver);

				HRESULT(STDMETHODCALLTYPE* SetUserDefinedData)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [in] */ void* pVoidUserDefinedData);

				HRESULT(STDMETHODCALLTYPE* GetTarget)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [out] */ IPB_String** ppTargetReceiver);

				HRESULT(STDMETHODCALLTYPE* GetData)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [out] */ IPB_String** ppDataReceiver);

				HRESULT(STDMETHODCALLTYPE* SetData)(
					IPB_XMLDOMProcessingInstruction* This,
					/* [in] */ const IPB_String* pData);

				END_INTERFACE
			} IPB_XMLDOMProcessingInstructionVtbl;

			interface IPB_XMLDOMProcessingInstruction
			{
				CONST_VTBL struct IPB_XMLDOMProcessingInstructionVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_XMLDOMProcessingInstruction_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_XMLDOMProcessingInstruction_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_XMLDOMProcessingInstruction_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_XMLDOMProcessingInstruction_GetNodeName(This,ppNodeNameReceiver)	\
    (This)->lpVtbl -> GetNodeName(This,ppNodeNameReceiver)

#define IPB_XMLDOMProcessingInstruction_GetNodeValue(This,ppNodeValueReceiver)	\
    (This)->lpVtbl -> GetNodeValue(This,ppNodeValueReceiver)

#define IPB_XMLDOMProcessingInstruction_GetNodeType(This,pNodeTypeReceiver)	\
    (This)->lpVtbl -> GetNodeType(This,pNodeTypeReceiver)

#define IPB_XMLDOMProcessingInstruction_GetParentNode(This,ppParentNodeReceiver)	\
    (This)->lpVtbl -> GetParentNode(This,ppParentNodeReceiver)

#define IPB_XMLDOMProcessingInstruction_GetChildNodes(This,ppChildNodesListReceiver)	\
    (This)->lpVtbl -> GetChildNodes(This,ppChildNodesListReceiver)

#define IPB_XMLDOMProcessingInstruction_GetFirstChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetFirstChild(This,ppXMLDOMNode)

#define IPB_XMLDOMProcessingInstruction_GetLastChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetLastChild(This,ppXMLDOMNode)

#define IPB_XMLDOMProcessingInstruction_GetNextSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetNextSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMProcessingInstruction_GetPreviousSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetPreviousSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMProcessingInstruction_GetAttributes(This,ppAttrNamedNodeMapReceiver)	\
    (This)->lpVtbl -> GetAttributes(This,ppAttrNamedNodeMapReceiver)

#define IPB_XMLDOMProcessingInstruction_GetOwnerDocument(This,ppOwnerDocumentReceiver)	\
    (This)->lpVtbl -> GetOwnerDocument(This,ppOwnerDocumentReceiver)

#define IPB_XMLDOMProcessingInstruction_GetNamespaceURI(This,ppNamespaceURIReceiver)	\
    (This)->lpVtbl -> GetNamespaceURI(This,ppNamespaceURIReceiver)

#define IPB_XMLDOMProcessingInstruction_GetPrefix(This,ppPrefixReceiver)	\
    (This)->lpVtbl -> GetPrefix(This,ppPrefixReceiver)

#define IPB_XMLDOMProcessingInstruction_GetLocalName(This,ppLocalNameReceiver)	\
    (This)->lpVtbl -> GetLocalName(This,ppLocalNameReceiver)

#define IPB_XMLDOMProcessingInstruction_InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMProcessingInstruction_ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMProcessingInstruction_RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMProcessingInstruction_AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMProcessingInstruction_HasChildNodes(This,pBoolReceiver)	\
    (This)->lpVtbl -> HasChildNodes(This,pBoolReceiver)

#define IPB_XMLDOMProcessingInstruction_CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)	\
    (This)->lpVtbl -> CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)

#define IPB_XMLDOMProcessingInstruction_SetNodeName(This,pXMLDOMNodeChild,pNodeName)	\
    (This)->lpVtbl -> SetNodeName(This,pXMLDOMNodeChild,pNodeName)

#define IPB_XMLDOMProcessingInstruction_SetNodeValue(This,pNodeValue)	\
    (This)->lpVtbl -> SetNodeValue(This,pNodeValue)

#define IPB_XMLDOMProcessingInstruction_SetPrefix(This,pPrefix)	\
    (This)->lpVtbl -> SetPrefix(This,pPrefix)

#define IPB_XMLDOMProcessingInstruction_Normalize(This)	\
    (This)->lpVtbl -> Normalize(This)

#define IPB_XMLDOMProcessingInstruction_IsSupported(This,pFeature,pVersion,pBoolReceiver)	\
    (This)->lpVtbl -> IsSupported(This,pFeature,pVersion,pBoolReceiver)

#define IPB_XMLDOMProcessingInstruction_GetLastErrorCode(This)	\
    (This)->lpVtbl -> GetLastErrorCode(This)

#define IPB_XMLDOMProcessingInstruction_GetLastErrorString(This,ppErrorStringReceiver)	\
    (This)->lpVtbl -> GetLastErrorString(This,ppErrorStringReceiver)

#define IPB_XMLDOMProcessingInstruction_GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)	\
    (This)->lpVtbl -> GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)

#define IPB_XMLDOMProcessingInstruction_SetUserDefinedData(This,pVoidUserDefinedData)	\
    (This)->lpVtbl -> SetUserDefinedData(This,pVoidUserDefinedData)


#define IPB_XMLDOMProcessingInstruction_GetTarget(This,ppTargetReceiver)	\
    (This)->lpVtbl -> GetTarget(This,ppTargetReceiver)

#define IPB_XMLDOMProcessingInstruction_GetData(This,ppDataReceiver)	\
    (This)->lpVtbl -> GetData(This,ppDataReceiver)

#define IPB_XMLDOMProcessingInstruction_SetData(This,pData)	\
    (This)->lpVtbl -> SetData(This,pData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



			HRESULT STDMETHODCALLTYPE IPB_XMLDOMProcessingInstruction_GetTarget_Proxy(
				IPB_XMLDOMProcessingInstruction* This,
				/* [out] */ IPB_String** ppTargetReceiver);


			void __RPC_STUB IPB_XMLDOMProcessingInstruction_GetTarget_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMProcessingInstruction_GetData_Proxy(
				IPB_XMLDOMProcessingInstruction* This,
				/* [out] */ IPB_String** ppDataReceiver);


			void __RPC_STUB IPB_XMLDOMProcessingInstruction_GetData_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMProcessingInstruction_SetData_Proxy(
				IPB_XMLDOMProcessingInstruction* This,
				/* [in] */ const IPB_String* pData);


			void __RPC_STUB IPB_XMLDOMProcessingInstruction_SetData_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);



#endif 	/* __IPB_XMLDOMProcessingInstruction_INTERFACE_DEFINED__ */


#ifndef __IPB_XMLDOMAttr_INTERFACE_DEFINED__
#define __IPB_XMLDOMAttr_INTERFACE_DEFINED__

			/* interface IPB_XMLDOMAttr */
			/* [unique][uuid][object][local] */


			EXTERN_C const IID IID_IPB_XMLDOMAttr;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("F5000FA1-059B-11d6-95A8-00B0D024631C")
				IPB_XMLDOMAttr : public IPB_XMLDOMNode
			{
			public:
				virtual HRESULT STDMETHODCALLTYPE GetName(
					/* [out] */ IPB_String * *ppNameReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetSpecified(
					/* [out] */ BOOL* pBoolReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetValue(
					/* [out] */ IPB_String** ppValueReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetValue(
					/* [in] */ const IPB_String* pValue) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetOwnerElement(
					/* [out] */ IPB_XMLDOMElement** ppOwnerElementReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE RequireTextNodeCreation(
					/* [out] */ BOOL* pBoolReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE DoTextNodeCreation(void) = 0;

			};

#else 	/* C style interface */

			typedef struct IPB_XMLDOMAttrVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_XMLDOMAttr* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_XMLDOMAttr* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_XMLDOMAttr* This);

				HRESULT(STDMETHODCALLTYPE* GetNodeName)(
					IPB_XMLDOMAttr* This,
					/* [out] */ IPB_String** ppNodeNameReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeValue)(
					IPB_XMLDOMAttr* This,
					/* [out] */ IPB_String** ppNodeValueReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeType)(
					IPB_XMLDOMAttr* This,
					/* [out] */ long* pNodeTypeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetParentNode)(
					IPB_XMLDOMAttr* This,
					/* [out] */ IPB_XMLDOMNode** ppParentNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetChildNodes)(
					IPB_XMLDOMAttr* This,
					/* [out] */ IPB_XMLDOMNodeList** ppChildNodesListReceiver);

				HRESULT(STDMETHODCALLTYPE* GetFirstChild)(
					IPB_XMLDOMAttr* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetLastChild)(
					IPB_XMLDOMAttr* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetNextSibling)(
					IPB_XMLDOMAttr* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetPreviousSibling)(
					IPB_XMLDOMAttr* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetAttributes)(
					IPB_XMLDOMAttr* This,
					/* [out] */ IPB_XMLDOMNamedNodeMap** ppAttrNamedNodeMapReceiver);

				HRESULT(STDMETHODCALLTYPE* GetOwnerDocument)(
					IPB_XMLDOMAttr* This,
					/* [out] */ IPB_XMLDOMDocument** ppOwnerDocumentReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNamespaceURI)(
					IPB_XMLDOMAttr* This,
					/* [out] */ IPB_String** ppNamespaceURIReceiver);

				HRESULT(STDMETHODCALLTYPE* GetPrefix)(
					IPB_XMLDOMAttr* This,
					/* [out] */ IPB_String** ppPrefixReceiver);

				HRESULT(STDMETHODCALLTYPE* GetLocalName)(
					IPB_XMLDOMAttr* This,
					/* [out] */ IPB_String** ppLocalNameReceiver);

				HRESULT(STDMETHODCALLTYPE* InsertBefore)(
					IPB_XMLDOMAttr* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeRefChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* ReplaceChild)(
					IPB_XMLDOMAttr* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* RemoveChild)(
					IPB_XMLDOMAttr* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* AppendChild)(
					IPB_XMLDOMAttr* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* HasChildNodes)(
					IPB_XMLDOMAttr* This,
					/* [out] */ BOOL* pBoolReceiver);

				HRESULT(STDMETHODCALLTYPE* CloneNode)(
					IPB_XMLDOMAttr* This,
					/* [in] */ BOOL bDeep,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMCloneNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* SetNodeName)(
					IPB_XMLDOMAttr* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeChild,
					/* [in] */ const IPB_String* pNodeName);

				HRESULT(STDMETHODCALLTYPE* SetNodeValue)(
					IPB_XMLDOMAttr* This,
					/* [in] */ const IPB_String* pNodeValue);

				HRESULT(STDMETHODCALLTYPE* SetPrefix)(
					IPB_XMLDOMAttr* This,
					/* [in] */ const IPB_String* pPrefix);

				HRESULT(STDMETHODCALLTYPE* Normalize)(
					IPB_XMLDOMAttr* This);

				HRESULT(STDMETHODCALLTYPE* IsSupported)(
					IPB_XMLDOMAttr* This,
					/* [in] */ const IPB_String* pFeature,
					/* [in] */ const IPB_String* pVersion,
					/* [out] */ BOOL* pBoolReceiver);

				ULONG(STDMETHODCALLTYPE* GetLastErrorCode)(
					IPB_XMLDOMAttr* This);

				ULONG(STDMETHODCALLTYPE* GetLastErrorString)(
					IPB_XMLDOMAttr* This,
					/* [out] */ IPB_String** ppErrorStringReceiver);

				HRESULT(STDMETHODCALLTYPE* GetUserDefinedData)(
					IPB_XMLDOMAttr* This,
					/* [out] */ void** ppVoidUserDefinedDataReceiver);

				HRESULT(STDMETHODCALLTYPE* SetUserDefinedData)(
					IPB_XMLDOMAttr* This,
					/* [in] */ void* pVoidUserDefinedData);

				HRESULT(STDMETHODCALLTYPE* GetName)(
					IPB_XMLDOMAttr* This,
					/* [out] */ IPB_String** ppNameReceiver);

				HRESULT(STDMETHODCALLTYPE* GetSpecified)(
					IPB_XMLDOMAttr* This,
					/* [out] */ BOOL* pBoolReceiver);

				HRESULT(STDMETHODCALLTYPE* GetValue)(
					IPB_XMLDOMAttr* This,
					/* [out] */ IPB_String** ppValueReceiver);

				HRESULT(STDMETHODCALLTYPE* SetValue)(
					IPB_XMLDOMAttr* This,
					/* [in] */ const IPB_String* pValue);

				HRESULT(STDMETHODCALLTYPE* GetOwnerElement)(
					IPB_XMLDOMAttr* This,
					/* [out] */ IPB_XMLDOMElement** ppOwnerElementReceiver);

				HRESULT(STDMETHODCALLTYPE* RequireTextNodeCreation)(
					IPB_XMLDOMAttr* This,
					/* [out] */ BOOL* pBoolReceiver);

				HRESULT(STDMETHODCALLTYPE* DoTextNodeCreation)(
					IPB_XMLDOMAttr* This);

				END_INTERFACE
			} IPB_XMLDOMAttrVtbl;

			interface IPB_XMLDOMAttr
			{
				CONST_VTBL struct IPB_XMLDOMAttrVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_XMLDOMAttr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_XMLDOMAttr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_XMLDOMAttr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_XMLDOMAttr_GetNodeName(This,ppNodeNameReceiver)	\
    (This)->lpVtbl -> GetNodeName(This,ppNodeNameReceiver)

#define IPB_XMLDOMAttr_GetNodeValue(This,ppNodeValueReceiver)	\
    (This)->lpVtbl -> GetNodeValue(This,ppNodeValueReceiver)

#define IPB_XMLDOMAttr_GetNodeType(This,pNodeTypeReceiver)	\
    (This)->lpVtbl -> GetNodeType(This,pNodeTypeReceiver)

#define IPB_XMLDOMAttr_GetParentNode(This,ppParentNodeReceiver)	\
    (This)->lpVtbl -> GetParentNode(This,ppParentNodeReceiver)

#define IPB_XMLDOMAttr_GetChildNodes(This,ppChildNodesListReceiver)	\
    (This)->lpVtbl -> GetChildNodes(This,ppChildNodesListReceiver)

#define IPB_XMLDOMAttr_GetFirstChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetFirstChild(This,ppXMLDOMNode)

#define IPB_XMLDOMAttr_GetLastChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetLastChild(This,ppXMLDOMNode)

#define IPB_XMLDOMAttr_GetNextSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetNextSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMAttr_GetPreviousSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetPreviousSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMAttr_GetAttributes(This,ppAttrNamedNodeMapReceiver)	\
    (This)->lpVtbl -> GetAttributes(This,ppAttrNamedNodeMapReceiver)

#define IPB_XMLDOMAttr_GetOwnerDocument(This,ppOwnerDocumentReceiver)	\
    (This)->lpVtbl -> GetOwnerDocument(This,ppOwnerDocumentReceiver)

#define IPB_XMLDOMAttr_GetNamespaceURI(This,ppNamespaceURIReceiver)	\
    (This)->lpVtbl -> GetNamespaceURI(This,ppNamespaceURIReceiver)

#define IPB_XMLDOMAttr_GetPrefix(This,ppPrefixReceiver)	\
    (This)->lpVtbl -> GetPrefix(This,ppPrefixReceiver)

#define IPB_XMLDOMAttr_GetLocalName(This,ppLocalNameReceiver)	\
    (This)->lpVtbl -> GetLocalName(This,ppLocalNameReceiver)

#define IPB_XMLDOMAttr_InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMAttr_ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMAttr_RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMAttr_AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMAttr_HasChildNodes(This,pBoolReceiver)	\
    (This)->lpVtbl -> HasChildNodes(This,pBoolReceiver)

#define IPB_XMLDOMAttr_CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)	\
    (This)->lpVtbl -> CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)

#define IPB_XMLDOMAttr_SetNodeName(This,pXMLDOMNodeChild,pNodeName)	\
    (This)->lpVtbl -> SetNodeName(This,pXMLDOMNodeChild,pNodeName)

#define IPB_XMLDOMAttr_SetNodeValue(This,pNodeValue)	\
    (This)->lpVtbl -> SetNodeValue(This,pNodeValue)

#define IPB_XMLDOMAttr_SetPrefix(This,pPrefix)	\
    (This)->lpVtbl -> SetPrefix(This,pPrefix)

#define IPB_XMLDOMAttr_Normalize(This)	\
    (This)->lpVtbl -> Normalize(This)

#define IPB_XMLDOMAttr_IsSupported(This,pFeature,pVersion,pBoolReceiver)	\
    (This)->lpVtbl -> IsSupported(This,pFeature,pVersion,pBoolReceiver)

#define IPB_XMLDOMAttr_GetLastErrorCode(This)	\
    (This)->lpVtbl -> GetLastErrorCode(This)

#define IPB_XMLDOMAttr_GetLastErrorString(This,ppErrorStringReceiver)	\
    (This)->lpVtbl -> GetLastErrorString(This,ppErrorStringReceiver)

#define IPB_XMLDOMAttr_GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)	\
    (This)->lpVtbl -> GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)

#define IPB_XMLDOMAttr_SetUserDefinedData(This,pVoidUserDefinedData)	\
    (This)->lpVtbl -> SetUserDefinedData(This,pVoidUserDefinedData)


#define IPB_XMLDOMAttr_GetName(This,ppNameReceiver)	\
    (This)->lpVtbl -> GetName(This,ppNameReceiver)

#define IPB_XMLDOMAttr_GetSpecified(This,pBoolReceiver)	\
    (This)->lpVtbl -> GetSpecified(This,pBoolReceiver)

#define IPB_XMLDOMAttr_GetValue(This,ppValueReceiver)	\
    (This)->lpVtbl -> GetValue(This,ppValueReceiver)

#define IPB_XMLDOMAttr_SetValue(This,pValue)	\
    (This)->lpVtbl -> SetValue(This,pValue)

#define IPB_XMLDOMAttr_GetOwnerElement(This,ppOwnerElementReceiver)	\
    (This)->lpVtbl -> GetOwnerElement(This,ppOwnerElementReceiver)

#define IPB_XMLDOMAttr_RequireTextNodeCreation(This,pBoolReceiver)	\
    (This)->lpVtbl -> RequireTextNodeCreation(This,pBoolReceiver)

#define IPB_XMLDOMAttr_DoTextNodeCreation(This)	\
    (This)->lpVtbl -> DoTextNodeCreation(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



			HRESULT STDMETHODCALLTYPE IPB_XMLDOMAttr_GetName_Proxy(
				IPB_XMLDOMAttr* This,
				/* [out] */ IPB_String** ppNameReceiver);


			void __RPC_STUB IPB_XMLDOMAttr_GetName_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMAttr_GetSpecified_Proxy(
				IPB_XMLDOMAttr* This,
				/* [out] */ BOOL* pBoolReceiver);


			void __RPC_STUB IPB_XMLDOMAttr_GetSpecified_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMAttr_GetValue_Proxy(
				IPB_XMLDOMAttr* This,
				/* [out] */ IPB_String** ppValueReceiver);


			void __RPC_STUB IPB_XMLDOMAttr_GetValue_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMAttr_SetValue_Proxy(
				IPB_XMLDOMAttr* This,
				/* [in] */ const IPB_String* pValue);


			void __RPC_STUB IPB_XMLDOMAttr_SetValue_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMAttr_GetOwnerElement_Proxy(
				IPB_XMLDOMAttr* This,
				/* [out] */ IPB_XMLDOMElement** ppOwnerElementReceiver);


			void __RPC_STUB IPB_XMLDOMAttr_GetOwnerElement_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMAttr_RequireTextNodeCreation_Proxy(
				IPB_XMLDOMAttr* This,
				/* [out] */ BOOL* pBoolReceiver);


			void __RPC_STUB IPB_XMLDOMAttr_RequireTextNodeCreation_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMAttr_DoTextNodeCreation_Proxy(
				IPB_XMLDOMAttr* This);


			void __RPC_STUB IPB_XMLDOMAttr_DoTextNodeCreation_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);



#endif 	/* __IPB_XMLDOMAttr_INTERFACE_DEFINED__ */


#ifndef __IPB_XMLDOMEntity_INTERFACE_DEFINED__
#define __IPB_XMLDOMEntity_INTERFACE_DEFINED__

			/* interface IPB_XMLDOMEntity */
			/* [unique][uuid][object][local] */


			EXTERN_C const IID IID_IPB_XMLDOMEntity;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("131DC2B2-0F0C-11d6-95AA-00B0D024631C")
				IPB_XMLDOMEntity : public IPB_XMLDOMNode
			{
			public:
				virtual HRESULT STDMETHODCALLTYPE GetPublicId(
					/* [out] */ IPB_String * *ppPublicIdReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetSystemId(
					/* [out] */ IPB_String** ppSystemIdReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetNotationName(
					/* [out] */ IPB_String** ppNotationNameReceiver) = 0;

			};

#else 	/* C style interface */

			typedef struct IPB_XMLDOMEntityVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_XMLDOMEntity* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_XMLDOMEntity* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_XMLDOMEntity* This);

				HRESULT(STDMETHODCALLTYPE* GetNodeName)(
					IPB_XMLDOMEntity* This,
					/* [out] */ IPB_String** ppNodeNameReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeValue)(
					IPB_XMLDOMEntity* This,
					/* [out] */ IPB_String** ppNodeValueReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeType)(
					IPB_XMLDOMEntity* This,
					/* [out] */ long* pNodeTypeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetParentNode)(
					IPB_XMLDOMEntity* This,
					/* [out] */ IPB_XMLDOMNode** ppParentNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetChildNodes)(
					IPB_XMLDOMEntity* This,
					/* [out] */ IPB_XMLDOMNodeList** ppChildNodesListReceiver);

				HRESULT(STDMETHODCALLTYPE* GetFirstChild)(
					IPB_XMLDOMEntity* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetLastChild)(
					IPB_XMLDOMEntity* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetNextSibling)(
					IPB_XMLDOMEntity* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetPreviousSibling)(
					IPB_XMLDOMEntity* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetAttributes)(
					IPB_XMLDOMEntity* This,
					/* [out] */ IPB_XMLDOMNamedNodeMap** ppAttrNamedNodeMapReceiver);

				HRESULT(STDMETHODCALLTYPE* GetOwnerDocument)(
					IPB_XMLDOMEntity* This,
					/* [out] */ IPB_XMLDOMDocument** ppOwnerDocumentReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNamespaceURI)(
					IPB_XMLDOMEntity* This,
					/* [out] */ IPB_String** ppNamespaceURIReceiver);

				HRESULT(STDMETHODCALLTYPE* GetPrefix)(
					IPB_XMLDOMEntity* This,
					/* [out] */ IPB_String** ppPrefixReceiver);

				HRESULT(STDMETHODCALLTYPE* GetLocalName)(
					IPB_XMLDOMEntity* This,
					/* [out] */ IPB_String** ppLocalNameReceiver);

				HRESULT(STDMETHODCALLTYPE* InsertBefore)(
					IPB_XMLDOMEntity* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeRefChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* ReplaceChild)(
					IPB_XMLDOMEntity* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* RemoveChild)(
					IPB_XMLDOMEntity* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* AppendChild)(
					IPB_XMLDOMEntity* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* HasChildNodes)(
					IPB_XMLDOMEntity* This,
					/* [out] */ BOOL* pBoolReceiver);

				HRESULT(STDMETHODCALLTYPE* CloneNode)(
					IPB_XMLDOMEntity* This,
					/* [in] */ BOOL bDeep,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMCloneNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* SetNodeName)(
					IPB_XMLDOMEntity* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeChild,
					/* [in] */ const IPB_String* pNodeName);

				HRESULT(STDMETHODCALLTYPE* SetNodeValue)(
					IPB_XMLDOMEntity* This,
					/* [in] */ const IPB_String* pNodeValue);

				HRESULT(STDMETHODCALLTYPE* SetPrefix)(
					IPB_XMLDOMEntity* This,
					/* [in] */ const IPB_String* pPrefix);

				HRESULT(STDMETHODCALLTYPE* Normalize)(
					IPB_XMLDOMEntity* This);

				HRESULT(STDMETHODCALLTYPE* IsSupported)(
					IPB_XMLDOMEntity* This,
					/* [in] */ const IPB_String* pFeature,
					/* [in] */ const IPB_String* pVersion,
					/* [out] */ BOOL* pBoolReceiver);

				ULONG(STDMETHODCALLTYPE* GetLastErrorCode)(
					IPB_XMLDOMEntity* This);

				ULONG(STDMETHODCALLTYPE* GetLastErrorString)(
					IPB_XMLDOMEntity* This,
					/* [out] */ IPB_String** ppErrorStringReceiver);

				HRESULT(STDMETHODCALLTYPE* GetUserDefinedData)(
					IPB_XMLDOMEntity* This,
					/* [out] */ void** ppVoidUserDefinedDataReceiver);

				HRESULT(STDMETHODCALLTYPE* SetUserDefinedData)(
					IPB_XMLDOMEntity* This,
					/* [in] */ void* pVoidUserDefinedData);

				HRESULT(STDMETHODCALLTYPE* GetPublicId)(
					IPB_XMLDOMEntity* This,
					/* [out] */ IPB_String** ppPublicIdReceiver);

				HRESULT(STDMETHODCALLTYPE* GetSystemId)(
					IPB_XMLDOMEntity* This,
					/* [out] */ IPB_String** ppSystemIdReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNotationName)(
					IPB_XMLDOMEntity* This,
					/* [out] */ IPB_String** ppNotationNameReceiver);

				END_INTERFACE
			} IPB_XMLDOMEntityVtbl;

			interface IPB_XMLDOMEntity
			{
				CONST_VTBL struct IPB_XMLDOMEntityVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_XMLDOMEntity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_XMLDOMEntity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_XMLDOMEntity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_XMLDOMEntity_GetNodeName(This,ppNodeNameReceiver)	\
    (This)->lpVtbl -> GetNodeName(This,ppNodeNameReceiver)

#define IPB_XMLDOMEntity_GetNodeValue(This,ppNodeValueReceiver)	\
    (This)->lpVtbl -> GetNodeValue(This,ppNodeValueReceiver)

#define IPB_XMLDOMEntity_GetNodeType(This,pNodeTypeReceiver)	\
    (This)->lpVtbl -> GetNodeType(This,pNodeTypeReceiver)

#define IPB_XMLDOMEntity_GetParentNode(This,ppParentNodeReceiver)	\
    (This)->lpVtbl -> GetParentNode(This,ppParentNodeReceiver)

#define IPB_XMLDOMEntity_GetChildNodes(This,ppChildNodesListReceiver)	\
    (This)->lpVtbl -> GetChildNodes(This,ppChildNodesListReceiver)

#define IPB_XMLDOMEntity_GetFirstChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetFirstChild(This,ppXMLDOMNode)

#define IPB_XMLDOMEntity_GetLastChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetLastChild(This,ppXMLDOMNode)

#define IPB_XMLDOMEntity_GetNextSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetNextSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMEntity_GetPreviousSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetPreviousSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMEntity_GetAttributes(This,ppAttrNamedNodeMapReceiver)	\
    (This)->lpVtbl -> GetAttributes(This,ppAttrNamedNodeMapReceiver)

#define IPB_XMLDOMEntity_GetOwnerDocument(This,ppOwnerDocumentReceiver)	\
    (This)->lpVtbl -> GetOwnerDocument(This,ppOwnerDocumentReceiver)

#define IPB_XMLDOMEntity_GetNamespaceURI(This,ppNamespaceURIReceiver)	\
    (This)->lpVtbl -> GetNamespaceURI(This,ppNamespaceURIReceiver)

#define IPB_XMLDOMEntity_GetPrefix(This,ppPrefixReceiver)	\
    (This)->lpVtbl -> GetPrefix(This,ppPrefixReceiver)

#define IPB_XMLDOMEntity_GetLocalName(This,ppLocalNameReceiver)	\
    (This)->lpVtbl -> GetLocalName(This,ppLocalNameReceiver)

#define IPB_XMLDOMEntity_InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMEntity_ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMEntity_RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMEntity_AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMEntity_HasChildNodes(This,pBoolReceiver)	\
    (This)->lpVtbl -> HasChildNodes(This,pBoolReceiver)

#define IPB_XMLDOMEntity_CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)	\
    (This)->lpVtbl -> CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)

#define IPB_XMLDOMEntity_SetNodeName(This,pXMLDOMNodeChild,pNodeName)	\
    (This)->lpVtbl -> SetNodeName(This,pXMLDOMNodeChild,pNodeName)

#define IPB_XMLDOMEntity_SetNodeValue(This,pNodeValue)	\
    (This)->lpVtbl -> SetNodeValue(This,pNodeValue)

#define IPB_XMLDOMEntity_SetPrefix(This,pPrefix)	\
    (This)->lpVtbl -> SetPrefix(This,pPrefix)

#define IPB_XMLDOMEntity_Normalize(This)	\
    (This)->lpVtbl -> Normalize(This)

#define IPB_XMLDOMEntity_IsSupported(This,pFeature,pVersion,pBoolReceiver)	\
    (This)->lpVtbl -> IsSupported(This,pFeature,pVersion,pBoolReceiver)

#define IPB_XMLDOMEntity_GetLastErrorCode(This)	\
    (This)->lpVtbl -> GetLastErrorCode(This)

#define IPB_XMLDOMEntity_GetLastErrorString(This,ppErrorStringReceiver)	\
    (This)->lpVtbl -> GetLastErrorString(This,ppErrorStringReceiver)

#define IPB_XMLDOMEntity_GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)	\
    (This)->lpVtbl -> GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)

#define IPB_XMLDOMEntity_SetUserDefinedData(This,pVoidUserDefinedData)	\
    (This)->lpVtbl -> SetUserDefinedData(This,pVoidUserDefinedData)


#define IPB_XMLDOMEntity_GetPublicId(This,ppPublicIdReceiver)	\
    (This)->lpVtbl -> GetPublicId(This,ppPublicIdReceiver)

#define IPB_XMLDOMEntity_GetSystemId(This,ppSystemIdReceiver)	\
    (This)->lpVtbl -> GetSystemId(This,ppSystemIdReceiver)

#define IPB_XMLDOMEntity_GetNotationName(This,ppNotationNameReceiver)	\
    (This)->lpVtbl -> GetNotationName(This,ppNotationNameReceiver)

#endif /* COBJMACROS */


#endif 	/* C style interface */



			HRESULT STDMETHODCALLTYPE IPB_XMLDOMEntity_GetPublicId_Proxy(
				IPB_XMLDOMEntity* This,
				/* [out] */ IPB_String** ppPublicIdReceiver);


			void __RPC_STUB IPB_XMLDOMEntity_GetPublicId_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMEntity_GetSystemId_Proxy(
				IPB_XMLDOMEntity* This,
				/* [out] */ IPB_String** ppSystemIdReceiver);


			void __RPC_STUB IPB_XMLDOMEntity_GetSystemId_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMEntity_GetNotationName_Proxy(
				IPB_XMLDOMEntity* This,
				/* [out] */ IPB_String** ppNotationNameReceiver);


			void __RPC_STUB IPB_XMLDOMEntity_GetNotationName_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);



#endif 	/* __IPB_XMLDOMEntity_INTERFACE_DEFINED__ */


#ifndef __IPB_XMLDOMEntityReference_INTERFACE_DEFINED__
#define __IPB_XMLDOMEntityReference_INTERFACE_DEFINED__

			/* interface IPB_XMLDOMEntityReference */
			/* [unique][uuid][object][local] */


			EXTERN_C const IID IID_IPB_XMLDOMEntityReference;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("65311877-1165-11d6-95AB-00B0D024631C")
				IPB_XMLDOMEntityReference : public IPB_XMLDOMNode
			{
			public:
			};

#else 	/* C style interface */

			typedef struct IPB_XMLDOMEntityReferenceVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_XMLDOMEntityReference* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_XMLDOMEntityReference* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_XMLDOMEntityReference* This);

				HRESULT(STDMETHODCALLTYPE* GetNodeName)(
					IPB_XMLDOMEntityReference* This,
					/* [out] */ IPB_String** ppNodeNameReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeValue)(
					IPB_XMLDOMEntityReference* This,
					/* [out] */ IPB_String** ppNodeValueReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeType)(
					IPB_XMLDOMEntityReference* This,
					/* [out] */ long* pNodeTypeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetParentNode)(
					IPB_XMLDOMEntityReference* This,
					/* [out] */ IPB_XMLDOMNode** ppParentNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetChildNodes)(
					IPB_XMLDOMEntityReference* This,
					/* [out] */ IPB_XMLDOMNodeList** ppChildNodesListReceiver);

				HRESULT(STDMETHODCALLTYPE* GetFirstChild)(
					IPB_XMLDOMEntityReference* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetLastChild)(
					IPB_XMLDOMEntityReference* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetNextSibling)(
					IPB_XMLDOMEntityReference* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetPreviousSibling)(
					IPB_XMLDOMEntityReference* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetAttributes)(
					IPB_XMLDOMEntityReference* This,
					/* [out] */ IPB_XMLDOMNamedNodeMap** ppAttrNamedNodeMapReceiver);

				HRESULT(STDMETHODCALLTYPE* GetOwnerDocument)(
					IPB_XMLDOMEntityReference* This,
					/* [out] */ IPB_XMLDOMDocument** ppOwnerDocumentReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNamespaceURI)(
					IPB_XMLDOMEntityReference* This,
					/* [out] */ IPB_String** ppNamespaceURIReceiver);

				HRESULT(STDMETHODCALLTYPE* GetPrefix)(
					IPB_XMLDOMEntityReference* This,
					/* [out] */ IPB_String** ppPrefixReceiver);

				HRESULT(STDMETHODCALLTYPE* GetLocalName)(
					IPB_XMLDOMEntityReference* This,
					/* [out] */ IPB_String** ppLocalNameReceiver);

				HRESULT(STDMETHODCALLTYPE* InsertBefore)(
					IPB_XMLDOMEntityReference* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeRefChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* ReplaceChild)(
					IPB_XMLDOMEntityReference* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* RemoveChild)(
					IPB_XMLDOMEntityReference* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* AppendChild)(
					IPB_XMLDOMEntityReference* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* HasChildNodes)(
					IPB_XMLDOMEntityReference* This,
					/* [out] */ BOOL* pBoolReceiver);

				HRESULT(STDMETHODCALLTYPE* CloneNode)(
					IPB_XMLDOMEntityReference* This,
					/* [in] */ BOOL bDeep,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMCloneNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* SetNodeName)(
					IPB_XMLDOMEntityReference* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeChild,
					/* [in] */ const IPB_String* pNodeName);

				HRESULT(STDMETHODCALLTYPE* SetNodeValue)(
					IPB_XMLDOMEntityReference* This,
					/* [in] */ const IPB_String* pNodeValue);

				HRESULT(STDMETHODCALLTYPE* SetPrefix)(
					IPB_XMLDOMEntityReference* This,
					/* [in] */ const IPB_String* pPrefix);

				HRESULT(STDMETHODCALLTYPE* Normalize)(
					IPB_XMLDOMEntityReference* This);

				HRESULT(STDMETHODCALLTYPE* IsSupported)(
					IPB_XMLDOMEntityReference* This,
					/* [in] */ const IPB_String* pFeature,
					/* [in] */ const IPB_String* pVersion,
					/* [out] */ BOOL* pBoolReceiver);

				ULONG(STDMETHODCALLTYPE* GetLastErrorCode)(
					IPB_XMLDOMEntityReference* This);

				ULONG(STDMETHODCALLTYPE* GetLastErrorString)(
					IPB_XMLDOMEntityReference* This,
					/* [out] */ IPB_String** ppErrorStringReceiver);

				HRESULT(STDMETHODCALLTYPE* GetUserDefinedData)(
					IPB_XMLDOMEntityReference* This,
					/* [out] */ void** ppVoidUserDefinedDataReceiver);

				HRESULT(STDMETHODCALLTYPE* SetUserDefinedData)(
					IPB_XMLDOMEntityReference* This,
					/* [in] */ void* pVoidUserDefinedData);

				END_INTERFACE
			} IPB_XMLDOMEntityReferenceVtbl;

			interface IPB_XMLDOMEntityReference
			{
				CONST_VTBL struct IPB_XMLDOMEntityReferenceVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_XMLDOMEntityReference_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_XMLDOMEntityReference_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_XMLDOMEntityReference_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_XMLDOMEntityReference_GetNodeName(This,ppNodeNameReceiver)	\
    (This)->lpVtbl -> GetNodeName(This,ppNodeNameReceiver)

#define IPB_XMLDOMEntityReference_GetNodeValue(This,ppNodeValueReceiver)	\
    (This)->lpVtbl -> GetNodeValue(This,ppNodeValueReceiver)

#define IPB_XMLDOMEntityReference_GetNodeType(This,pNodeTypeReceiver)	\
    (This)->lpVtbl -> GetNodeType(This,pNodeTypeReceiver)

#define IPB_XMLDOMEntityReference_GetParentNode(This,ppParentNodeReceiver)	\
    (This)->lpVtbl -> GetParentNode(This,ppParentNodeReceiver)

#define IPB_XMLDOMEntityReference_GetChildNodes(This,ppChildNodesListReceiver)	\
    (This)->lpVtbl -> GetChildNodes(This,ppChildNodesListReceiver)

#define IPB_XMLDOMEntityReference_GetFirstChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetFirstChild(This,ppXMLDOMNode)

#define IPB_XMLDOMEntityReference_GetLastChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetLastChild(This,ppXMLDOMNode)

#define IPB_XMLDOMEntityReference_GetNextSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetNextSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMEntityReference_GetPreviousSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetPreviousSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMEntityReference_GetAttributes(This,ppAttrNamedNodeMapReceiver)	\
    (This)->lpVtbl -> GetAttributes(This,ppAttrNamedNodeMapReceiver)

#define IPB_XMLDOMEntityReference_GetOwnerDocument(This,ppOwnerDocumentReceiver)	\
    (This)->lpVtbl -> GetOwnerDocument(This,ppOwnerDocumentReceiver)

#define IPB_XMLDOMEntityReference_GetNamespaceURI(This,ppNamespaceURIReceiver)	\
    (This)->lpVtbl -> GetNamespaceURI(This,ppNamespaceURIReceiver)

#define IPB_XMLDOMEntityReference_GetPrefix(This,ppPrefixReceiver)	\
    (This)->lpVtbl -> GetPrefix(This,ppPrefixReceiver)

#define IPB_XMLDOMEntityReference_GetLocalName(This,ppLocalNameReceiver)	\
    (This)->lpVtbl -> GetLocalName(This,ppLocalNameReceiver)

#define IPB_XMLDOMEntityReference_InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMEntityReference_ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMEntityReference_RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMEntityReference_AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMEntityReference_HasChildNodes(This,pBoolReceiver)	\
    (This)->lpVtbl -> HasChildNodes(This,pBoolReceiver)

#define IPB_XMLDOMEntityReference_CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)	\
    (This)->lpVtbl -> CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)

#define IPB_XMLDOMEntityReference_SetNodeName(This,pXMLDOMNodeChild,pNodeName)	\
    (This)->lpVtbl -> SetNodeName(This,pXMLDOMNodeChild,pNodeName)

#define IPB_XMLDOMEntityReference_SetNodeValue(This,pNodeValue)	\
    (This)->lpVtbl -> SetNodeValue(This,pNodeValue)

#define IPB_XMLDOMEntityReference_SetPrefix(This,pPrefix)	\
    (This)->lpVtbl -> SetPrefix(This,pPrefix)

#define IPB_XMLDOMEntityReference_Normalize(This)	\
    (This)->lpVtbl -> Normalize(This)

#define IPB_XMLDOMEntityReference_IsSupported(This,pFeature,pVersion,pBoolReceiver)	\
    (This)->lpVtbl -> IsSupported(This,pFeature,pVersion,pBoolReceiver)

#define IPB_XMLDOMEntityReference_GetLastErrorCode(This)	\
    (This)->lpVtbl -> GetLastErrorCode(This)

#define IPB_XMLDOMEntityReference_GetLastErrorString(This,ppErrorStringReceiver)	\
    (This)->lpVtbl -> GetLastErrorString(This,ppErrorStringReceiver)

#define IPB_XMLDOMEntityReference_GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)	\
    (This)->lpVtbl -> GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)

#define IPB_XMLDOMEntityReference_SetUserDefinedData(This,pVoidUserDefinedData)	\
    (This)->lpVtbl -> SetUserDefinedData(This,pVoidUserDefinedData)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPB_XMLDOMEntityReference_INTERFACE_DEFINED__ */


#ifndef __IPB_XMLDOMNotation_INTERFACE_DEFINED__
#define __IPB_XMLDOMNotation_INTERFACE_DEFINED__

			/* interface IPB_XMLDOMNotation */
			/* [unique][uuid][object][local] */


			EXTERN_C const IID IID_IPB_XMLDOMNotation;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("E61A394B-13C7-11d6-95AB-00B0D024631C")
				IPB_XMLDOMNotation : public IPB_XMLDOMNode
			{
			public:
				virtual HRESULT STDMETHODCALLTYPE GetPublicId(
					/* [out] */ IPB_String * *ppPublicIdReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetSystemId(
					/* [out] */ IPB_String** ppSystemIdReceiver) = 0;

			};

#else 	/* C style interface */

			typedef struct IPB_XMLDOMNotationVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_XMLDOMNotation* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_XMLDOMNotation* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_XMLDOMNotation* This);

				HRESULT(STDMETHODCALLTYPE* GetNodeName)(
					IPB_XMLDOMNotation* This,
					/* [out] */ IPB_String** ppNodeNameReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeValue)(
					IPB_XMLDOMNotation* This,
					/* [out] */ IPB_String** ppNodeValueReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeType)(
					IPB_XMLDOMNotation* This,
					/* [out] */ long* pNodeTypeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetParentNode)(
					IPB_XMLDOMNotation* This,
					/* [out] */ IPB_XMLDOMNode** ppParentNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetChildNodes)(
					IPB_XMLDOMNotation* This,
					/* [out] */ IPB_XMLDOMNodeList** ppChildNodesListReceiver);

				HRESULT(STDMETHODCALLTYPE* GetFirstChild)(
					IPB_XMLDOMNotation* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetLastChild)(
					IPB_XMLDOMNotation* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetNextSibling)(
					IPB_XMLDOMNotation* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetPreviousSibling)(
					IPB_XMLDOMNotation* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetAttributes)(
					IPB_XMLDOMNotation* This,
					/* [out] */ IPB_XMLDOMNamedNodeMap** ppAttrNamedNodeMapReceiver);

				HRESULT(STDMETHODCALLTYPE* GetOwnerDocument)(
					IPB_XMLDOMNotation* This,
					/* [out] */ IPB_XMLDOMDocument** ppOwnerDocumentReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNamespaceURI)(
					IPB_XMLDOMNotation* This,
					/* [out] */ IPB_String** ppNamespaceURIReceiver);

				HRESULT(STDMETHODCALLTYPE* GetPrefix)(
					IPB_XMLDOMNotation* This,
					/* [out] */ IPB_String** ppPrefixReceiver);

				HRESULT(STDMETHODCALLTYPE* GetLocalName)(
					IPB_XMLDOMNotation* This,
					/* [out] */ IPB_String** ppLocalNameReceiver);

				HRESULT(STDMETHODCALLTYPE* InsertBefore)(
					IPB_XMLDOMNotation* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeRefChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* ReplaceChild)(
					IPB_XMLDOMNotation* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* RemoveChild)(
					IPB_XMLDOMNotation* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* AppendChild)(
					IPB_XMLDOMNotation* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* HasChildNodes)(
					IPB_XMLDOMNotation* This,
					/* [out] */ BOOL* pBoolReceiver);

				HRESULT(STDMETHODCALLTYPE* CloneNode)(
					IPB_XMLDOMNotation* This,
					/* [in] */ BOOL bDeep,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMCloneNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* SetNodeName)(
					IPB_XMLDOMNotation* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeChild,
					/* [in] */ const IPB_String* pNodeName);

				HRESULT(STDMETHODCALLTYPE* SetNodeValue)(
					IPB_XMLDOMNotation* This,
					/* [in] */ const IPB_String* pNodeValue);

				HRESULT(STDMETHODCALLTYPE* SetPrefix)(
					IPB_XMLDOMNotation* This,
					/* [in] */ const IPB_String* pPrefix);

				HRESULT(STDMETHODCALLTYPE* Normalize)(
					IPB_XMLDOMNotation* This);

				HRESULT(STDMETHODCALLTYPE* IsSupported)(
					IPB_XMLDOMNotation* This,
					/* [in] */ const IPB_String* pFeature,
					/* [in] */ const IPB_String* pVersion,
					/* [out] */ BOOL* pBoolReceiver);

				ULONG(STDMETHODCALLTYPE* GetLastErrorCode)(
					IPB_XMLDOMNotation* This);

				ULONG(STDMETHODCALLTYPE* GetLastErrorString)(
					IPB_XMLDOMNotation* This,
					/* [out] */ IPB_String** ppErrorStringReceiver);

				HRESULT(STDMETHODCALLTYPE* GetUserDefinedData)(
					IPB_XMLDOMNotation* This,
					/* [out] */ void** ppVoidUserDefinedDataReceiver);

				HRESULT(STDMETHODCALLTYPE* SetUserDefinedData)(
					IPB_XMLDOMNotation* This,
					/* [in] */ void* pVoidUserDefinedData);

				HRESULT(STDMETHODCALLTYPE* GetPublicId)(
					IPB_XMLDOMNotation* This,
					/* [out] */ IPB_String** ppPublicIdReceiver);

				HRESULT(STDMETHODCALLTYPE* GetSystemId)(
					IPB_XMLDOMNotation* This,
					/* [out] */ IPB_String** ppSystemIdReceiver);

				END_INTERFACE
			} IPB_XMLDOMNotationVtbl;

			interface IPB_XMLDOMNotation
			{
				CONST_VTBL struct IPB_XMLDOMNotationVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_XMLDOMNotation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_XMLDOMNotation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_XMLDOMNotation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_XMLDOMNotation_GetNodeName(This,ppNodeNameReceiver)	\
    (This)->lpVtbl -> GetNodeName(This,ppNodeNameReceiver)

#define IPB_XMLDOMNotation_GetNodeValue(This,ppNodeValueReceiver)	\
    (This)->lpVtbl -> GetNodeValue(This,ppNodeValueReceiver)

#define IPB_XMLDOMNotation_GetNodeType(This,pNodeTypeReceiver)	\
    (This)->lpVtbl -> GetNodeType(This,pNodeTypeReceiver)

#define IPB_XMLDOMNotation_GetParentNode(This,ppParentNodeReceiver)	\
    (This)->lpVtbl -> GetParentNode(This,ppParentNodeReceiver)

#define IPB_XMLDOMNotation_GetChildNodes(This,ppChildNodesListReceiver)	\
    (This)->lpVtbl -> GetChildNodes(This,ppChildNodesListReceiver)

#define IPB_XMLDOMNotation_GetFirstChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetFirstChild(This,ppXMLDOMNode)

#define IPB_XMLDOMNotation_GetLastChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetLastChild(This,ppXMLDOMNode)

#define IPB_XMLDOMNotation_GetNextSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetNextSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMNotation_GetPreviousSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetPreviousSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMNotation_GetAttributes(This,ppAttrNamedNodeMapReceiver)	\
    (This)->lpVtbl -> GetAttributes(This,ppAttrNamedNodeMapReceiver)

#define IPB_XMLDOMNotation_GetOwnerDocument(This,ppOwnerDocumentReceiver)	\
    (This)->lpVtbl -> GetOwnerDocument(This,ppOwnerDocumentReceiver)

#define IPB_XMLDOMNotation_GetNamespaceURI(This,ppNamespaceURIReceiver)	\
    (This)->lpVtbl -> GetNamespaceURI(This,ppNamespaceURIReceiver)

#define IPB_XMLDOMNotation_GetPrefix(This,ppPrefixReceiver)	\
    (This)->lpVtbl -> GetPrefix(This,ppPrefixReceiver)

#define IPB_XMLDOMNotation_GetLocalName(This,ppLocalNameReceiver)	\
    (This)->lpVtbl -> GetLocalName(This,ppLocalNameReceiver)

#define IPB_XMLDOMNotation_InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMNotation_ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMNotation_RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMNotation_AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMNotation_HasChildNodes(This,pBoolReceiver)	\
    (This)->lpVtbl -> HasChildNodes(This,pBoolReceiver)

#define IPB_XMLDOMNotation_CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)	\
    (This)->lpVtbl -> CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)

#define IPB_XMLDOMNotation_SetNodeName(This,pXMLDOMNodeChild,pNodeName)	\
    (This)->lpVtbl -> SetNodeName(This,pXMLDOMNodeChild,pNodeName)

#define IPB_XMLDOMNotation_SetNodeValue(This,pNodeValue)	\
    (This)->lpVtbl -> SetNodeValue(This,pNodeValue)

#define IPB_XMLDOMNotation_SetPrefix(This,pPrefix)	\
    (This)->lpVtbl -> SetPrefix(This,pPrefix)

#define IPB_XMLDOMNotation_Normalize(This)	\
    (This)->lpVtbl -> Normalize(This)

#define IPB_XMLDOMNotation_IsSupported(This,pFeature,pVersion,pBoolReceiver)	\
    (This)->lpVtbl -> IsSupported(This,pFeature,pVersion,pBoolReceiver)

#define IPB_XMLDOMNotation_GetLastErrorCode(This)	\
    (This)->lpVtbl -> GetLastErrorCode(This)

#define IPB_XMLDOMNotation_GetLastErrorString(This,ppErrorStringReceiver)	\
    (This)->lpVtbl -> GetLastErrorString(This,ppErrorStringReceiver)

#define IPB_XMLDOMNotation_GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)	\
    (This)->lpVtbl -> GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)

#define IPB_XMLDOMNotation_SetUserDefinedData(This,pVoidUserDefinedData)	\
    (This)->lpVtbl -> SetUserDefinedData(This,pVoidUserDefinedData)


#define IPB_XMLDOMNotation_GetPublicId(This,ppPublicIdReceiver)	\
    (This)->lpVtbl -> GetPublicId(This,ppPublicIdReceiver)

#define IPB_XMLDOMNotation_GetSystemId(This,ppSystemIdReceiver)	\
    (This)->lpVtbl -> GetSystemId(This,ppSystemIdReceiver)

#endif /* COBJMACROS */


#endif 	/* C style interface */



			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNotation_GetPublicId_Proxy(
				IPB_XMLDOMNotation* This,
				/* [out] */ IPB_String** ppPublicIdReceiver);


			void __RPC_STUB IPB_XMLDOMNotation_GetPublicId_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMNotation_GetSystemId_Proxy(
				IPB_XMLDOMNotation* This,
				/* [out] */ IPB_String** ppSystemIdReceiver);


			void __RPC_STUB IPB_XMLDOMNotation_GetSystemId_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);



#endif 	/* __IPB_XMLDOMNotation_INTERFACE_DEFINED__ */


#ifndef __IPB_XMLDOMDocumentFragment_INTERFACE_DEFINED__
#define __IPB_XMLDOMDocumentFragment_INTERFACE_DEFINED__

			/* interface IPB_XMLDOMDocumentFragment */
			/* [unique][uuid][object][local] */


			EXTERN_C const IID IID_IPB_XMLDOMDocumentFragment;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("AC5B1A59-1179-11d6-95AB-00B0D024631C")
				IPB_XMLDOMDocumentFragment : public IPB_XMLDOMNode
			{
			public:
			};

#else 	/* C style interface */

			typedef struct IPB_XMLDOMDocumentFragmentVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_XMLDOMDocumentFragment* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_XMLDOMDocumentFragment* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_XMLDOMDocumentFragment* This);

				HRESULT(STDMETHODCALLTYPE* GetNodeName)(
					IPB_XMLDOMDocumentFragment* This,
					/* [out] */ IPB_String** ppNodeNameReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeValue)(
					IPB_XMLDOMDocumentFragment* This,
					/* [out] */ IPB_String** ppNodeValueReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeType)(
					IPB_XMLDOMDocumentFragment* This,
					/* [out] */ long* pNodeTypeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetParentNode)(
					IPB_XMLDOMDocumentFragment* This,
					/* [out] */ IPB_XMLDOMNode** ppParentNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetChildNodes)(
					IPB_XMLDOMDocumentFragment* This,
					/* [out] */ IPB_XMLDOMNodeList** ppChildNodesListReceiver);

				HRESULT(STDMETHODCALLTYPE* GetFirstChild)(
					IPB_XMLDOMDocumentFragment* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetLastChild)(
					IPB_XMLDOMDocumentFragment* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetNextSibling)(
					IPB_XMLDOMDocumentFragment* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetPreviousSibling)(
					IPB_XMLDOMDocumentFragment* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetAttributes)(
					IPB_XMLDOMDocumentFragment* This,
					/* [out] */ IPB_XMLDOMNamedNodeMap** ppAttrNamedNodeMapReceiver);

				HRESULT(STDMETHODCALLTYPE* GetOwnerDocument)(
					IPB_XMLDOMDocumentFragment* This,
					/* [out] */ IPB_XMLDOMDocument** ppOwnerDocumentReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNamespaceURI)(
					IPB_XMLDOMDocumentFragment* This,
					/* [out] */ IPB_String** ppNamespaceURIReceiver);

				HRESULT(STDMETHODCALLTYPE* GetPrefix)(
					IPB_XMLDOMDocumentFragment* This,
					/* [out] */ IPB_String** ppPrefixReceiver);

				HRESULT(STDMETHODCALLTYPE* GetLocalName)(
					IPB_XMLDOMDocumentFragment* This,
					/* [out] */ IPB_String** ppLocalNameReceiver);

				HRESULT(STDMETHODCALLTYPE* InsertBefore)(
					IPB_XMLDOMDocumentFragment* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeRefChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* ReplaceChild)(
					IPB_XMLDOMDocumentFragment* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* RemoveChild)(
					IPB_XMLDOMDocumentFragment* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* AppendChild)(
					IPB_XMLDOMDocumentFragment* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* HasChildNodes)(
					IPB_XMLDOMDocumentFragment* This,
					/* [out] */ BOOL* pBoolReceiver);

				HRESULT(STDMETHODCALLTYPE* CloneNode)(
					IPB_XMLDOMDocumentFragment* This,
					/* [in] */ BOOL bDeep,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMCloneNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* SetNodeName)(
					IPB_XMLDOMDocumentFragment* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeChild,
					/* [in] */ const IPB_String* pNodeName);

				HRESULT(STDMETHODCALLTYPE* SetNodeValue)(
					IPB_XMLDOMDocumentFragment* This,
					/* [in] */ const IPB_String* pNodeValue);

				HRESULT(STDMETHODCALLTYPE* SetPrefix)(
					IPB_XMLDOMDocumentFragment* This,
					/* [in] */ const IPB_String* pPrefix);

				HRESULT(STDMETHODCALLTYPE* Normalize)(
					IPB_XMLDOMDocumentFragment* This);

				HRESULT(STDMETHODCALLTYPE* IsSupported)(
					IPB_XMLDOMDocumentFragment* This,
					/* [in] */ const IPB_String* pFeature,
					/* [in] */ const IPB_String* pVersion,
					/* [out] */ BOOL* pBoolReceiver);

				ULONG(STDMETHODCALLTYPE* GetLastErrorCode)(
					IPB_XMLDOMDocumentFragment* This);

				ULONG(STDMETHODCALLTYPE* GetLastErrorString)(
					IPB_XMLDOMDocumentFragment* This,
					/* [out] */ IPB_String** ppErrorStringReceiver);

				HRESULT(STDMETHODCALLTYPE* GetUserDefinedData)(
					IPB_XMLDOMDocumentFragment* This,
					/* [out] */ void** ppVoidUserDefinedDataReceiver);

				HRESULT(STDMETHODCALLTYPE* SetUserDefinedData)(
					IPB_XMLDOMDocumentFragment* This,
					/* [in] */ void* pVoidUserDefinedData);

				END_INTERFACE
			} IPB_XMLDOMDocumentFragmentVtbl;

			interface IPB_XMLDOMDocumentFragment
			{
				CONST_VTBL struct IPB_XMLDOMDocumentFragmentVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_XMLDOMDocumentFragment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_XMLDOMDocumentFragment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_XMLDOMDocumentFragment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_XMLDOMDocumentFragment_GetNodeName(This,ppNodeNameReceiver)	\
    (This)->lpVtbl -> GetNodeName(This,ppNodeNameReceiver)

#define IPB_XMLDOMDocumentFragment_GetNodeValue(This,ppNodeValueReceiver)	\
    (This)->lpVtbl -> GetNodeValue(This,ppNodeValueReceiver)

#define IPB_XMLDOMDocumentFragment_GetNodeType(This,pNodeTypeReceiver)	\
    (This)->lpVtbl -> GetNodeType(This,pNodeTypeReceiver)

#define IPB_XMLDOMDocumentFragment_GetParentNode(This,ppParentNodeReceiver)	\
    (This)->lpVtbl -> GetParentNode(This,ppParentNodeReceiver)

#define IPB_XMLDOMDocumentFragment_GetChildNodes(This,ppChildNodesListReceiver)	\
    (This)->lpVtbl -> GetChildNodes(This,ppChildNodesListReceiver)

#define IPB_XMLDOMDocumentFragment_GetFirstChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetFirstChild(This,ppXMLDOMNode)

#define IPB_XMLDOMDocumentFragment_GetLastChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetLastChild(This,ppXMLDOMNode)

#define IPB_XMLDOMDocumentFragment_GetNextSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetNextSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMDocumentFragment_GetPreviousSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetPreviousSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMDocumentFragment_GetAttributes(This,ppAttrNamedNodeMapReceiver)	\
    (This)->lpVtbl -> GetAttributes(This,ppAttrNamedNodeMapReceiver)

#define IPB_XMLDOMDocumentFragment_GetOwnerDocument(This,ppOwnerDocumentReceiver)	\
    (This)->lpVtbl -> GetOwnerDocument(This,ppOwnerDocumentReceiver)

#define IPB_XMLDOMDocumentFragment_GetNamespaceURI(This,ppNamespaceURIReceiver)	\
    (This)->lpVtbl -> GetNamespaceURI(This,ppNamespaceURIReceiver)

#define IPB_XMLDOMDocumentFragment_GetPrefix(This,ppPrefixReceiver)	\
    (This)->lpVtbl -> GetPrefix(This,ppPrefixReceiver)

#define IPB_XMLDOMDocumentFragment_GetLocalName(This,ppLocalNameReceiver)	\
    (This)->lpVtbl -> GetLocalName(This,ppLocalNameReceiver)

#define IPB_XMLDOMDocumentFragment_InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMDocumentFragment_ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMDocumentFragment_RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMDocumentFragment_AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMDocumentFragment_HasChildNodes(This,pBoolReceiver)	\
    (This)->lpVtbl -> HasChildNodes(This,pBoolReceiver)

#define IPB_XMLDOMDocumentFragment_CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)	\
    (This)->lpVtbl -> CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)

#define IPB_XMLDOMDocumentFragment_SetNodeName(This,pXMLDOMNodeChild,pNodeName)	\
    (This)->lpVtbl -> SetNodeName(This,pXMLDOMNodeChild,pNodeName)

#define IPB_XMLDOMDocumentFragment_SetNodeValue(This,pNodeValue)	\
    (This)->lpVtbl -> SetNodeValue(This,pNodeValue)

#define IPB_XMLDOMDocumentFragment_SetPrefix(This,pPrefix)	\
    (This)->lpVtbl -> SetPrefix(This,pPrefix)

#define IPB_XMLDOMDocumentFragment_Normalize(This)	\
    (This)->lpVtbl -> Normalize(This)

#define IPB_XMLDOMDocumentFragment_IsSupported(This,pFeature,pVersion,pBoolReceiver)	\
    (This)->lpVtbl -> IsSupported(This,pFeature,pVersion,pBoolReceiver)

#define IPB_XMLDOMDocumentFragment_GetLastErrorCode(This)	\
    (This)->lpVtbl -> GetLastErrorCode(This)

#define IPB_XMLDOMDocumentFragment_GetLastErrorString(This,ppErrorStringReceiver)	\
    (This)->lpVtbl -> GetLastErrorString(This,ppErrorStringReceiver)

#define IPB_XMLDOMDocumentFragment_GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)	\
    (This)->lpVtbl -> GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)

#define IPB_XMLDOMDocumentFragment_SetUserDefinedData(This,pVoidUserDefinedData)	\
    (This)->lpVtbl -> SetUserDefinedData(This,pVoidUserDefinedData)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPB_XMLDOMDocumentFragment_INTERFACE_DEFINED__ */


#ifndef __IPB_XMLDOMImplementation_INTERFACE_DEFINED__
#define __IPB_XMLDOMImplementation_INTERFACE_DEFINED__

			/* interface IPB_XMLDOMImplementation */
			/* [unique][uuid][object][local] */


			EXTERN_C const IID IID_IPB_XMLDOMImplementation;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("31DA78C9-1494-11d6-95AB-00B0D024631C")
				IPB_XMLDOMImplementation : public IUnknown
			{
			public:
				virtual HRESULT STDMETHODCALLTYPE HasFeature(
					/* [in] */ const IPB_String * pFeature,
					/* [in] */ const IPB_String * pVersion,
					/* [out] */ BOOL * pBoolReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE CreateDocumentType(
					/* [in] */ const IPB_String* pQualifiedName,
					/* [in] */ const IPB_String* pPublicId,
					/* [in] */ const IPB_String* pSystemId,
					/* [out] */ IPB_XMLDOMDocumentType** ppXMLDOMDocumentTypeReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE CreateDocument(
					/* [in] */ const IPB_String* pNamespaceURI,
					/* [in] */ const IPB_String* pQualifiedName,
					/* [in] */ const IPB_XMLDOMDocumentType* pDocumentType,
					/* [out] */ IPB_XMLDOMDocument** ppXMLDOMDocumentReceiver) = 0;

				virtual ULONG STDMETHODCALLTYPE GetLastErrorCode(void) = 0;

				virtual ULONG STDMETHODCALLTYPE GetLastErrorString(
					/* [out] */ IPB_String** ppErrorStringReceiver) = 0;

			};

#else 	/* C style interface */

			typedef struct IPB_XMLDOMImplementationVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_XMLDOMImplementation* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_XMLDOMImplementation* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_XMLDOMImplementation* This);

				HRESULT(STDMETHODCALLTYPE* HasFeature)(
					IPB_XMLDOMImplementation* This,
					/* [in] */ const IPB_String* pFeature,
					/* [in] */ const IPB_String* pVersion,
					/* [out] */ BOOL* pBoolReceiver);

				HRESULT(STDMETHODCALLTYPE* CreateDocumentType)(
					IPB_XMLDOMImplementation* This,
					/* [in] */ const IPB_String* pQualifiedName,
					/* [in] */ const IPB_String* pPublicId,
					/* [in] */ const IPB_String* pSystemId,
					/* [out] */ IPB_XMLDOMDocumentType** ppXMLDOMDocumentTypeReceiver);

				HRESULT(STDMETHODCALLTYPE* CreateDocument)(
					IPB_XMLDOMImplementation* This,
					/* [in] */ const IPB_String* pNamespaceURI,
					/* [in] */ const IPB_String* pQualifiedName,
					/* [in] */ const IPB_XMLDOMDocumentType* pDocumentType,
					/* [out] */ IPB_XMLDOMDocument** ppXMLDOMDocumentReceiver);

				ULONG(STDMETHODCALLTYPE* GetLastErrorCode)(
					IPB_XMLDOMImplementation* This);

				ULONG(STDMETHODCALLTYPE* GetLastErrorString)(
					IPB_XMLDOMImplementation* This,
					/* [out] */ IPB_String** ppErrorStringReceiver);

				END_INTERFACE
			} IPB_XMLDOMImplementationVtbl;

			interface IPB_XMLDOMImplementation
			{
				CONST_VTBL struct IPB_XMLDOMImplementationVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_XMLDOMImplementation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_XMLDOMImplementation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_XMLDOMImplementation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_XMLDOMImplementation_HasFeature(This,pFeature,pVersion,pBoolReceiver)	\
    (This)->lpVtbl -> HasFeature(This,pFeature,pVersion,pBoolReceiver)

#define IPB_XMLDOMImplementation_CreateDocumentType(This,pQualifiedName,pPublicId,pSystemId,ppXMLDOMDocumentTypeReceiver)	\
    (This)->lpVtbl -> CreateDocumentType(This,pQualifiedName,pPublicId,pSystemId,ppXMLDOMDocumentTypeReceiver)

#define IPB_XMLDOMImplementation_CreateDocument(This,pNamespaceURI,pQualifiedName,pDocumentType,ppXMLDOMDocumentReceiver)	\
    (This)->lpVtbl -> CreateDocument(This,pNamespaceURI,pQualifiedName,pDocumentType,ppXMLDOMDocumentReceiver)

#define IPB_XMLDOMImplementation_GetLastErrorCode(This)	\
    (This)->lpVtbl -> GetLastErrorCode(This)

#define IPB_XMLDOMImplementation_GetLastErrorString(This,ppErrorStringReceiver)	\
    (This)->lpVtbl -> GetLastErrorString(This,ppErrorStringReceiver)

#endif /* COBJMACROS */


#endif 	/* C style interface */



			HRESULT STDMETHODCALLTYPE IPB_XMLDOMImplementation_HasFeature_Proxy(
				IPB_XMLDOMImplementation* This,
				/* [in] */ const IPB_String* pFeature,
				/* [in] */ const IPB_String* pVersion,
				/* [out] */ BOOL* pBoolReceiver);


			void __RPC_STUB IPB_XMLDOMImplementation_HasFeature_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMImplementation_CreateDocumentType_Proxy(
				IPB_XMLDOMImplementation* This,
				/* [in] */ const IPB_String* pQualifiedName,
				/* [in] */ const IPB_String* pPublicId,
				/* [in] */ const IPB_String* pSystemId,
				/* [out] */ IPB_XMLDOMDocumentType** ppXMLDOMDocumentTypeReceiver);


			void __RPC_STUB IPB_XMLDOMImplementation_CreateDocumentType_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMImplementation_CreateDocument_Proxy(
				IPB_XMLDOMImplementation* This,
				/* [in] */ const IPB_String* pNamespaceURI,
				/* [in] */ const IPB_String* pQualifiedName,
				/* [in] */ const IPB_XMLDOMDocumentType* pDocumentType,
				/* [out] */ IPB_XMLDOMDocument** ppXMLDOMDocumentReceiver);


			void __RPC_STUB IPB_XMLDOMImplementation_CreateDocument_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			ULONG STDMETHODCALLTYPE IPB_XMLDOMImplementation_GetLastErrorCode_Proxy(
				IPB_XMLDOMImplementation* This);


			void __RPC_STUB IPB_XMLDOMImplementation_GetLastErrorCode_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			ULONG STDMETHODCALLTYPE IPB_XMLDOMImplementation_GetLastErrorString_Proxy(
				IPB_XMLDOMImplementation* This,
				/* [out] */ IPB_String** ppErrorStringReceiver);


			void __RPC_STUB IPB_XMLDOMImplementation_GetLastErrorString_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);



#endif 	/* __IPB_XMLDOMImplementation_INTERFACE_DEFINED__ */


#ifndef __IPB_XMLDOMDocument_INTERFACE_DEFINED__
#define __IPB_XMLDOMDocument_INTERFACE_DEFINED__

			/* interface IPB_XMLDOMDocument */
			/* [unique][uuid][object][local] */


			EXTERN_C const IID IID_IPB_XMLDOMDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("4ACED1A6-C397-11d5-9598-00B0D024631C")
				IPB_XMLDOMDocument : public IPB_XMLDOMNode
			{
			public:
				virtual HRESULT STDMETHODCALLTYPE CreateDocument(
					/* [in] */ const IPB_String * pDocumentElementNamespaceURI,
					/* [in] */ const IPB_String * pDoumentElementQualifiedName,
					/* [in] */ const IPB_String * pDocumentTypeQualifiedName,
					/* [in] */ const IPB_String * pDocumentTypePublicId,
					/* [in] */ const IPB_String * pDocumentTypeSystemId) = 0;

				virtual HRESULT STDMETHODCALLTYPE CreateElement(
					/* [in] */ IPB_String* pElementName,
					/* [out] */ IPB_XMLDOMElement** ppXMLDOMElement) = 0;

				virtual HRESULT STDMETHODCALLTYPE CreateDocumentFragment(
					/* [out] */ IPB_XMLDOMDocumentFragment** ppXMLDOMDocumentFragmentReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE CreateTextNode(
					/* [in] */ IPB_String* pTextNodeData,
					/* [out] */ IPB_XMLDOMText** ppXMLDOMTextNew) = 0;

				virtual HRESULT STDMETHODCALLTYPE CreateComment(
					/* [in] */ const IPB_String* pCommentData,
					/* [out] */ IPB_XMLDOMComment** ppXMLDOMCommentReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE CreateCDATASection(
					/* [in] */ const IPB_String* pCDATASectionData,
					/* [out] */ IPB_XMLDOMCDATASection** ppXMLCDATASectionReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE CreateDocumentType(
					/* [in] */ const IPB_String* pName,
					/* [out] */ IPB_XMLDOMDocumentType** ppXMLDOMDocumentTypeReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE CreateProcessingInstruction(
					/* [in] */ const IPB_String* pTarget,
					/* [in] */ const IPB_String* pData,
					/* [out] */ IPB_XMLDOMProcessingInstruction** ppXMLDOMProcessingInstructionReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE CreateAttribute(
					/* [in] */ const IPB_String* pName,
					/* [out] */ IPB_XMLDOMAttr** ppXMLDOMAttributeReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE CreateEntityReference(
					/* [in] */ const IPB_String* pNameOfEntityToReference,
					/* [out] */ IPB_XMLDOMEntityReference** ppXMLDOMEntityReferenceReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE CreateXMLDecl(
					/* [in] */ const IPB_String* pVersion,
					/* [in] */ const IPB_String* pEncoding,
					/* [in] */ const IPB_String* pStandAlone,
					/* [out] */ IPB_XMLDOMXMLDecl** ppXMLDOMXMLDeclReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetText(
					/* [in] */ IPB_String* pText) = 0;

				virtual HRESULT STDMETHODCALLTYPE SaveDocument(
					/* [in] */ IPB_String* pFileName,
					/* [in] */ IPB_String* pEncoding,
					/* [in] */ BOOL bIncludeWhitespace) = 0;

				virtual HRESULT STDMETHODCALLTYPE SaveDocumentIntoString(
					/* [in] */ BOOL bIncludeWhitespace,
					/* [in] */ IPB_String* pEncoding,
					/* [out] */ IPB_String** pDocumentAsStringReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetDocumentType(
					/* [out] */ IPB_XMLDOMDocumentType** ppXMLDOMDocumentTypeReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetImplementation(
					/* [out] */ IPB_XMLDOMImplementation** ppXMLDOMImplementationReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetDocumentElement(
					/* [out] */ IPB_XMLDOMElement** ppXMLDOMDocumentElement) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetElementsByTagName(
					/* [in] */ const IPB_String* pTagName,
					/* [out] */ IPB_XMLDOMNodeList** ppElementsListReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE ImportNode(
					/* [in] */ const IPB_XMLDOMNode* pImportedNode,
					/* [in] */ const BOOL bDeep,
					/* [out] */ IPB_XMLDOMNode** ppImportedNodeReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE CreateElementNS(
					/* [in] */ const IPB_String* pNamespaceURI,
					/* [in] */ const IPB_String* pQualifiedName,
					/* [out] */ IPB_XMLDOMElement** ppXMLDOMElementReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE CreateAttributeNS(
					/* [in] */ const IPB_String* pNamespaceURI,
					/* [in] */ const IPB_String* pQualifiedName,
					/* [out] */ IPB_XMLDOMAttr** ppXMLDOMAttributeReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetElementsByTagNameNS(
					/* [in] */ const IPB_String* pNamespaceURI,
					/* [in] */ const IPB_String* pLocalName,
					/* [out] */ IPB_XMLDOMNodeList** ppElementsListReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetElementById(
					/* [in] */ const IPB_String* pElementId,
					/* [out] */ IPB_XMLDOMElement** ppXMLDOMElementReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE LoadDocument(
					/* [in] */ IPB_String* pDocumentName) = 0;

				virtual HRESULT STDMETHODCALLTYPE LoadDocumentFromString(
					/* [in] */ const IPB_String* pDocumentAsString) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetDOMParserOptions(
					/* [out] */ ULONG* pulDOMParserOptionsReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetDOMParserOptions(
					/* [in] */ const ULONG ulDOMParserOptions) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetParseCallBackHandler(
					/* [in] */ IPB_XMLParseCallBack* pParseCallBack,
					/* [in] */ const ULONG ulParseErrorOptions) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetParseErrors(
					/* [out] */ IPB_List** ppErrors) = 0;

			};

#else 	/* C style interface */

			typedef struct IPB_XMLDOMDocumentVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_XMLDOMDocument* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_XMLDOMDocument* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_XMLDOMDocument* This);

				HRESULT(STDMETHODCALLTYPE* GetNodeName)(
					IPB_XMLDOMDocument* This,
					/* [out] */ IPB_String** ppNodeNameReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeValue)(
					IPB_XMLDOMDocument* This,
					/* [out] */ IPB_String** ppNodeValueReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNodeType)(
					IPB_XMLDOMDocument* This,
					/* [out] */ long* pNodeTypeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetParentNode)(
					IPB_XMLDOMDocument* This,
					/* [out] */ IPB_XMLDOMNode** ppParentNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetChildNodes)(
					IPB_XMLDOMDocument* This,
					/* [out] */ IPB_XMLDOMNodeList** ppChildNodesListReceiver);

				HRESULT(STDMETHODCALLTYPE* GetFirstChild)(
					IPB_XMLDOMDocument* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetLastChild)(
					IPB_XMLDOMDocument* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetNextSibling)(
					IPB_XMLDOMDocument* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetPreviousSibling)(
					IPB_XMLDOMDocument* This,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNode);

				HRESULT(STDMETHODCALLTYPE* GetAttributes)(
					IPB_XMLDOMDocument* This,
					/* [out] */ IPB_XMLDOMNamedNodeMap** ppAttrNamedNodeMapReceiver);

				HRESULT(STDMETHODCALLTYPE* GetOwnerDocument)(
					IPB_XMLDOMDocument* This,
					/* [out] */ IPB_XMLDOMDocument** ppOwnerDocumentReceiver);

				HRESULT(STDMETHODCALLTYPE* GetNamespaceURI)(
					IPB_XMLDOMDocument* This,
					/* [out] */ IPB_String** ppNamespaceURIReceiver);

				HRESULT(STDMETHODCALLTYPE* GetPrefix)(
					IPB_XMLDOMDocument* This,
					/* [out] */ IPB_String** ppPrefixReceiver);

				HRESULT(STDMETHODCALLTYPE* GetLocalName)(
					IPB_XMLDOMDocument* This,
					/* [out] */ IPB_String** ppLocalNameReceiver);

				HRESULT(STDMETHODCALLTYPE* InsertBefore)(
					IPB_XMLDOMDocument* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeRefChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* ReplaceChild)(
					IPB_XMLDOMDocument* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* RemoveChild)(
					IPB_XMLDOMDocument* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeOldChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeOldChildReceiver);

				HRESULT(STDMETHODCALLTYPE* AppendChild)(
					IPB_XMLDOMDocument* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeNewChild,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeNewChildReceiver);

				HRESULT(STDMETHODCALLTYPE* HasChildNodes)(
					IPB_XMLDOMDocument* This,
					/* [out] */ BOOL* pBoolReceiver);

				HRESULT(STDMETHODCALLTYPE* CloneNode)(
					IPB_XMLDOMDocument* This,
					/* [in] */ BOOL bDeep,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMCloneNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* SetNodeName)(
					IPB_XMLDOMDocument* This,
					/* [in] */ const IPB_XMLDOMNode* pXMLDOMNodeChild,
					/* [in] */ const IPB_String* pNodeName);

				HRESULT(STDMETHODCALLTYPE* SetNodeValue)(
					IPB_XMLDOMDocument* This,
					/* [in] */ const IPB_String* pNodeValue);

				HRESULT(STDMETHODCALLTYPE* SetPrefix)(
					IPB_XMLDOMDocument* This,
					/* [in] */ const IPB_String* pPrefix);

				HRESULT(STDMETHODCALLTYPE* Normalize)(
					IPB_XMLDOMDocument* This);

				HRESULT(STDMETHODCALLTYPE* IsSupported)(
					IPB_XMLDOMDocument* This,
					/* [in] */ const IPB_String* pFeature,
					/* [in] */ const IPB_String* pVersion,
					/* [out] */ BOOL* pBoolReceiver);

				ULONG(STDMETHODCALLTYPE* GetLastErrorCode)(
					IPB_XMLDOMDocument* This);

				ULONG(STDMETHODCALLTYPE* GetLastErrorString)(
					IPB_XMLDOMDocument* This,
					/* [out] */ IPB_String** ppErrorStringReceiver);

				HRESULT(STDMETHODCALLTYPE* GetUserDefinedData)(
					IPB_XMLDOMDocument* This,
					/* [out] */ void** ppVoidUserDefinedDataReceiver);

				HRESULT(STDMETHODCALLTYPE* SetUserDefinedData)(
					IPB_XMLDOMDocument* This,
					/* [in] */ void* pVoidUserDefinedData);

				HRESULT(STDMETHODCALLTYPE* CreateDocument)(
					IPB_XMLDOMDocument* This,
					/* [in] */ const IPB_String* pDocumentElementNamespaceURI,
					/* [in] */ const IPB_String* pDoumentElementQualifiedName,
					/* [in] */ const IPB_String* pDocumentTypeQualifiedName,
					/* [in] */ const IPB_String* pDocumentTypePublicId,
					/* [in] */ const IPB_String* pDocumentTypeSystemId);

				HRESULT(STDMETHODCALLTYPE* CreateElement)(
					IPB_XMLDOMDocument* This,
					/* [in] */ IPB_String* pElementName,
					/* [out] */ IPB_XMLDOMElement** ppXMLDOMElement);

				HRESULT(STDMETHODCALLTYPE* CreateDocumentFragment)(
					IPB_XMLDOMDocument* This,
					/* [out] */ IPB_XMLDOMDocumentFragment** ppXMLDOMDocumentFragmentReceiver);

				HRESULT(STDMETHODCALLTYPE* CreateTextNode)(
					IPB_XMLDOMDocument* This,
					/* [in] */ IPB_String* pTextNodeData,
					/* [out] */ IPB_XMLDOMText** ppXMLDOMTextNew);

				HRESULT(STDMETHODCALLTYPE* CreateComment)(
					IPB_XMLDOMDocument* This,
					/* [in] */ const IPB_String* pCommentData,
					/* [out] */ IPB_XMLDOMComment** ppXMLDOMCommentReceiver);

				HRESULT(STDMETHODCALLTYPE* CreateCDATASection)(
					IPB_XMLDOMDocument* This,
					/* [in] */ const IPB_String* pCDATASectionData,
					/* [out] */ IPB_XMLDOMCDATASection** ppXMLCDATASectionReceiver);

				HRESULT(STDMETHODCALLTYPE* CreateDocumentType)(
					IPB_XMLDOMDocument* This,
					/* [in] */ const IPB_String* pName,
					/* [out] */ IPB_XMLDOMDocumentType** ppXMLDOMDocumentTypeReceiver);

				HRESULT(STDMETHODCALLTYPE* CreateProcessingInstruction)(
					IPB_XMLDOMDocument* This,
					/* [in] */ const IPB_String* pTarget,
					/* [in] */ const IPB_String* pData,
					/* [out] */ IPB_XMLDOMProcessingInstruction** ppXMLDOMProcessingInstructionReceiver);

				HRESULT(STDMETHODCALLTYPE* CreateAttribute)(
					IPB_XMLDOMDocument* This,
					/* [in] */ const IPB_String* pName,
					/* [out] */ IPB_XMLDOMAttr** ppXMLDOMAttributeReceiver);

				HRESULT(STDMETHODCALLTYPE* CreateEntityReference)(
					IPB_XMLDOMDocument* This,
					/* [in] */ const IPB_String* pNameOfEntityToReference,
					/* [out] */ IPB_XMLDOMEntityReference** ppXMLDOMEntityReferenceReceiver);

				HRESULT(STDMETHODCALLTYPE* CreateXMLDecl)(
					IPB_XMLDOMDocument* This,
					/* [in] */ const IPB_String* pVersion,
					/* [in] */ const IPB_String* pEncoding,
					/* [in] */ const IPB_String* pStandAlone,
					/* [out] */ IPB_XMLDOMXMLDecl** ppXMLDOMXMLDeclReceiver);

				HRESULT(STDMETHODCALLTYPE* SetText)(
					IPB_XMLDOMDocument* This,
					/* [in] */ IPB_String* pText);

				HRESULT(STDMETHODCALLTYPE* SaveDocument)(
					IPB_XMLDOMDocument* This,
					/* [in] */ IPB_String* pFileName,
					/* [in] */ IPB_String* pEncoding,
					/* [in] */ BOOL bIncludeWhitespace);

				HRESULT(STDMETHODCALLTYPE* SaveDocumentIntoString)(
					IPB_XMLDOMDocument* This,
					/* [in] */ BOOL bIncludeWhitespace,
					/* [in] */ IPB_String* pEncoding,
					/* [out] */ IPB_String** pDocumentAsStringReceiver);

				HRESULT(STDMETHODCALLTYPE* GetDocumentType)(
					IPB_XMLDOMDocument* This,
					/* [out] */ IPB_XMLDOMDocumentType** ppXMLDOMDocumentTypeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetImplementation)(
					IPB_XMLDOMDocument* This,
					/* [out] */ IPB_XMLDOMImplementation** ppXMLDOMImplementationReceiver);

				HRESULT(STDMETHODCALLTYPE* GetDocumentElement)(
					IPB_XMLDOMDocument* This,
					/* [out] */ IPB_XMLDOMElement** ppXMLDOMDocumentElement);

				HRESULT(STDMETHODCALLTYPE* GetElementsByTagName)(
					IPB_XMLDOMDocument* This,
					/* [in] */ const IPB_String* pTagName,
					/* [out] */ IPB_XMLDOMNodeList** ppElementsListReceiver);

				HRESULT(STDMETHODCALLTYPE* ImportNode)(
					IPB_XMLDOMDocument* This,
					/* [in] */ const IPB_XMLDOMNode* pImportedNode,
					/* [in] */ const BOOL bDeep,
					/* [out] */ IPB_XMLDOMNode** ppImportedNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* CreateElementNS)(
					IPB_XMLDOMDocument* This,
					/* [in] */ const IPB_String* pNamespaceURI,
					/* [in] */ const IPB_String* pQualifiedName,
					/* [out] */ IPB_XMLDOMElement** ppXMLDOMElementReceiver);

				HRESULT(STDMETHODCALLTYPE* CreateAttributeNS)(
					IPB_XMLDOMDocument* This,
					/* [in] */ const IPB_String* pNamespaceURI,
					/* [in] */ const IPB_String* pQualifiedName,
					/* [out] */ IPB_XMLDOMAttr** ppXMLDOMAttributeReceiver);

				HRESULT(STDMETHODCALLTYPE* GetElementsByTagNameNS)(
					IPB_XMLDOMDocument* This,
					/* [in] */ const IPB_String* pNamespaceURI,
					/* [in] */ const IPB_String* pLocalName,
					/* [out] */ IPB_XMLDOMNodeList** ppElementsListReceiver);

				HRESULT(STDMETHODCALLTYPE* GetElementById)(
					IPB_XMLDOMDocument* This,
					/* [in] */ const IPB_String* pElementId,
					/* [out] */ IPB_XMLDOMElement** ppXMLDOMElementReceiver);

				HRESULT(STDMETHODCALLTYPE* LoadDocument)(
					IPB_XMLDOMDocument* This,
					/* [in] */ IPB_String* pDocumentName);

				HRESULT(STDMETHODCALLTYPE* LoadDocumentFromString)(
					IPB_XMLDOMDocument* This,
					/* [in] */ const IPB_String* pDocumentAsString);

				HRESULT(STDMETHODCALLTYPE* GetDOMParserOptions)(
					IPB_XMLDOMDocument* This,
					/* [out] */ ULONG* pulDOMParserOptionsReceiver);

				HRESULT(STDMETHODCALLTYPE* SetDOMParserOptions)(
					IPB_XMLDOMDocument* This,
					/* [in] */ const ULONG ulDOMParserOptions);

				HRESULT(STDMETHODCALLTYPE* SetParseCallBackHandler)(
					IPB_XMLDOMDocument* This,
					/* [in] */ IPB_XMLParseCallBack* pParseCallBack,
					/* [in] */ const ULONG ulParseErrorOptions);

				HRESULT(STDMETHODCALLTYPE* GetParseErrors)(
					IPB_XMLDOMDocument* This,
					/* [out] */ IPB_List** ppErrors);

				END_INTERFACE
			} IPB_XMLDOMDocumentVtbl;

			interface IPB_XMLDOMDocument
			{
				CONST_VTBL struct IPB_XMLDOMDocumentVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_XMLDOMDocument_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_XMLDOMDocument_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_XMLDOMDocument_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_XMLDOMDocument_GetNodeName(This,ppNodeNameReceiver)	\
    (This)->lpVtbl -> GetNodeName(This,ppNodeNameReceiver)

#define IPB_XMLDOMDocument_GetNodeValue(This,ppNodeValueReceiver)	\
    (This)->lpVtbl -> GetNodeValue(This,ppNodeValueReceiver)

#define IPB_XMLDOMDocument_GetNodeType(This,pNodeTypeReceiver)	\
    (This)->lpVtbl -> GetNodeType(This,pNodeTypeReceiver)

#define IPB_XMLDOMDocument_GetParentNode(This,ppParentNodeReceiver)	\
    (This)->lpVtbl -> GetParentNode(This,ppParentNodeReceiver)

#define IPB_XMLDOMDocument_GetChildNodes(This,ppChildNodesListReceiver)	\
    (This)->lpVtbl -> GetChildNodes(This,ppChildNodesListReceiver)

#define IPB_XMLDOMDocument_GetFirstChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetFirstChild(This,ppXMLDOMNode)

#define IPB_XMLDOMDocument_GetLastChild(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetLastChild(This,ppXMLDOMNode)

#define IPB_XMLDOMDocument_GetNextSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetNextSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMDocument_GetPreviousSibling(This,ppXMLDOMNode)	\
    (This)->lpVtbl -> GetPreviousSibling(This,ppXMLDOMNode)

#define IPB_XMLDOMDocument_GetAttributes(This,ppAttrNamedNodeMapReceiver)	\
    (This)->lpVtbl -> GetAttributes(This,ppAttrNamedNodeMapReceiver)

#define IPB_XMLDOMDocument_GetOwnerDocument(This,ppOwnerDocumentReceiver)	\
    (This)->lpVtbl -> GetOwnerDocument(This,ppOwnerDocumentReceiver)

#define IPB_XMLDOMDocument_GetNamespaceURI(This,ppNamespaceURIReceiver)	\
    (This)->lpVtbl -> GetNamespaceURI(This,ppNamespaceURIReceiver)

#define IPB_XMLDOMDocument_GetPrefix(This,ppPrefixReceiver)	\
    (This)->lpVtbl -> GetPrefix(This,ppPrefixReceiver)

#define IPB_XMLDOMDocument_GetLocalName(This,ppLocalNameReceiver)	\
    (This)->lpVtbl -> GetLocalName(This,ppLocalNameReceiver)

#define IPB_XMLDOMDocument_InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> InsertBefore(This,pXMLDOMNodeNewChild,pXMLDOMNodeRefChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMDocument_ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> ReplaceChild(This,pXMLDOMNodeNewChild,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMDocument_RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)	\
    (This)->lpVtbl -> RemoveChild(This,pXMLDOMNodeOldChild,ppXMLDOMNodeOldChildReceiver)

#define IPB_XMLDOMDocument_AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)	\
    (This)->lpVtbl -> AppendChild(This,pXMLDOMNodeNewChild,ppXMLDOMNodeNewChildReceiver)

#define IPB_XMLDOMDocument_HasChildNodes(This,pBoolReceiver)	\
    (This)->lpVtbl -> HasChildNodes(This,pBoolReceiver)

#define IPB_XMLDOMDocument_CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)	\
    (This)->lpVtbl -> CloneNode(This,bDeep,ppXMLDOMCloneNodeReceiver)

#define IPB_XMLDOMDocument_SetNodeName(This,pXMLDOMNodeChild,pNodeName)	\
    (This)->lpVtbl -> SetNodeName(This,pXMLDOMNodeChild,pNodeName)

#define IPB_XMLDOMDocument_SetNodeValue(This,pNodeValue)	\
    (This)->lpVtbl -> SetNodeValue(This,pNodeValue)

#define IPB_XMLDOMDocument_SetPrefix(This,pPrefix)	\
    (This)->lpVtbl -> SetPrefix(This,pPrefix)

#define IPB_XMLDOMDocument_Normalize(This)	\
    (This)->lpVtbl -> Normalize(This)

#define IPB_XMLDOMDocument_IsSupported(This,pFeature,pVersion,pBoolReceiver)	\
    (This)->lpVtbl -> IsSupported(This,pFeature,pVersion,pBoolReceiver)

#define IPB_XMLDOMDocument_GetLastErrorCode(This)	\
    (This)->lpVtbl -> GetLastErrorCode(This)

#define IPB_XMLDOMDocument_GetLastErrorString(This,ppErrorStringReceiver)	\
    (This)->lpVtbl -> GetLastErrorString(This,ppErrorStringReceiver)

#define IPB_XMLDOMDocument_GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)	\
    (This)->lpVtbl -> GetUserDefinedData(This,ppVoidUserDefinedDataReceiver)

#define IPB_XMLDOMDocument_SetUserDefinedData(This,pVoidUserDefinedData)	\
    (This)->lpVtbl -> SetUserDefinedData(This,pVoidUserDefinedData)


#define IPB_XMLDOMDocument_CreateDocument(This,pDocumentElementNamespaceURI,pDoumentElementQualifiedName,pDocumentTypeQualifiedName,pDocumentTypePublicId,pDocumentTypeSystemId)	\
    (This)->lpVtbl -> CreateDocument(This,pDocumentElementNamespaceURI,pDoumentElementQualifiedName,pDocumentTypeQualifiedName,pDocumentTypePublicId,pDocumentTypeSystemId)

#define IPB_XMLDOMDocument_CreateElement(This,pElementName,ppXMLDOMElement)	\
    (This)->lpVtbl -> CreateElement(This,pElementName,ppXMLDOMElement)

#define IPB_XMLDOMDocument_CreateDocumentFragment(This,ppXMLDOMDocumentFragmentReceiver)	\
    (This)->lpVtbl -> CreateDocumentFragment(This,ppXMLDOMDocumentFragmentReceiver)

#define IPB_XMLDOMDocument_CreateTextNode(This,pTextNodeData,ppXMLDOMTextNew)	\
    (This)->lpVtbl -> CreateTextNode(This,pTextNodeData,ppXMLDOMTextNew)

#define IPB_XMLDOMDocument_CreateComment(This,pCommentData,ppXMLDOMCommentReceiver)	\
    (This)->lpVtbl -> CreateComment(This,pCommentData,ppXMLDOMCommentReceiver)

#define IPB_XMLDOMDocument_CreateCDATASection(This,pCDATASectionData,ppXMLCDATASectionReceiver)	\
    (This)->lpVtbl -> CreateCDATASection(This,pCDATASectionData,ppXMLCDATASectionReceiver)

#define IPB_XMLDOMDocument_CreateDocumentType(This,pName,ppXMLDOMDocumentTypeReceiver)	\
    (This)->lpVtbl -> CreateDocumentType(This,pName,ppXMLDOMDocumentTypeReceiver)

#define IPB_XMLDOMDocument_CreateProcessingInstruction(This,pTarget,pData,ppXMLDOMProcessingInstructionReceiver)	\
    (This)->lpVtbl -> CreateProcessingInstruction(This,pTarget,pData,ppXMLDOMProcessingInstructionReceiver)

#define IPB_XMLDOMDocument_CreateAttribute(This,pName,ppXMLDOMAttributeReceiver)	\
    (This)->lpVtbl -> CreateAttribute(This,pName,ppXMLDOMAttributeReceiver)

#define IPB_XMLDOMDocument_CreateEntityReference(This,pNameOfEntityToReference,ppXMLDOMEntityReferenceReceiver)	\
    (This)->lpVtbl -> CreateEntityReference(This,pNameOfEntityToReference,ppXMLDOMEntityReferenceReceiver)

#define IPB_XMLDOMDocument_CreateXMLDecl(This,pVersion,pEncoding,pStandAlone,ppXMLDOMXMLDeclReceiver)	\
    (This)->lpVtbl -> CreateXMLDecl(This,pVersion,pEncoding,pStandAlone,ppXMLDOMXMLDeclReceiver)

#define IPB_XMLDOMDocument_SetText(This,pText)	\
    (This)->lpVtbl -> SetText(This,pText)

#define IPB_XMLDOMDocument_SaveDocument(This,pFileName,pEncoding,bIncludeWhitespace)	\
    (This)->lpVtbl -> SaveDocument(This,pFileName,pEncoding,bIncludeWhitespace)

#define IPB_XMLDOMDocument_SaveDocumentIntoString(This,bIncludeWhitespace,pEncoding,pDocumentAsStringReceiver)	\
    (This)->lpVtbl -> SaveDocumentIntoString(This,bIncludeWhitespace,pEncoding,pDocumentAsStringReceiver)

#define IPB_XMLDOMDocument_GetDocumentType(This,ppXMLDOMDocumentTypeReceiver)	\
    (This)->lpVtbl -> GetDocumentType(This,ppXMLDOMDocumentTypeReceiver)

#define IPB_XMLDOMDocument_GetImplementation(This,ppXMLDOMImplementationReceiver)	\
    (This)->lpVtbl -> GetImplementation(This,ppXMLDOMImplementationReceiver)

#define IPB_XMLDOMDocument_GetDocumentElement(This,ppXMLDOMDocumentElement)	\
    (This)->lpVtbl -> GetDocumentElement(This,ppXMLDOMDocumentElement)

#define IPB_XMLDOMDocument_GetElementsByTagName(This,pTagName,ppElementsListReceiver)	\
    (This)->lpVtbl -> GetElementsByTagName(This,pTagName,ppElementsListReceiver)

#define IPB_XMLDOMDocument_ImportNode(This,pImportedNode,bDeep,ppImportedNodeReceiver)	\
    (This)->lpVtbl -> ImportNode(This,pImportedNode,bDeep,ppImportedNodeReceiver)

#define IPB_XMLDOMDocument_CreateElementNS(This,pNamespaceURI,pQualifiedName,ppXMLDOMElementReceiver)	\
    (This)->lpVtbl -> CreateElementNS(This,pNamespaceURI,pQualifiedName,ppXMLDOMElementReceiver)

#define IPB_XMLDOMDocument_CreateAttributeNS(This,pNamespaceURI,pQualifiedName,ppXMLDOMAttributeReceiver)	\
    (This)->lpVtbl -> CreateAttributeNS(This,pNamespaceURI,pQualifiedName,ppXMLDOMAttributeReceiver)

#define IPB_XMLDOMDocument_GetElementsByTagNameNS(This,pNamespaceURI,pLocalName,ppElementsListReceiver)	\
    (This)->lpVtbl -> GetElementsByTagNameNS(This,pNamespaceURI,pLocalName,ppElementsListReceiver)

#define IPB_XMLDOMDocument_GetElementById(This,pElementId,ppXMLDOMElementReceiver)	\
    (This)->lpVtbl -> GetElementById(This,pElementId,ppXMLDOMElementReceiver)

#define IPB_XMLDOMDocument_LoadDocument(This,pDocumentName)	\
    (This)->lpVtbl -> LoadDocument(This,pDocumentName)

#define IPB_XMLDOMDocument_LoadDocumentFromString(This,pDocumentAsString)	\
    (This)->lpVtbl -> LoadDocumentFromString(This,pDocumentAsString)

#define IPB_XMLDOMDocument_GetDOMParserOptions(This,pulDOMParserOptionsReceiver)	\
    (This)->lpVtbl -> GetDOMParserOptions(This,pulDOMParserOptionsReceiver)

#define IPB_XMLDOMDocument_SetDOMParserOptions(This,ulDOMParserOptions)	\
    (This)->lpVtbl -> SetDOMParserOptions(This,ulDOMParserOptions)

#define IPB_XMLDOMDocument_SetParseCallBackHandler(This,pParseCallBack,ulParseErrorOptions)	\
    (This)->lpVtbl -> SetParseCallBackHandler(This,pParseCallBack,ulParseErrorOptions)

#define IPB_XMLDOMDocument_GetParseErrors(This,ppErrors)	\
    (This)->lpVtbl -> GetParseErrors(This,ppErrors)

#endif /* COBJMACROS */


#endif 	/* C style interface */



			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_CreateDocument_Proxy(
				IPB_XMLDOMDocument* This,
				/* [in] */ const IPB_String* pDocumentElementNamespaceURI,
				/* [in] */ const IPB_String* pDoumentElementQualifiedName,
				/* [in] */ const IPB_String* pDocumentTypeQualifiedName,
				/* [in] */ const IPB_String* pDocumentTypePublicId,
				/* [in] */ const IPB_String* pDocumentTypeSystemId);


			void __RPC_STUB IPB_XMLDOMDocument_CreateDocument_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_CreateElement_Proxy(
				IPB_XMLDOMDocument* This,
				/* [in] */ IPB_String* pElementName,
				/* [out] */ IPB_XMLDOMElement** ppXMLDOMElement);


			void __RPC_STUB IPB_XMLDOMDocument_CreateElement_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_CreateDocumentFragment_Proxy(
				IPB_XMLDOMDocument* This,
				/* [out] */ IPB_XMLDOMDocumentFragment** ppXMLDOMDocumentFragmentReceiver);


			void __RPC_STUB IPB_XMLDOMDocument_CreateDocumentFragment_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_CreateTextNode_Proxy(
				IPB_XMLDOMDocument* This,
				/* [in] */ IPB_String* pTextNodeData,
				/* [out] */ IPB_XMLDOMText** ppXMLDOMTextNew);


			void __RPC_STUB IPB_XMLDOMDocument_CreateTextNode_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_CreateComment_Proxy(
				IPB_XMLDOMDocument* This,
				/* [in] */ const IPB_String* pCommentData,
				/* [out] */ IPB_XMLDOMComment** ppXMLDOMCommentReceiver);


			void __RPC_STUB IPB_XMLDOMDocument_CreateComment_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_CreateCDATASection_Proxy(
				IPB_XMLDOMDocument* This,
				/* [in] */ const IPB_String* pCDATASectionData,
				/* [out] */ IPB_XMLDOMCDATASection** ppXMLCDATASectionReceiver);


			void __RPC_STUB IPB_XMLDOMDocument_CreateCDATASection_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_CreateDocumentType_Proxy(
				IPB_XMLDOMDocument* This,
				/* [in] */ const IPB_String* pName,
				/* [out] */ IPB_XMLDOMDocumentType** ppXMLDOMDocumentTypeReceiver);


			void __RPC_STUB IPB_XMLDOMDocument_CreateDocumentType_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_CreateProcessingInstruction_Proxy(
				IPB_XMLDOMDocument* This,
				/* [in] */ const IPB_String* pTarget,
				/* [in] */ const IPB_String* pData,
				/* [out] */ IPB_XMLDOMProcessingInstruction** ppXMLDOMProcessingInstructionReceiver);


			void __RPC_STUB IPB_XMLDOMDocument_CreateProcessingInstruction_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_CreateAttribute_Proxy(
				IPB_XMLDOMDocument* This,
				/* [in] */ const IPB_String* pName,
				/* [out] */ IPB_XMLDOMAttr** ppXMLDOMAttributeReceiver);


			void __RPC_STUB IPB_XMLDOMDocument_CreateAttribute_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_CreateEntityReference_Proxy(
				IPB_XMLDOMDocument* This,
				/* [in] */ const IPB_String* pNameOfEntityToReference,
				/* [out] */ IPB_XMLDOMEntityReference** ppXMLDOMEntityReferenceReceiver);


			void __RPC_STUB IPB_XMLDOMDocument_CreateEntityReference_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_CreateXMLDecl_Proxy(
				IPB_XMLDOMDocument* This,
				/* [in] */ const IPB_String* pVersion,
				/* [in] */ const IPB_String* pEncoding,
				/* [in] */ const IPB_String* pStandAlone,
				/* [out] */ IPB_XMLDOMXMLDecl** ppXMLDOMXMLDeclReceiver);


			void __RPC_STUB IPB_XMLDOMDocument_CreateXMLDecl_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_SetText_Proxy(
				IPB_XMLDOMDocument* This,
				/* [in] */ IPB_String* pText);


			void __RPC_STUB IPB_XMLDOMDocument_SetText_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_SaveDocument_Proxy(
				IPB_XMLDOMDocument* This,
				/* [in] */ IPB_String* pFileName,
				/* [in] */ IPB_String* pEncoding,
				/* [in] */ BOOL bIncludeWhitespace);


			void __RPC_STUB IPB_XMLDOMDocument_SaveDocument_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_SaveDocumentIntoString_Proxy(
				IPB_XMLDOMDocument* This,
				/* [in] */ BOOL bIncludeWhitespace,
				/* [in] */ IPB_String* pEncoding,
				/* [out] */ IPB_String** pDocumentAsStringReceiver);


			void __RPC_STUB IPB_XMLDOMDocument_SaveDocumentIntoString_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_GetDocumentType_Proxy(
				IPB_XMLDOMDocument* This,
				/* [out] */ IPB_XMLDOMDocumentType** ppXMLDOMDocumentTypeReceiver);


			void __RPC_STUB IPB_XMLDOMDocument_GetDocumentType_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_GetImplementation_Proxy(
				IPB_XMLDOMDocument* This,
				/* [out] */ IPB_XMLDOMImplementation** ppXMLDOMImplementationReceiver);


			void __RPC_STUB IPB_XMLDOMDocument_GetImplementation_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_GetDocumentElement_Proxy(
				IPB_XMLDOMDocument* This,
				/* [out] */ IPB_XMLDOMElement** ppXMLDOMDocumentElement);


			void __RPC_STUB IPB_XMLDOMDocument_GetDocumentElement_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_GetElementsByTagName_Proxy(
				IPB_XMLDOMDocument* This,
				/* [in] */ const IPB_String* pTagName,
				/* [out] */ IPB_XMLDOMNodeList** ppElementsListReceiver);


			void __RPC_STUB IPB_XMLDOMDocument_GetElementsByTagName_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_ImportNode_Proxy(
				IPB_XMLDOMDocument* This,
				/* [in] */ const IPB_XMLDOMNode* pImportedNode,
				/* [in] */ const BOOL bDeep,
				/* [out] */ IPB_XMLDOMNode** ppImportedNodeReceiver);


			void __RPC_STUB IPB_XMLDOMDocument_ImportNode_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_CreateElementNS_Proxy(
				IPB_XMLDOMDocument* This,
				/* [in] */ const IPB_String* pNamespaceURI,
				/* [in] */ const IPB_String* pQualifiedName,
				/* [out] */ IPB_XMLDOMElement** ppXMLDOMElementReceiver);


			void __RPC_STUB IPB_XMLDOMDocument_CreateElementNS_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_CreateAttributeNS_Proxy(
				IPB_XMLDOMDocument* This,
				/* [in] */ const IPB_String* pNamespaceURI,
				/* [in] */ const IPB_String* pQualifiedName,
				/* [out] */ IPB_XMLDOMAttr** ppXMLDOMAttributeReceiver);


			void __RPC_STUB IPB_XMLDOMDocument_CreateAttributeNS_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_GetElementsByTagNameNS_Proxy(
				IPB_XMLDOMDocument* This,
				/* [in] */ const IPB_String* pNamespaceURI,
				/* [in] */ const IPB_String* pLocalName,
				/* [out] */ IPB_XMLDOMNodeList** ppElementsListReceiver);


			void __RPC_STUB IPB_XMLDOMDocument_GetElementsByTagNameNS_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_GetElementById_Proxy(
				IPB_XMLDOMDocument* This,
				/* [in] */ const IPB_String* pElementId,
				/* [out] */ IPB_XMLDOMElement** ppXMLDOMElementReceiver);


			void __RPC_STUB IPB_XMLDOMDocument_GetElementById_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_LoadDocument_Proxy(
				IPB_XMLDOMDocument* This,
				/* [in] */ IPB_String* pDocumentName);


			void __RPC_STUB IPB_XMLDOMDocument_LoadDocument_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_LoadDocumentFromString_Proxy(
				IPB_XMLDOMDocument* This,
				/* [in] */ const IPB_String* pDocumentAsString);


			void __RPC_STUB IPB_XMLDOMDocument_LoadDocumentFromString_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_GetDOMParserOptions_Proxy(
				IPB_XMLDOMDocument* This,
				/* [out] */ ULONG* pulDOMParserOptionsReceiver);


			void __RPC_STUB IPB_XMLDOMDocument_GetDOMParserOptions_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_SetDOMParserOptions_Proxy(
				IPB_XMLDOMDocument* This,
				/* [in] */ const ULONG ulDOMParserOptions);


			void __RPC_STUB IPB_XMLDOMDocument_SetDOMParserOptions_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_SetParseCallBackHandler_Proxy(
				IPB_XMLDOMDocument* This,
				/* [in] */ IPB_XMLParseCallBack* pParseCallBack,
				/* [in] */ const ULONG ulParseErrorOptions);


			void __RPC_STUB IPB_XMLDOMDocument_SetParseCallBackHandler_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLDOMDocument_GetParseErrors_Proxy(
				IPB_XMLDOMDocument* This,
				/* [out] */ IPB_List** ppErrors);


			void __RPC_STUB IPB_XMLDOMDocument_GetParseErrors_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);



#endif 	/* __IPB_XMLDOMDocument_INTERFACE_DEFINED__ */


#ifndef __IPB_XMLServiceProvider_INTERFACE_DEFINED__
#define __IPB_XMLServiceProvider_INTERFACE_DEFINED__

			/* interface IPB_XMLServiceProvider */
			/* [unique][uuid][object][local] */


			EXTERN_C const IID IID_IPB_XMLServiceProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("7D49F221-C7AF-11d5-959B-00B0D024631C")
				IPB_XMLServiceProvider : public IUnknown
			{
			public:
				virtual HRESULT STDMETHODCALLTYPE CreatePBXMLDOMDocument(
					/* [out] */ IPB_XMLDOMDocument * *ppXMLDOMDocument) = 0;

				virtual HRESULT STDMETHODCALLTYPE CreatePBXMLSAXParser(
					/* [out] */ IPB_XMLSAXParser** ppXMLSaxParser) = 0;

				virtual HRESULT STDMETHODCALLTYPE CreatePBXMLTrace(
					/* [out] */ IPB_XMLTrace** ppXMLTrace) = 0;

				virtual HRESULT STDMETHODCALLTYPE ConvertNodeToDocument(
					/* [in] */ IPB_XMLDOMNode* pDOMNode,
					/* [out] */ IPB_XMLDOMDocument** ppXMLDOMDocumentReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE ConvertNodeToText(
					/* [in] */ IPB_XMLDOMNode* pDOMNode,
					/* [out] */ IPB_XMLDOMText** ppXMLDOMTextReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE ConvertNodeToElement(
					/* [in] */ IPB_XMLDOMNode* pDOMNode,
					/* [out] */ IPB_XMLDOMElement** ppXMLDOMElementReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE ConvertNodeToAttr(
					/* [in] */ IPB_XMLDOMNode* pDOMNode,
					/* [out] */ IPB_XMLDOMAttr** ppXMLDOMAttrReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE ConvertTextToNode(
					/* [in] */ IPB_XMLDOMText* pDOMText,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE ConvertElementToNode(
					/* [in] */ IPB_XMLDOMElement* pDOMElement,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE ConvertDocumentTypeToNode(
					/* [in] */ IPB_XMLDOMDocumentType* pDOMDocumentType,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE ConvertXMLDeclToNode(
					/* [in] */ IPB_XMLDOMXMLDecl* pDOMXMLDecl,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE ConvertProcessingInstructionToNode(
					/* [in] */ IPB_XMLDOMProcessingInstruction* pDOMProcessingInstruction,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE ConvertAttrToNode(
					/* [in] */ IPB_XMLDOMAttr* pDOMAttr,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE ConvertCommentToNode(
					/* [in] */ IPB_XMLDOMComment* pDOMComment,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE ConvertCDATASectionToNode(
					/* [in] */ IPB_XMLDOMCDATASection* pDOMCDATASection,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE IsEncodingSupported(
					/* [in] */ IPB_String* pEncoding,
					/* [out] */ BOOL* pBoolReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetSupportedEncodings(
					/* [out] */ IPB_String** ppEncodingsReceiver,
					/* [out] */ ULONG* ulCountReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE StringToFileEncoded(
					/* [in] */ IPB_String* pInputString,
					/* [in] */ IPB_String* pFileName,
					/* [in] */ IPB_String* pEncoding) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetDefaultEncoding(
					/* [out] */ IPB_String** ppDefaultEncodingReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetLocale(
					/* [in] */ int iCategory,
					/* [in] */ IPB_String* pLocale) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetLocale(
					/* [in] */ int iCategory,
					/* [out] */ IPB_String** pLocaleReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetAnsiEncoding(
					/* [out] */ IPB_String** ppAnsiEncodingReceiver) = 0;

			};

#else 	/* C style interface */

			typedef struct IPB_XMLServiceProviderVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_XMLServiceProvider* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_XMLServiceProvider* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_XMLServiceProvider* This);

				HRESULT(STDMETHODCALLTYPE* CreatePBXMLDOMDocument)(
					IPB_XMLServiceProvider* This,
					/* [out] */ IPB_XMLDOMDocument** ppXMLDOMDocument);

				HRESULT(STDMETHODCALLTYPE* CreatePBXMLSAXParser)(
					IPB_XMLServiceProvider* This,
					/* [out] */ IPB_XMLSAXParser** ppXMLSaxParser);

				HRESULT(STDMETHODCALLTYPE* CreatePBXMLTrace)(
					IPB_XMLServiceProvider* This,
					/* [out] */ IPB_XMLTrace** ppXMLTrace);

				HRESULT(STDMETHODCALLTYPE* ConvertNodeToDocument)(
					IPB_XMLServiceProvider* This,
					/* [in] */ IPB_XMLDOMNode* pDOMNode,
					/* [out] */ IPB_XMLDOMDocument** ppXMLDOMDocumentReceiver);

				HRESULT(STDMETHODCALLTYPE* ConvertNodeToText)(
					IPB_XMLServiceProvider* This,
					/* [in] */ IPB_XMLDOMNode* pDOMNode,
					/* [out] */ IPB_XMLDOMText** ppXMLDOMTextReceiver);

				HRESULT(STDMETHODCALLTYPE* ConvertNodeToElement)(
					IPB_XMLServiceProvider* This,
					/* [in] */ IPB_XMLDOMNode* pDOMNode,
					/* [out] */ IPB_XMLDOMElement** ppXMLDOMElementReceiver);

				HRESULT(STDMETHODCALLTYPE* ConvertNodeToAttr)(
					IPB_XMLServiceProvider* This,
					/* [in] */ IPB_XMLDOMNode* pDOMNode,
					/* [out] */ IPB_XMLDOMAttr** ppXMLDOMAttrReceiver);

				HRESULT(STDMETHODCALLTYPE* ConvertTextToNode)(
					IPB_XMLServiceProvider* This,
					/* [in] */ IPB_XMLDOMText* pDOMText,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* ConvertElementToNode)(
					IPB_XMLServiceProvider* This,
					/* [in] */ IPB_XMLDOMElement* pDOMElement,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* ConvertDocumentTypeToNode)(
					IPB_XMLServiceProvider* This,
					/* [in] */ IPB_XMLDOMDocumentType* pDOMDocumentType,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* ConvertXMLDeclToNode)(
					IPB_XMLServiceProvider* This,
					/* [in] */ IPB_XMLDOMXMLDecl* pDOMXMLDecl,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* ConvertProcessingInstructionToNode)(
					IPB_XMLServiceProvider* This,
					/* [in] */ IPB_XMLDOMProcessingInstruction* pDOMProcessingInstruction,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* ConvertAttrToNode)(
					IPB_XMLServiceProvider* This,
					/* [in] */ IPB_XMLDOMAttr* pDOMAttr,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* ConvertCommentToNode)(
					IPB_XMLServiceProvider* This,
					/* [in] */ IPB_XMLDOMComment* pDOMComment,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* ConvertCDATASectionToNode)(
					IPB_XMLServiceProvider* This,
					/* [in] */ IPB_XMLDOMCDATASection* pDOMCDATASection,
					/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeReceiver);

				HRESULT(STDMETHODCALLTYPE* IsEncodingSupported)(
					IPB_XMLServiceProvider* This,
					/* [in] */ IPB_String* pEncoding,
					/* [out] */ BOOL* pBoolReceiver);

				HRESULT(STDMETHODCALLTYPE* GetSupportedEncodings)(
					IPB_XMLServiceProvider* This,
					/* [out] */ IPB_String** ppEncodingsReceiver,
					/* [out] */ ULONG* ulCountReceiver);

				HRESULT(STDMETHODCALLTYPE* StringToFileEncoded)(
					IPB_XMLServiceProvider* This,
					/* [in] */ IPB_String* pInputString,
					/* [in] */ IPB_String* pFileName,
					/* [in] */ IPB_String* pEncoding);

				HRESULT(STDMETHODCALLTYPE* GetDefaultEncoding)(
					IPB_XMLServiceProvider* This,
					/* [out] */ IPB_String** ppDefaultEncodingReceiver);

				HRESULT(STDMETHODCALLTYPE* SetLocale)(
					IPB_XMLServiceProvider* This,
					/* [in] */ int iCategory,
					/* [in] */ IPB_String* pLocale);

				HRESULT(STDMETHODCALLTYPE* GetLocale)(
					IPB_XMLServiceProvider* This,
					/* [in] */ int iCategory,
					/* [out] */ IPB_String** pLocaleReceiver);

				HRESULT(STDMETHODCALLTYPE* GetAnsiEncoding)(
					IPB_XMLServiceProvider* This,
					/* [out] */ IPB_String** ppAnsiEncodingReceiver);

				END_INTERFACE
			} IPB_XMLServiceProviderVtbl;

			interface IPB_XMLServiceProvider
			{
				CONST_VTBL struct IPB_XMLServiceProviderVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_XMLServiceProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_XMLServiceProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_XMLServiceProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_XMLServiceProvider_CreatePBXMLDOMDocument(This,ppXMLDOMDocument)	\
    (This)->lpVtbl -> CreatePBXMLDOMDocument(This,ppXMLDOMDocument)

#define IPB_XMLServiceProvider_CreatePBXMLSAXParser(This,ppXMLSaxParser)	\
    (This)->lpVtbl -> CreatePBXMLSAXParser(This,ppXMLSaxParser)

#define IPB_XMLServiceProvider_CreatePBXMLTrace(This,ppXMLTrace)	\
    (This)->lpVtbl -> CreatePBXMLTrace(This,ppXMLTrace)

#define IPB_XMLServiceProvider_ConvertNodeToDocument(This,pDOMNode,ppXMLDOMDocumentReceiver)	\
    (This)->lpVtbl -> ConvertNodeToDocument(This,pDOMNode,ppXMLDOMDocumentReceiver)

#define IPB_XMLServiceProvider_ConvertNodeToText(This,pDOMNode,ppXMLDOMTextReceiver)	\
    (This)->lpVtbl -> ConvertNodeToText(This,pDOMNode,ppXMLDOMTextReceiver)

#define IPB_XMLServiceProvider_ConvertNodeToElement(This,pDOMNode,ppXMLDOMElementReceiver)	\
    (This)->lpVtbl -> ConvertNodeToElement(This,pDOMNode,ppXMLDOMElementReceiver)

#define IPB_XMLServiceProvider_ConvertNodeToAttr(This,pDOMNode,ppXMLDOMAttrReceiver)	\
    (This)->lpVtbl -> ConvertNodeToAttr(This,pDOMNode,ppXMLDOMAttrReceiver)

#define IPB_XMLServiceProvider_ConvertTextToNode(This,pDOMText,ppXMLDOMNodeReceiver)	\
    (This)->lpVtbl -> ConvertTextToNode(This,pDOMText,ppXMLDOMNodeReceiver)

#define IPB_XMLServiceProvider_ConvertElementToNode(This,pDOMElement,ppXMLDOMNodeReceiver)	\
    (This)->lpVtbl -> ConvertElementToNode(This,pDOMElement,ppXMLDOMNodeReceiver)

#define IPB_XMLServiceProvider_ConvertDocumentTypeToNode(This,pDOMDocumentType,ppXMLDOMNodeReceiver)	\
    (This)->lpVtbl -> ConvertDocumentTypeToNode(This,pDOMDocumentType,ppXMLDOMNodeReceiver)

#define IPB_XMLServiceProvider_ConvertXMLDeclToNode(This,pDOMXMLDecl,ppXMLDOMNodeReceiver)	\
    (This)->lpVtbl -> ConvertXMLDeclToNode(This,pDOMXMLDecl,ppXMLDOMNodeReceiver)

#define IPB_XMLServiceProvider_ConvertProcessingInstructionToNode(This,pDOMProcessingInstruction,ppXMLDOMNodeReceiver)	\
    (This)->lpVtbl -> ConvertProcessingInstructionToNode(This,pDOMProcessingInstruction,ppXMLDOMNodeReceiver)

#define IPB_XMLServiceProvider_ConvertAttrToNode(This,pDOMAttr,ppXMLDOMNodeReceiver)	\
    (This)->lpVtbl -> ConvertAttrToNode(This,pDOMAttr,ppXMLDOMNodeReceiver)

#define IPB_XMLServiceProvider_ConvertCommentToNode(This,pDOMComment,ppXMLDOMNodeReceiver)	\
    (This)->lpVtbl -> ConvertCommentToNode(This,pDOMComment,ppXMLDOMNodeReceiver)

#define IPB_XMLServiceProvider_ConvertCDATASectionToNode(This,pDOMCDATASection,ppXMLDOMNodeReceiver)	\
    (This)->lpVtbl -> ConvertCDATASectionToNode(This,pDOMCDATASection,ppXMLDOMNodeReceiver)

#define IPB_XMLServiceProvider_IsEncodingSupported(This,pEncoding,pBoolReceiver)	\
    (This)->lpVtbl -> IsEncodingSupported(This,pEncoding,pBoolReceiver)

#define IPB_XMLServiceProvider_GetSupportedEncodings(This,ppEncodingsReceiver,ulCountReceiver)	\
    (This)->lpVtbl -> GetSupportedEncodings(This,ppEncodingsReceiver,ulCountReceiver)

#define IPB_XMLServiceProvider_StringToFileEncoded(This,pInputString,pFileName,pEncoding)	\
    (This)->lpVtbl -> StringToFileEncoded(This,pInputString,pFileName,pEncoding)

#define IPB_XMLServiceProvider_GetDefaultEncoding(This,ppDefaultEncodingReceiver)	\
    (This)->lpVtbl -> GetDefaultEncoding(This,ppDefaultEncodingReceiver)

#define IPB_XMLServiceProvider_SetLocale(This,iCategory,pLocale)	\
    (This)->lpVtbl -> SetLocale(This,iCategory,pLocale)

#define IPB_XMLServiceProvider_GetLocale(This,iCategory,pLocaleReceiver)	\
    (This)->lpVtbl -> GetLocale(This,iCategory,pLocaleReceiver)

#define IPB_XMLServiceProvider_GetAnsiEncoding(This,ppAnsiEncodingReceiver)	\
    (This)->lpVtbl -> GetAnsiEncoding(This,ppAnsiEncodingReceiver)

#endif /* COBJMACROS */


#endif 	/* C style interface */



			HRESULT STDMETHODCALLTYPE IPB_XMLServiceProvider_CreatePBXMLDOMDocument_Proxy(
				IPB_XMLServiceProvider* This,
				/* [out] */ IPB_XMLDOMDocument** ppXMLDOMDocument);


			void __RPC_STUB IPB_XMLServiceProvider_CreatePBXMLDOMDocument_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLServiceProvider_CreatePBXMLSAXParser_Proxy(
				IPB_XMLServiceProvider* This,
				/* [out] */ IPB_XMLSAXParser** ppXMLSaxParser);


			void __RPC_STUB IPB_XMLServiceProvider_CreatePBXMLSAXParser_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLServiceProvider_CreatePBXMLTrace_Proxy(
				IPB_XMLServiceProvider* This,
				/* [out] */ IPB_XMLTrace** ppXMLTrace);


			void __RPC_STUB IPB_XMLServiceProvider_CreatePBXMLTrace_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLServiceProvider_ConvertNodeToDocument_Proxy(
				IPB_XMLServiceProvider* This,
				/* [in] */ IPB_XMLDOMNode* pDOMNode,
				/* [out] */ IPB_XMLDOMDocument** ppXMLDOMDocumentReceiver);


			void __RPC_STUB IPB_XMLServiceProvider_ConvertNodeToDocument_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLServiceProvider_ConvertNodeToText_Proxy(
				IPB_XMLServiceProvider* This,
				/* [in] */ IPB_XMLDOMNode* pDOMNode,
				/* [out] */ IPB_XMLDOMText** ppXMLDOMTextReceiver);


			void __RPC_STUB IPB_XMLServiceProvider_ConvertNodeToText_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLServiceProvider_ConvertNodeToElement_Proxy(
				IPB_XMLServiceProvider* This,
				/* [in] */ IPB_XMLDOMNode* pDOMNode,
				/* [out] */ IPB_XMLDOMElement** ppXMLDOMElementReceiver);


			void __RPC_STUB IPB_XMLServiceProvider_ConvertNodeToElement_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLServiceProvider_ConvertNodeToAttr_Proxy(
				IPB_XMLServiceProvider* This,
				/* [in] */ IPB_XMLDOMNode* pDOMNode,
				/* [out] */ IPB_XMLDOMAttr** ppXMLDOMAttrReceiver);


			void __RPC_STUB IPB_XMLServiceProvider_ConvertNodeToAttr_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLServiceProvider_ConvertTextToNode_Proxy(
				IPB_XMLServiceProvider* This,
				/* [in] */ IPB_XMLDOMText* pDOMText,
				/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeReceiver);


			void __RPC_STUB IPB_XMLServiceProvider_ConvertTextToNode_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLServiceProvider_ConvertElementToNode_Proxy(
				IPB_XMLServiceProvider* This,
				/* [in] */ IPB_XMLDOMElement* pDOMElement,
				/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeReceiver);


			void __RPC_STUB IPB_XMLServiceProvider_ConvertElementToNode_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLServiceProvider_ConvertDocumentTypeToNode_Proxy(
				IPB_XMLServiceProvider* This,
				/* [in] */ IPB_XMLDOMDocumentType* pDOMDocumentType,
				/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeReceiver);


			void __RPC_STUB IPB_XMLServiceProvider_ConvertDocumentTypeToNode_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLServiceProvider_ConvertXMLDeclToNode_Proxy(
				IPB_XMLServiceProvider* This,
				/* [in] */ IPB_XMLDOMXMLDecl* pDOMXMLDecl,
				/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeReceiver);


			void __RPC_STUB IPB_XMLServiceProvider_ConvertXMLDeclToNode_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLServiceProvider_ConvertProcessingInstructionToNode_Proxy(
				IPB_XMLServiceProvider* This,
				/* [in] */ IPB_XMLDOMProcessingInstruction* pDOMProcessingInstruction,
				/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeReceiver);


			void __RPC_STUB IPB_XMLServiceProvider_ConvertProcessingInstructionToNode_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLServiceProvider_ConvertAttrToNode_Proxy(
				IPB_XMLServiceProvider* This,
				/* [in] */ IPB_XMLDOMAttr* pDOMAttr,
				/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeReceiver);


			void __RPC_STUB IPB_XMLServiceProvider_ConvertAttrToNode_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLServiceProvider_ConvertCommentToNode_Proxy(
				IPB_XMLServiceProvider* This,
				/* [in] */ IPB_XMLDOMComment* pDOMComment,
				/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeReceiver);


			void __RPC_STUB IPB_XMLServiceProvider_ConvertCommentToNode_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLServiceProvider_ConvertCDATASectionToNode_Proxy(
				IPB_XMLServiceProvider* This,
				/* [in] */ IPB_XMLDOMCDATASection* pDOMCDATASection,
				/* [out] */ IPB_XMLDOMNode** ppXMLDOMNodeReceiver);


			void __RPC_STUB IPB_XMLServiceProvider_ConvertCDATASectionToNode_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLServiceProvider_IsEncodingSupported_Proxy(
				IPB_XMLServiceProvider* This,
				/* [in] */ IPB_String* pEncoding,
				/* [out] */ BOOL* pBoolReceiver);


			void __RPC_STUB IPB_XMLServiceProvider_IsEncodingSupported_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLServiceProvider_GetSupportedEncodings_Proxy(
				IPB_XMLServiceProvider* This,
				/* [out] */ IPB_String** ppEncodingsReceiver,
				/* [out] */ ULONG* ulCountReceiver);


			void __RPC_STUB IPB_XMLServiceProvider_GetSupportedEncodings_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLServiceProvider_StringToFileEncoded_Proxy(
				IPB_XMLServiceProvider* This,
				/* [in] */ IPB_String* pInputString,
				/* [in] */ IPB_String* pFileName,
				/* [in] */ IPB_String* pEncoding);


			void __RPC_STUB IPB_XMLServiceProvider_StringToFileEncoded_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLServiceProvider_GetDefaultEncoding_Proxy(
				IPB_XMLServiceProvider* This,
				/* [out] */ IPB_String** ppDefaultEncodingReceiver);


			void __RPC_STUB IPB_XMLServiceProvider_GetDefaultEncoding_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLServiceProvider_SetLocale_Proxy(
				IPB_XMLServiceProvider* This,
				/* [in] */ int iCategory,
				/* [in] */ IPB_String* pLocale);


			void __RPC_STUB IPB_XMLServiceProvider_SetLocale_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLServiceProvider_GetLocale_Proxy(
				IPB_XMLServiceProvider* This,
				/* [in] */ int iCategory,
				/* [out] */ IPB_String** pLocaleReceiver);


			void __RPC_STUB IPB_XMLServiceProvider_GetLocale_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLServiceProvider_GetAnsiEncoding_Proxy(
				IPB_XMLServiceProvider* This,
				/* [out] */ IPB_String** ppAnsiEncodingReceiver);


			void __RPC_STUB IPB_XMLServiceProvider_GetAnsiEncoding_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);



#endif 	/* __IPB_XMLServiceProvider_INTERFACE_DEFINED__ */


#ifndef __IPB_ObjectFactory_INTERFACE_DEFINED__
#define __IPB_ObjectFactory_INTERFACE_DEFINED__

			/* interface IPB_ObjectFactory */
			/* [unique][uuid][object][local] */


			EXTERN_C const IID IID_IPB_ObjectFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("FB1D9755-24EF-11d6-95AF-00B0D024631C")
				IPB_ObjectFactory : public IUnknown
			{
			public:
				virtual HRESULT STDMETHODCALLTYPE CreateString(
					/* [in] */ LPTSTR lpszString,
					/* [out] */ IPB_String * *ppPBStringReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE CreateList(
					/* [out] */ IPB_List** ppPBListReceiver) = 0;

			};

#else 	/* C style interface */

			typedef struct IPB_ObjectFactoryVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_ObjectFactory* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_ObjectFactory* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_ObjectFactory* This);

				HRESULT(STDMETHODCALLTYPE* CreateString)(
					IPB_ObjectFactory* This,
					/* [in] */ LPTSTR lpszString,
					/* [out] */ IPB_String** ppPBStringReceiver);

				HRESULT(STDMETHODCALLTYPE* CreateList)(
					IPB_ObjectFactory* This,
					/* [out] */ IPB_List** ppPBListReceiver);

				END_INTERFACE
			} IPB_ObjectFactoryVtbl;

			interface IPB_ObjectFactory
			{
				CONST_VTBL struct IPB_ObjectFactoryVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_ObjectFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_ObjectFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_ObjectFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_ObjectFactory_CreateString(This,lpszString,ppPBStringReceiver)	\
    (This)->lpVtbl -> CreateString(This,lpszString,ppPBStringReceiver)

#define IPB_ObjectFactory_CreateList(This,ppPBListReceiver)	\
    (This)->lpVtbl -> CreateList(This,ppPBListReceiver)

#endif /* COBJMACROS */


#endif 	/* C style interface */



			HRESULT STDMETHODCALLTYPE IPB_ObjectFactory_CreateString_Proxy(
				IPB_ObjectFactory* This,
				/* [in] */ LPTSTR lpszString,
				/* [out] */ IPB_String** ppPBStringReceiver);


			void __RPC_STUB IPB_ObjectFactory_CreateString_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_ObjectFactory_CreateList_Proxy(
				IPB_ObjectFactory* This,
				/* [out] */ IPB_List** ppPBListReceiver);


			void __RPC_STUB IPB_ObjectFactory_CreateList_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);



#endif 	/* __IPB_ObjectFactory_INTERFACE_DEFINED__ */


#ifndef __IPB_XMLSAXParser_INTERFACE_DEFINED__
#define __IPB_XMLSAXParser_INTERFACE_DEFINED__

			/* interface IPB_XMLSAXParser */
			/* [unique][uuid][object][local] */


			enum HandlerType
			{
				FORM_PARSER = 1,
				TEMPLATE_PARSER = 2,
				DEFAULT_IMPORT = 3,
				TEMPLATE_IMPORT = 4
			};

			EXTERN_C const IID IID_IPB_XMLSAXParser;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("b44ae8c8-3f09-4db0-8d6a-856219ab3e47")
				IPB_XMLSAXParser : public IUnknown
			{
			public:
				virtual HRESULT STDMETHODCALLTYPE SetValidationScheme(
					/* [in] */ INT valScheme) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetDoNamespaces(
					/* [in] */ BOOL doNamespaces) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetDoSchema(
					/* [in] */ BOOL doSchema) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetValidationSchemaFullChecking(
					/* [in] */ BOOL schemaFullChecking) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetHandler(
					/* [in] */ PVOID sa,
					/* [in] */ PVOID subpool,
					/* [in] */ INT handlertype,
					/* [out] */ IPB_XMLSAXHandler** ppXMLSAXHandlerReceiver) = 0;

				virtual HRESULT STDMETHODCALLTYPE ParseFile(
					/* [in] */ IPB_String* pXMLFileName) = 0;

				virtual HRESULT STDMETHODCALLTYPE ParseString(
					/* [in] */ IPB_String* pXMLString) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetError(
					/* [out] */ IPB_XMLSAXError** pError) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetTrace(
					/* [in] */ IPB_XMLTrace* ppXMLTrace) = 0;

			};

#else 	/* C style interface */

			typedef struct IPB_XMLSAXParserVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_XMLSAXParser* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_XMLSAXParser* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_XMLSAXParser* This);

				HRESULT(STDMETHODCALLTYPE* SetValidationScheme)(
					IPB_XMLSAXParser* This,
					/* [in] */ INT valScheme);

				HRESULT(STDMETHODCALLTYPE* SetDoNamespaces)(
					IPB_XMLSAXParser* This,
					/* [in] */ BOOL doNamespaces);

				HRESULT(STDMETHODCALLTYPE* SetDoSchema)(
					IPB_XMLSAXParser* This,
					/* [in] */ BOOL doSchema);

				HRESULT(STDMETHODCALLTYPE* SetValidationSchemaFullChecking)(
					IPB_XMLSAXParser* This,
					/* [in] */ BOOL schemaFullChecking);

				HRESULT(STDMETHODCALLTYPE* SetHandler)(
					IPB_XMLSAXParser* This,
					/* [in] */ PVOID sa,
					/* [in] */ PVOID subpool,
					/* [in] */ INT handlertype,
					/* [out] */ IPB_XMLSAXHandler** ppXMLSAXHandlerReceiver);

				HRESULT(STDMETHODCALLTYPE* ParseFile)(
					IPB_XMLSAXParser* This,
					/* [in] */ IPB_String* pXMLFileName);

				HRESULT(STDMETHODCALLTYPE* ParseString)(
					IPB_XMLSAXParser* This,
					/* [in] */ IPB_String* pXMLString);

				HRESULT(STDMETHODCALLTYPE* GetError)(
					IPB_XMLSAXParser* This,
					/* [out] */ IPB_XMLSAXError** pError);

				HRESULT(STDMETHODCALLTYPE* SetTrace)(
					IPB_XMLSAXParser* This,
					/* [in] */ IPB_XMLTrace* ppXMLTrace);

				END_INTERFACE
			} IPB_XMLSAXParserVtbl;

			interface IPB_XMLSAXParser
			{
				CONST_VTBL struct IPB_XMLSAXParserVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_XMLSAXParser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_XMLSAXParser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_XMLSAXParser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_XMLSAXParser_SetValidationScheme(This,valScheme)	\
    (This)->lpVtbl -> SetValidationScheme(This,valScheme)

#define IPB_XMLSAXParser_SetDoNamespaces(This,doNamespaces)	\
    (This)->lpVtbl -> SetDoNamespaces(This,doNamespaces)

#define IPB_XMLSAXParser_SetDoSchema(This,doSchema)	\
    (This)->lpVtbl -> SetDoSchema(This,doSchema)

#define IPB_XMLSAXParser_SetValidationSchemaFullChecking(This,schemaFullChecking)	\
    (This)->lpVtbl -> SetValidationSchemaFullChecking(This,schemaFullChecking)

#define IPB_XMLSAXParser_SetHandler(This,sa,subpool,handlertype,ppXMLSAXHandlerReceiver)	\
    (This)->lpVtbl -> SetHandler(This,sa,subpool,handlertype,ppXMLSAXHandlerReceiver)

#define IPB_XMLSAXParser_ParseFile(This,pXMLFileName)	\
    (This)->lpVtbl -> ParseFile(This,pXMLFileName)

#define IPB_XMLSAXParser_ParseString(This,pXMLString)	\
    (This)->lpVtbl -> ParseString(This,pXMLString)

#define IPB_XMLSAXParser_GetError(This,pError)	\
    (This)->lpVtbl -> GetError(This,pError)

#define IPB_XMLSAXParser_SetTrace(This,ppXMLTrace)	\
    (This)->lpVtbl -> SetTrace(This,ppXMLTrace)

#endif /* COBJMACROS */


#endif 	/* C style interface */



			HRESULT STDMETHODCALLTYPE IPB_XMLSAXParser_SetValidationScheme_Proxy(
				IPB_XMLSAXParser* This,
				/* [in] */ INT valScheme);


			void __RPC_STUB IPB_XMLSAXParser_SetValidationScheme_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLSAXParser_SetDoNamespaces_Proxy(
				IPB_XMLSAXParser* This,
				/* [in] */ BOOL doNamespaces);


			void __RPC_STUB IPB_XMLSAXParser_SetDoNamespaces_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLSAXParser_SetDoSchema_Proxy(
				IPB_XMLSAXParser* This,
				/* [in] */ BOOL doSchema);


			void __RPC_STUB IPB_XMLSAXParser_SetDoSchema_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLSAXParser_SetValidationSchemaFullChecking_Proxy(
				IPB_XMLSAXParser* This,
				/* [in] */ BOOL schemaFullChecking);


			void __RPC_STUB IPB_XMLSAXParser_SetValidationSchemaFullChecking_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLSAXParser_SetHandler_Proxy(
				IPB_XMLSAXParser* This,
				/* [in] */ PVOID sa,
				/* [in] */ PVOID subpool,
				/* [in] */ INT handlertype,
				/* [out] */ IPB_XMLSAXHandler** ppXMLSAXHandlerReceiver);


			void __RPC_STUB IPB_XMLSAXParser_SetHandler_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLSAXParser_ParseFile_Proxy(
				IPB_XMLSAXParser* This,
				/* [in] */ IPB_String* pXMLFileName);


			void __RPC_STUB IPB_XMLSAXParser_ParseFile_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLSAXParser_ParseString_Proxy(
				IPB_XMLSAXParser* This,
				/* [in] */ IPB_String* pXMLString);


			void __RPC_STUB IPB_XMLSAXParser_ParseString_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLSAXParser_GetError_Proxy(
				IPB_XMLSAXParser* This,
				/* [out] */ IPB_XMLSAXError** pError);


			void __RPC_STUB IPB_XMLSAXParser_GetError_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLSAXParser_SetTrace_Proxy(
				IPB_XMLSAXParser* This,
				/* [in] */ IPB_XMLTrace* ppXMLTrace);


			void __RPC_STUB IPB_XMLSAXParser_SetTrace_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);



#endif 	/* __IPB_XMLSAXParser_INTERFACE_DEFINED__ */


#ifndef __IPB_XMLSAXHandler_INTERFACE_DEFINED__
#define __IPB_XMLSAXHandler_INTERFACE_DEFINED__

			/* interface IPB_XMLSAXHandler */
			/* [unique][uuid][object][local] */


			EXTERN_C const IID IID_IPB_XMLSAXHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("F00C6A5E-D81B-4fe8-8F7A-2C189601D9A6")
				IPB_XMLSAXHandler : public IUnknown
			{
			public:
				virtual HRESULT STDMETHODCALLTYPE SetRowSize(
					/* [in] */ SHORT rowsize) = 0;

				virtual HRESULT STDMETHODCALLTYPE ShowWarnings(
					/* [in] */ BOOL show) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetMatchList(
					/* [in] */ LPVOID matchlist) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetTrace(
					/* [in] */ IPB_XMLTrace* ppXMLTrace) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetRowStart(
					/* [out] */ LPVOID* item) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetNextItem(
					/* [out] */ LPVOID* item) = 0;

			};

#else 	/* C style interface */

			typedef struct IPB_XMLSAXHandlerVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_XMLSAXHandler* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_XMLSAXHandler* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_XMLSAXHandler* This);

				HRESULT(STDMETHODCALLTYPE* SetRowSize)(
					IPB_XMLSAXHandler* This,
					/* [in] */ SHORT rowsize);

				HRESULT(STDMETHODCALLTYPE* ShowWarnings)(
					IPB_XMLSAXHandler* This,
					/* [in] */ BOOL show);

				HRESULT(STDMETHODCALLTYPE* SetMatchList)(
					IPB_XMLSAXHandler* This,
					/* [in] */ LPVOID matchlist);

				HRESULT(STDMETHODCALLTYPE* SetTrace)(
					IPB_XMLSAXHandler* This,
					/* [in] */ IPB_XMLTrace* ppXMLTrace);

				HRESULT(STDMETHODCALLTYPE* GetRowStart)(
					IPB_XMLSAXHandler* This,
					/* [out] */ LPVOID* item);

				HRESULT(STDMETHODCALLTYPE* GetNextItem)(
					IPB_XMLSAXHandler* This,
					/* [out] */ LPVOID* item);

				END_INTERFACE
			} IPB_XMLSAXHandlerVtbl;

			interface IPB_XMLSAXHandler
			{
				CONST_VTBL struct IPB_XMLSAXHandlerVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_XMLSAXHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_XMLSAXHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_XMLSAXHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_XMLSAXHandler_SetRowSize(This,rowsize)	\
    (This)->lpVtbl -> SetRowSize(This,rowsize)

#define IPB_XMLSAXHandler_ShowWarnings(This,show)	\
    (This)->lpVtbl -> ShowWarnings(This,show)

#define IPB_XMLSAXHandler_SetMatchList(This,matchlist)	\
    (This)->lpVtbl -> SetMatchList(This,matchlist)

#define IPB_XMLSAXHandler_SetTrace(This,ppXMLTrace)	\
    (This)->lpVtbl -> SetTrace(This,ppXMLTrace)

#define IPB_XMLSAXHandler_GetRowStart(This,item)	\
    (This)->lpVtbl -> GetRowStart(This,item)

#define IPB_XMLSAXHandler_GetNextItem(This,item)	\
    (This)->lpVtbl -> GetNextItem(This,item)

#endif /* COBJMACROS */


#endif 	/* C style interface */



			HRESULT STDMETHODCALLTYPE IPB_XMLSAXHandler_SetRowSize_Proxy(
				IPB_XMLSAXHandler* This,
				/* [in] */ SHORT rowsize);


			void __RPC_STUB IPB_XMLSAXHandler_SetRowSize_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLSAXHandler_ShowWarnings_Proxy(
				IPB_XMLSAXHandler* This,
				/* [in] */ BOOL show);


			void __RPC_STUB IPB_XMLSAXHandler_ShowWarnings_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLSAXHandler_SetMatchList_Proxy(
				IPB_XMLSAXHandler* This,
				/* [in] */ LPVOID matchlist);


			void __RPC_STUB IPB_XMLSAXHandler_SetMatchList_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLSAXHandler_SetTrace_Proxy(
				IPB_XMLSAXHandler* This,
				/* [in] */ IPB_XMLTrace* ppXMLTrace);


			void __RPC_STUB IPB_XMLSAXHandler_SetTrace_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLSAXHandler_GetRowStart_Proxy(
				IPB_XMLSAXHandler* This,
				/* [out] */ LPVOID* item);


			void __RPC_STUB IPB_XMLSAXHandler_GetRowStart_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLSAXHandler_GetNextItem_Proxy(
				IPB_XMLSAXHandler* This,
				/* [out] */ LPVOID* item);


			void __RPC_STUB IPB_XMLSAXHandler_GetNextItem_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);



#endif 	/* __IPB_XMLSAXHandler_INTERFACE_DEFINED__ */


#ifndef __IPB_XMLTrace_INTERFACE_DEFINED__
#define __IPB_XMLTrace_INTERFACE_DEFINED__

			/* interface IPB_XMLTrace */
			/* [unique][uuid][object][local] */


			EXTERN_C const IID IID_IPB_XMLTrace;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("c906e794-80f0-4a9a-af8a-efacf1e07e9a")
				IPB_XMLTrace : public IUnknown
			{
			public:
				virtual HRESULT STDMETHODCALLTYPE Init(
					/* [in] */ BOOL dbg,
					/* [in] */ LPTSTR lpdbgfile) = 0;

				virtual HRESULT STDMETHODCALLTYPE TraceMessage(
					/* [in] */ LPTSTR strTraceMessage) = 0;

				virtual HRESULT STDMETHODCALLTYPE NewLine(void) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetDebug(
					/* [in] */ BOOL dbg) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetDebug(
					/* [out] */ BOOL* dbg) = 0;

			};

#else 	/* C style interface */

			typedef struct IPB_XMLTraceVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_XMLTrace* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_XMLTrace* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_XMLTrace* This);

				HRESULT(STDMETHODCALLTYPE* Init)(
					IPB_XMLTrace* This,
					/* [in] */ BOOL dbg,
					/* [in] */ LPTSTR lpdbgfile);

				HRESULT(STDMETHODCALLTYPE* TraceMessage)(
					IPB_XMLTrace* This,
					/* [in] */ LPTSTR strTraceMessage);

				HRESULT(STDMETHODCALLTYPE* NewLine)(
					IPB_XMLTrace* This);

				HRESULT(STDMETHODCALLTYPE* SetDebug)(
					IPB_XMLTrace* This,
					/* [in] */ BOOL dbg);

				HRESULT(STDMETHODCALLTYPE* GetDebug)(
					IPB_XMLTrace* This,
					/* [out] */ BOOL* dbg);

				END_INTERFACE
			} IPB_XMLTraceVtbl;

			interface IPB_XMLTrace
			{
				CONST_VTBL struct IPB_XMLTraceVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_XMLTrace_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_XMLTrace_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_XMLTrace_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_XMLTrace_Init(This,dbg,lpdbgfile)	\
    (This)->lpVtbl -> Init(This,dbg,lpdbgfile)

#define IPB_XMLTrace_TraceMessage(This,strTraceMessage)	\
    (This)->lpVtbl -> TraceMessage(This,strTraceMessage)

#define IPB_XMLTrace_NewLine(This)	\
    (This)->lpVtbl -> NewLine(This)

#define IPB_XMLTrace_SetDebug(This,dbg)	\
    (This)->lpVtbl -> SetDebug(This,dbg)

#define IPB_XMLTrace_GetDebug(This,dbg)	\
    (This)->lpVtbl -> GetDebug(This,dbg)

#endif /* COBJMACROS */


#endif 	/* C style interface */



			HRESULT STDMETHODCALLTYPE IPB_XMLTrace_Init_Proxy(
				IPB_XMLTrace* This,
				/* [in] */ BOOL dbg,
				/* [in] */ LPTSTR lpdbgfile);


			void __RPC_STUB IPB_XMLTrace_Init_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLTrace_TraceMessage_Proxy(
				IPB_XMLTrace* This,
				/* [in] */ LPTSTR strTraceMessage);


			void __RPC_STUB IPB_XMLTrace_TraceMessage_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLTrace_NewLine_Proxy(
				IPB_XMLTrace* This);


			void __RPC_STUB IPB_XMLTrace_NewLine_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLTrace_SetDebug_Proxy(
				IPB_XMLTrace* This,
				/* [in] */ BOOL dbg);


			void __RPC_STUB IPB_XMLTrace_SetDebug_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLTrace_GetDebug_Proxy(
				IPB_XMLTrace* This,
				/* [out] */ BOOL* dbg);


			void __RPC_STUB IPB_XMLTrace_GetDebug_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);



#endif 	/* __IPB_XMLTrace_INTERFACE_DEFINED__ */


#ifndef __IPB_XMLSAXError_INTERFACE_DEFINED__
#define __IPB_XMLSAXError_INTERFACE_DEFINED__

			/* interface IPB_XMLSAXError */
			/* [unique][uuid][object][local] */


			enum ErrorType
			{
				PB_CUSTOMERROR = 0,
				PB_SAXPARSEEXCEPTION = 1,
				PB_SAXEXCEPTION = 2
			};

			EXTERN_C const IID IID_IPB_XMLSAXError;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("5C04CED0-1D3D-4bbf-A295-2B42D4BF6CF3")
				IPB_XMLSAXError : public IUnknown
			{
			public:
				virtual HRESULT STDMETHODCALLTYPE GetType(
					/* [out] */ INT * errortype) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetMessage(
					/* [out] */ LPTSTR* pErrorString) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetSystemID(
					/* [out] */ LPTSTR* pSystemID) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetLine(
					/* [out] */ LONG* line) = 0;

				virtual HRESULT STDMETHODCALLTYPE GetColumn(
					/* [out] */ LONG* column) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetType(
					/* [in] */ INT errortype) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetMessage(
					/* [in] */ LPTSTR pErrorString) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetSystemID(
					/* [in] */ LPTSTR pSystemID) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetSAXException(
					/* [in] */ PVOID e) = 0;

				virtual HRESULT STDMETHODCALLTYPE SetSAXParseException(
					/* [in] */ PVOID e) = 0;

			};

#else 	/* C style interface */

			typedef struct IPB_XMLSAXErrorVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_XMLSAXError* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_XMLSAXError* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_XMLSAXError* This);

				HRESULT(STDMETHODCALLTYPE* GetType)(
					IPB_XMLSAXError* This,
					/* [out] */ INT* errortype);

				HRESULT(STDMETHODCALLTYPE* GetMessage)(
					IPB_XMLSAXError* This,
					/* [out] */ LPTSTR* pErrorString);

				HRESULT(STDMETHODCALLTYPE* GetSystemID)(
					IPB_XMLSAXError* This,
					/* [out] */ LPTSTR* pSystemID);

				HRESULT(STDMETHODCALLTYPE* GetLine)(
					IPB_XMLSAXError* This,
					/* [out] */ LONG* line);

				HRESULT(STDMETHODCALLTYPE* GetColumn)(
					IPB_XMLSAXError* This,
					/* [out] */ LONG* column);

				HRESULT(STDMETHODCALLTYPE* SetType)(
					IPB_XMLSAXError* This,
					/* [in] */ INT errortype);

				HRESULT(STDMETHODCALLTYPE* SetMessage)(
					IPB_XMLSAXError* This,
					/* [in] */ LPTSTR pErrorString);

				HRESULT(STDMETHODCALLTYPE* SetSystemID)(
					IPB_XMLSAXError* This,
					/* [in] */ LPTSTR pSystemID);

				HRESULT(STDMETHODCALLTYPE* SetSAXException)(
					IPB_XMLSAXError* This,
					/* [in] */ PVOID e);

				HRESULT(STDMETHODCALLTYPE* SetSAXParseException)(
					IPB_XMLSAXError* This,
					/* [in] */ PVOID e);

				END_INTERFACE
			} IPB_XMLSAXErrorVtbl;

			interface IPB_XMLSAXError
			{
				CONST_VTBL struct IPB_XMLSAXErrorVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_XMLSAXError_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_XMLSAXError_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_XMLSAXError_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_XMLSAXError_GetType(This,errortype)	\
    (This)->lpVtbl -> GetType(This,errortype)

#define IPB_XMLSAXError_GetMessage(This,pErrorString)	\
    (This)->lpVtbl -> GetMessage(This,pErrorString)

#define IPB_XMLSAXError_GetSystemID(This,pSystemID)	\
    (This)->lpVtbl -> GetSystemID(This,pSystemID)

#define IPB_XMLSAXError_GetLine(This,line)	\
    (This)->lpVtbl -> GetLine(This,line)

#define IPB_XMLSAXError_GetColumn(This,column)	\
    (This)->lpVtbl -> GetColumn(This,column)

#define IPB_XMLSAXError_SetType(This,errortype)	\
    (This)->lpVtbl -> SetType(This,errortype)

#define IPB_XMLSAXError_SetMessage(This,pErrorString)	\
    (This)->lpVtbl -> SetMessage(This,pErrorString)

#define IPB_XMLSAXError_SetSystemID(This,pSystemID)	\
    (This)->lpVtbl -> SetSystemID(This,pSystemID)

#define IPB_XMLSAXError_SetSAXException(This,e)	\
    (This)->lpVtbl -> SetSAXException(This,e)

#define IPB_XMLSAXError_SetSAXParseException(This,e)	\
    (This)->lpVtbl -> SetSAXParseException(This,e)

#endif /* COBJMACROS */


#endif 	/* C style interface */



			HRESULT STDMETHODCALLTYPE IPB_XMLSAXError_GetType_Proxy(
				IPB_XMLSAXError* This,
				/* [out] */ INT* errortype);


			void __RPC_STUB IPB_XMLSAXError_GetType_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLSAXError_GetMessage_Proxy(
				IPB_XMLSAXError* This,
				/* [out] */ LPTSTR* pErrorString);


			void __RPC_STUB IPB_XMLSAXError_GetMessage_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLSAXError_GetSystemID_Proxy(
				IPB_XMLSAXError* This,
				/* [out] */ LPTSTR* pSystemID);


			void __RPC_STUB IPB_XMLSAXError_GetSystemID_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLSAXError_GetLine_Proxy(
				IPB_XMLSAXError* This,
				/* [out] */ LONG* line);


			void __RPC_STUB IPB_XMLSAXError_GetLine_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLSAXError_GetColumn_Proxy(
				IPB_XMLSAXError* This,
				/* [out] */ LONG* column);


			void __RPC_STUB IPB_XMLSAXError_GetColumn_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLSAXError_SetType_Proxy(
				IPB_XMLSAXError* This,
				/* [in] */ INT errortype);


			void __RPC_STUB IPB_XMLSAXError_SetType_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLSAXError_SetMessage_Proxy(
				IPB_XMLSAXError* This,
				/* [in] */ LPTSTR pErrorString);


			void __RPC_STUB IPB_XMLSAXError_SetMessage_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLSAXError_SetSystemID_Proxy(
				IPB_XMLSAXError* This,
				/* [in] */ LPTSTR pSystemID);


			void __RPC_STUB IPB_XMLSAXError_SetSystemID_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLSAXError_SetSAXException_Proxy(
				IPB_XMLSAXError* This,
				/* [in] */ PVOID e);


			void __RPC_STUB IPB_XMLSAXError_SetSAXException_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLSAXError_SetSAXParseException_Proxy(
				IPB_XMLSAXError* This,
				/* [in] */ PVOID e);


			void __RPC_STUB IPB_XMLSAXError_SetSAXParseException_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);



#endif 	/* __IPB_XMLSAXError_INTERFACE_DEFINED__ */


#ifndef __IPB_XMLParseCallBack_INTERFACE_DEFINED__
#define __IPB_XMLParseCallBack_INTERFACE_DEFINED__

			/* interface IPB_XMLParseCallBack */
			/* [unique][uuid][object][local] */


			EXTERN_C const IID IID_IPB_XMLParseCallBack;

#if defined(__cplusplus) && !defined(CINTERFACE)

			MIDL_INTERFACE("94492ADB-3A27-4038-ABB3-C735A62419E6")
				IPB_XMLParseCallBack : public IUnknown
			{
			public:
				virtual HRESULT STDMETHODCALLTYPE Warning(
					/* [in] */ IPB_XMLSAXError * pSAXError) = 0;

				virtual HRESULT STDMETHODCALLTYPE Error(
					/* [in] */ IPB_XMLSAXError* pSAXError) = 0;

				virtual HRESULT STDMETHODCALLTYPE FatalError(
					/* [in] */ IPB_XMLSAXError* pSAXError) = 0;

				virtual HRESULT STDMETHODCALLTYPE ResetErrors(void) = 0;

			};

#else 	/* C style interface */

			typedef struct IPB_XMLParseCallBackVtbl
			{
				BEGIN_INTERFACE

					HRESULT(STDMETHODCALLTYPE* QueryInterface)(
						IPB_XMLParseCallBack* This,
						/* [in] */ REFIID riid,
						/* [iid_is][out] */ void** ppvObject);

				ULONG(STDMETHODCALLTYPE* AddRef)(
					IPB_XMLParseCallBack* This);

				ULONG(STDMETHODCALLTYPE* Release)(
					IPB_XMLParseCallBack* This);

				HRESULT(STDMETHODCALLTYPE* Warning)(
					IPB_XMLParseCallBack* This,
					/* [in] */ IPB_XMLSAXError* pSAXError);

				HRESULT(STDMETHODCALLTYPE* Error)(
					IPB_XMLParseCallBack* This,
					/* [in] */ IPB_XMLSAXError* pSAXError);

				HRESULT(STDMETHODCALLTYPE* FatalError)(
					IPB_XMLParseCallBack* This,
					/* [in] */ IPB_XMLSAXError* pSAXError);

				HRESULT(STDMETHODCALLTYPE* ResetErrors)(
					IPB_XMLParseCallBack* This);

				END_INTERFACE
			} IPB_XMLParseCallBackVtbl;

			interface IPB_XMLParseCallBack
			{
				CONST_VTBL struct IPB_XMLParseCallBackVtbl* lpVtbl;
			};



#ifdef COBJMACROS


#define IPB_XMLParseCallBack_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPB_XMLParseCallBack_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPB_XMLParseCallBack_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPB_XMLParseCallBack_Warning(This,pSAXError)	\
    (This)->lpVtbl -> Warning(This,pSAXError)

#define IPB_XMLParseCallBack_Error(This,pSAXError)	\
    (This)->lpVtbl -> Error(This,pSAXError)

#define IPB_XMLParseCallBack_FatalError(This,pSAXError)	\
    (This)->lpVtbl -> FatalError(This,pSAXError)

#define IPB_XMLParseCallBack_ResetErrors(This)	\
    (This)->lpVtbl -> ResetErrors(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



			HRESULT STDMETHODCALLTYPE IPB_XMLParseCallBack_Warning_Proxy(
				IPB_XMLParseCallBack* This,
				/* [in] */ IPB_XMLSAXError* pSAXError);


			void __RPC_STUB IPB_XMLParseCallBack_Warning_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLParseCallBack_Error_Proxy(
				IPB_XMLParseCallBack* This,
				/* [in] */ IPB_XMLSAXError* pSAXError);


			void __RPC_STUB IPB_XMLParseCallBack_Error_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLParseCallBack_FatalError_Proxy(
				IPB_XMLParseCallBack* This,
				/* [in] */ IPB_XMLSAXError* pSAXError);


			void __RPC_STUB IPB_XMLParseCallBack_FatalError_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);


			HRESULT STDMETHODCALLTYPE IPB_XMLParseCallBack_ResetErrors_Proxy(
				IPB_XMLParseCallBack* This);


			void __RPC_STUB IPB_XMLParseCallBack_ResetErrors_Stub(
				IRpcStubBuffer* This,
				IRpcChannelBuffer* _pRpcChannelBuffer,
				PRPC_MESSAGE _pRpcMessage,
				DWORD* _pdwStubPhase);



#endif 	/* __IPB_XMLParseCallBack_INTERFACE_DEFINED__ */


			/* interface __MIDL_itf_pbxml_0136 */
			/* [local] */

			PBWINAPI_(HRESULT) PB_CreateXMLDOMDocument(IPB_XMLDOMDocument** ppXMLDOMDocument);
			PBWINAPI_(HRESULT) PB_CreateXMLSAXParser(IPB_XMLSAXParser** ppXMLSAXParser);
			PBWINAPI_(HRESULT) PB_CreateXMLTrace(IPB_XMLTrace** ppXMLTrace);
			PBWINAPI_(HRESULT) PB_CreateXMLServiceProvider(IPB_XMLServiceProvider** ppXMLServiceProvider);
			PBWINAPI_(HRESULT) PB_CreatePBObjectFactory(IPB_ObjectFactory** ppIPB_ObjectFactoryReceiver);
			PBWINAPI_(HRESULT) PB_SetObjectFactory(IPB_ObjectFactory* pIPB_ObjectFactory);
			HRESULT WINAPI PB_ConvertNodeToDocument(IPB_XMLDOMNode* pDOMNode, IPB_XMLDOMDocument** ppXMLDOMDocumentReceiver);
			HRESULT WINAPI PB_ConvertNodeToText(IPB_XMLDOMNode* pDOMNode, IPB_XMLDOMText** ppXMLDOMTextReceiver);
			HRESULT WINAPI PB_ConvertNodeToElement(IPB_XMLDOMNode* pDOMNode, IPB_XMLDOMElement** ppXMLDOMElementReceiver);
			HRESULT WINAPI PB_ConvertNodeToAttr(IPB_XMLDOMNode* pDOMNode, IPB_XMLDOMAttr** ppXMLDOMAttrReceiver);
			HRESULT WINAPI PB_ConvertTextToNode(IPB_XMLDOMText* pDOMText, IPB_XMLDOMNode** ppXMLDOMNodeReceiver);
			HRESULT WINAPI PB_ConvertElementToNode(IPB_XMLDOMElement* pDOMElement, IPB_XMLDOMNode** ppXMLDOMNodeReceiver);
			HRESULT WINAPI PB_ConvertDocumentTypeToNode(IPB_XMLDOMDocumentType* pDOMDocumentType, IPB_XMLDOMNode** ppXMLDOMNodeReceiver);
			HRESULT WINAPI PB_ConvertXMLDeclToNode(IPB_XMLDOMXMLDecl* pDOMXMLDecl, IPB_XMLDOMNode** ppXMLDOMNodeReceiver);
			HRESULT WINAPI PB_ConvertProcessingInstructionToNode(IPB_XMLDOMProcessingInstruction* pDOMProcessingInstruction, IPB_XMLDOMNode** ppXMLDOMNodeReceiver);
			HRESULT WINAPI PB_ConvertAttrToNode(IPB_XMLDOMAttr* pDOMAttr, IPB_XMLDOMNode** ppXMLDOMNodeReceiver);
			HRESULT WINAPI PB_ConvertCommentToNode(IPB_XMLDOMComment* pDOMComment, IPB_XMLDOMNode** ppXMLDOMNodeReceiver);
			HRESULT WINAPI PB_ConvertCDATASectionToNode(IPB_XMLDOMCDATASection* pDOMCDATASection, IPB_XMLDOMNode** ppXMLDOMNodeReceiver);
			HRESULT WINAPI PB_IsEncodingSupported(IPB_String* pEncoding, BOOL* pBoolReceiver);
			HRESULT WINAPI PB_GetSupportedEncodings(IPB_String** ppEncodingsReceiver, ULONG* ulCountReceiver);
			HRESULT WINAPI PB_StringToFileEncoded(IPB_String* pInputString, IPB_String* pFileName, IPB_String* pEncoding);
			HRESULT WINAPI PB_GetDefaultEncoding(IPB_String** ppDefaultEncodingReceiver);


			extern RPC_IF_HANDLE __MIDL_itf_pbxml_0136_v0_0_c_ifspec;
			extern RPC_IF_HANDLE __MIDL_itf_pbxml_0136_v0_0_s_ifspec;


#ifndef __PBXMLLib_LIBRARY_DEFINED__
#define __PBXMLLib_LIBRARY_DEFINED__

			/* library PBXMLLib */
			/* [uuid] */




















			EXTERN_C const IID LIBID_PBXMLLib;
#endif /* __PBXMLLib_LIBRARY_DEFINED__ */

			/* Additional Prototypes for ALL interfaces */

			/* end of Additional Prototypes */

#ifdef __cplusplus
		}
#endif

#endif


		// DOINC popped back into header 'pbdw.h'
#endif

#endif

#ifdef __cplusplus
		extern "C" {
#endif

			typedef struct PB_WSConnection
			{
				LPTSTR				Endpoint;
				BOOL 				UseWindowsIntegratedAuthentication;
				LPTSTR				AuthenticationMode;
				LPTSTR 				UserDomain;
				LPTSTR				UserName;
				LPTSTR				Password;
				LPTSTR				ClientCertificateFile;
				LPTSTR				ProxyServerHostName;
				USHORT				ProxyServerPort;
				LPTSTR				ProxyServerUserName;
				LPTSTR				ProxyServerPassword;
				LPTSTR				reserved1;
				LPTSTR				reserved2;
				LONG				Timeout;
				INT					reserved4;
			} *PPB_WSConnection;

			typedef struct
			{
				DWORD lInkColor;
				long lInkHeight;
				long lInkWidth;
				unsigned short iPenTip;
				unsigned short iTransparency;
				unsigned short iRasterOperation;
				unsigned short inkFlags;
#define inkFlags_AntiAliased		0x0001
#define inkFlags_FitToCurve			0x0002
#define inkFlags_IgnorePressure		0x0004
			} DWINKATT, * PDWINKATT;//Ink drawing attributes
			typedef struct
			{
				LPTSTR strFactoid;
				long lRecogTimeout;
				short iInkMode;
				short iStatus;
				short iZoomFactor;
				unsigned short inkedFlags;
#define inkedFlags_EditBar	0x0001
#define inkedFlags_InsertAsText	0x0002
#define inkedFlags_UseMouse		0x0004
#define inkedFlags_FocusRect	0x0008
#define inkedFlags_InkDirty		0x0010
			} DWEDITINKEDIT, * PDWEDITINKEDIT;

			typedef struct
			{
				LONG lTextColor;
				LONG lTitleTextColor;
				LONG lTrailingTextColor;
				LONG lBackColor;
				LONG lTitleBackColor;
				unsigned short uFlags;
#define DDCal_AlignRight    0x0001 //dropdown align right
				unsigned short uFiller;
			} DDCALENDARPROPS, * PDDCALENDARPROPS;
			// DataWindow Class names
#if defined(DW_OCX)
#define DW_WNDCLASS 	psAddVersionID( PBTEXT("pbdwx"), PBTEXT("") )
#define DW_WNDCLASSLB 	psAddVersionID( PBTEXT("pbdwlbx"), PBTEXT("") )
#define DW_WNDCLASSST 	psAddVersionID( PBTEXT("pbdwstx"), PBTEXT("") )
#elif defined(DW_PLUGIN)
#define DW_WNDCLASS 	psAddVersionID( PBTEXT("pbdwg"), PBTEXT("") )
#define DW_WNDCLASSLB 	psAddVersionID( PBTEXT("pbdwlbg"), PBTEXT("") )
#define DW_WNDCLASSST 	psAddVersionID( PBTEXT("pbdwstg"), PBTEXT("") )
#elif defined(NISQL)
#define DW_WNDCLASS 	psAddVersionID( PBTEXT("pbdwn"), PBTEXT("") )
#define DW_WNDCLASSLB 	psAddVersionID( PBTEXT("pbdwlbn"), PBTEXT("") )
#define DW_WNDCLASSST 	psAddVersionID( PBTEXT("pbdwstn"), PBTEXT("") )
#elif defined(DW_NET)
#define DW_WNDCLASS 	psAddVersionID( PBTEXT("pbdwnet"), PBTEXT("") )
#define DW_WNDCLASSLB 	psAddVersionID( PBTEXT("pbdwlbnet"), PBTEXT("") )
#define DW_WNDCLASSST 	psAddVersionID( PBTEXT("pbdwstnet"), PBTEXT("") )
#else
#define DW_WNDCLASS 	psAddVersionID( PBTEXT("pbdw"), PBTEXT("") )
#define DW_WNDCLASSLB 	psAddVersionID( PBTEXT("pbdwlb"), PBTEXT("") )
#define DW_WNDCLASSST 	psAddVersionID( PBTEXT("pbdwst"), PBTEXT("") )
#endif

#ifndef RC_INVOKED // Make this more efficient for 16-bit resource compile

// DataWindow Control Notification Codes
// Any RC=0 is the default action if no script is coded.

// ITEMCHANGE issued after an item has passed its validation test
// but before it has been put into the dw table.
// RC=0; means accept the data value
// RC=1; means reject the data value
// Arguments: long row, long col#, string colname, string data
#define DWN_ITEMCHANGE             0x0100
// ITEMVALUECHANGE is issued when an item has passed its validation test
// and it has passed the ITEMCHANGE event and the data has been succesfully
// placed into the dw table
#define DWN_ITEMVALUECHANGE        0x0102
// ITEMVALIDATEIONERROR issued when an item fails its validation test.
// RC=0; means reject data value and show message box
// RC=1; means reject data value with no message box
// RC=2; means accept data value
// Arguments: long row, long col#, string colname, string data
#define DWN_ITEMVALIDATIONERROR    0x0200
// RETRIEVESTART issued before starting any database retrieval.  It
// can be used to set the database transaction parameters.
// RC=0; continue
// RC=1; don't do retrieval
#define DWN_RETRIEVESTART          0x0300
// RETRIEVEEND issued after all rows have been retrieved.
// RC=0; continue
#define DWN_RETRIEVEEND            0x0301
// RETRIEVEROW issued after a row has been retrieved and placed in the
// dw table.
// RC=0; continue
// RC=1; stop retrieval
#define DWN_RETRIEVEROW            0x0302
// UPDATESTART issued before starting any database update.  It can be used
// to set the database transaction parameters.
// RC=0; continue
// RC=1; don't do update
#define DWN_UPDATESTART            0x0400
// UPDATEEND issued after all database update.  A COMMIT has been done
// prior to this message except for user defined transactions.  A user
// must do their own commit if they supplied the transaction.
// RC=0; continue
#define DWN_UPDATEEND			   0x0401
// LBUTTONDBLCLK issued when user double clicks.  Note: there is no
// guarentee that currency exists or is visible on the window.  If the user
// has clicked on top of a field then this field is made current before the
// LBUTTONDBLCLK is issued.  If the click does not occur on top of a field
// then whatever currency that existed prior to the request (if any) is
// maintained.
#define DWN_LBUTTONDBLCLK          0x0500

// Left Button Down
// RC=0; continue
// RC=1; stop processing
// Arguments: long x, long y, long row, dwobject dwo
#define DWN_LBUTTONCLK             0x0501
#define DWN_RBUTTONDBLCLK          0x0502
#define DWN_RBUTTONCLK             0x0503
#define DWN_MBUTTONDBLCLK          0x0504
#define DWN_MBUTTONCLK             0x0505
// DBERROR issued when a database error is encountered.  The message is
// issued after a ROLLBACK is issued (unless this is a user specified transaction)
// and before a message box is displayed.  If this is a user specified
// transaction the user is responsible for issuing the ROLLBACK.
// RC=0; display error message
// RC=1; don't display error message
// Arguments: long sqldbcode, string sqlerrtext
#define DWN_DBERROR                0x0600
// WSError issued when the web service reports an error
#define DWN_WSERROR				   0x0601	
// ITEMCHANGEFOCUS issued when a new item gets focus
// Arguments: long row, long col#, string colname
#define DWN_ITEMCHANGEFOCUS        0x0700
// ROWCHANGE issued when the current row changes.  Use GetRow to find out
// what that row is.  This is primarily useful for listbox style processing.
#define DWN_ROWCHANGE              0x0800
// ROWCHANGING issued _before_ the current row changes.
#define DWN_ROWCHANGING				0x0802
// SELCHANGE issued when a row selection changes.
#define DWN_SELCHANGE			   0x0801
// TABOUT issued when user tabs out of DataWindow.
#define DWN_TABOUT                 0x0900
#define DWN_BACKTABOUT             0x0901
#define DWN_TABUPOUT               0x0902
#define DWN_TABDOWNOUT             0x0903
// Return 1 when you want DW to ignore the enter key
#define DWN_PROCESSENTER		   0x0904
// New events for release 2
#define DWN_KILLFOCUS			   0x0905
#define DWN_SETFOCUS			   0x0906
#define DWN_MOUSEMOVE			   0x0907
#define DWN_LBUTTONDOWN			   0x0908
#define DWN_LBUTTONUP			   0x0909
#define DWN_RBUTTONDOWN			   0x090A
#define DWN_RBUTTONUP			   0x090B
#define DWN_CHANGING			   0x090C
#define DWN_HSCROLL				   0x090D
#define DWN_VSCROLL				   0x090E

// SQL issued prior to any syntax passed to the database engine.
// User can inspect the syntax using "dwSQLGetSyntax" and modify
// it using "dwSQLSetSyntax".  Event is triggered by issuing
// RETRIEVE, UPDATE, RESELECT.
// RC=0; continue
// RC=1; fail
// RC=2; skip and continue
// Arguments: long request, long sqltype, string SQLsyntax, long row, long buffer
//    Arg-request type
#define DWN_SQL_ARG_RETRIEVE	1
#define DWN_SQL_ARG_RESELECT	2
#define DWN_SQL_ARG_UPDATE		3
//	  Arg-sqltype
#define DWN_SQL_ARG_SQLSELECT	1
#define DWN_SQL_ARG_SQLINSERT	2
#define DWN_SQL_ARG_SQLDELETE	3
#define DWN_SQL_ARG_SQLUPDATE   4

#define DWN_SQL					   0x090F
#define DWN_RESIZE				   0x0910
#define DWN_MOVE				   0x0911
#define DWN_SYSCHAR				   0x0912
// Print events
#define DWN_PRINTSTART			   0x0913
// Print page occurs before printing the page.
// RC=0; continue
// RC=1; skip page
#define DWN_PRINTPAGE			   0x0914
#define DWN_PRINTEND			   0x0915
// DWN_KEY is really on WM_KEYDOWN
#define DWN_KEY					   0x0916
// DDDW and DDLB when drop down is about to be shown this event is triggered
// Return 1 when you want to disallow the drop down.
#define DWN_DROPDOWN			   0x0917
// Graph has just been built when this event is triggered
#define DWN_GRAPHCREATE			   0x0918
// Margin has been dragged by the user
#define DWN_PRINTMARGINCHANGE	   0x0919
// Non-client area messages
#define DWN_NCHITTEST              0x0920
#define DWN_NCRBUTTONDOWN          0x0921
// Notify message that tells you that message text is availale - get text by using
// dwMessageText function
#define DWN_MESSAGETEXT            0x0922

// More non-client area messages
#define DWN_NCLBUTTONDOWN          0x0923
#define DWN_NCLBUTTONDBLCLK        0x0924

// UNPUBLISHED MESSAGES!!!
// Nest needs a transaction for retrieval
#define DWN_NEED_TRANS             0x925
// In place activate notifications
#define DWN_APPNOTIFY_UIACTIVATE   0x926
#define DWN_APPNOTIFY_UIDEACTIVATE 0x927
#define DWN_APPNOTIFY_GETIPSHAREDMENUCOUNT 0x928
#define DWN_APPNOTIFY_GETIPSHAREDMENUS 0x929
#define DWN_APPNOTIFY_GETISMDI     0x930
#define DWN_APPNOTIFY_IPACTIVATE   0x931
#define DWN_APPNOTIFY_IPDEACTIVATE 0x932

// Button Events:
#define DWN_BUTTONCLICKING         0x933
#define DWN_BUTTONCLICKED          0x934

// Internally-used event: SyntaxModified (used by dw painter to know when
// it's time to update the design view)
#define DWN_SYNTAXMODIFIED         0x935

#define DWN_GRID_COLUMN_RESIZED	   0x936

// Some events used by PB runtime
#define DWN_DRAGDROP			   0x0A00
#define DWN_DRAGENTER			   0x0A01
#define DWN_DRAGLEAVE			   0x0A02
#define DWN_DRAGWITHIN			   0x0A03
//

// Events used to communicate to the host
// PRE_GETFOCUS is called when the SET_FOCUS message come in,
// but before any other processing is done
#define DWN_PRE_GETFOCUS           0x0B01

// used by SetHTMLAction() to allow for server side validation
#define DWN_HTMLCONTEXTAPPLIED     0x0C00

//used by TreeView DW
#define DWN_EXPANDING			0x0C01
#define DWN_COLLAPSING		0x0C02
#define DWN_EXPANDED			0x0C03
#define DWN_COLLAPSED		0x0C04
#define DWN_TREENODESELECTING			0x0C05
#define DWN_TREENODESELECTED		0x0C06

#define DWN_RICHTEXTLIMITERROR		0x0C10
#define DWN_RICHTEXTCURRENTSTYLECHANGED		0x0C11
#define DWN_RICHTEXTLOSEFOCUS		0x0C12

// Datawindow Control Messages
// Message we accept.

#define DWM_USER (WM_USER+256)

#define DWM_RUNPROG        (DWM_USER+21)    // run the program
#define DWM_MINMESSAGE     (DWM_USER+22)
#define DWM_ESCAPE         (DWM_USER+22)    // revert value to before edit
#define DWM_PRINT          (DWM_USER+23)    // print
// Do actual database update
#define DWM_UPDATE         (DWM_USER+24)    // update data base
// Foreign file support
#define DWM_SAVEAS         (DWM_USER+25)    // save as foreign file
// Do actual retrieval from data source
#define DWM_RETRIEVE       (DWM_USER+26)    // do the retrieval
#define DWM_DELETE         (DWM_USER+27)    // delete current row
// Sorting
#define DWM_SORT           (DWM_USER+28)    // sort table
#define DWM_SETSORT        (DWM_USER+29)    // change the sort columns/order
// Display filter
#define DWM_FILTER         (DWM_USER+30)    // filter rows of table
#define DWM_SETFILTER      (DWM_USER+31)    // change the filter
// New row
#define DWM_INSERT         (DWM_USER+32)    // insert row; returns row #
// Row/Column currency information
#define DWM_GETCURRENTROW  (DWM_USER+33)    // Get current row #
#define DWM_GETCURRENTCOL  (DWM_USER+34)    // Get current column #
// Scrolling messages
#define DWM_SCROLLTOROW    (DWM_USER+35)    // Scroll window to row #
#define DWM_SCROLLNEXTROW  (DWM_USER+36)    // Scroll window to next row
#define DWM_SCROLLPRIORROW (DWM_USER+37)    // Scroll window to prior row
#define DWM_SCROLLNEXTPAGE (DWM_USER+38)    // Scroll window to next page
#define DWM_SCROLLPRIORPAGE (DWM_USER+39)   // Scroll window to prior page
#define DWM_SCROLLHOME     (DWM_USER+44)    // Scroll to 1st row
#define DWM_SCROLLLINEHOME (DWM_USER+45)    // Scroll to 1st tab column
#define DWM_SCROLLEND      (DWM_USER+46)    // Scroll to last row
#define DWM_SCROLLLINEEND  (DWM_USER+47)    // Scroll to last tab column
// Statistics messages
#define DWM_GETROWCOUNT    (DWM_USER+40)    // Count of displayable rows
#define DWM_GETDELETECOUNT (DWM_USER+41)    // Count of rows deleted
#define DWM_GETFILTERCOUNT (DWM_USER+42)    // Count of rows filtered out
#define DWM_GETMODIFYCOUNT (DWM_USER+43)    // Count of rows modified
#define DWM_GETNESTCOUNT   (DWM_USER+78)    // Count of displayable rows in nests

#define DWM_IMPORT         (DWM_USER+48)    // Import rows into dw
#define DWM_RESETCONTENT   (DWM_USER+49)    // Clear data from data window
#define DWM_SETTABORDER    (DWM_USER+50)    // Set tabbing order of column
#define DWM_FIND           (DWM_USER+51)    // Find: set/first/next/prior/last
#define DWM_DWINFO         (DWM_USER+52)    // Misc. info.  Passed struct
#define DWM_SELECTROW      (DWM_USER+53)    // Select the row (TRUE/FALSE)
#define DWM_GETSELECTEDROW (DWM_USER+54)    // Get next selected row
#define DWM_GETCLICKEDCOL  (DWM_USER+55)    // Get the current clicked column
#define DWM_GETCLICKEDROW  (DWM_USER+56)    // Get the current clicked row
#define DWM_ISROWSELECTED  (DWM_USER+57)    // Is the current row selected
#define DWM_ACCEPTTEXT     (DWM_USER+58)    // Accept current text
#define DWM_SQLGET         (DWM_USER+59)    // Return sql select syntax
#define DWM_SQLGETLENGTH   (DWM_USER+60)    // Return length of sql select
#define DWM_SQLSET         (DWM_USER+61)    // Set sql select syntax
#define DWM_RESELECTROW    (DWM_USER+62)    // Reselect Row
#define DWM_GETSTYLE       (DWM_USER+63)    // Get style of column
#define DWM_SETSTYLE       (DWM_USER+64)    // Set style of column
#define DWM_ROWINDICATOR   (DWM_USER+65)    // Current row indicator
#define DWM_CLOSEDROPDOWN  (DWM_USER+66)    // Close drop down popups
#define DWM_SYSCHAR 	      (DWM_USER+67)	   // Get the syschar accelerator
#define DWM_SCROLLCOLUMN   (DWM_USER+68)    // Scroll to column
#define DWM_ACCELERATOR	   (DWM_USER+69)	   // Do accelerator
#define DWM_SETTRANSDIS	   (DWM_USER+70)	   // Disconnect; settransobject check
#define DWM_PRINTCANCEL	   (DWM_USER+71)	   // Cancel printing
#define DWM_OLECHANGE	   (DWM_USER+72)    // OLE change object message
#define DWM_GETEDIT	      (DWM_USER+73)    // Get the current edit control
#define DWM_GETGRAPH	      (DWM_USER+74)    // Get the named graph object
#define DWM_GETDW	   	   (DWM_USER+75)    // Get the named DDDW
#define DWM_DDDWRECURSION  (DWM_USER+76)    // Is DDDW forcing a recursion?
#define DWM_ANYEDITS  	   (DWM_USER+77)    // Are any columns editable
#define DWM_IMPORTDATA	   (DWM_USER+79)    // External invoked message for obtaining data
#define DWM_CANTDEACTIVATE (DWM_USER+80)    // Cannot deactivate in place object
#define DWM_ADJUSTPBU      (DWM_USER+81)    // Adjust the PBU mapping to a particular font
#define DWM_PBQA           (DWM_USER+82)    // PB QA message
#define DWM_SET_NOTIFY_CALL (DWM_USER+83)   // Notification callback
#define DWM_GETCLICKEDBUTTON (DWM_USER+84)  // Get info about the current button clicked
#define DWM_ISDDDW			(DWM_USER+85)	// Is it a dddw?
#define DWM_PRINTWITHDLG    (DWM_USER+86)    // print with dialog
#define DWM_GETEDITOBJECT	(DWM_USER+87)		// send on message
#define DWM_GETEDITOBJECTCLIENT	(DWM_USER+88)    // get accessible object underneath dw edit control
#define DWM_DELETEALL         (DWM_USER+89)    // delete current row
#define DWM_DWGETFOCUS			(DWM_USER+90) // CR229231
#define DWM_RICHTEXTCOLUMNWASCLICKED (DWM_USER+91)
#define DWM_CONTROL_IN_PAINTER (DWM_USER+92)

// current maximum is 100--
#define DWM_MAXMESSAGE     (DWM_USER+100)

// Restrict maximum number of columns to ensure consistent performance.
// Should look at this number again at some point.
#define DW_MAXIMUM_COLUMNS     1000

// File save as type definitions
#define DW_FILESAVEAS_BEGIN    1
#define DW_FILESAVEAS_EXCEL    1
#define DW_FILESAVEAS_TEXT     2
#define DW_FILESAVEAS_CSV      3
#define DW_FILESAVEAS_SYLK     4
#define DW_FILESAVEAS_WKS      5
#define DW_FILESAVEAS_WK1      6
#define DW_FILESAVEAS_DIF      7
#define DW_FILESAVEAS_DBF2     8
#define DW_FILESAVEAS_DBF3     9
#define DW_FILESAVEAS_SQL      10
#define DW_FILESAVEAS_CLIPBOARD 11
#define DW_FILESAVEAS_PSR      12
#define DW_FILESAVEAS_WMF      13
#define DW_FILESAVEAS_HTMLTABLE 14
#define DW_FILESAVEAS_EXCEL_5   15
#define DW_FILESAVEAS_HTML_PREVIEW 16  // this is an HTMLTABLE that previews HTMLDW if specified.
#define DW_FILESAVEAS_XML      17
#define DW_FILESAVEAS_XSLFO    18
#define DW_FILESAVEAS_PDF      19
#define DW_FILESAVEAS_EXCEL_8   20
#define DW_FILESAVEAS_EMF      21
#define DW_FILESAVEAS_XLSX	   22
#define DW_FILESAVEAS_XLSB	   23
#define DW_FILESAVEAS_END      23


// Find type definitions
#define DW_FIND_SETFIND        1    /* lparam contains find string or NULL */
#define DW_FIND_FIRST          2
#define DW_FIND_NEXT           3
#define DW_FIND_PRIOR          4
#define DW_FIND_LAST           5
#define DW_FIND_CURRENTROW     6    /* set the current row to find from */

// File import type definitions
//#define DW_IMPORT_CLIPBOARD    1
//#define DW_IMPORT_STRING       2
//#define DW_IMPORT_USEEXTENSION 3    // Load dynamically using extension

// import type bitmask values for DWIMPORT struct
// source types
#define DW_IMPORT_CLIPBOARD			0x00000001
#define DW_IMPORT_STRING			0x00000002
#define DW_IMPORT_USEEXTENSION		0x00000004
#define DW_IMPORT_FILE				0x00000008
#define DW_IMPORT_UNSUPPORTEDENUM	0x00000080
// file types
#define DW_IMPORT_TXT				0x00000100
#define DW_IMPORT_DBF				0x00000200
#define DW_IMPORT_XML				0x00000400
#define DW_IMPORT_CSV				0x00000800


// script event flag1 equates(evtF1) - 1 means that this event has a script

#define DWNBACKTABOUT               0x80000000
#define DWNCHANGING					0x40000000
#define DWNDBERROR					0x20000000
#define DWNDRAGDROP					0x10000000
#define DWNDRAGENTER				0x08000000
#define DWNDRAGLEAVE				0x04000000
#define DWNDRAGWITHIN				0x02000000
#define DWNDROPDOWN					0x01000000
#define DWNGRAPHCREATE				0x00800000
#define DWNHSCROLL					0x00400000
#define DWNITEMCHANGE				0x00200000
#define DWNITEMCHANGEFOCUS			0x00100000
#define DWNITEMVALIDATIONERROR		0x00080000
#define DWNKEY						0x00040000
#define DWNKILLFOCUS				0x00020000
#define DWNLBUTTONCLK				0x00010000
#define DWNLBUTTONDBLCLK			0x00008000
#define DWNLBUTTONUP				0x00004000
#define DWNMESSAGETEXT				0x00002000
#define DWNMOUSEMOVE				0x00001000
#define DWNPRINTEND					0x00000800
#define DWNPRINTMARGINCHANGE		0x00000400
#define DWNPRINTPAGE				0x00000200
#define DWNPRINTSTART				0x00000100
#define DWNPROCESSENTER				0x00000080
#define DWNRBUTTONDBLCLK			0x00000040
#define DWNRBUTTONDOWN				0x00000020
#define DWNRBUTTONUP				0x00000010
#define DWNRESIZE					0x00000008
#define DWNRETRIEVEEND				0x00000004
#define DWNRETRIEVEROW				0x00000002
#define DWNRETRIEVESTART			0x00000001

// script event flag2 equates(evtF2) - 1 means that this event has a script

#define DWNROWCHANGE				0x80000000
#define DWNSETFOCUS					0x40000000
#define DWNSQL						0x20000000
#define DWNTABDOWNOUT				0x10000000
#define DWNTABOUT					0x08000000
#define DWNTABUPOUT					0x04000000
#define DWNUPDATEEND				0x02000000
#define DWNUPDATESTART				0x01000000
#define DWNVSCROLL					0x00800000
#define DWNROWCHANGING				0x00400000
#define DWNHTMLCONTEXTAPPLIED		0x00200000
#define DWNEXPANDING				0x00100000
#define DWNCOLLAPSING				0x00080000
#define DWNEXPANDED					0x00040000
#define DWNCOLLAPSED				0x00020000
#define DWNTREENODESELECTING		0x00010000
#define DWNTREENODESELECTED			0x00008000
#define DWNWSERROR					0x00004000
#define DWNRICHTEXTLIMITERROR             0x00002000
#define DWNRICHTEXTCURRENTSTYLECHANGED    0x00001000
#define DWNRICHTEXTLOSEFOCUS              0x00000800

			typedef struct                  // for now columns need to match
			{
				LPTSTR name;                 // NULL if type=CLIPBOARD
											// CSV string if type=STRING
											// else file name
				short type;					 // clipboard, string, use extension ...
				LONG inputstartrow;         // input start row (1 is first row)
				LONG inputstoprow;          // -1 if EOF else inputstoprow > inputstartrow
				short inputstartcol;		 // 1st column to use of input
				short inputstopcol;			 // last column to use of input
				short dwstartcol;			 // start column of data window
			} DWIMPORT, FAR* PDWIMPORT;

#define DW_IMPORT_OK				0
#define DW_IMPORT_EOF				-1
#define DW_IMPORT_NULL				-2
#define DW_IMPORT_ERROR_BADARG		-3
#define DW_IMPORT_ERROR_BADINPUT	-4
#define DW_IMPORT_ERROR_FILEOPEN	-5
#define DW_IMPORT_ERROR_FILECLOSE	-6
#define DW_IMPORT_ERROR_FILEREAD	-7
#define DW_IMPORT_ERROR_BADEXT		-8
#define DW_IMPORT_ERROR_CANCEL		-9
#define DW_IMPORT_ERROR_FILEFORMAT	-10
#define DW_IMPORT_ERROR_XMLPARSE	-11
#define DW_IMPORT_ERROR_XMLTEMPLATE	-12
#define DW_IMPORT_ERROR_DWSTYLE		-13
#define DW_IMPORT_ERROR_NESTED		-14
#define DW_IMPORT_ERROR_OVERFLOW	-15

#define DW_IMPORT_ROWSTART			-100

#ifndef LRECTDEFN
#define LRECTDEFN
			// Definition of a rectangle with LONG: RECT uses int
			typedef struct tagLRECT {
				LONG left;
				LONG top;
				LONG right;
				LONG bottom;
			} LRECT;
#endif

			/* Function prototypes */
			// Fortify SCA: (Assert) errmsg must be at least 255 chars in size
			PBWINAPI(PVOID, dwCompile)(LPTSTR syntax, LPTSTR errmsg, PVOID obthis, PVOID dbtran);
			PBWINAPI(HWND, dwCreateWindow)(LPTSTR, LPTSTR, DWORD, int, int, int, int, HWND, HMENU, HANDLE, LPTSTR);
			PBWINAPI(HWND, dwCreateWindowEx)(DWORD, LPTSTR, LPTSTR, DWORD, int, int, int, int, HWND, HMENU, HANDLE, LPTSTR);
			PBWINAPI(BOOL, dwCrosstabDLG)(HWND hWnd);
			PBWINAPI(LPTSTR, dwDescribe)(HWND hWnd, LPTSTR syntax);
			PBWINAPI(BOOL, dwFree)(PVOID prog);
			PBWINAPI(BOOL, dwSetDataStoreHWndBehavior) (BOOL bUseHWnd);
			PBWINAPI(short, dwLoadData)(LPOLESTR pFileName, HWND hWnd);
			PBWINAPI(short, dwLoadDataProg)(LPOLESTR pFileName, PVOID pProg);
			PBWINAPI(short, dwLoadDataCrosstab)(LPTSTR pFileName, HWND hWnd);
			PBWINAPI(short, dwLoadDataStorage)(PVOID pStg, PVOID given_pDW, BOOL bInDWSync);
			PBWINAPI(VOID, dwLoadDataOle)(LPOLESTR pFileName, PVOID pDW);
			PBWINAPI(PVOID, dwLoadDW)(PVOID pDW, LPTSTR name);
			PBWINAPI(PVOID, dwLoadFile)(LPOLESTR pFileName, PVOID obthis);
			PBWINAPI(PVOID, dwLoadLibrary)(LPTSTR FAR* files, UINT filecount, LPTSTR entry, PVOID obthis);
			PBWINAPI(PVOID, dwLoadMemory)(PVOID data);
			PBWINAPI(PVOID, dwLoadStorage)(PVOID pStg, PVOID obthis);
			PBWINAPI(LPTSTR, dwModify)(HWND hWnd, LPTSTR syntax);
			PBWINAPI(short, dwSaveData)(LPOLESTR pFileName, HWND hWnd);
			PBWINAPI(short, dwSaveDataStorage)(PVOID pStg, HWND hWnd);
			PBWINAPI(short, dwSaveDataCopy)(LPOLESTR pOutFileName, LPOLESTR pInFileName, PVOID sa, pbstg_subpool subpool);
			PBWINAPI(short, dwSaveDataCopyStorage)(PVOID pOutStg, PVOID pInStg, PVOID sa, pbstg_subpool subpool);
			PBWINAPI(short, dwSaveFile)(LPOLESTR pFileName, LPTSTR pSyn, PVOID pProg, PVOID pData, unsigned int flags);
			PBWINAPI(short, dwSaveLibrary)(PVOID prog, LPTSTR file, LPTSTR entry);
			PBWINAPI(short, dwSaveOle)(LPOLESTR pFileName, HWND hWnd);
			PBWINAPI(short, dwSaveObjects)(LPOLESTR pFileName, HWND hWnd);
			PBWINAPI(short, dwSaveStorage)(PVOID pStg, LPTSTR pSyn, PVOID pProg, PVOID pData, unsigned int flags);

			PBWINAPI(long, dwFileSaveStorage)(HWND hWnd, PVOID pStorage, BOOL bInDWSync);
			PBWINAPI(short, dwSaveStorageStg)(PVOID pStg, LPTSTR pSyn, PVOID pProg, PVOID pData, unsigned int flags);
			PBWINAPI(short, dwSaveOleStg)(PVOID pStorage, PVOID pDW);
			PBWINAPI(short, dwSaveObjectsStg)(PVOID pStorage, PVOID pDW);
			PBWINAPI(short, dwSaveDataStg)(PVOID pStorage, HWND hWnd, BOOL bInDWSync);
			PBWINAPI(PVOID, dwLoadFileBlob)(PVOID pBlob, PVOID obthis, ULONG ulLen, PVOID pStg);

			PBWINAPI(void, dwStgFree)(HWND hWnd, PVOID s);
			PBWINAPI(LPTSTR, dwGetMessageText)(HWND hWnd);
			PBWINAPI(LPTSTR, dwGetExceedPageMessage)(HWND hWnd, ppbstg_anchor sa, pbstg_subpool subpool);
			PBWINAPI(LONG, DW_PluginStart)(HINSTANCE hInst, LPTSTR pAppName, LPTSTR FAR* pLibListEntries,
				INT iLibListEntries, BOOL bWindow, INT iWidth, INT iHeight,
				INT iExeType, PVOID obShare, HWND hParent, LPTSTR pObjectName,
				LPTSTR pCommandLine, ppbstg_anchor FAR* stgThis, PVOID obThis,
				PVOID obInst, HWND FAR* hWnd, VOID* context);
			PBWINAPI(LONG, DW_PluginStop) (PVOID pobThis, ppbstg_anchor FAR* pstgThis, PVOID pobInst,
				HWND  FAR* phWnd);
			LONG dwGetRowId(HWND hWnd, LONG ri, SHORT sQ);
			LONG dwGetRowFromId(HWND hWnd, LONG ri, SHORT sQ);
			PVOID dwGetUserFunctionCallback(HWND hWnd);

#define DW_OLE_STREAM_FSINFO PBTEXT("FSInfo")							// FullState Info block
#define DW_OLE_STREAM_SOURCE PBTEXT("source")							// syntax
#define DW_OLE_STREAM_OBJECT PBTEXT("object")							// objects
#define DW_OLE_STREAM_DATA   PBTEXT("data")								// Primary data
#define DW_OLE_STREAM_DATA_DELETED PBTEXT("data_deleted")				// Deleted data
#define DW_OLE_STORAGE_NESTDATA_DELETED PBTEXT("nestdata_deleted")		// Deleted nest data
#define DW_OLE_STREAM_DATA_FILTERED PBTEXT("data_filtered")				// Filtered data
#define DW_OLE_STORAGE_NESTDATA_FILTERED PBTEXT("nestdata_filtered")	// Filtered nest data
#define DW_OLE_STREAM_DATA_ORIGINAL PBTEXT("original_data")				// Primary original data
#define DW_OLE_STREAM_DATA_ORIGINAL_FILTERED PBTEXT("original_data_filtered")	// Filtered original data
#define DW_OLE_STREAM_DATA_ORIGINAL_DELETED PBTEXT("original_data_deleted")		// Deleted original data
#define DW_OLE_STREAM_OLE    PBTEXT("ole")
#define DW_OLE_STORAGE_OLEDATA     PBTEXT("olestg")
#define DW_OLE_STORAGE_NESTDATA    PBTEXT("neststg")
#define DW_OLE_STREAM_NESTDATA     PBTEXT("nestdir")
#define DW_OLE_STREAM_CONNECTION   PBTEXT("connection")
#define DW_OLE_STORAGE_DW          PBTEXT("dwstg")
#define DW_OLE_STREAM_DW_LOOKUP    PBTEXT("dwlookup")

#define	DW_OLE_REM_ROWSET_MAP      PBTEXT("RSM")

			// DataWindow options
#define DW_MAPMODE_PB		0	// Powerbuilder units
#define DW_MAPMODE_DEVICE	1	// Device units
#define DW_MAPMODE_ENGLISH	2	// 1/1000 inches
#define DW_MAPMODE_METRIC	3	// 1/1000 centimeters


//	DataWindow processing attributes
#define DW_PROCESSING_NORMAL			( 0 )	//	No default style processing
#define DW_PROCESSING_GRID				( 1 )	//	Force grid style processing
#define DW_PROCESSING_SPREADSHEET		( 1 )	//	Same as grid
#define DW_PROCESSING_LABEL				( 2 )	//	Force label processing
#define DW_PROCESSING_GRAPH				( 3 )	//	Force graph processing
#define DW_PROCESSING_CROSSTAB			( 4 )	//	Force crosstab processing
#define DW_PROCESSING_NESTED			( 5 )	//	Force nested processing
#define DW_PROCESSING_OLE				( 6 )	//	Force ole processing
#define DW_PROCESSING_RTE				( 7 )	//	Force rte processing
#define DW_PROCESSING_TREE				( 8 )	//	Force tree processing
#define DW_PROCESSING_GRIDTREE				( 9 )	//	Force tree processing
#define DW_PROCESSING_MAX				( 9 )

// DataWindow grid processing;  use macro to determine this
#define ISTREE(p) ((p) == DW_PROCESSING_TREE || (p) == DW_PROCESSING_GRIDTREE)
// DataWindow grid lines
#define DW_GRID_LINE_ON			0	// Always show grid lines
#define DW_GRID_LINE_OFF		1	// Never show grid lines
#define DW_GRID_LINE_DISPLAY	2	// Show grid lines only on display
#define DW_GRID_LINE_PRINT		3	// Show grid lines only on print

// DataWindow help equates
#define DW_HELP_INDEX			0	// Help file index: typeid ignored
#define DW_HELP_TOPIC			1	// Help file topic: typeid is number
#define DW_HELP_KEYWORD			2	// Help file keyword: typeid is string

// DataWindow print equates
#define DW_PRINT_ORIENT_DEFAULT	0	// Default to printer defaults
#define DW_PRINT_ORIENT_LANDSCAPE 1 // Landscape
#define DW_PRINT_ORIENT_PORTRAIT  2 // Portrait
#define DW_PRINT_ORIENT_PROMPT	3	// Prompt for printer attributes
#define DW_PRINT_ORIENT_MAX		3	// Maximum

#define DW_PRINT_PSIZE_DEFAULT 0	// Paper size map directly to windows equates
#define DW_PRINT_PSIZE_MAX	   32000

#define DW_PRINT_PSOURCE_DEFAULT 0	// Paper source map directly to windows equates
#define DW_PRINT_PSOURCE_MAX 	32000

#define DW_PRINT_QUALITY_DEFAULT 0
#define DW_PRINT_QUALITY_HIGH    1
#define DW_PRINT_QUALITY_MEDIUM  2
#define DW_PRINT_QUALITY_LOW     3
#define DW_PRINT_QUALITY_DRAFT   4
#define DW_PRINT_QUALITY_MAX   4

#define DW_PRINT_COLOR_DEFAULT 0
#define DW_PRINT_COLOR_COLOR   1
#define DW_PRINT_COLOR_MONOCHROME 2
#define DW_PRINT_COLOR_MAX 2

#define DW_PRINT_DUPLEX_DEFAULT 0
#define DW_PRINT_DUPLEX_SIMPLEX 1
#define DW_PRINT_DUPLEX_HORIZONTAL 2
#define DW_PRINT_DUPLEX_VERTICAL   3
#define DW_PRINT_DUPLEX_MAX   	3


// Datawindow font bias
#define DW_FONT_BIAS_DISPLAY	0	// Font mapping biased to display
#define DW_FONT_BIAS_PRINTER	1	// Font mapping biased to printer
#define DW_FONT_BIAS_NEUTRAL	2	// Font mapping neutral

// Prefix #defines
#define DW_PREFIX_COMPUTE   1
#define DW_PREFIX_GRAPH     2
#define DW_PREFIX_DW        3
#define DW_PREFIX_OLE       4
#define DW_PREFIX_BLOB      5
#define DW_PREFIX_GRPBOX    6
#define DW_PREFIX_BUTTON    7
#define DW_PREFIX_TEXT      8
#define DW_PREFIX_PICTURE   9
#define DW_PREFIX_LINE      10
#define DW_PREFIX_OVAL      11
#define DW_PREFIX_RECT      12
#define DW_PREFIX_RRECT     13
#define DW_PREFIX_COUNT     14
#define DW_PREFIX_SUM       15
#define DW_PREFIX_AVG       16
#define DW_PREFIX_PAGE      17
#define DW_PREFIX_DATE      18
#define DW_PREFIX_COLUMN    19
#define DW_PREFIX_INKPIC    20


// Data window object types
			typedef enum {
				DWBITMAP, DWCOL, DWCOMPUTE,
				DWOVAL, DWLINE, DWRECT, DWRRECT, DWTEXT, DWTBLOB,
				DWGRAPH, DWCROSSTAB, DWREPORT, DWOLE, DWBUTTON, DWGROUPBOX, DWINKPIC, DWWPF, DWNULL
			} DWTYPES;

			// Datawindow row resize attributes
#define DW_ROWRESIZE_OFF        0   // Row resize disabled
#define DW_ROWRESIZE_ON         1   // Row resize enabled

// Datawindow OLE containter equates

#define DW_ACTIVATEMANUALLY 0
#define DW_ACTIVATEONDOUBLECLICK 1
#define DW_ACTIVATEONGETFOCUS 2


// Datawindow OLE containter types
#define DW_GENERAL 0
#define DW_SMI_MAP 1

// Datawindow OLE integrated server classes
#define DW_SMI_CLASS PBTEXT("AtlasMapViewer.Map.1")

// When in place active, ole control needs this structure
			typedef struct
			{
				PVOID  prog;                    // pDW
				HWND   hWnd;                    // DW hwnd
				HWND   hWndClient;              // supplied by app
				PVOID  activeOle;               // ip ole gob user part
				PVOID  pControl;                // ip gob control info
				long   sharedMenuCount;         // supplied by app
				PVOID  pSharedMenu;             // supplied by ROI+app (do not free)
				short  bMDI;                    // TRUE if this is an MDI app
				RECT   rect;
			} DWOLER, FAR* PDWOLER;


			typedef struct
			{
				LONG timer_interval;	// timer interval

				fillBrushInfo bkinfo;

				LONG rows_per_detail;	// Rows allowed in detail
				LPTSTR pointer;			// mouser pointer for DW
				short mapmode;			// mapping mode
				short processing;			// Default

				struct {
					TCHAR szDocument[32];	// Document name
					TCHAR szPrinterName[64];// Printer Name
					LONG orientation;		// Orientation
					LONG left;				// Margin
					LONG right;				// Margin
					LONG top;				// Margin
					LONG bottom;			// Margin
					long scolumns_width;    // Snaked columns width
					short scolumns;         // Number of snaked columns
					short psize;			// Paper size
					short psource;			// Paper source
					BOOL bCanUseDefaultPrinter; // Can use Default printer if named printer is invalid
					BOOL bPrompt;			// Prompt before print
					BOOL bPrintButtons;		// Indicator for whether or not to print the buttons
					BOOL bPrintPreviewButtons;		// Indicator for whether or not to display buttons in preview
					BOOL bOverridePrintJob; // DW should override the batch print job
					BOOL bClipTextOnPrint;  // Text should be clipped to the text-box size
					BOOL bPrintCollate;     // Printed copies should be collated
					BOOL bPrintPreviewShowsOutline; // Print preview shows paper outline with blue line.
					BOOL bPrintShowsBackground; // Print show background
					BOOL bPrintPreviewShowsBackground; // Preview show background
				} print;

				LPTSTR lpOleClientClass; 	// OLE client class
				LPTSTR lpOleClientName;		// OLE client name

				struct {
					LPTSTR name;			// Name of label
					short width;		// Width of a single label
					short height;		// height of a single label
					short rows;			// # of labels vertically
					short rows_spacing;	// Spacing between rows
					short columns;		// # of labels horizontally
					short columns_spacing; // Spacing between columns
					BOOL bTopDown;		// Use top to bottom left to right
					BOOL bSheet;		// Using sheet feed
					DWTYPES gType;		// type of graphic object
					short ellipse_height;	// gType = aRoundRect;  This defines the
					short ellipse_width;	// corners
				} label;

				short iGridLines;		// show grid lines options
				short iRowResize;       // allow rows to be resized by user
				BOOL bGridColMove;      // allow columns to be moved
				BOOL bSelectedMouse;    // allow mouse selection

				//the following are HTML-related stuff associated with the datawindow
				BOOL    bHTMLDW;
				LPTSTR  bExprGenerateCss;
				LPTSTR  bExprNoWrap;
				LPTSTR  lExprBorder;
				LPTSTR  lExprCellSpacing;
				LPTSTR  lExprCellPadding;
				LPTSTR  lpszStyleSheet;
				LPTSTR  lExprWidth;
				LPTSTR  bExprGenerateJavaScript;
				LPTSTR  bExprClientEvents;
				LPTSTR  bExprClientValidation;
				LPTSTR  bExprClientComputedFields;
				LPTSTR  bExprClientFormatting;
				LPTSTR  bExprClientScriptable;
				LPTSTR  bExprFirstOnPage;
				LPTSTR  lExprPageSize;
				LPTSTR  sExprSelfLink;
				LPTSTR  lpszSelfLinkArgs;
				LPTSTR  bExprEncodeSelfLinkArgs;
				LPTSTR  sExprObjectName;
				LPTSTR  sExprBrowser;
				LPTSTR  sExprHTMLVersion;
				LPTSTR  sExprResourceBase;
				LPTSTR  sExprCommonJSFile;
				LPTSTR  sExprDateJSFile;
				LPTSTR  sExprNumberJSFile;
				LPTSTR  sExprStringJSFile;
				LPTSTR  sExprUserJSFile;
				LPTSTR  bExprNetscapeLayers;
				LPTSTR  lExprTabIndexBase;
				SHORT	iPagingMethod;
				LPTSTR	bExprGenerateDDDWFrames;
				//end HTML-specific stuff

				//the following are XHTML/XMLWeb-related props associated with the datawindow
				LPTSTR  sExprXHTMLBrowser;
				LPTSTR  sExprCSSResourceBase;
				LPTSTR  sExprCSSPublishPath;
				LPTSTR  bExprCSSSessionSpecific;
				LPTSTR  sExprXMLResourceBase;
				LPTSTR  sExprXMLPublishPath;
				LPTSTR  bExprXMLInline;
				LPTSTR  sExprXSLTResourceBase;
				LPTSTR  sExprXSLTPublishPath;
				LPTSTR  sExprJSResourceBase;
				LPTSTR  sExprJSPublishPath;
				//end XHTML/XMLWeb-specific props

				//List of data export template lists by format (e.g. XML)
				IDW_DataTemplateList* pIDWExportDataTemplateList;
				//List of data import template lists by format (e.g. XML)
				IDW_DataTemplateList* pIDWImportDataTemplateList;

				// DW XML Import trace
				BOOL    bImportXMLTrace;
				LPTSTR	sImportXMLTraceFile;

				LPTSTR   pRTEDetailText; // richtext - text for initializing the detail section
				LPTSTR   pRTEHeaderText; // richtext - text for initializing the header section
				LPTSTR   pRTEFooterText; // richtext - text for initializing the footer section
				PVOID   pRTEComputes; // richtext - ptr to chain of wingobs for computes
				PVOID   pRTEColumns; // rcihtext - ptr to chain of wingobs for columns
				BOOL    bRTEHeaderFooter; // richtext - header/footer flag
				BOOL    bRTELineBreak;
				BOOL    bRTEReturnsVisible;
				BOOL    bRTESpacesVisible;
				BOOL    bRTETabsVisible;
				BOOL    bRTEInputFieldsVisible;
				BOOL    bRTEPictureFrame;
				BOOL    bRTEInputFieldNamesVisible;
				BOOL    bRTEPopMenu;
				BOOL    bRTEToolBar;
				BOOL    bRTETabBar;
				BOOL    bRTERulerBar;
				BOOL    bRTEReadOnly;
				short   iRTEUnit;
				LONG    lRTEInputFieldBackColor;
				LONG    lRTEBackColor;
				LPTSTR   pRTEInitialFile;
				BOOL	bHideGrayLine; // Prasenjit -- cr264969
				BOOL    bShowBackcolorOnXp; //CR344801

				struct
				{
					LONG camera_distance;
					LONG camera_elevation;
					LONG camera_rotation;
					LONG animation_duration;
					LONG animation_transitions;
					LONG current_page_on_click;
					LONG pages_width;
					LONG pages_height;
					LONG perspective;
					LONG quality;
					LONG orthogonal;
					LONG refresh_on_mouseover;

					LPTSTR expr_pages_total_visible;
					LPTSTR expr_pages_focal;
					LPTSTR expr_reflection;
					LPTSTR expr_rotation_x;
					LPTSTR expr_rotation_y;
					LPTSTR expr_rotation_z;
					LPTSTR expr_scaling_width;
					LPTSTR expr_scaling_height;
					LPTSTR expr_translation_x;
					LPTSTR expr_translation_y;
					LPTSTR expr_translation_z;
					LPTSTR expr_transparency;
				} viewport3d;
				//CR358762 revert CR322622 fixes partially
				//BOOL	bScrollByPage;// qliang cr322622,scroll by page when click up/down scroll arrow,behavior before PB8
			} DWOPTIONS, FAR* PDWOPTIONS;

			// Suffixes for source, compiled programs
#define DWSOURCE           PBTEXT(".srd")
#define DWBINARY           PBTEXT(".bin")
#define DWPROGRAMSUFFIX    PBTEXT(".dwo")

// Types of editing capabilities
// Right 4 digits are the generic type.  Left 4 are styles within the type.
#define DWEDIT_EDIT                 0x00000001
#define DWEDIT_EDIT_UPPER           0x80000000
#define DWEDIT_EDIT_LOWER           0x40000000
#define DWEDIT_EDIT_AUTOSELECT		0x20000000
#define DWEDIT_EDIT_PASSWORD        0x10000000
#define DWEDIT_EDIT_AUTOHSCROLL     0x08000000
#define DWEDIT_EDIT_AUTOVSCROLL     0x04000000
#define DWEDIT_EDIT_HSCROLLBAR      0x02000000
#define DWEDIT_EDIT_VSCROLLBAR      0x01000000
#define DWEDIT_EDIT_CODETABLE       0x00800000
#define DWEDIT_EDIT_CODETABLEEDIT	0x00400000
#define DWEDIT_EDIT_DISPLAYONLY 	0x00200000
#define DWEDIT_EDIT_NILISNULL 		0x00100000
#define DWEDIT_EDIT_REQUIRED 		0x00080000
#define DWEDIT_EDIT_USEELLIPSIS 	0x00040000

#define DWEDIT_COMBO                0x00000002
#define DWEDIT_COMBO_SORTED         0x80000000
#define DWEDIT_COMBO_ALLOWEDIT      0x40000000
#define DWEDIT_COMBO_AUTOHSCROLL    0x20000000
#define DWEDIT_COMBO_VSCROLLBAR     0x10000000
#define DWEDIT_COMBO_ALWAYSSHOWLIST 0x08000000
#define DWEDIT_COMBO_USEASBORDER	0x04000000
#define DWEDIT_COMBO_UPPER			0x02000000
#define DWEDIT_COMBO_LOWER			0x01000000
#define DWEDIT_COMBO_NILISNULL 		0x00800000
#define DWEDIT_COMBO_REQUIRED 		0x00400000

#define DWEDIT_CHECK                0x00000004
#define DWEDIT_CHECK_LEFTTEXT       0x80000000
#define DWEDIT_CHECK_3STATE         0x40000000
#define DWEDIT_CHECK_3D      		0x20000000
#define DWEDIT_CHECK_SCALE     		0x10000000

#define DWEDIT_RADIO				0x00000008
#define DWEDIT_RADIO_LEFTTEXT		0x80000000
#define DWEDIT_RADIO_3D				0x40000000
#define DWEDIT_RADIO_SCALE			0x20000000

#define DWEDIT_DDDW					0x00000010
#define DWEDIT_DDDW_ALLOWEDIT		0x80000000
#define DWEDIT_DDDW_AUTOHSCROLL 	0x40000000
#define DWEDIT_DDDW_VSCROLLBAR		0x20000000
#define DWEDIT_DDDW_ALWAYSSHOWLIST	0x10000000
#define DWEDIT_DDDW_UPPER			0x08000000
#define DWEDIT_DDDW_LOWER			0x04000000
#define DWEDIT_DDDW_HSCROLLBAR		0x02000000
#define DWEDIT_DDDW_HSPLITSCROLL	0x01000000
#define DWEDIT_DDDW_NILISNULL 		0x00800000
#define DWEDIT_DDDW_REQUIRED 		0x00400000
#define DWEDIT_DDDW_USEASBORDER		0x00200000
#define DWEDIT_DDDW_AUTORETRIEVE    0x00100000

#define DWEDIT_EMASK				0x00000020
#define DWEDIT_EMASK_REQUIRED 		0x80000000
#define DWEDIT_EMASK_AUTOSKIP 		0x40000000
#define DWEDIT_EMASK_SPIN     		0x20000000
#define DWEDIT_EMASK_READONLY 		0x10000000
#define DWEDIT_EMASK_CODETABLE		0x08000000
#define DWEDIT_EMASK_USEFORMAT		0x04000000
#define DWEDIT_EMASK_DDCALENDAR		0x02000000
#define DWEDIT_EMASK_USEELLIPSIS 	0x01000000

#define DWEDIT_INKEDIT              0x00000040
#define DWEDIT_INKEDIT_UPPER        0x80000000
#define DWEDIT_INKEDIT_LOWER        0x40000000
#define DWEDIT_INKEDIT_AUTOSELECT	0x20000000
#define DWEDIT_INKEDIT_AUTOHSCROLL  0x08000000
#define DWEDIT_INKEDIT_AUTOVSCROLL  0x04000000
#define DWEDIT_INKEDIT_HSCROLLBAR   0x02000000
#define DWEDIT_INKEDIT_VSCROLLBAR   0x01000000
#define DWEDIT_INKEDIT_DISPLAYONLY  0x00200000
#define DWEDIT_INKEDIT_NILISNULL 	0x00100000
#define DWEDIT_INKEDIT_REQUIRED 	0x00080000

#define DWEDIT_RICH                 0x00000080
#define DWEDIT_RICH_AUTOSELECT		0x80000000
#define DWEDIT_RICH_AUTOHSCROLL     0x40000000
#define DWEDIT_RICH_AUTOVSCROLL     0x20000000
#define DWEDIT_RICH_HSCROLLBAR      0x10000000
#define DWEDIT_RICH_VSCROLLBAR      0x08000000
#define DWEDIT_RICH_DISPLAYONLY 	0x04000000
#define DWEDIT_RICH_NILISNULL 		0x02000000
#define DWEDIT_RICH_REQUIRED 		0x01080000

#define DPXEDIT_COLUMN_NAME         0x00000001
#define DPXEDIT_STYLE_MAINTAINENCE  0x00000002
#define DWXEDIT_COLUMN_NAME         0x00000004
#define DWXEDIT_WINDOW_CALLER       0x00000008

			union editUnion
			{
				LPTSTR dddw_displaycol;		// dddw: dw display column
				LPTSTR spin_range;            // range of spin control
			};

			// Extended column
			//int dwExtCol(PDATAWIN pDatawin, long gob);
			// Extended column edit dialogs
#define DWEDIT_MAX_STYLE_NAME 30
			typedef struct {
				LPTSTR name;                 // name of column
				long  style;                // edit style
				LPTSTR values;				// values
				LPTSTR dddw_name;			// dddw: dw name
				union editUnion u;
				LPTSTR dddw_datacol; 		// dddw: dw data column
				LPTSTR edit_format;			// edit: format
				TCHAR  style_name[DWEDIT_MAX_STYLE_NAME + 1];  // catalog style name
				BOOL  edit_bFocusRect;		// edit: use focus rectangle
				short dddw_pwidth;			// dddw: dw percent width
				short limit;				// edit limit / spin increment
				TCHAR accelerator;			// accelerator character
				short type;					// internal type
				short dddw_lines;   	    // dddw: Lines in drop down
				DWINKATT inkatt;
				DWEDITINKEDIT inkedit;
				DDCALENDARPROPS ddcal_props;
			} EXTCOLEDIT, FAR* PEXTCOLEDIT;
			/* Ptr to struct */
			typedef struct tagEditStyle FAR* PPDWXEDT;

			typedef PBCALLBACK(BOOL, *PB_EDITSTYLECALLBACK) (PPDWXEDT);

			// structure to hold edit style definition information
			typedef struct tagEditStyle
			{
				LPTSTR               pbThis;                // PowerBuilder variables
				ppbstg_anchor       sa;
				pbstg_subpool       subpool;
				LONG                caller_id;
				HWND                hWndDW;                // datawindow handle
				LPTSTR               szAppName;
				LPTSTR               table_name;
				LPTSTR               column_name;
				PEXTCOLEDIT         edit_style_info;
				PEXTCOLEDIT         new_edit_style_info;
				PB_EDITSTYLECALLBACK	pInitCallBackProc;		/* Ptr to initialization callback proc */
				PB_EDITSTYLECALLBACK	pCallBackProc;			/* Ptr to callback proc */
				PVOID               pExtension;
				PVOID               pUserData;
				PVOID               pvFormatBlock;
				LPTSTR           	lpObjectName;       /* datawindow object name */
				TCHAR                workname[DWEDIT_MAX_STYLE_NAME + 1];

				BYTE                edtFlags;
#define   EDTFLAGS_updt_ctlg_allowed      0x80
#define   EDTFLAGS_add_edit_style         0x40
#define   EDTFLAGS_ctlg_style_displayed   0x20
#define   EDTFLAGS_bReturn                0x10
#define   EDTFLAGS_bKeepEditWrkSpace      0x08
#define   EDTFLAGS_updt_win_obj           0x04
#define   EDTFLAGS_bApplyDone             0x02
#define   EDTFLAGS_bPassWord              0x01
				// edtFlags replaces the following since it is non-portable:
				//   BYTE                updt_ctlg_allowed : 1,
				//                       add_edit_style : 1,
				//                       ctlg_style_displayed : 1,
				//                       bReturn : 1,
				//                       bKeepEditWrkSpace : 1,
				//                       updt_win_obj : 1,
				//                       bApplyDone : 1,
				//                       bPassWord : 1;
#ifdef	PS_DBCS	// IMEMODE (KANJI)
				short edit_imemode;
#endif
			}
			PDWXEDT;

			typedef struct {
				HWND		   hwndDW;                  /* current datawindow */
				HWND           hwndCBDW;				/* checkbox datawindow */
				HWND           hwndRBDW;				/* radiobutton datawindow */
				HWND           hwndLBDW;				/* combobox datawindow */
				HWND           hwndDDDW;				/* dropdown datawindow */
				HWND           hwndEDDW;				/* edit datawindow */
				HWND           hwndEMDW;				/* editmask datawindow */
				HWND           hwndCTDW;                /* code table datawindow */
				HWND           hwndEMODW;				/* edit mask options DW */
				HWND           hwndEMI;					/* edit mask sle handle */
				FARPROC        pValidNameRoutine;       /* Routine to validate names */
				PVOID          pValidNameData;          /* Control Block         */
				long           tmWeight;                /* dialog font weight    */
				int            iWorkStyleType;          /* Work style type       */
				BYTE           cWorkDataType;           /* DW data type          */
				TCHAR           stylename[DWEDIT_MAX_STYLE_NAME + 1];

				BYTE           stylFlags;
#define STYLFLAGS_bNeedTestRefresh         0x80
#define STYLFLAGS_bColumnTitle             0x40
#define STYLFLAGS_bAllowNameChange         0x20
#define STYLFLAGS_bUpdateCodeTable         0x10
#define STYLFLAGS_bApplyChanges            0x08
#define STYLFLAGS_bAcceptText              0x04
				// stylFlags replaces the following since it is non-portable:
				// BYTE           bNeedTestRefresh : 1,    /* need to refresh test value */
				//                bColumnTitle : 1,        /* use the column title  */
				//                bAllowNameChange : 1,    /* TRUE = allow editing  */
				//                bUpdateCodeTable : 1,    /* need to update code   */
											   /* for edit mask test    */
				//                bApplyChanges : 1,       /* Apply changes      */
				//                bAcceptText  : 1;        /* Accept text for edit mask DW */

			} DWEDITSTYLESHEET, FAR* PDWEDITSTYLESHEET;
			// Function prototypes for editstyle utilities
			VOID pdwUtilSetEdit(PPDWXEDT pMainEdit);
			VOID pdwUtilSetRich(PPDWXEDT pMainEdit);
			VOID pdwUtilSetInkEdit(PPDWXEDT pMainEdit);
			VOID pdwUtilSetEditMask(PPDWXEDT pMainEdit);
			VOID pdwUtilSetEditRB(PPDWXEDT pMainEdit);
			VOID pdwUtilSetEditCB(PPDWXEDT pMainEdit);
			VOID pdwUtilSetEditDDLB(PPDWXEDT pMainEdit);
			VOID pdwUtilSetEditDDDW(PPDWXEDT pMainEdit);
			LPTSTR pdwUtilUpdateEdit(PPDWXEDT pMainEdit, PEXTCOLEDIT pColumnEdit);
			LPTSTR pdwUtilUpdateRich(PPDWXEDT pMainEdit, PEXTCOLEDIT pColumnEdit);
			LPTSTR pdwUtilUpdateInkEdit(PPDWXEDT pMainEdit, PEXTCOLEDIT pColumnEdit);
			LPTSTR pdwUtilUpdateEditMask(PPDWXEDT pMainEdit, PEXTCOLEDIT pColumnEdit);
			LPTSTR pdwUtilUpdateRB(PPDWXEDT pMainEdit, PEXTCOLEDIT pColumnEdit);
			LPTSTR pdwUtilUpdateCB(PPDWXEDT pMainEdit, PEXTCOLEDIT pColumnEdit);
			LPTSTR pdwUtilUpdateDDLB(PPDWXEDT pMainEdit, PEXTCOLEDIT pColumnEdit);
			LPTSTR pdwUtilUpdateDDDW(PPDWXEDT pMainEdit, PEXTCOLEDIT pColumnEdit);

			// Function prototypes for edit style dialog entry routines
			PBCALLBACK(BOOL, pdxColEditStyleDialog) (HWND, PPDWXEDT);
			// Leave until infomaker is updated for dilbert
			PBCALLBACK(BOOL, pdoColEditMaskDialog)(HWND, PPDWXEDT, FARPROC, PVOID, BOOL);

			// Types of columns currently supported	- DO NOT CHANGE THE ORDER!!!! CAN ONLY APPEND TO THE END
#define DWTYPESTRING     1
#define DWTYPENUMBER     2
#define DWTYPEDATETIME   3
#define DWTYPEDATE       4
#define DWTYPETIME       5
#define DWTYPETIMESTAMP  6
#define DWTYPEBLOB		 7
#define DWTYPELSTRING	 8
#define DWTYPEBOOL		 9
#define DWTYPEDECIMAL	 10
#define DWTYPEREAL  	 11
#define DWTYPELONG  	 12
#define DWTYPEULONG 	 13
#define DWTYPEINT64		 14						// As of 03/18/2007 - only for WSDW retrieval args.
#define DWTYPEMAX		 14

// Accents on columns/computed fields/text objects
#define DWACCENTNOTHING 	0
#define DWACCENTSHADOW		1
#define DWACCENTRECT		2
#define DWACCENTRESIZE		3
#define DWACCENTLINE		4
#define DWACCENT3DLOWERED	5
#define DWACCENT3DRAISED	6
#define DWACCENTBUTTONRAISED  7
#define DWACCENTBUTTONLOWERED 8
#define DWACCENTMAX 		8	/* all other accents are internal */
#define DWACCENTGROUPBOXRAISED  9
#define DWACCENTGROUPBOXLOWERED 10

// Actions associated with button object
#define DWACTIONNOACTION 	0
#define DWACTIONRETRIEVEYIELD 1
#define DWACTIONRETRIEVE	2
#define DWACTIONCANCEL  	3
#define DWACTIONPAGENEXT	4
#define DWACTIONPAGEPRIOR	5
#define DWACTIONPAGEFIRST	6
#define DWACTIONPAGELAST	7
#define DWACTIONSORT        8
#define DWACTIONFILTER      9
#define DWACTIONDELETEROW  10
#define DWACTIONAPPENDROW  11
#define DWACTIONINSERTROW  12
#define DWACTIONUPDATE     13
#define DWACTIONSAVEROWSAS 14
#define DWACTIONPRINT      15
#define DWACTIONPREVIEW    16
#define DWACTIONPREVIEWWITHRULERS 17
#define DWACTIONQUERYMODE  18
#define DWACTIONQUERYSORT  19
#define DWACTIONQUERYCLEAR 20

// Button text's vertical alignment
#define DWVALIGNCENTER      0
#define DWVALIGNTOP         1
#define DWVALIGNBOTTOM      2
#define DWVALIGNMULTILINE   3

// Button text's horizontal alignment
#define DWHALIGNCENTER      0
#define DWHALIGNLEFT        1
#define DWHALIGNRIGHT       2

			union runArgs
			{
				LPTSTR text;             // DWTYPESTRING with listcount == -1
				double FAR* number;     // DWTYPEDOUBLE with listcount == -1
				PSH_DEC dec;
				PSH_TIME dt;			// DWTYPEDATETIME with listcount == -1
				LPTSTR FAR* textlist;   // DWTYPESTRING with listcount != -1
				double FAR* FAR* numberlist;   // DWTYPEDOUBLE with listcount != -1
				PSH_DEC FAR* decimallist;
				PSH_TIME FAR* dtlist;	// DWTYPEDATETIME with listcount != -1
			};

			// Retrieval arguments (runtime retrieve function)
			typedef struct
			{
				BYTE  type;              // DWTYPESTRING, DOUBLE, DATETIME
				short listcount;		 // -1 if not a list; else count
				union runArgs u;
			} DWRETRIEVEARG, FAR* PDWRETRIEVEARG;

			typedef struct
			{
				short argcount;				 // count of arguments in structure
				DWRETRIEVEARG args[1];      // really repeated argcount times
			} DWRETRIEVEARGS, FAR* PDWRETRIEVEARGS;


			// Retrieval Arguments: compile time format structure
#define ARGTYPENUMBER       1
#define ARGTYPENUMBERLIST   2
#define ARGTYPESTRING       3
#define ARGTYPESTRINGLIST   4
#define ARGTYPEDT           5
#define ARGTYPEDTLIST       6
#define ARGTYPEDATE         7
#define ARGTYPEDATELIST     8
#define ARGTYPETIME         9
#define ARGTYPETIMELIST     10
#define ARGTYPEDECIMAL      11
#define ARGTYPEDECIMALLIST  12

			typedef struct {
				TCHAR name[129];      // user name of argument (128 with 0 terminator)
				BYTE type;          // type of argument
				TCHAR value[100];	// default value (for EP in Eclipse)
			} DWBARGENT;

			typedef struct {
				short maxCount;		 // maximum number of args in structure
				short argCount;		 // number of args in structure
				DWBARGENT args[1];  // argument (really repeated argCount times)
			} DWBTBLARG, FAR* PDWBTBLARG;

			typedef struct {
				LPTSTR nestExpr;      // arg expression
			} DWBNESTENT;

			typedef struct {
				short argCount;		 // number of args in structure
				DWBNESTENT args[1];  // argument (really repeated argCount times)
			} DWBNESTARG, FAR* PDWBNESTARG;

			// Stored Procedure Argument structures (subject to revisions)

			typedef struct
			{
				short   type;                   // Datatype of the argument
				short   column;                 // Index of column value to substitute
				LPTSTR  name;                   // Name of the argument
			} DWSPARG, FAR* PDWSPARG;

			typedef struct
			{
				short   argCount;               // Number of arguments
				DWSPARG args[1];                // argCount of arguments
			} DWSPARGS, FAR* PDWSPARGS;

			typedef struct
			{
				LPTSTR transparency;
				LPTSTR blur;
			} DWINFOEFFECTS, FAR* PDWINFOEFFECTS;

			typedef struct
			{
				LPTSTR enabled;
				LPTSTR tip;
				LPTSTR title;
				LPTSTR isBubble;
				LPTSTR textcolor;
				LPTSTR backcolor;
				LPTSTR icon;
				LPTSTR maxwidth;
				LPTSTR transparency;
				LPTSTR delayvisible;
				LPTSTR delayinitial;
				LPTSTR hasclosebutton;
				LPTSTR position;

			} DWINFOTOOLTIP, FAR* PDWINFOTOOLTIP;

			typedef struct
			{
				LPTSTR color;        // LONG: RGB color
				LPTSTR transparency;	//	number (percentage) (0 to 100) 0 = opaque
				LPTSTR gradientcolor;  //second color for gradient
				LPTSTR gradienttransparency;	//	number (percentage) (0 to 100) 0 = opaque
				LPTSTR gradientangle;  //number: gradient directional angle
				LPTSTR brushmode; // enumerated: nogradient, horizontal, vertical, forwarddiagonal, backwarddiagonal, angle, anglescaled
				LPTSTR gradientrepetitionmode;
				LPTSTR gradientrepetitioncount;
				LPTSTR gradientrepetitionlength;
				LPTSTR gradientfocus;
				LPTSTR gradientscale;
				LPTSTR gradientspread;
			} DWFILLBRUSH, FAR* PDWFILLBRUSH;

			// backgrounds: if opaque, used for drawing non-solid lines and text
			typedef struct
			{
				LPTSTR mode;         // int: opaque, transparent
				DWFILLBRUSH fillBrush;
			} DWINFOBK, FAR* PDWINFOBK;

			// brushes: used for filling graphic objects
			typedef struct
			{
				LPTSTR color;        // LONG: RGB color
				LPTSTR hatch;        // int: bdiagonal, cross, diagcross, fdiagonal, horizontal, vertical, solid, transparent
			} DWINFOBR, FAR* PDWINFOBR;

			// fonts: used for drawing text
			typedef struct
			{
				LPTSTR height;       // int: height
				LPTSTR width;        // int: width: 0 to have windows select based on height
				LPTSTR weight;       // int: specify boldface; use 400 or 700
				LPTSTR italic;       // char: nonzero specifies italics
				LPTSTR underline;    // char: nonzero specifies underline
				LPTSTR strikeout;    // char: nonzero specifies strikeout
				LPTSTR charset;      // char: character set; ANSI, OEM
				LPTSTR pitch;        // char: default, fixed, variable
				LPTSTR family;       // char: dontcare, roman, swiss, modern, script, decroative
				LPTSTR face;         // PCHAR: Courier, Helv, TmsRmn, ..
				LPTSTR orientation;  // int:
				LPTSTR escapement;   // int:
			} DWINFOFONT, FAR* PDWINFOFONT;

			// pens: used for all drawing of lines
			typedef struct
			{
				LPTSTR style;        // int: solid, dash, dot, dashdot, dashdotdot, null, insideframe
				LPTSTR width;        // int: width in pixels
				LPTSTR color;        // LONG: RGB color
			} DWINFOPEN, FAR* PDWINFOPEN;

			// Region:
#define DWREGIONTYPEHEADER          1
#define DW_BANDTYPE_DETAIL          2
#define DWREGIONTYPESUMMARY         3
#define DWREGIONTYPEFOOTER          4
#define DWREGIONTYPEGROUPHEADER     5
#define DWREGIONTYPEGROUPTRAILER    6
#define DWREGIONTYPEBACKGROUND    	7
#define DWREGIONTYPEFOREGROUND		8

// Sorting:
			typedef struct {
				LPTSTR keyExpr;		// key expression
				BYTE keySeq;        // ASC: 0   DESC: 1
			} DWINFOSORTKEY, FAR* PDWINFOSORTKEY;

			typedef struct {
				short keyCount;				// number of sort keys
				DWINFOSORTKEY keys[1];      // really repeated keyCount times
			} DWINFOTBLSORT, FAR* PDWINFOTBLSORT;

			typedef struct
			{
				LONG gobs;              // chain of graphic objects
				LONG height;            // height of a particular instance
				short type;			    // type of region
				// Below fields only meaningfull if type == DWREGIONTYPEGROUP...
				short level;		    // group level
				short item_count;	    // number of group by items
				LPTSTR FAR* items;	    // group by expressions
				LPTSTR pointer;		    // pointer for region
				DWFILLBRUSH fillBrush;
				PDWINFOTBLSORT pSort;   // sort on group definition
				BOOL newpage;		    // force page on break
				BOOL resetpagecount;    // reset page counter on break
				BOOL bHeightAuto;	    // Calculate height based on variable height gobs
				BOOL bSuppressHeader;	// Suppress the header if not on a group break and not printing and not print preview.
			} DWINFOREGION, FAR* PDWINFOREGION;

			// Bitmap
			typedef struct
			{
				LPTSTR visible;  // visible expression
				LPTSTR obj_name;	// object name
				LPTSTR name; 	// filename
				LPTSTR x;        // x-coordinate of upper left corner of bounding rect
				LPTSTR y;        // y-coordinate of upper left corner of bounding rect
				LPTSTR width;    // width of bounding rect
				LPTSTR height;   // height of bounding rect
				DWINFOEFFECTS effects;
				DWINFOTOOLTIP tooltip;
				LPTSTR transparentcolor;
				LPTSTR invert;	// invert
				LPTSTR tag;		// tag
				LPTSTR pointer;	// pointer
				LPTSTR border;	// border
				LPTSTR htmlLinkExpr;
				LPTSTR htmlLinkTargetExpr;
				LPTSTR htmlLinkArgs;
				LPTSTR htmlAppendedExpr;
				BOOL bResizeable;	// object is resizable
				BOOL bMoveable;		// object is moveable
				BOOL bSlideLeft;            // Slide object left
				BOOL bSlideUpAllAbove;      // Slide object up using all above object
				BOOL bSlideUpDirectlyAbove; // Slide object up using object above it
				BOOL bHideSnake;            // Hide object when snaked
				LPTSTR AccessibleDescription;
				LPTSTR AccessibleName;
				LONG AccessibleRole;
				BOOL bOriginalSize;
				short tabseq;
				LPTSTR enabled;
				BOOL bFocusRect;
			} DWINFOBITMAP, FAR* PDWINFOBITMAP;

			// Table Blob
			typedef struct
			{
				LPTSTR visible;  // visible expression
				LPTSTR obj_name; 	// object name
				LPTSTR x;
				LPTSTR y;
				LPTSTR width;
				LPTSTR height;
				DWINFOTOOLTIP tooltip;
				LPTSTR table;
				LPTSTR keyClause;
				LPTSTR column;
				LPTSTR template_file;
				LPTSTR oleclass;
				LPTSTR clientname;
				LPTSTR tag;		// tag
				LPTSTR pointer;	// pointer
				LPTSTR border;
				BOOL bResizeable;	// object is resizable
				BOOL bMoveable;		// object is moveable
				BOOL bSlideLeft;            // Slide object left
				BOOL bSlideUpAllAbove;      // Slide object up using all above object
				BOOL bSlideUpDirectlyAbove; // Slide object up using object above it
				BOOL bHideSnake;            // Hide object when snaked
				LPTSTR AccessibleDescription;
				LPTSTR AccessibleName;
				LONG AccessibleRole;
				LONG fileType;
				BOOL bHeightAuto;
				short tabseq;
				LPTSTR enabled;
				BOOL bFocusRect;
				BOOL bRichAutoSelect;
				BOOL bRichDisplayOnly;
				BOOL bRichVScrollBar;
			} DWINFOBLOB, FAR* PDWINFOBLOB;

			// Button:
			typedef struct
			{
				LPTSTR visible;  // visible expression
				LPTSTR obj_name;		// object name
				DWINFOFONT font;	// font
				DWINFOEFFECTS effects;
				DWINFOBK bk;        // background
				DWINFOTOOLTIP tooltip;
				LPTSTR color;        // RGB color
				LPTSTR x;            // x-coordinate of upper left corner of rect
				LPTSTR y;            // y-coordinate of upper left corner of rect
				LPTSTR width;        // x-coordinate of lower right corner of rect
				LPTSTR height;       // y-coordinate of lower right corner of rect
				LPTSTR t;            // Points to the character string to be drawn
				LPTSTR accent;		// accent: nothing, underline, shadowbox, box
				LPTSTR tag;			// tag
				LPTSTR pointer;		// pointer
				LPTSTR filename;		// picture filename
				LPTSTR action;		// action
				LPTSTR vTextAlign;	// vertical text alignment
				LPTSTR hTextAlign;	// horizontal text alignment
				BOOL bResizeable;	// object is resizable
				BOOL bMoveable;		// object is moveable
				BOOL bHeightAuto;		    // Calculate height based on content
				BOOL bSlideLeft;            // Slide object left
				BOOL bSlideUpAllAbove;      // Slide object up using all above object
				BOOL bSlideUpDirectlyAbove; // Slide object up using object above it
				BOOL bHideSnake;            // Hide object when snaked
				BOOL bDefaultPicture;
				BOOL bSuppressEventProcessing;
				BOOL bEnabled;
				BOOL bOriginalSize;
				LPTSTR AccessibleDescription;
				LPTSTR AccessibleName;
				LONG AccessibleRole;
				short tabseq;
				LPTSTR enabled;
			} DWINFOBUTTON, FAR* PDWINFOBUTTON;

			typedef struct {
				LPTSTR      visible;     // visible expression
				LPTSTR	   username;	// name user has given to column
				LPTSTR	   format;		// value for format
				DWINFOFONT font;		// font for column
				DWINFOEFFECTS effects;
				DWINFOBK   bk;			// background for column
				DWINFOTOOLTIP tooltip;
				LPTSTR      color;       // color for column
				LPTSTR	   width;		// value for width
				LPTSTR	   height;		// value for height
				LPTSTR      x;           // value for x
				LPTSTR      y;           // value for y
				LPTSTR	   alignment;	// value for alignment
				LPTSTR	   accent;		// value for accent
				LPTSTR	   tag;			// tag
				LPTSTR	   pointer;		// pointer
				LPTSTR     htmlLinkExpr;
				LPTSTR     htmlLinkTargetExpr;
				LPTSTR     htmlLinkArgs;
				LPTSTR     htmlValueIs;
				LPTSTR     htmlAppendedExpr;
				LONG	   editstyle;	// editing style
				LPTSTR      editname;	// edit name
				LPTSTR	   dddw_name;	// when editstyle & DDDW: dw name
				union editUnion u;
				LPTSTR	   dddw_datacol;	// when editstyle & DDDW: dw data column
				LPTSTR      edit_format; // when editstyle & DDDW: edit format
				LPTSTR      protect;     // protect expression
				LONG	   row_in_detail; // row in detail for n-up
				short	   dddw_pwidth;	// when editstyle & DDDW: dropdown width
				short	   editlimit;	// editing limit
				short	   ci;			// column number
				short	   tabseq;		// value for tabbing sequence
				short      dddw_lines;  // lines in drop down dw
				BOOL	   bitmapname;	// bitmapname
				BOOL       edit_bfocusrect;  // when editstyle & DDDW: show focus rect
				TCHAR	   accelerator;	// accelerator character
				BOOL bResizeable;	    // object is resizable
				BOOL bMoveable;		    // object is moveable
				BOOL bHeightAuto;		// Calculate height based on content
				BOOL bSlideLeft;            // Slide object left
				BOOL bSlideUpAllAbove;      // Slide object up using all above object
				BOOL bSlideUpDirectlyAbove; // Slide object up using object above it
				BOOL bHideSnake;            // Hide object when snaked
				BYTE colFlags;
#define   COLFLAGS_bCriteriaRequired      0x80
#define   COLFLAGS_bOverrideEdit          0x40
#define   COLFLAGS_bCrosstabRepeat        0x20
#define   COLFLAGS_bRTOL                  0x10
				// colFlags replaces the following since it is non-portable:
				//    BYTE bCriteriaRequired :1,  // if true, then criteria is required
				//         bOverrideEdit :1,      // if true, use our own edit control
				//         bCrosstabRepeat :1,    // if true, cosstab column must repeat
				//         bRTOL :1,				// if true, right to left support
				//         unused :4;             // free space for flags
#ifdef   PS_DBCS                // IME MODE (KANJI)
				short edit_imemode;
#endif
				LPTSTR AccessibleDescription;
				LPTSTR AccessibleName;
				LONG AccessibleRole;
				DWINKATT inkatt;
				DWEDITINKEDIT inkedit;
				DDCALENDARPROPS ddcal_props;
				short sWidthAuto;
			} DWINFOCOL, FAR* PDWINFOCOL;

			// Column table
			typedef struct {
				LPTSTR	  username; 	// name user has given to column
				LPTSTR     dbname;       // data base name of column
				LPTSTR	  pattern;		// value for validation
				LPTSTR	  validation_msg; // value for validation error msg
				LPTSTR	  values;		// list of values for a combo box
				LPTSTR     compute;      // compute expression (if computed column)
				LPTSTR     initial;      // initial value
				LONG	  length;		// database length
				short	  ci;			// column number
				short	  type;			// type of column
				BOOL	  key;			// key column
				BOOL	  update;		// updateable column
				BOOL      bCriteriaDialog;	// criteria dialog
				BOOL      bIdentity;    // identity column
				BOOL      updatewhereclause; //TRUE if column can be placed in update WHERE clause
				BYTE      decimals;		// number of decimal places
				BOOL	  bBinaryHex;   // binary hex data column
			} DWINFOTCOL, FAR* PDWINFOTCOL;

			// Use this equate in the tab sequence when you want to protect a column
#define DWPROTECTCOLUMN (SHRT_MAX-1)

// Computed field
			typedef struct
			{
				LPTSTR visible;  // visible expression
				LPTSTR obj_name;		// object name
				DWINFOFONT font;	// font
				DWINFOEFFECTS effects;
				DWINFOBK bk;        // background
				DWINFOTOOLTIP tooltip;
				LPTSTR color;        // RGB color
				LPTSTR x;            // top left x coordinate
				LPTSTR y;            // top left y coordinate
				LPTSTR width;        // width of field
				LPTSTR height;       // height of field
				LPTSTR dispsyn;      // display format syntax
				LPTSTR exprsyn;      // syntax of expression
				LPTSTR alignment;    // align: left/right/center
				LPTSTR accent;       // accent:
				LPTSTR tag;			// tag
				LPTSTR pointer;		// pointer
				LPTSTR     htmlLinkExpr;
				LPTSTR     htmlLinkTargetExpr;
				LPTSTR     htmlLinkArgs;
				LPTSTR     htmlValueIs;
				LPTSTR     htmlAppendedExpr;
				short iDataType;    // data type of object
				BOOL bResizeable;	// object is resizable
				BOOL bMoveable;		// object is moveable
				BOOL bHeightAuto;	// Calculate height based on content
				BOOL bSlideLeft;            // Slide object left
				BOOL bSlideUpAllAbove;      // Slide object up using all above object
				BOOL bSlideUpDirectlyAbove; // Slide object up using object above it
				BOOL bHideSnake;            // Hide object when snaked
				BOOL bCrosstabRepeat;       // Repeatable crosstab column
				LPTSTR AccessibleDescription;
				LPTSTR AccessibleName;
				LONG AccessibleRole;
				short tabseq;
				LPTSTR enabled;
				BOOL bFocusRect;
				short sWidthAuto;
			} DWINFOCOMPUTE, FAR* PDWINFOCOMPUTE;

			// Crosstab
			typedef struct
			{
				LPTSTR      columns;      //  columns expression string
				LPTSTR      rows;			//  rows expression string
				LPTSTR      values;       //  values expression string
				PVOID       source_names; //  list of source names
				LONG        RowCount;     // Count of rows
				BYTE        ctFlags;
#define   CT_FLAGS_bCrosstabOnly    0x80
#define   CT_FLAGS_bDynamic         0x40
#define   CT_FLAGS_bFlag3           0x20
#define   CT_FLAGS_bFlag4           0x10
#define   CT_FLAGS_bFlag5           0x08
#define   CT_FLAGS_bFlag6           0x04
#define   CT_FLAGS_bFlag7           0x02
#define   CT_FLAGS_bFlag8           0x01
				// ctFlags replaces the following since it is non-portable:
				//  BYTE      bCrosstabOnly : 1,        // set if this is crosstab style
				//	          bDynamic :1,              // build dynamic crosstab
				//	          bFlag3 :1,                // flag3
				//	          bFlag4 :1,                // flag4
				//	          bFlag5 :1,                // flag5
				//	          bFlag6 :1,                // flag6
				//	          bFlag7 :1,                // flag7
				//	          bFlag8 :1;                // flag8
				LPTSTR AccessibleDescription;
				LPTSTR AccessibleName;
				LONG AccessibleRole;
			}  DWINFOCROSSTAB, FAR* PDWINFOCROSSTAB;

			// structures used when existing crosstab gets modified
			typedef struct
			{
				BOOL  bMatch;
				short oldLevel;
				short newLevel;
			} COLEXPR, FAR* PCOLEXPR;

			typedef struct
			{
				PVOID   prog;
				short   numOldRows;
				short   numOldCols;
				short   numOldVals;
				BOOL    bColChanged;
				BOOL    bValChanged;
				BOOL    bRowChanged;
				PCOLEXPR pColExpr;
				PVOID   newColumns;
				PVOID   newRows;
				PVOID   newValues;
			} CROSSMODEL, FAR* PCROSSMODEL;

			// Graph

			// Graph types
#define DWGR_AREA 				1
#define DWGR_BAR 				2
#define DWGR_BAR3D 				3
#define DWGR_BAR3DOBJ			4
#define DWGR_BARSTACKED			5
#define DWGR_BARSTACKED3DOBJ	6
#define DWGR_COL 				7
#define DWGR_COL3D 				8
#define DWGR_COL3DOBJ			9
#define DWGR_COLSTACKED			10
#define DWGR_COLSTACKED3DOBJ	11
#define DWGR_LINE 				12
#define DWGR_PIE 				13
#define DWGR_SCATTER			14
#define DWGR_AREA3D				15
#define DWGR_LINE3D 			16
#define DWGR_PIE3D 				17

// RoundTo equates
#define DWGR_ROUND_DEFAULT      0
#define DWGR_ROUND_YEARS        1
#define DWGR_ROUND_MONTHS       2
#define DWGR_ROUND_DAYS         3
#define DWGR_ROUND_HOURS        4
#define DWGR_ROUND_MINUTES      5
#define DWGR_ROUND_SECONDS      6
#define DWGR_ROUND_MICROSECONDS 7

// Graph scale values
#define DWGR_SCALE_ACTUAL		1
#define DWGR_SCALE_CUMULATIVE	2
#define DWGR_SCALE_PERCENTAGE	3
#define DWGR_SCALE_CUMPERCENT	4

// Graph scale types
#define DWGR_SCALE_LINEAR		1
#define DWGR_SCALE_LOG10		2
#define DWGR_SCALE_LOGE			3

// Graph sort values
#define DWGR_SORT_UNSORTED      0
#define DWGR_SORT_ASCENDING     1
#define DWGR_SORT_DESCENDING    2

// Graph tics
#define DWGR_TIC_NO				1
#define DWGR_TIC_INSIDE			2
#define DWGR_TIC_OUTSIDE		3
#define DWGR_TIC_STRADDLE		4

// Graph lines
#define DWGR_LINE_NONE       	0
#define DWGR_LINE_SOLID      	1
#define DWGR_LINE_DASH        	2
#define DWGR_LINE_DOT        	3
#define DWGR_LINE_DASHDOT    	4
#define DWGR_LINE_DASHDOTDOT 	5

// Graph legend types
#define DWGR_LEGEND_NONE       	0
#define DWGR_LEGEND_LEFT       	1
#define DWGR_LEGEND_RIGHT      	2
#define DWGR_LEGEND_TOP       	3
#define DWGR_LEGEND_BOTTOM     	4

			typedef struct
			{
				DWINFOFONT font;		// font
				LPTSTR bkcolor;    		// RGB color
				LPTSTR textcolor;    	// RGB color
				LPTSTR align;        	// align: left/right/center
				LPTSTR format;   		// string display format syntax
				LPTSTR autosize;   		// boolean:
				LPTSTR dsplexpr;         // display expression
			} DWINFOGRAPHDISP, FAR* PDWINFOGRAPHDISP;

			typedef struct
			{
				LPTSTR autoscale;    	// boolean
				LPTSTR dsplnlabels;      // int-
				LPTSTR droplines;		// int-line style
				LPTSTR frame;			// int-line style
				LPTSTR label;        	// string label
				LPTSTR majordiv;			// int
				LPTSTR majorgrid;		// int-line style
				LPTSTR majortic;			// int
				LPTSTR maxval;       	// double
				LPTSTR minval;       	// double
				LPTSTR maxvaldatetime;   // datetime
				LPTSTR minvaldatetime;   // datetime
				LPTSTR minordiv;			// int
				LPTSTR minorgrid;		// int-line style
				LPTSTR minortic;			// int
				LPTSTR originline;		// int-line style
				LPTSTR primaryline;		// int-line style
				LPTSTR roundto;			// double
				LPTSTR roundtounit;      // int-
				LPTSTR scaletype;		// int-
				LPTSTR scalevalue;		// int-
				LPTSTR secondaryline;	// int-line style
				LPTSTR shadebackedge;	// boolean
				DWINFOGRAPHDISP dispattr;	// display attributes
				DWINFOGRAPHDISP labeldispattr;	// label display attributes
			} DWINFOGRAPHAXIS, FAR* PDWINFOGRAPHAXIS;

			typedef struct
			{
				LPTSTR visible;  // visible expression
				LPTSTR obj_name;		// object name
				LPTSTR x;            // top left x coordinate
				LPTSTR y;            // top left y coordinate
				LPTSTR width;        // width of field
				LPTSTR height;       // height of field
				LPTSTR tag;			// tag
				LPTSTR pointer;		// pointer
				LPTSTR grtype;		// type of chart
				LPTSTR new3drendering;
				LPTSTR color;		// color
				LPTSTR backcolor;	// background color
				LPTSTR shadecolor;	// shade color
				LPTSTR perspective;	// perspective
				LPTSTR rotation;		// rotation
				LPTSTR title;		// title
				DWINFOTOOLTIP tooltip;
				DWINFOGRAPHDISP titledisp; 	//
				DWINFOGRAPHDISP piedisp; 	//
				DWINFOGRAPHAXIS ax_series;
				DWINFOGRAPHAXIS ax_category;
				DWINFOGRAPHAXIS ax_values;
				LPTSTR series;		// series
				LPTSTR seriessort;	// series sort
				LPTSTR category;		// category
				LPTSTR categorysort;	// category sort
				LPTSTR values;		// values
				LPTSTR spacing;		// spacing
				LPTSTR depth;		// depth
				LPTSTR elevation;	// elevation
				LPTSTR overlappercent; // overlappercent
				LPTSTR border; 		// border
				LPTSTR legendType; 	//
				LPTSTR plotnulldata;            // CR321434_2
				DWINFOGRAPHDISP legenddisp; //
				short range;		// -1:page, 0:all, 1:group 1, ...
				BOOL bResizeable;	// object is resizable
				BOOL bMoveable;		// object is moveable
				BOOL bSizeToDisplay;	// object is sized to display
				BOOL bSlideLeft;            // Slide object left
				BOOL bSlideUpAllAbove;      // Slide object up using all above object
				BOOL bSlideUpDirectlyAbove; // Slide object up using object above it
				BOOL bHideSnake;            // Hide object when snaked
				short iSeriesType;      // Types of expressions
				short iCategoryType;
				short iValuesType;
				LPTSTR AccessibleDescription;
				LPTSTR AccessibleName;
				LONG AccessibleRole;
				short tabseq;
				LPTSTR enabled;
				BOOL bFocusRect;
			} DWINFOGRAPH, FAR* PDWINFOGRAPH;

			// GroupBox:
			typedef struct
			{
				LPTSTR visible;  // visible expression
				LPTSTR obj_name;		// object name
				DWINFOFONT font;	// font
				DWINFOEFFECTS effects;
				DWINFOBK bk;        // background
				DWINFOTOOLTIP tooltip;
				LPTSTR color;        // RGB color
				LPTSTR x;            // x-coordinate of upper left corner of rect
				LPTSTR y;            // y-coordinate of upper left corner of rect
				LPTSTR width;        // x-coordinate of lower right corner of rect
				LPTSTR height;       // y-coordinate of lower right corner of rect
				LPTSTR t;            // Points to the character string to be drawn
				LPTSTR accent;		// accent: nothing, underline, shadowbox, box
				LPTSTR tag;			// tag
				LPTSTR pointer;		// pointer
				BOOL bResizeable;	// object is resizable
				BOOL bMoveable;		// object is moveable
				BOOL bHeightAuto;		    // Calculate height based on content
				BOOL bSlideLeft;            // Slide object left
				BOOL bSlideUpAllAbove;      // Slide object up using all above object
				BOOL bSlideUpDirectlyAbove; // Slide object up using object above it
				BOOL bHideSnake;            // Hide object when snaked
				BOOL bRTOL;            // Right to left
				LPTSTR AccessibleDescription;
				LPTSTR AccessibleName;
				LONG AccessibleRole;
			} DWINFOGROUPBOX, FAR* PDWINFOGROUPBOX;

			//  Line
			typedef struct
			{
				LPTSTR visible;  // visible expression
				LPTSTR obj_name;		// object name
				DWINFOPEN pen;		// pen
				DWINFOBK bk;        // background
				DWINFOTOOLTIP tooltip;
				LPTSTR x1;           // x-coordinate of start of line segment
				LPTSTR y1;           // y-coordinate of start of line segment
				LPTSTR x2;           // x-coordinate of end of line segment
				LPTSTR y2;           // y-coordinate of end of line segment
				LPTSTR tag;			// tag
				LPTSTR pointer;		// pointer
				BOOL bResizeable;	// object is resizable
				BOOL bMoveable;		// object is moveable
				BOOL bSlideLeft;            // Slide object left
				BOOL bSlideUpAllAbove;      // Slide object up using all above object
				BOOL bSlideUpDirectlyAbove; // Slide object up using object above it
				BOOL bHideSnake;            // Hide object when snaked
			} DWINFOLINE, FAR* PDWINFOLINE;

			typedef struct
			{
				LPTSTR       pGeoRetrieve;          // Pin sql statement
				LPTSTR       pThematicDomain;       // Thematic domain
				LPTSTR       pGeoDomain;            // Geo domain
				PVOID       pDW;                   // runtime pDW
			} DWINFOSMI, FAR* PDWINFOSMI;

			// OLE:
			typedef struct
			{
				LPTSTR visible;      // visible expression
				LPTSTR obj_name;		// object name
				LPTSTR x;            // x-coordinate of upper left corner of rect
				LPTSTR y;            // y-coordinate of upper left corner of rect
				LPTSTR width;        // x-coordinate of lower right corner of rect
				LPTSTR height;       // y-coordinate of lower right corner of rect
				DWINFOTOOLTIP tooltip;
				LPTSTR tag;			// tag
				LPTSTR pointer;		// pointer
				LPTSTR border;       // border
				LPTSTR target;       // target data
				LPTSTR summary;      // summary data
				PVOID pBinary;      // Ptr to binary contents
				LPTSTR clientname;   // clientname
				PVOID pOleExtra;    // extra ole info
				short type;         // ole type
				INT   activation;   // Activation type
				INT   displaytype;  // Display type
				INT   contentsallowed;    // Contents allowed
				INT   linkupdateoptions;  // Link update options
				INT   row;          // range
				BOOL  isdragtarget; // Drag target
				BOOL  bOleInsert;   // if true, data was inserted
				BOOL  bResizeable;	// object is resizable
				BOOL  bMoveable;	// object is moveable
				BOOL  bSlideLeft;   // Slide object left
				BOOL  bSlideUpAllAbove;      // Slide object up using all above object
				BOOL  bSlideUpDirectlyAbove; // Slide object up using object above it
				BOOL  bHideSnake;   // Hide object when snaked
				BOOL  bSizeToDisplay;	// object is sized to display
				LPTSTR AccessibleDescription;
				LPTSTR AccessibleName;
				LONG AccessibleRole;
				short tabseq;
				LPTSTR enabled;
				BOOL bFocusRect;
			} DWINFOOLE, FAR* PDWINFOOLE;

			// OLE:
			typedef struct
			{
				LPTSTR visible;  // visible expression
				LPTSTR obj_name; 	// object name
				LPTSTR x;
				LPTSTR y;
				LPTSTR width;
				LPTSTR height;
				DWINFOTOOLTIP tooltip;

				LPTSTR table;
				LPTSTR keyClause;
				LPTSTR column;
				LPTSTR bkcolumnName;

				//props of inkpic
				BOOL inkpic_autoerase;
				LONG inkpic_bkcolor;
				short inkpic_collectionmode;
				BOOL inkpic_dynrender;
				short inkpic_editmode;
				BOOL inkpic_enabled;
				short inkpic_erasermode;
				LONG inkpic_eraserwidth;
				BOOL inkpic_highcontrastink;
				BOOL inkpic_inkenabled;
				LONG inkpic_marginx;
				LONG inkpic_marginy;
				LPTSTR inkpic_pointer;
				short inkpic_picsizemode;

				//props of ink
				BOOL ink_antialiased;
				BOOL ink_ignorepressure;
				LONG ink_inkcolor;
				LONG ink_inkheight;
				LONG ink_inkwidth;
				short ink_pentip;
				short ink_transparency;
				//unsupport ink props
				LPTSTR ink_fittocurve;
				LPTSTR ink_rasteroperation;

				LPTSTR tag;		// tag
				LPTSTR pointer;	// pointer
				LPTSTR border;
				BOOL bResizeable;	// object is resizable
				BOOL bMoveable;		// object is moveable
				BOOL bSlideLeft;            // Slide object left
				BOOL bSlideUpAllAbove;      // Slide object up using all above object
				BOOL bSlideUpDirectlyAbove; // Slide object up using object above it
				BOOL bHideSnake;            // Hide object when snaked

				LPTSTR AccessibleDescription;
				LPTSTR AccessibleName;
				LONG AccessibleRole;
				short row_in_detail;
			} DWINFOINKPIC, FAR* PDWINFOINKPIC;

			// Oval:
			typedef struct
			{
				LPTSTR visible;  // visible expression
				LPTSTR obj_name;		// object name
				DWINFOPEN pen;		// pen
				DWINFOBR brush; 	// brush
				DWINFOBK bk;		// background
				DWINFOTOOLTIP tooltip;
				LPTSTR x;			// x-coordinate of upper left corner of rect
				LPTSTR y;			// y-coordinate of upper left corner of rect
				LPTSTR width;		// x-coordinate of lower right corner of rect
				LPTSTR height;		// y-coordinate of lower right corner of rect
				LPTSTR tag;			// tag
				LPTSTR pointer;		// pointer
				BOOL bResizeable;	// object is resizable
				BOOL bMoveable;		// object is moveable
				BOOL bSlideLeft;            // Slide object left
				BOOL bSlideUpAllAbove;      // Slide object up using all above object
				BOOL bSlideUpDirectlyAbove; // Slide object up using object above it
				BOOL bHideSnake;            // Hide object when snaked
			} DWINFOOVAL, FAR* PDWINFOOVAL;

			// Rectangle:
			typedef struct
			{
				LPTSTR visible;  // visible expression
				LPTSTR obj_name;		// object name
				DWINFOPEN pen;		// pen
				DWINFOBR brush;     // brush
				DWINFOBK bk;        // background
				DWINFOTOOLTIP tooltip;
				LPTSTR x;            // x-coordinate of upper left corner of rect
				LPTSTR y;            // y-coordinate of upper left corner of rect
				LPTSTR width;        // x-coordinate of lower right corner of rect
				LPTSTR height;       // y-coordinate of lower right corner of rect
				LPTSTR tag;			// tag
				LPTSTR pointer;		// pointer
				BOOL bResizeable;	// object is resizable
				BOOL bMoveable;		// object is moveable
				BOOL bSlideLeft;            // Slide object left
				BOOL bSlideUpAllAbove;      // Slide object up using all above object
				BOOL bSlideUpDirectlyAbove; // Slide object up using object above it
				BOOL bHideSnake;            // Hide object when snaked
			} DWINFORECT, FAR* PDWINFORECT;

			// Round Rectangle:
			typedef struct
			{
				LPTSTR visible;  // visible expression
				LPTSTR obj_name;		// object name
				DWINFOPEN pen;		// pen
				DWINFOBR brush;     // brush
				DWINFOBK bk;        // background
				DWINFOTOOLTIP tooltip;
				LPTSTR x;            // x-coordinate of upper left corner of rect
				LPTSTR y;            // y-coordinate of upper left corner of rect
				LPTSTR width;        //
				LPTSTR height;       //
				LPTSTR ellipse_width;    // width of ellipse for corner
				LPTSTR ellipse_height;   // heigth of ellipse for corner
				LPTSTR tag;			// tag
				LPTSTR pointer;		// pointer
				BOOL bResizeable;	// object is resizable
				BOOL bMoveable;		// object is moveable
				BOOL bSlideLeft;            // Slide object left
				BOOL bSlideUpAllAbove;      // Slide object up using all above object
				BOOL bSlideUpDirectlyAbove; // Slide object up using object above it
				BOOL bHeightAuto;		// Calculate height based on content
				BOOL bHideSnake;            // Hide object when snaked
			} DWINFORRECT, FAR* PDWINFORRECT;

			// Report:
			typedef struct
			{
				LPTSTR visible;      // visible expression
				LPTSTR obj_name;		// object name
				LPTSTR x;            // x-coordinate of upper left corner of rect
				LPTSTR y;            // y-coordinate of upper left corner of rect
				LPTSTR width;        // x-coordinate of lower right corner of rect
				LPTSTR height;       // y-coordinate of lower right corner of rect
				DWINFOTOOLTIP tooltip;
				LPTSTR criteria;     // criteria
				LPTSTR dataobject;   // report name
				LPTSTR tag;			// tag
				LPTSTR pointer;		// pointer
				LPTSTR border;       // border
				PDWBNESTARG nestArgs; // nest arguments
				BOOL bResizeable;	// object is resizable
				BOOL bMoveable;		// object is moveable
				BOOL bSlideLeft;            // Slide object left
				BOOL bSlideUpAllAbove;      // Slide object up using all above object
				BOOL bSlideUpDirectlyAbove; // Slide object up using object above it
				BOOL bHeightAuto;   // auto height
				BOOL bHideSnake;    // Hide object when snaked
				BOOL bNewPage;      // Start fromnew page
				BOOL bShowBackground;
				BOOL bTrailFooter;  // Trail footer
				LPTSTR AccessibleDescription;
				LPTSTR AccessibleName;
				LONG AccessibleRole;
				short tabseq;
				LPTSTR enabled;
				BOOL bFocusRect;
			} DWINFOREPORT, FAR* PDWINFOREPORT;

			// table structure
#define DWTABLEDATA         1
#define DWTABLESELECT       2
#define DWTABLEPROCEDURE    3
#define DWTABLEUNBOUNDED    4
#define DWTABLEWEBSERVICE   5

#define DWTABLE_WHERE_KEYONLY	  0
#define DWTABLE_WHERE_KEYANDUPDATE 1
#define DWTABLE_WHERE_KEYANDMODIFY 2
#define DWTABLE_WHERE_MAX 2

			typedef struct               // crosstab data definition
			{
				short numLevels;          // # of levels
				short filler;
				LPTSTR pData[1];           // Ptr to data for a level (repeated numLevels times)
			} infoCrossData, FAR* pinfoCrossData;

			typedef struct webServiceMetadataStrings
			{
				LPTSTR	m_assembly;				// Assembly for accessing the web service
				LPTSTR  m_namespace;			// Namespace(s) in the assembly
				LPTSTR	m_classname;			// The main class name for the Web service
				LPTSTR  m_method;				// Method to invoke from the Web Service
				LPTSTR  m_methoddefinition;		// Method definition.
				LPTSTR  m_resultset;			// Resultset definition
				LPTSTR  m_structurename;		// Name of the WS structure "containing" the resultset.
				LPTSTR	m_inputparms;			// Input (retrieval args) parameters
				LPTSTR	m_WSDL;					// Originating WSDL
				LONG	m_resultsetparm;		// Number of the resultset parameter, -1 = [RET].

				// Methods
				inline LPTSTR GetMethodName()
				{
					return m_method;
				}

				inline LPTSTR GetWSInfo()
				{
					if (m_WSDL == NULL)
						return (LPTSTR)m_assembly;
					else
						return m_WSDL;
				}

			} DWWSMETA, * PDWWSMETA;

#define UPDMETHODSQL                    0       // The default
#define UPDMETODSQLSTRING               PBTEXT("SQL")
#define UPDMETHODSP                     1       // Stored procedure
#define UPDMETHODSPSTRING               PBTEXT("SP")
#define UPDMETHODWS						3
#define UPDMETHODWSSTRING				PBTEXT("WS")

			typedef struct						// information for updating with stored procedure
			{
				LPTSTR   spArgName;				// Argname from the provider (SP or WS)
				LPTSTR   spColName;				// Column name assoicated with the arg
				LPTSTR   spExpression;			// Expression (if used)
				short	ordinal;				// Ordinal position (if Web Service)
				short    spColId;
				short    spMatch;
				short    spInOut;
				BOOL     bOriginalValue;
			} DWINFOUPDATEARG, FAR* PDWINFOUPDATEARG;

			typedef struct					// information for updating with stored procedure
			{
				short		type;				// Update type
				LPTSTR		spName;				// name of stored procedure (if stored procedure)
				PDWWSMETA	ws_MetaData;		// Web service meta data (if web service)
				short		argCount;			// # arguments
				short		filler;
				DWINFOUPDATEARG spArg[1];   // Ptr to first argument structure
			} DWINFOUPDATE, FAR* PDWINFOUPDATE;

			typedef struct
			{
				PDWINFOTBLSORT sort; // sort definition of table
				PDWBTBLARG rargs;   // retrieval arguments
				LPTSTR updttbl;		// name of table
				LPTSTR exprSyn;      // syntax of expression
				LPTSTR select;       //  select syntax
				LPTSTR nl;           //  natural language syntax
				LPTSTR savedata;     //  saved data
				short numCols;		 // number of columns
				short type;			// type of table
				short update_where;	// type of update where clause to build
				BOOL update_keyinplace; // use update not (delete/insert)
				BOOL updateable;	// data window is updateable
				BOOL bRetrieveAsreq;	// retrieve rows as needed
				BOOL bRetrieveMem;		// retrieve rows into memory
				pinfoCrossData pCrossData;    // set of column values for crosstab style
				PDWINFOUPDATE pUpdateInsert;
				PDWINFOUPDATE pUpdateDelete;
				PDWINFOUPDATE pUpdateUpdate;
				LPTSTR	m_assembly;				// Assembly for accessing the web service
				LPTSTR  m_namespace;			// Namespace(s) in the assembly
				LPTSTR	m_classname;			// The main class name for the Web service
				LPTSTR  m_directory;			// Directory location of the assembly if design time
				LPTSTR  m_method;				// Method to invoke from the Web Service
				LPTSTR  m_methoddefinition;		// Method definition (XML).
				LPTSTR  m_structurename;		// Structure that "contains" the resultset
				LPTSTR  m_inputparms;			// Input parms that get mapped to retrieval args.
				LPTSTR  m_WSDL;					// WSDL file/URL.
				INT		m_resultsetparm;		// Resultset parameter number, -1 = [RET].
			} DWINFOTABLE, FAR* PDWINFOTABLE;

			// Draw text:
			typedef struct
			{
				LPTSTR visible;  // visible expression
				LPTSTR obj_name;		// object name
				DWINFOFONT font;	// font
				DWINFOEFFECTS effects;
				DWINFOBK bk;        // background
				DWINFOTOOLTIP tooltip;
				LPTSTR color;        // RGB color
				LPTSTR align;        // computed from tabstop and align
				LPTSTR x;            // x-coordinate of upper left corner of rect
				LPTSTR y;            // y-coordinate of upper left corner of rect
				LPTSTR width;        // x-coordinate of lower right corner of rect
				LPTSTR height;       // y-coordinate of lower right corner of rect
				LPTSTR t;            // Points to the character string to be drawn
				LPTSTR accent;		// accent: nothing, underline, shadowbox, box
				LPTSTR tag;			// tag
				LPTSTR pointer;		// pointer
				LPTSTR     htmlLinkExpr;
				LPTSTR     htmlLinkTargetExpr;
				LPTSTR     htmlLinkArgs;
				LPTSTR     htmlValueIs;
				LPTSTR     htmlAppendedExpr;
				BOOL bResizeable;	// object is resizable
				BOOL bMoveable;		// object is moveable
				BOOL bHeightAuto;		    // Calculate height based on content
				BOOL bSlideLeft;            // Slide object left
				BOOL bSlideUpAllAbove;      // Slide object up using all above object
				BOOL bSlideUpDirectlyAbove; // Slide object up using object above it
				BOOL bHideSnake;            // Hide object when snaked
				LPTSTR AccessibleDescription;
				LPTSTR AccessibleName;
				LONG AccessibleRole;
				short tabseq;
				LPTSTR enabled;
				BOOL bFocusRect;
			} DWINFOTEXT, FAR* PDWINFOTEXT;

			typedef struct
			{
				DWINFOTOOLTIP tooltip;
				LPTSTR visible;  // visible expression
				LPTSTR obj_name;		// object name
				LPTSTR x;            // x-coordinate of upper left corner of rect
				LPTSTR y;            // y-coordinate of upper left corner of rect
				LPTSTR width;        // x-coordinate of lower right corner of rect
				LPTSTR height;       // y-coordinate of lower right corner of rect

				LPTSTR xaml;
				LPTSTR contentProperty;
				LPTSTR itemsProperty;
				LPTSTR table;
				LPTSTR keyClause;
				LPTSTR column;

				LPTSTR AccessibleDescription;
				LPTSTR AccessibleName;
				LONG AccessibleRole;
				LPTSTR pointer;		// pointer

				BOOL bResizeable;	// object is resizable
				BOOL bMoveable;		// object is moveable
				BOOL bSlideUpAllAbove;      // Slide object up using all above object
				BOOL bSlideUpDirectlyAbove; // Slide object up using object above it
				BOOL bHideSnake;            // Hide object when snaked

				short ci;
				short tabseq;
				LPTSTR enabled;
				BOOL bFocusRect;
			} DWINFOWPF, FAR* PDWINFOWPF;

			//TreeView DataWindow
			typedef struct gentreeLevelStruct
			{
				LPTSTR ExpandTreeNodeIconName;
				LPTSTR CollapseTreeNodeIconName;
				LONG ExpandTreeNodeIconTransColor;
				LONG CollapseTreeNodeIconTransColor;
				gentreeLevelStruct* pNext;
				gentreeLevelStruct* pPrev;
				LPTSTR ExpandTreeNodeIconName_expr;
				LPTSTR CollapseTreeNodeIconName_expr;
				LPTSTR ExpandTreeNodeIconTransColor_expr;
				LPTSTR CollapseTreeNodeIconTransColor_expr;
			} gen_treeLevel, * pgen_treeLevel;

			typedef struct
			{
				LONG MaxLevel;
				BOOL bShowLines;
				BOOL bConnectLeafNodes;
				LONG Indent;
				BOOL bShowTreeNodeIcon;
				pgen_treeLevel TreeLevels;
				pgen_treeLevel pLastLevel;
				LONG lDefaultExpandToLevel;//1 base;0 means that no level is expanded.
				SHORT StateIconAlignMode;//0:Mid,1:Top,2,Bottom.
				BOOL	bSelectNodeByMouse;
				BOOL  bRtoLLayout;
				//LONG type; //0:no tree,1:group,2:free
			} gen_treeInfo, * pgen_treeInfo;
#define DW_TREEVIEW_SYMBOL_SIZE 16
#define DW_TREEVIEW_STATE_SIZE 9
#define DW_TREEVIEW_STATE_OFFSET 4
#define DW_TREEVIEW_LINE_COLOR  (RGB(122,122,122))
			// Anchor block for all information
			typedef struct
			{
				PVOID prog;         // program
				ppbstg_anchor sa;   // storage anchor
				pbstg_subpool subpool; // subpool for allocation
				PVOID stglist;      // list of storage allocated
				PVOID rgnlist;      // list of regions
				LONG currentGob;    // current gob in current region
				short  curCol;		 // current column in table
				pgen_treeInfo pTree;
			} DWINFO, FAR* PDWINFO;

			// Special support for testing of expressions
			typedef struct              // Column information
			{
				BYTE  coltype;						// type of column
				BYTE  bColUsed;				// column used
				LPTSTR colname;						// name of column
				LONG colid;							// column id of column
				LONG  collen;                       // length of column
			} DWEXPRCOL, FAR* PDWEXPRCOL;

			typedef struct              // Gob information
			{
				LPTSTR pName;                        // Name of gob
				short iObjType;                     // Object type
				short iDataType;                    // Data type (if known)
			} DWEXPRGOB, FAR* PDWEXPRGOB;

			typedef struct              // Background information for expression
			{
				ppbstg_anchor sa;                   // storage anchor
				pbstg_subpool subpool;              // storage subpool
				PVOID obthis;						// POB_THIS pointer or NULL;
				LPTSTR syntax;                       // syntax to parse
				LONG  collen;                       // return column length
				short numCols;						// number of columns
				short numLevels;					// number of group levels
				BYTE coltype;						// return column type
				PVOID names;						// hash table of names
				PVOID pGobRunHash;					// hash table of runtime pwinGobs
				PVOID pGobPaintHash;				// hash table of PDWEXPRGOBs
				PVOID pArgRun;					    // Runtime arguments (PTBLARGS)
				PVOID pArgPaint;				    // Painter arguments (PDWBTBLARG)
				TCHAR errmsg[256];					// error message
				PVOID pWebUserFunctionCallBack;		// call back function for calling user function in PB .NET.
				DWEXPRCOL cols[1];                  // really repeated numCols
			} DWEXPRTEST, FAR* PDWEXPRTEST;

			// Special support for generating stored procedure and data retrieval types

			typedef struct              // Column information
			{
				PVOID pExtInfo;                     // can be PDWINFOCOLUMN or PDWINFOCOMPUTE
				BOOL  bBold;                        // if TRUE, make font bold
			} DWCOLEXT, FAR* PDWCOLEXT;

			typedef struct              // Column information
			{
				PVOID       prog;                   // model pDW
				PCROSSMODEL pModel;                 // model for crosstab
				PDWINFOFONT hdrFont;                // default header font
				PDWINFOBK   hdrBk;                  // default hdr bk
				LPTSTR       hdrColor;               // default hdr color
				LPTSTR       hdrBorder;              // default hdr border
				LONG        hdrHeight;              // height of the header text
				PDWINFOFONT dataFont;               // default data font
				PDWINFOBK   dataBk;                 // default data bk
				LPTSTR       dataColor;              // default data color
				LONG        dataHeight;             // height of the detail column
				LPTSTR       dataBorder;             // default data border
			} DWDATAEXT, FAR* PDWDATAEXT;


			typedef struct              // Column information
			{
				TCHAR name[512];                      // name of column
				TCHAR alias[512];
				TCHAR dwname[512];					// valid name for dw column gob CR419473. it is a runtime name for dw syntax generation.
				BYTE  coltype;                       // type of column
				LONG  collen;                       // length of column
				LPTSTR lpHeader;						// header of column
				short decimals;						// number of decimals
				LONG  width;                        // width of column
				LPTSTR expression;                   // expression if computed column
				PDWCOLEXT pColExt;                  // additional column/compute information
				BOOL key;						 // column is a key column (for ADO DataSets)
			} DWDATACOL, FAR* PDWDATACOL;

			typedef struct              // Background information for data/ sp
			{
				PDWDATAEXT pDataExt;                // extension for the model dw
				short numCols;						// number of columns
				LPTSTR	m_assembly;				// Assembly for accessing the web service
				LPTSTR  m_namespace;			// Namespace(s) in the assembly
				LPTSTR	m_classname;			// The main class name for the Web service
				LPTSTR  m_method;				// Method to invoke from the Web Service
				LPTSTR  m_methoddefinition;	    // Method definition.
				LPTSTR  m_structurename;		// Structure that "contains" the resultset
				LPTSTR	m_inputparms;			// Input (retrieval args) parameters
				LPTSTR  m_WSDL;					// WSDL file string.
				INT		m_resultsetparm;		// Resultset parm number, -1 = [RET].
				DWDATACOL cols[1];                  // really repeated numCols
			} DWDATATABLE, FAR* PDWDATATABLE;

#define DWFSAVEAS_BUFSIZE 256

			typedef struct {
				TCHAR filename[DWFSAVEAS_BUFSIZE];  // file name
				int saveastype;                       // file type
				int encodingtype;                   // encoding type
			} DWFSAVEAS, FAR* PDWFSAVEAS;


			// Syntax generation routines
			PBWINAPI(LPTSTR, dwSyntaxGen)(ppbstg_anchor sa, PVOID db, LPTSTR selectSyn, LPTSTR tableName, LPTSTR keys, PDWBTBLARG args);
			PBWINAPI(LPTSTR, dwSyntaxGenForm)(ppbstg_anchor sa, PVOID db, LPTSTR selectSyn, LPTSTR tableName, LPTSTR keys, PDWBTBLARG args);
			PBWINAPI(void, dwSyntaxFree)(ppbstg_anchor sa, LPTSTR progSyn);
			PBWINAPI(LPTSTR, dwGenDataListSyntax)(ppbstg_anchor sa, PDWDATATABLE dtable, LPTSTR sp, PDWBTBLARG arg);
			PBWINAPI(LPTSTR, dwGenDataFormSyntax)(ppbstg_anchor sa, PDWDATATABLE dtable, LPTSTR sp, PDWBTBLARG arg);
			PBWINAPI(LPTSTR, dwSyntaxFromSQL)(ppbstg_anchor sa, pbstg_subpool subpool,
				PVOID db, LPTSTR selectSyn, PDWBTBLARG args,
				LPTSTR style, LPTSTR errmsg);
			PBWINAPI(LPTSTR, dwSyntaxFromDesc)(ppbstg_anchor sa, pbstg_subpool subpool,
				PDWDATATABLE dtable, LPTSTR sp, PDWBTBLARG args,
				LPTSTR style, LPTSTR errmsg);

			// Functions for interacting with a data window program
			PBWINAPI(long, dwClearOriginalValues)(HWND hWnd);

			PBWINAPI(short, dwRowsDiscard)(HWND hWnd, LONG lStartRow, LONG lEndRow, short queue);
#define DW_DATA_MOVE        0x0001
#define DW_DATA_COPY        0x0002
			PBWINAPI(short, dwRowsMove)(HWND hWndFrom, LONG lStartRow, LONG lEndRow, short queueFrom,
				HWND hWndTo, LONG lInsertRow, short queueTo, UINT iFlags);
#define DW_DEFAULT_OK			-1
#define DW_DEFAULT_ARGUNDEFINED -2
			//#define DW_DEFAULT_ARGUNUSED  >=0 contains first unreferenced argument
			PBWINAPI(PVOID, dwCreateObjectStorage) (HWND hWnd, PVOID obInst, PVOID obThis);
			PBWINAPI(LPTSTR, dwDefaultArgs)(ppbstg_anchor sa, LPTSTR selectSyn, PVOID db, PDWBTBLARG arg, short FAR* rc);
			PBWINAPI(void, dwDefaultArgsFree)(ppbstg_anchor sa, LPTSTR syn);
			PBWINAPI(HWND, dwCrosstabDef)(PVOID prog, PVOID FAR* pData);
			PBWINAPI(HWND, dwCrosstabDefDynamic)(PVOID pMainStg, PVOID FAR* pvData);
			PBWINAPI(HWND, dwCrosstabModifyDynamic)(PVOID pMainStg, PVOID FAR* pvData, PCROSSMODEL pModel, PVOID baseTbl);
			PBWINAPI(HWND, dwCrosstabModifyStatic)(PVOID pMainStg, PVOID FAR* pvData, PCROSSMODEL pModel, PVOID baseTbl);
			PBWINAPI(PCROSSMODEL, dwCrosstabBuildModel) (PVOID prog, LPTSTR columns, LPTSTR rows, LPTSTR values, PVOID baseTbl, PVOID runProg);
			PBWINAPI(void, dwInfoBegin)(PVOID prog, PDWINFO ia);
			PBWINAPI(void, dwInfoBitmap)(PDWINFO ia, LONG lbk, PDWINFOBITMAP bk);
			PBWINAPI(void, dwInfoBlob)(PDWINFO ia, LONG lblob, PDWINFOBLOB bm);
			PBWINAPI(void, dwInfoInkpic)(PDWINFO ia, LONG lblob, PDWINFOINKPIC bm);
			PBWINAPI(void, dwInfoButton)(PDWINFO ia, LONG lblob, PDWINFOBUTTON bt);
			PBWINAPI(void, dwInfoColumn)(PDWINFO ia, LONG lc, PDWINFOCOL c);
			PBWINAPI(void, dwInfoCompute)(PDWINFO ia, LONG lc, PDWINFOCOMPUTE c);
			PBWINAPI(void, dwInfoCrosstab)(PDWINFO ia, LONG lc, PDWINFOCROSSTAB c);
			PBWINAPI(void, dwInfoWpf)(PDWINFO ia, LONG lblob, PDWINFOWPF w);
			PBWINAPI(void, dwInfoDataWindow)(PDWINFO ia, PDWOPTIONS dwo);
			PBWINAPI(void, dwInfoEnd)(PDWINFO ia);
			PBWINAPI(void, dwInfoFunctions)(ppbstg_anchor, HWND hWnd, short level, INT* iNumFuncs, PSHLIST pFuncs);
			PBWINAPI(BOOL, dwInfoGetFirstColumn)(PDWINFO ia, PDWINFOTCOL c);
			PBWINAPI(BOOL, dwInfoGetNextColumn)(PDWINFO ia, PDWINFOTCOL c);
			PBWINAPI(LONG, dwInfoGetDWWidth)(HWND hWnd);
			PBWINAPI(LONG, dwInfoGetFirstObject)(PDWINFO ia);
			PBWINAPI(LONG, dwInfoGetNextObject)(PDWINFO ia);
			PBWINAPI(short, dwInfoGetObjectType)(PDWINFO ia, LONG obj);
			PBWINAPI(void, dwInfoGraph)(PDWINFO ia, LONG lgraph, PDWINFOGRAPH g);
			PBWINAPI(void, dwInfoGroupBox)(PDWINFO ia, LONG lgraph, PDWINFOGROUPBOX g);
			PBWINAPI(void, dwInfoLine)(PDWINFO ia, LONG lline, PDWINFOLINE l);
			PBWINAPI(void, dwInfoOle)(PDWINFO ia, LONG lole, PDWINFOOLE o);
			PBWINAPI(void, dwInfoOval)(PDWINFO ia, LONG loval, PDWINFOOVAL o);
			PBWINAPI(short, dwInfoProcessType)(PVOID prog);
			PBWINAPI(void, dwInfoRect)(PDWINFO ia, LONG lrect, PDWINFORECT r);
			PBWINAPI(BOOL, dwInfoRegionFirst)(PDWINFO ia, PDWINFOREGION r);
			PBWINAPI(BOOL, dwInfoRegionNext)(PDWINFO ia, PDWINFOREGION r);
			PBWINAPI(void, dwInfoReport)(PDWINFO ia, LONG lrect, PDWINFOREPORT r);
			PBWINAPI(PVOID, dwInfoResourceNames)(ppbstg_anchor sa, pbstg_subpool subpool, LPTSTR lpLibrary, LPTSTR lpEntry);
			PBWINAPI(void, dwInfoRoundRect)(PDWINFO ia, LONG lrect, PDWINFORRECT r);
			PBWINAPI(LPTSTR, dwInfoSparse)(PDWINFO ia);
			PBWINAPI(void, dwInfoTable)(PDWINFO ia, PDWINFOTABLE t);
			PBWINAPI(PVOID, dwInfoTableExtract) (PVOID prog);
			PBWINAPI(void, dwInfoText)(PDWINFO ia, LONG ltext, PDWINFOTEXT t);
			PBWINAPI(short, dwInfoVerifyCompute)(PDWEXPRTEST gx);
			PBWINAPI(short, dwInfoVerifyFilter)(PDWEXPRTEST gx);
			PBWINAPI(PVOID, dwInfoVerifyStmt)(PDWEXPRTEST gx);
			PBWINAPI(short, dwInfoVerifyString)(PDWEXPRTEST gx);
			PBWINAPI(PVOID, dwInfoParseStmt)(PDWEXPRTEST gx);
			PBWINAPI(void, dwInfoSetPSRFileName)(PVOID prog, LPOLESTR szFileName, short iLen);

			// Functions for interacting with an open data window
#define DW_RC_OK        0       // Request satisfied
#define DW_RC_BADROW    -1      // Row # provided is not valid
#define DW_RC_BADCOL    -2      // Column # provided is not valid
#define DW_RC_NOCURRENT -3      // Request requires currency but no current
#define DW_RC_BADTYPE   -4      // Data type of request doesn't match column
#define DW_RC_BADARG    -5      // Argument passed is invalid
#define DW_RC_NULL      -6      // Result is null
#define DW_RC_BADEXPR   -7      // Expression is bad
#define DW_RC_IOERROR   -8      // Error occured during file i/o processing
#define DW_RC_CANCEL    -9      // User cancelled

// Following more error codes are used when running
// in context of a transaction server (Jag or MTS)
// and when GenerateResultSet f(x) is called
#define DW_RC_NOTINTXNSVR -10	// Not running in TXN Server
#define DW_RC_NOENTRYPOINT -11	// Couldn't find TXN Server entry points for TXN Server calls
#define DW_RC_SVRCTXERROR -12	// Error using TXN Server specific calls in DW

#define DW_RC_INVALIDDW		-13	// The DW is invalid
#define DW_RC_INVALIDGRAPH -14  // The graph object specified is invalid
#define DW_RC_BADINDEX		-15 // Code table index is invalid
#define DW_RC_INVALIDTREE -16  // It is not a treeview DW
#define DW_RC_WSRUNTIMEERROR -17	// An error occured in the WS runtime.

			PBWINAPI(short, dwClientToObject)(HWND hWnd, LPTSTR lpName, POINT FAR* p, LONG ri);
			PBWINAPI(short, dwDBCancel)(HWND hWnd);
			PBWINAPI(VOID, dwDeleteCrosstabSourceList)(PVOID prog, PVOID source_names);
			PBWINAPI(short, dwDragObjectCreate)(HWND hWnd, int x, int y, PVOID FAR* pdwo, LONG FAR* row);
			PBWINAPI(short, dwDragObjectDestroy)(HWND hWnd, PVOID dwo);
			PBWINAPI(short, dwExprDialog)(HWND hWnd, HWND hWndOwner, LPTSTR pTitle, LPTSTR FAR* pExpr, BOOL bAllowNULL);
			PBWINAPI(short, dwValidationExprDialog)(HWND hWnd, HWND hWndOwner, LPTSTR pTitle, LPTSTR FAR* pExpr, BOOL bAllowNULL);
			PBWINAPI(short, dwExprValidate)(HWND hWnd, LPTSTR fexpr);
			PBWINAPI(LONG, dwFind)(HWND hWnd, LPTSTR fexpr, LONG srow, LONG erow);
			PBWINAPI(LONG, dwFindGroupChange)(HWND hWnd, LONG row, short	level);
			PBWINAPI(short, dwFindRequired)(HWND hWnd, short queue, LONG FAR* rrow, short FAR* col, LPTSTR lpName, BOOL bUpdate);
			PBWINAPI(short, dwFitColumn)(HWND hWnd, short col, LONG lCount, BOOL bPrinter, LPTSTR lpszSeparator);
			PBWINAPI(LPTSTR, dwGenTableName)(ppbstg_anchor sa, pbstg_subpool subpool, BOOL bText,
				int row, int rows_per_detail, PVOID col, short tableCount, BOOL bCrosstab, short ci);
			PBWINAPI(LPTSTR, dwGenXTableName)(ppbstg_anchor sa, pbstg_subpool subpool, BOOL bText,
				int row, int rows_per_detail, PVOID pcol, BOOL bCrosstab, short ci);

			PBWINAPI(short, dwGetBandUnderMouse)(HWND hWnd, LPTSTR name);
			PBWINAPI(BOOL, dwGetRowColUnderPoint)(HWND hWnd, int x, int y, LONG* hrow, short* hcol);
			PBWINAPI(BOOL, dwIsPointOutsideEditCol)(HWND hWnd, int x, int y);
			PBWINAPI(short, dwGetColumnFormat)(HWND hWnd, short col, LPTSTR v, short maxsize);
			PBWINAPI(short, dwGetColumnFormatLength)(HWND hWnd, short col);
			PBWINAPI(short, dwGetColumnNumber)(HWND hWnd, LPTSTR colname);
			PBWINAPI(short, dwGetColumnType)(HWND hWnd, short col);
			PBWINAPI(short, dwGetColumnValidation)(HWND hWnd, short col, LPTSTR v, short maxsize);
			PBWINAPI(short, dwGetColumnValidationLength)(HWND hWnd, short col);
			PBWINAPI(short, dwGetColumnValue)(HWND hWnd, short col, LPTSTR v, short maxsize, short item);
			PBWINAPI(short, dwGetColumnValueLength)(HWND hWnd, short	col, short item);
			PBWINAPI(LONG, dwGetCurrentCol)(HWND hWnd, short bName); //bName true,(LPCTSTR),id
			PBWINAPI(short, dwGetCurrentRowCol)(HWND hWnd, LONG FAR* row, short FAR* col);
			PBWINAPI(ULONG, dwGetCurrentText)(HWND hWnd, LPTSTR v, ULONG maxsize);
			PBWINAPI(ULONG, dwGetCurrentTextLength)(HWND hWnd);
			PBWINAPI(short, dwGetDBvendor)(HWND hWnd, LPTSTR v, short	maxsize);
			PBWINAPI(short, dwGetDBvendorLength)(HWND hWnd);
			PBWINAPI(short, dwGetDBlogid)(HWND hWnd, LPTSTR v, short maxsize);
			PBWINAPI(short, dwGetDBlogidLength)(HWND hWnd);
			PBWINAPI(short, dwGetDBlogpass)(HWND hWnd, LPTSTR v, short maxsize);
			PBWINAPI(short, dwGetDBlogpassLength)(HWND hWnd);
			PBWINAPI(short, dwGetDBserver)(HWND hWnd, LPTSTR v, short	maxsize);
			PBWINAPI(short, dwGetDBserverLength)(HWND hWnd);
			PBWINAPI(short, dwGetDBdatabase)(HWND hWnd, LPTSTR v, short maxsize);
			PBWINAPI(short, dwGetDBdatabaseLength)(HWND hWnd);
			PBWINAPI(short, dwGetDBuserid)(HWND hWnd, LPTSTR v, short	maxsize);
			PBWINAPI(short, dwGetDBuseridLength)(HWND hWnd);
			PBWINAPI(short, dwGetDBdatabasepass)(HWND hWnd, LPTSTR v, short maxsize);
			PBWINAPI(short, dwGetDBdatabasepassLength)(HWND hWnd);
			PBWINAPI(short, dwGetDBparm)(HWND hWnd, LPTSTR v, short maxsize);
			PBWINAPI(short, dwGetDBparmLength)(HWND hWnd);
			PBWINAPI(LONG, dwGetDBError)(HWND hWnd, LPTSTR errtext, short	maxsize);
			PBWINAPI(short, dwGetDBErrorLength)(HWND hWnd);
#define DW_QUEUE_DISPLAY   0
#define DW_QUEUE_DELETED   1
#define DW_QUEUE_FILTERED  2
			PBWINAPI(short, dwGetItemDateTime)(HWND hWnd, LONG row, short col, PSH_TIME v, short	queue, BOOL original);
			PBWINAPI(short, dwGetItemDecimal)(HWND hWnd, LONG row, short col, PSH_DEC v, short	queue, BOOL orig);
			PBWINAPI(short, dwGetItemDouble)(HWND hWnd, LONG row, short col, double FAR* v, short queue, BOOL original);
			PBWINAPI(short, dwGetItemLength)(HWND hWnd, LONG row, short col, short queue, BOOL original);
			PBWINAPI(LONG, dwGetItemLengthLong)(HWND hWnd, LONG row, short col, short queue, BOOL original);
#define DW_ITEMSTATUS_NOCHANGE		0
#define DW_ITEMSTATUS_MODIFIED		1
#define DW_ITEMSTATUS_NEW			2
#define DW_ITEMSTATUS_NEW_MODIFIED	3
			PBWINAPI(short, dwGetItemStatus)(HWND hWnd, LONG row, short col, short queue);

			PBWINAPI(short, dwGetItemLengthAndString)(HWND hWnd, LONG row, short col, LPTSTR FAR* v,
				LONG lMaxsize, short queue, BOOL original,
				LONG* lLength, ppbstg_anchor sa, pbstg_subpool pool);

			PBWINAPI(short, dwGetItemString)(HWND hWnd, LONG row, short col, LPTSTR v, short maxsize, short queue, BOOL original);
			PBWINAPI(short, dwGetItemStringLong)(HWND hWnd, LONG row, short col, LPTSTR v, LONG maxsize, short queue, BOOL original);
			PBWINAPI(short, dwGetItemType)(HWND hWnd, short col);
			PBWINAPI(LONG, dwGetNextModifiedRow)(HWND hWnd, LONG startrow, short	q);
			PBWINAPI(PVOID FAR*, dwGetNotifyArgs)(HWND hWnd, PVOID given_DW);
			PBWINAPI(short, dwGetObjectUnderMouse)(HWND hWnd, LPTSTR name);
			PBWINAPI(short, dwGroupCalc)(HWND hWnd);
#ifndef NOMETAFILE
			PBWINAPI(HMETAFILE, dwMetaFile)(HWND hWnd, LONG lPage, int iWidth, int iHeight);
			PBWINAPI(HENHMETAFILE, dwEnhMetaFile)(HWND hWnd, LONG lPage, int iWidth, int iHeight);
#endif
			PBWINAPI(short, dwOleActivateItem)(HWND hWnd, LONG ri, short	ci, WORD iVerb);
			PBWINAPI(PDWOLER, dwOleGetControlInfo)(HWND hWnd);
			PBWINAPI(BOOL, dwOleDeactivate) (HWND hWnd, BOOL bFromPostMessage, LPARAM lParamForPost);
			PBWINAPI(VOID, dwOleIPactivate) (HWND hWnd, BOOL bActive);
			PBWINAPI(VOID, dwOleIPResize) (HWND hWnd);
			PBWINAPI(void, dwOleReset) (HWND hWnd, BOOL bDestroy);
			PBWINAPI(PVOID, dwGetProgram)(HWND hWnd);
			PBWINAPI(short, dwPosition)(HWND hWnd, LPTSTR gobname, LPTSTR bandname, BOOL bFront);
			PBWINAPI(LPTSTR, dwQryDialog)(HWND hWnd, LPTSTR sql, PDWEXPRTEST gx, LPTSTR pCriteria, PDWBTBLARG args);
			PBWINAPI(BOOL, dwCanChangeQryMode) (HWND hWnd, PVOID given_DW);
			PBWINAPI(short, dwResetColumnValues)(HWND hWnd, short col);
			PBWINAPI(short, dwResetTrans)(HWND hWnd);
			PBWINAPI(long, dwRetrieve)(HWND hWnd, PDWRETRIEVEARGS args, BOOL bRepaint);
			PBWINAPI(long, dwSendMessage)(HWND hWnd, unsigned iMessage, WPARAM wParam, LPARAM lParam);
			PBWINAPI(short, dwSetColumnFormat)(HWND hWnd, short col, LPTSTR m);
			PBWINAPI(short, dwSetColumnValidation)(HWND hWnd, short col, LPTSTR m);
			PBWINAPI(short, dwSetColumnValue)(HWND hWnd, short col, LPTSTR m, short item);
			PBWINAPI(short, dwSetCurrentRowCol)(HWND hWnd, LONG row, short col);
			PBWINAPI(short, dwSetCurrentText)(HWND hWnd, LPTSTR v);
			PBWINAPI(short, dwSetDBvendor)(HWND hWnd, LPTSTR v);
			PBWINAPI(short, dwSetDBlogid)(HWND hWnd, LPTSTR v);
			PBWINAPI(short, dwSetDBlogpass)(HWND hWnd, LPTSTR v);
			PBWINAPI(short, dwSetDBserver)(HWND hWnd, LPTSTR v);
			PBWINAPI(short, dwSetDBdatabase)(HWND hWnd, LPTSTR v);
			PBWINAPI(short, dwSetDBuserid)(HWND hWnd, LPTSTR v);
			PBWINAPI(short, dwSetDBdatabasepass)(HWND hWnd, LPTSTR v);
			PBWINAPI(short, dwSetDBparm)(HWND hWnd, LPTSTR v);
			PBWINAPI(short, dwSetDetailHeight)(HWND hWnd, LONG lStartRow, LONG lEndRow, LONG lHeight);
			PBWINAPI(short, dwSetHTMLAction)(HWND hWnd, LPTSTR lpstrAction, LPTSTR lpstrContext);
			PBWINAPI(short, dwSetEventFlags)(HWND hWnd, ULONG evtF1, ULONG evtF2, PVOID given_DW);
			PBWINAPI(short, dwSetItemDateTime)(HWND hWnd, LONG row, short col, PSH_TIME v);
			PBWINAPI(short, dwSetItemDecimal)(HWND hWnd, LONG row, short col, PVOID v);
			PBWINAPI(short, dwSetItemDouble)(HWND hWnd, LONG row, short col, double FAR* v);
			PBWINAPI(short, dwSetItemLong)(HWND hWnd, LONG row, short col, long FAR* v);
			PBWINAPI(short, dwSetItemReal)(HWND hWnd, LONG row, short col, float FAR* v);
			PBWINAPI(short, dwSetItemStatus)(HWND hWnd, LONG row, short col, short queue, short status);
			PBWINAPI(short, dwSetItemString)(HWND hWnd, LONG row, short col, LPTSTR v);
			PBWINAPI(short, dwSetItemULong)(HWND hWnd, LONG row, short col, unsigned long FAR* v);
			PBWINAPI(short, dwSetItemNull)(HWND hWnd, LONG row, short col);
			PBWINAPI(short, dwSetLibrary)(PVOID pDW, LPTSTR FAR* files, UINT filecount);
			PBWINAPI(short, dwSetRC)(HWND hWnd, LONG rc, PVOID given_DW);
			PBWINAPI(short, dwSetTrans)(HWND hWnd, PVOID trans);
			PBWINAPI(short, dwShareData)(HWND dw_primary, HWND dw_secondary);
			PBWINAPI(short, dwShareDataOff)(HWND hWndOff);
			PBWINAPI(LPTSTR, dwSQLGetSyntax)(HWND hWnd);
			PBWINAPI(short, dwSQLSetSyntax)(HWND hWnd, LPTSTR syn);
			PBWINAPI(short, dwStorageDump)(HWND hWnd, LPTSTR lpFile);
			PBWINAPI(short, dwStyleChange)(HWND hWnd, LONG lStyle);
			PBWINAPI(LONG, dwUpdateSQLGetRow)(HWND hWnd);
			PBWINAPI(short, dwUpdateSQLGetQ)(HWND hWnd);
			PBWINAPI(LONG, dwGenerateHTMLForm)(HWND hWnd, LPTSTR FAR* lpszSyntax, LPTSTR FAR* lpszStyle, LPTSTR lpszAction, LONG startRow, LONG endRow, short startCol, short endCol, short queue);
			PBWINAPI(LONG, dwSaveAsAscii)(HWND hWnd, LPTSTR lpszSyntax, LPTSTR lpszSeparator, LPTSTR lpszQuote, LPTSTR lpszLineFeed, BOOL bRetainNewLineChar);
			PBWINAPI(LONG, dwBuildXHTMLTemplate)(HWND hWnd, IPB_XMLDOMDocument** ppITemplate, IPB_XMLDOMDocument** ppIStyle);

			PBWINAPI(long, dwSetFullState) (HWND hWnd, PVOID pBlob, PVOID obthis, ULONG ulLen, PVOID FAR* ppStgOpen, PVOID FAR* ppProg);
			PBWINAPI(long, dwGetFullState) (HWND hWnd, PVOID FAR* ppBlob, LONG FAR* pRowCount);
			PBWINAPI(long, dwGetChanges) (HWND hWnd, PVOID FAR* ppBlob, PVOID pCookie, LONG FAR* pRowCount);
			PBWINAPI(long, dwSetChanges) (HWND hWnd, PVOID pBlob, ULONG ulLen, short CR);
			PBWINAPI(long, dwGetStateStatus) (HWND hWnd, PVOID FAR* ppBlob);
			PBWINAPI(VOID, dwSetBlobStorageNULL) (HWND hWnd);

			// this free's the memory allocated by dwGetFullState() or dwGetChanges()
			PBWINAPI(long, dwFreeBlob) (HWND hWnd, PVOID pBlob);

			// set the callback to use when loading bitmaps
			// see osfdib.h
			PBWINAPI(long, dwSetWebLoadCallback) (HWND hWnd, PVOID pCallback);

			// paint the dw into the given device context
			PBWINAPI(LONG, dwPaintDC)(HWND hWnd, HDC hDC, LPRECT pRect);

			// function to set the notify callback function to datastore
			PBWINAPI(LONG, DS_SetNotifyFunc)(PVOID Given_pDW, PVOID GivenFunction);

			//function to get if use's prompts are allowed.
			BOOL WINAPI DW_User_Prompts_Are_NOT_Allowed(PVOID GivenDW);

			// function for print dw thought pDW pointer instead of hWnd. If dw has hWnd, you can use DWM_PRINT msg.
			PBWINAPI(LONG, dwPrintObject)(PVOID given_pDW, BOOL Show_Cancel_DialogBox, HDC Print_Job_DC);

			// function to save a graph control of a DW in PDF format
			PBWINAPI(LONG, dwGraphSaveAsPdf)(PVOID pdw, LPTSTR lpszGraphName, LPTSTR lpszFileNamePdf);

			// function to get the dataheader version of the psr file
			PBWINAPI(LONG, dwGetPsrDataVersion)(LPOLESTR szFileName);

			PBWINAPI(VOID, dwSetTransparency)(HWND hWnd, INT nTransparency);
			// -------------------------------------------------------------------------------
			// Lim Bio Liong December 15th 2000. BLIM\CR221208\1\2000\DECEMBER\15th
			// We create a new definition "GOB_MAXNAME" which is used to encapsulate the
			// maximum limit on the number of characters settable for a DW GOB.
			// We must #include "pbdbi.h" because "DBI_MAXNAME" is defined in "pbdbi.h".
			// GOB_MAXNAME is set to be 2 times the max name length of a database table or
			// column name. We add to this the space for a "_" and space for an additional
			// "_t" (for text labels which are associated with columns).
			//
			// Also declare a new global function dwGenNameExhaustive().
			// -------------------------------------------------------------------------------
			// ***** DOINC including pbdbi.h *****
				// DOINC skipping duplicate include
#define GOB_MAXNAME				((DBI_MAXNAME * 3) + 1 + 2)

			PBWINAPI(LPTSTR, dwGenNameExhaustive)(ppbstg_anchor sa, PSHHASH name_hash, pbstg_subpool subpool, LPTSTR lpszGivenName, BOOL bText);

			// -------------------------------------------------------------------------------

			// Destroy a NOHWND Datastore
			PBWINAPI(VOID, DS_Destroy) (PVOID givenDW);

			PBWINAPI(HRESULT, dwXMLGetDefaultEncoding)(IPB_String** ppEncoding);


#endif // !defined(RC_INVOKED)

#ifdef __cplusplus
		} /* end of 'extern "C" {' */
#endif

#endif
// DOINC popped back into header 'pbdbi.h'
#endif

/***************************************************************************/
//                            Defines
/***************************************************************************/
#define PB_DBI_VERSION		400	/* current powerbuilder version number with two */
								/* implied decimal places */
								/* this should only change for development releases */

/**************************************************************************** */
/* support for 16 bit huge pointer stuff - das                                */
/**************************************************************************** */
#ifdef PBWIN16
#define LPDBI_BYTE BYTE _huge *
#else
#define LPDBI_BYTE LPBYTE
#endif


#define DBI_WARNING_SERVERDOWN		1
#define DBI_WARNING_FAILOVER		2
#define DBI_WARNING_DATATRUNCATED	3

/**************************************************************************** */
/*  SQL runtime informational return codes */
/**************************************************************************** */
#define DBI_FETCHEND     1                   /* No more rows to fetch */
#define DBI_FETCHTRUNC   2                   /* Data truncated during fetch */
#define DBI_RESULTEND    3                   /* End of results */
#define DBI_NOVIEWTEXT   4                   /* No authority to see the view text */

/**************************************************************************** */
/*  SQL runtime language return codes */
/**************************************************************************** */
#define DBI_SQLOK        0                   /* Things are ducky */
#define DBI_NOTFOUND     100                 /* Row not found */
#define DBI_SQLERROR     -1                  /* Error has occurred */


/**************************************************************************** */
/*  Database editions types */
/**************************************************************************** */
#define DBI_STANDARD     20                  /* Standard edition - no longer */
								   /* valid for standard */
#define DBI_PREMIUM      30                  /* Premium edition */
#define DBI_MARGE        40                  /* New setting for Standard */
								   /* edition - only the PBODBxxx */
								   /* dll should return this! */
/**************************************************************************** */
/*  SQL runtime data type */
/**************************************************************************** */
#define DBI_TYPEUNSUPPORTED 0                /* Unsupported or Unknown  */
#define DBI_TYPECHAR      1                  /* Character */
#define DBI_TYPEVCHAR     2                  /* Var character */
#define DBI_TYPEFLOAT     3                  /* Long Float    (8 bytes) */
#define DBI_TYPEDECIMAL   4                  /* Decimal */
#define DBI_TYPEINT       5                  /* Integer       (4 bytes) */
#define DBI_TYPESINT      6                  /* Small integer (2 bytes) */
#define DBI_TYPEDATE      7                  /* Date */
#define DBI_TYPETIME      8                  /* Time */
#define DBI_TYPEDATETIME  9                  /* Datetime */
#define DBI_TINYINT       11                 /* Tiny int (1 byte) */
#define DBI_TYPESTRINGLONG 14                /* Long string (over 255 bytes) */
#define DBI_TYPEBLOB      15                 /* Binary data (has 4-byte prefix) */
#define DBI_TYPEBIT       16                 /* bit data */
#define DBI_TYPEMONEY     17                 /* money data */
#define DBI_TYPETIMESTAMP 18                 /* timestamp data */
#define DBI_UINT          19                 /* unsigned int  (2 bytes) */
#define DBI_ULONG         20                 /* unsigned long (4 bytes) */
#define DBI_FLOAT4        21                 /* short float   (4 bytes) */
#define DBI_LONG          22                 /* signed long   (4 bytes) */
#define DBI_TYPEINT64	  23				 /* LONGLONG */
#define DBI_TYPEBINARYHEX 24                 /* hex representation of binary data */
#define DBI_TYPEUINT64	  25				 /* ULONGLONG */
#define DBI_TYPENCHAR	  26				 /* nchar */
#define DBI_TYPENVCHAR  27				 /* nvarchar */
#define DBI_TYPENSTRINGLONG 28				/* ntext */
#define DBI_TYPEXML			29				/* XML type */
#define DBI_TYPESDATETIME		30				/* Smalldatetime*/
#define DBI_TYPESMONEY			31				/* smallmoney*/
#define DBI_TYPEBINARY			32				/* binary*/
#define DBI_TYPEVARBINARY		33				/* varbinary*/
#define DBI_TYPELONGVARBINARY	34				/* long varbinary*/
#define DBI_UNIQUEIDENTIFIER	35			/* Uniqueidentifier*/
#define DBI_DBTIMESTAMP			36			/* Oracle/ASA datetime type*/
#define DBI_TYPEINTERVAL_DS		37			/* informix interval type */
#define DBI_TYPEINTERVAL_YM		38			/* informix interval type */
#define DBI_BLOB				39			/* DB BLOB TYPE*/
#define DBI_CLOB				40			/* db clob type */
#define DBI_NCLOB				41			/* db nclob type */
#define DBI_UNICHAR				42			/* unichar type */
#define DBI_UNIVARCHAR			43			/* univarchar type */

/**************************************************************************** */
/*  SQL buffer sizes */
/**************************************************************************** */

#ifdef PBOS_UNIX
#define DBI_NUMERIC_BUFSIZE   40*sizeof(TCHAR)
#else
#define DBI_NUMERIC_BUFSIZE   80
#endif

#define DBI_TIMESTAMP_BUFSIZE 32*sizeof(TCHAR)
#define DBI_DATETIME_BUFSIZE 80
#define DBI_GUIDSTRING_BUFSIZE 37

/**************************************************************************** */
/*  Operation modes */
/**************************************************************************** */

#define DBI_RESPONSE_PENDING   1
#define DBI_REQUEST_CANCELLED  2
#define DBI_ROWS_PENDING       3

/**************************************************************************** */
/*  Parsing equates */
/**************************************************************************** */

#define DBI_GROUPBY            1
#define DBI_ORDERBY            2
#define DBI_WHERE              3
#define DBI_HAVING             4

// ***** DOINC including pbdbidef.h *****
/*                                                                         */
/* *********************************************************************** */
/*                                                                         */
/*                 Copyright Powersoft Corporation 1991-1994               */
/*                                                                         */
/*       Powersoft Corporation ("Powersoft") claims copyright in this      */
/*     program and documentation as an unpublished work, versions of       */
/*     which were first licensed on the date indicated in the foregoing    */
/*     notice. Claim of copyright does not imply waiver of Powersoft's     */
/*     other rights. See Notice of Proprietary Rights.                     */
/*                                                                         */
/*                 NOTICE OF PROPRIETARY RIGHTS                            */
/*                                                                         */
/*       This program and documentation are confidential trade             */
/*     secrets and the property of Powersoft.  Use, examination,           */
/*     reproduction, copying, disassembly, decompilation, transfer         */
/*     and/or disclosure to others are strictly prohibited except by       */
/*     express written agreement with Powersoft.                           */
/*                                                                         */
/* ----------------------------------------------------------------------- */
/*                                                                         */
/*    Filename :    pbdbidef.h                                             */
/*                                                                         */
/*    Purpose  :    Header file for database interface resource file defs  */
/*                                                                         */
/* *********************************************************************** */


#if !defined(DW_OCX) && !defined(DW_PLUGIN) && !defined(NISQL) && !defined(DW_NET)
#define PBDBI_STRING_BASE 100
#else
  // to avoid conflicts in DWE OCX
#define PBDBI_STRING_BASE 400
#endif
// pt279397.  We must keep #defines that are used as data values in pbcat???
// columns constant.  Unfortunately, these #defines also do double duty to as stringids.
// The #defines for PBDBI_STRING_BASE+n that have been commented out in this
// header file have already been used in other pbshr headers and should not be reused.
// If you change the value of PBDBI_STRING_BASE, also change pbrc.h in pbshr.
#define DBI_YES           20      // pt279397
#define DBI_NO            21      // pt279397
#define DBI_POS_LEFT      23      // pt279397
#define DBI_POS_RIGHT     24      // pt279397
#define DBI_POS_CENTER    25      // pt279397
#define DBI_CASE_ACTUAL   26      // pt279397
#define DBI_CASE_UPPER    27      // pt279397
#define DBI_CASE_LOWER    28      // pt279397
#define DBI_CASE_WORDCAP  29      // pt279397
#define DBI_CASE_FIRSTCAP 30      // pt279397
//  #define DBI_YES           PBDBI_STRING_BASE       // pt279397
//  #define DBI_NO            PBDBI_STRING_BASE + 1   // pt279397
//  #define DBI_POS_LEFT      PBDBI_STRING_BASE + 2   // pt279397
//  #define DBI_POS_RIGHT     PBDBI_STRING_BASE + 3   // pt279397
//  #define DBI_POS_CENTER    PBDBI_STRING_BASE + 4   // pt279397
//  #define DBI_CASE_ACTUAL   PBDBI_STRING_BASE + 5   // pt279397
//  #define DBI_CASE_UPPER    PBDBI_STRING_BASE + 6   // pt279397
//  #define DBI_CASE_LOWER    PBDBI_STRING_BASE + 7   // pt279397
//  #define DBI_CASE_WORDCAP  PBDBI_STRING_BASE + 8   // pt279397
//  #define DBI_CASE_FIRSTCAP PBDBI_STRING_BASE + 9   // pt279397
//  #define DBI_COLOR_SYSTEM  PBDBI_STRING_BASE + 10  //obselete
//  #define DBI_COLOR_BLACK   PBDBI_STRING_BASE + 11  //obselete
//  #define DBI_COLOR_WHITE   PBDBI_STRING_BASE + 12  //obselete
//  #define DBI_COLOR_RED     PBDBI_STRING_BASE + 13  //obselete
//  #define DBI_COLOR_GREEN   PBDBI_STRING_BASE + 14  //obselete
//  #define DBI_COLOR_BLUE    PBDBI_STRING_BASE + 15  //obselete
//  #define DBI_COLOR_YELLOW  PBDBI_STRING_BASE + 16  //obselete
//  #define DBI_COLOR_MAGENTA PBDBI_STRING_BASE + 17  //obselete
//  #define DBI_COLOR_CYAN    PBDBI_STRING_BASE + 18  //obselete

#define DBI_FMTSTRING     80     // pt279397
#define DBI_FMTNUMBER     81     // pt279397
#define DBI_FMTDATE       82     // pt279397
#define DBI_FMTTIME       83     // pt279397
#define DBI_FMTDATETIME   84     // pt279397
#define DBI_EDIT_CB       85     // pt279397
#define DBI_EDIT_RB       86     // pt279397
#define DBI_EDIT_DDCB     87     // pt279397
#define DBI_EDIT_DDDW     88     // pt279397
#define DBI_EDIT_EB       89     // pt279397
#define DBI_EDIT_MC       90     // pt279397
#define DBI_EDIT_INK      91     //  Add ink edit style
//  #define DBI_FMTSTRING     PBDBI_STRING_BASE + 19    // pt279397
//  #define DBI_FMTNUMBER     PBDBI_STRING_BASE + 20    // pt279397
//  #define DBI_FMTDATE       PBDBI_STRING_BASE + 21    // pt279397
//  #define DBI_FMTTIME       PBDBI_STRING_BASE + 22    // pt279397
//  #define DBI_FMTDATETIME   PBDBI_STRING_BASE + 23    // pt279397
//  #define DBI_EDIT_CB       PBDBI_STRING_BASE + 24    // pt279397
//  #define DBI_EDIT_RB       PBDBI_STRING_BASE + 25    // pt279397
//  #define DBI_EDIT_DDCB     PBDBI_STRING_BASE + 26    // pt279397
//  #define DBI_EDIT_DDDW     PBDBI_STRING_BASE + 27    // pt279397
//  #define DBI_EDIT_EB       PBDBI_STRING_BASE + 28    // pt279397
//  #define DBI_EDIT_MC       PBDBI_STRING_BASE + 29    // pt279397
#if !defined(DW_OCX) && !defined(DW_PLUGIN) && !defined(NISQL)
#define DBI_EDIT_STRING_CB       PBDBI_STRING_BASE + 30
#define DBI_EDIT_STRING_DDDW     PBDBI_STRING_BASE + 31
#define DBI_EDIT_STRING_DDCB     PBDBI_STRING_BASE + 32
#define DBI_EDIT_STRING_EB       PBDBI_STRING_BASE + 33
#define DBI_EDIT_STRING_MC       PBDBI_STRING_BASE + 34
#define DBI_EDIT_STRING_RB       PBDBI_STRING_BASE + 35
#define DBI_EDIT_STRING_INK      PBDBI_STRING_BASE + 36
#endif // DW_OCX and DW_PLUGIN and NISQL

#if !defined(DW_OCX) && !defined(DW_PLUGIN) && !defined(NISQL)
#define DBI_WRONG_EDITION PBDBI_STRING_BASE + 36
#define DBI_ILLEGAL_COPY  PBDBI_STRING_BASE + 38
#endif // DW_OCX and DW_PLUGIN and NISQL

#define DBI_WRONG_VENDOR  PBDBI_STRING_BASE + 37

/* message's */
#if !defined(DW_OCX) && !defined(DW_PLUGIN) && !defined(NISQL)
#define DBI_MSG_PK_KEYNAME_NEEDED PBDBI_STRING_BASE + 39
#endif // DW_OCX and DW_PLUGIN and NISQL

#define DBI_CONVERT_INTERNAL_ERROR PBDBI_STRING_BASE + 40

/* #defines for SQL generator */

#define   DBI_SQL_SYNPER           PBDBI_STRING_BASE + 41
#define   DBI_SQL_SYNCOMMA         PBDBI_STRING_BASE + 42
#define   DBI_SQL_SYNBLANK         PBDBI_STRING_BASE + 43
#define   DBI_SQL_SYNGROUP         PBDBI_STRING_BASE + 44
#define   DBI_SQL_SYNALL           PBDBI_STRING_BASE + 45
#define   DBI_SQL_SYNASC           PBDBI_STRING_BASE + 46
#define   DBI_SQL_SYNWHERE         PBDBI_STRING_BASE + 47
#define   DBI_SQL_SYNORDER         PBDBI_STRING_BASE + 48
#define   DBI_SQL_SYNDESC          PBDBI_STRING_BASE + 49
#define   DBI_SQL_SYNDIST          PBDBI_STRING_BASE + 50
#define   DBI_SQL_SYNUNION         PBDBI_STRING_BASE + 51
#define   DBI_SQL_SYNSELECT        PBDBI_STRING_BASE + 52
#define   DBI_SQL_SYNFROM1         PBDBI_STRING_BASE + 53
#define   DBI_SQL_SYNTERM          PBDBI_STRING_BASE + 54
#define   DBI_SQL_LPAREN           PBDBI_STRING_BASE + 55
#define   DBI_SQL_RPAREN           PBDBI_STRING_BASE + 56
#define   DBI_SQL_AND              PBDBI_STRING_BASE + 57
#define   DBI_SQL_NULL             PBDBI_STRING_BASE + 58
#define   DBI_SQL_SYNHAVNG         PBDBI_STRING_BASE + 59
#define   DBI_SQL_SYNHOLD          PBDBI_STRING_BASE + 60
#define   DBX_SQL_SEQUENCE_ERROR   PBDBI_STRING_BASE + 61
#define   DBX_SQL_INVALID_CONNECT_HANDLE_ERROR  PBDBI_STRING_BASE + 62
#define   DBX_SQL_INVALID_STMT_HANDLE_ERROR  PBDBI_STRING_BASE + 63
#define   DBX_SQL_CONNECT_FAILURE  PBDBI_STRING_BASE + 64
#define   DBX_SQL_DATA_TRUNCATION_ERROR  PBDBI_STRING_BASE + 65
#define   DBX_SQL_CONNECT_IN_USE   PBDBI_STRING_BASE + 66
#define   DBX_SQL_OPTION_NOT_SUPPORTED   PBDBI_STRING_BASE + 67
#define   DBX_SQL_OPTION_VALUE_NOT_SUPPORTED   PBDBI_STRING_BASE + 68
#define   DBX_SQL_OPTION_BEFORE_CONNECT_ONLY   PBDBI_STRING_BASE + 69
#define   DBX_SQL_OPTION_VALUE_CHANGED		   PBDBI_STRING_BASE + 70
#define   DBX_SQL_CONNECT_NOT_IN_USE   PBDBI_STRING_BASE + 71
#define   DBX_SQL_DRIVER_NOT_CAPABLE   PBDBI_STRING_BASE + 72
#define   DBX_SQL_CURSOR_OPEN_FAILURE  PBDBI_STRING_BASE + 73
#define   DBX_UNSUPPORTED_DATA_TYPE    PBDBI_STRING_BASE + 74
#define   DBX_INVALID_COLUMN_NUMBER    PBDBI_STRING_BASE + 75
#define   DBX_INVALID_READBLOB_SYNTAX  PBDBI_STRING_BASE + 76
#define   DBX_NEED_DATA_ERROR          PBDBI_STRING_BASE + 77
#define   DBI_TXNSERVER_CONTEXTOBJECT_SEMANTICS          PBDBI_STRING_BASE + 78
#define   DBI_TXNSERVER_NOT_SUPPORTED  PBDBI_STRING_BASE + 79
#define	 DBI_PARSE_TABLE_ERROR		  PBDBI_STRING_BASE + 80


// DOINC popped back into header 'pbdbi.h'

/**************************************************************************** */
/*  SQL runtime column attributes */
/**************************************************************************** */


#define   DBI_MAXTOKEN         33        /* Max syntax token size     */
								/*  in resource file         */
								/*  + 1 for null terminator  */

/**************************************************************************** */
/*  SQL runtime indicator variable codes */
/**************************************************************************** */
#define DBI_NULLVALUE       -1               /* Null value */
#define DBI_BADCONVERSION   -2               /* Conversion error */

/**************************************************************************** */
/*  DBI_DESCRIBE command parameter value */
/**************************************************************************** */
#define DBI_KEEPRESULTSET    1
#define DBI_DROPRESULTSET    0

/**************************************************************************** */
/*  signon #defines */
/**************************************************************************** */
#define DBI_NEW_SIGNON      0                    /* Brand new signon */
#define DBI_CHANGE_DBMS     1                    /* not supported anymore */
#define DBI_CHANGE_SERVER   2                    /* not supported anymore */
#define DBI_CHANGE_DATABASE 3                    /* not supported anymore */
#define DBI_PROMPT_FOR_ALL_INFORMATION_FIRST 4   /* Prompt for connection */
									   /* information (everything */
									   /* but dbms name). */
#define DBI_PROMPT_FOR_DBMS_NAME  5              /* same as 'DBI_PROMPT_FOR_ALL_INFORMATION_FIRST' */
									   /* except the user is prompted */
									   /* for the vendor name first. */

/**************************************************************************** */
/*  Cursor Types */
/**************************************************************************** */
#define DBI_OPEN_CURSOR		0
#define DBI_EXECUTE_CURSOR	1

/**************************************************************************** */
/*  Assorted values */
/**************************************************************************** */


#define DBI_MAXNAME      129
#define DBI_MAXPROCNAME  256				/* Added to support Jaguar methods in dw sp dialog */
#define DBI_MAXBERRBUFFER 1024
#define DBI_MAX_COMMANDBUFFER 0x08000000
#define DBI_MAX_PARAMID  41
#define SYNTAX_LINE_LEN  120
#define MAX_SYNTAX_LINES 30
#define SYNTAX_INDENT    7
#define MAXCONCAT        32
#define DBI_HDRLEN       120
#define DBI_NUMLINES     500             /* vertical scroll range */
#define DBI_MAXWIDTH     500             /* horizontal scroll range */
#define DBI_PKINFO_UNDETERMINED  0       /* Don't know if PK exists */
#define DBI_PKINFO_KNOWN         1       /* We know PK from Index call */
#define ID_ESTYLE_TYPE	113 /* must stay in sync with IDD_DW_COLEDIT_STYLE_TYPE */
						/* in the \painters\pdw\dwpestyl.h file */
#define DBI_INSERT_PARM  42  /* Forces DBI_UPDATE_CATALOG to generate INSERT stmts */

#define DBI_SQLCACHE_KEYWORD_SIZE  PBTEXT("SQLCache") /* dbparm control SQL Cache size */
									/* see 'CacheList' structure definition. */

									/* [database] section keyword */
#define DBI_TBLLISTCACHE_KEYWORD   PBTEXT("TableListCache")
#define DBI_TBLLISTCACHE_DEFAULT   (60 * 30)  /* default to refreshing the list every 30 minutes */
#define DBI_NAMEDPARM				PBTEXT("@Parm") //used by generating named parameters
#define DBI_NAMEDPARMANSI			PBANSI("@Parm") //used by generating named parameters
/* */
/* SQL command execution types */
/* */
#define DBI_COMMIT               1    /* commit transaction */
#define DBI_COMPILE              2    /* compile SQL statement */
#define DBI_CONNECT              3    /* connect to the database */
#define DBI_DISCONNECT           4    /* disconnect from the database */
#define DBI_EXECUTE              5    /* execute SQL statement */
#define DBI_ROLLBACK             6    /* rollback transaction */
#define DBI_DATABASE_INFO        7    /* build directory of tables in a database */
#define DBI_TABLE_INFO           8    /* specific table information */
#define DBI_COLUMNS_INFO         9    /* columns info for a specific table */
#define DBI_INDEX_INFO          10    /* index info for a specific table */
#define DBI_KEY_INFO            11    /* key info for a specific index */
#define DBI_FIND_COMBO          12    /* SHOULD BE MADE OBSOLETE */
#define DBI_MATCH_COMBO         13    /* SHOULD BE MADE OBSOLETE */
#define DBI_TYPES_FORWARD       14    /* translate PB datatypes to SQL datatypes */
#define DBI_TYPES_BACKWARD      15    /* translate SQL datatypes to PB datatypes */
#define DBI_COMBO_LIST          16    /* SHOULD BE MADE OBSOLETE */
#define DBI_LENGTH_MAX          17    /* return max length for a given datatype */
#define DBI_VALIDATE_IDENT      19    /* validate database identifier */
#define DBI_DBMS_INFO           20    /* return names of databases on a server */
#define DBI_PREPARE             21    /* prepare SQL statement (DW) */
#define DBI_DESCRIBE            22    /* describe SQL statement (DW) */
#define DBI_FETCHNEXT           23    /* fetch next row  (DW) */
#define DBI_SELBIND             25    /* bind a row of data (DW) */
#define DBI_DYN_EXECUTE         26    /* execute + cursor connection (runtime) */
#define DBI_GET_AGGREGATE       28    /* return names of aggregate functions */
#define DBI_GET_FUNCTIONS       29    /* return names of the rest of the functions */
#define DBI_PROC_DESCRIBE       30    /* describe stored procedure */
#define DBI_FREE_MEM            34    /* free memory gotten by DBMS DLL */
#define DBI_LOGIN               35    /* login to a server */
#define DBI_PB_TYPE             37    /* return PB datatype for a given */
									  /*  internal datatype */
#define DBI_GET_AFFECTED_ROWS   38    /* return # of rows affected by SQL statement */
#define DBI_LENGTH_DEFAULT      39    /* return default length for a given datatype */
#define DBI_SYS_CHECK           42    /* check if a given table is a system table */
#define DBI_EXTEND_CATALOG      43    /* create PB catalog tables */
#define DBI_UPDATE_CATALOG      45    /* update PB catalog information */
#define DBI_DELETE_DIR          46    /* delete table directory */
#define DBI_SYSTEM_COLUMN       47    /* check if a given column is a system column */
#define DBI_DESCRIBE_EXTRA      48    /* parse select statement and get all sorts of info */
#define DBI_DATE_STRING         49    /* return date as a string */
#define DBI_CURSOR_CONNECT      52    /* connect as a cursor (runtime) */
#define DBI_GET_SELECT_ITEMS    53    /* get # of columns in a column list (runtime) */
#define DBI_GET_SELECT_INFO     54    /* get describe info (runtime) */
#define DBI_BIND_SELECT_BUFFER  55    /* runtime bind a row of data (runtime) */
#define DBI_RTFETCHNEXT         56    /* fetch next row (runtime) */
#define DBI_DIALOGBOX			57    /* REMOVE ONCE ALL DRIVERS PORTED */
#define DBI_GET_DRIVER_OBJECTS  57    /* Get list of objects driver can manage (ie. users, groups) */
#define DBI_START_TRAN          58    /* start transaction */
#define DBI_GET_OBJID           59    /* get object id for a give object name */
									  /*   (Sybase only) */
#define DBI_CLEAN_CATALOG       60    /* delete all PB info for a given table */
#define DBI_UNIQUE_KEY          61    /* return unique/primary key info for a DW */
#define DBI_PARSE_FROM          62    /* return FROM clause info */
#define DBI_FREE_PREPLIST       63    /* free the work list */
#define DBI_COLUMN_INFO         64    /* return info for a given column */
#define DBI_LOGIN_DLG           65    /* invoke login dialog */
#define DBI_DATABASE_DLG        66    /* invoke database dialog */
#define DBI_DIALOG_CONNECT      67    /* invoke connect dialog */
#define DBI_COMPLETE_TABLE_INFO 70    /* return complete table info */
									  /*  (including PB catalog info) */
#define DBI_CANCEL              71    /* cancel SQL statement */
#define DBI_SECURITY_POPUP      72    /* build dynamic menu for security */
									  /* popup in DBA notepad */
#define DBI_PROC_INFO           73    /* return stored proc info */
#define DBI_PROC_TEXT           74    /* return stored proc text */
#define DBI_PROC_PREPARE        75    /* prepare stored proc */
#define DBI_PARSE               76    /* parse SQL statement (w/out exec) */
#define DBI_SUPPORT_UNION       77    /* does DBMS support "union"? */
#define DBI_SUPPORT_WITH_CHECK  78    /* does DBMS support "create view ... */
									  /*   with check"? */
#define DBI_SUPPORT_HOLDLOCK    79    /* does DBMS support "holdlock" clause */
									  /*  in select statement? */
#define DBI_SUPPORT_BROWSE      80    /* does DBMS support browse mode? */
#define DBI_SUPPORT_CLUSTERED_IDX 81  /* does DBSM support clustered indices? */
#define DBI_SUPPORT_GROUP_BYALL 82    /* does DBMS support "group by all"? */
#define DBI_SUPPORT_MULTITBL    83    /* does DBMS support update / delete */
									  /*  with multiple tbls in "where" clause? */
#define DBI_OUTERJOIN_SYNTAX    84    /* return outer join syntax */
#define DBI_COLON_VARS          85    /* does DBMS support colon host variables? */
#define DBI_PARSE_ONLY          86    /* should we do "parse only" as opposed */
									  /*  to compile? */
									  /* (yes in Sybase because it executes) */
#define DBI_RUNTIME_SUBSTITUTE  87    /* should we substitute parms ourselves? */
									  /*  (runtime) */
#define DBI_RUNTIME_EXECUTE     88    /* execute SQL command (runtime) */
#define DBI_FORMAT_HASH         89    /* build format hash list */
#define DBI_VALIDATE_HASH       90    /* build validate hash list */
#define DBI_SYSTEM_QUALIFY      94    /* return system quailfier ("dbo", "system", .. */
#define DBI_CURRENT_OF_CURSOR   95    /* does DBSM support "update/delete ... */
									  /*  where current of cursor"? */
#define DBI_GET_NEXT_RESULT_SET 96    /* get next result set */
#define DBI_VIEW_TEXT           97    /* return  text for a view */
#define DBI_EXEC_PLAN           98    /* return execution plan text */
#define DBI_GET_TIMESTAMP       99    /* get new value for a timestamp */
#define DBI_PARSE_SPECIAL_CHAR  100   /* does DBMS parse special chars? */
									  /*  (carriage returns etc) */
#define DBI_CASE_SENSITIVE      101   /* is DBMS case sensitive? */
#define DBI_DW_EXECUTE          102   /* execute SQL statement for DW */
#define DBI_CAN_CHANGE_DATABASE 103   /* can DBMS change database? */
#define DBI_CAN_INCREASE_DEC_LEN 104  /* can DBMS increase length of decimal? */
#define DBI_SHOW_SYSTEM_VIEWS   105   /* should we show system views? */
#define DBI_SYSTEM_INFO         106   /* return system tables info */
#define DBI_DICT_INFO           107   /* return PB dict info */
#define DBI_NEGATIVE_SCALE      108   /* does DBSM support negative scale? */
#define DBI_DESCRIBE_OPTIMIZED  109   /* does particular DBSM DLL optimize */
									  /*  its describe technique? */
#define DBI_DW_COL_DICT         110   /* return PB column info for optimized */
									  /*  "DescribeExtra" case */
#define DBI_CHECK_TABLE         111   /* does a given column belong to a given table? */
#define DBI_SPECIAL_CURSOR      112   /* does DBSM need a special cursor processing? */
#define DBI_CURSOR_CONNECTION   113   /* let DBMS know this is a cursor connect */
#define DBI_DATABASE_ALL_INFO   114   /* return both user/system table info */
#define DBI_CHECK_VIEW          115   /* can DBMS return text for a given view? */
#define DBI_CURSOR_LOGIN        116   /* login as a cursor (runtime) */
#define DBI_MPFETCHNEXT         117   /* MPOWER fetch next (just for Rob) */
#define DBI_UNDERLINE_TABLES    118   /* does "drop table / view" cleans all */
									  /*  the dependent views? */
#define DBI_EDITION             119   /* return DBMS edition */
#define DBI_READ_BLOB           120   /* read blob column */
#define DBI_WRITE_BLOB          121   /* write blob column */
#define DBI_MAX_LONG_LENGTH     122   /* return max length for long identifier */
#define DBI_MAX_SHORT_LENGTH    123   /* return max length for short identifier */
#define DBI_NUM_OF_DATATYPES    124   /* return # of datatypes for DBMS */
#define DBI_MAX_SCALE           125   /* return max # of digits in a scale */
#define DBI_MAX_CONCAT          126   /* return max # of concats in an index */
#define DBI_CAN_RENAME_TBL      127   /* can DBMS rename a table? */
#define DBI_CAN_RENAME_COL      128   /* can DBMS rename a column? */
#define DBI_CAN_DELETE_COL      129   /* can DBSM delete existing column? */
#define DBI_CAN_INCREASE_COL_LEN 130  /* can DBMS increase char/varchar column? */
#define DBI_CAN_CHANGE_NULL     131   /* can DBSM switch NULLS? */
#define DBI_CAN_ROLLBACK_DDL    132   /* can DBMS rollback DDL? */
#define DBI_INDEX_DESCEND       133   /* does DBMS support descending index? */
#define DBI_SERVER              135   /* does DBMS have a "change server" step? */
#define DBI_SUPPORT_STORED_PROC 136   /* does DBMS support stored procs? */
#define DBI_KEY_UPDATE          137   /* can DBMS update key value? */
#define DBI_CREATETBL_SYNTAX    139   /* return syntax for "create table" */
#define DBI_CREATEIDX_SYNTAX    140   /* return syntax for "create index" */
#define DBI_RENMTBL_SYNTAX      141   /* return syntax for "rename table" */
#define DBI_RENMCOL_SYNTAX      142   /* return syntax for "rename column" */
#define DBI_MODIFYCOL_SYNTAX    143   /* return syntax for "modify column" */
#define DBI_DROPCOL_SYNTAX      144   /* return syntax for "modify column" */
#define DBI_DROPIDX_SYNTAX      145   /* return syntax for "drop index" */
#define DBI_CAN_DECREASE_COL_LEN 146  /* can DBMS decrease column length? */
#define DBI_ADDCOL_SYNTAX       147   /* return "add column" syntax */
#define DBI_DROPTBL_SYNTAX      148   /* return "drop table" syntax */
#define DBI_RENAMECOL_CAT_SYNTAX 149  /* return "rename column" syntax for catalog */
#define DBI_RENAMETBL_CAT_SYNTAX 150  /* return "rename table" syntax for catalog */
#define DBI_DROPCOL_CAT_SYNTAX   151  /* return "drop column" syntax for catalog */
#define DBI_SYNC_CAT_SYNTAX      153  /* return "synchronize catalog" syntax */
#define DBI_SUPPORT_EXTENSION    155  /* does DBMS support extension? */
									  /* (for the future) */
#define DBI_SUPPORT_EXPLAIN      156  /* does DBSM support "explain"? */
#define DBI_SKIP_VERIFY          157  /* should we skip "verify" step */
									  /* in cursor processing? (runtime) */
#define DBI_SUPPORT_FETCH_FIRST  158  /* does DBMS support "fetch first"? */
									  /*   (cursor) */
#define DBI_SUPPORT_FETCH_PREV   159  /* does DBMS support "fetch prior"? */
									  /* (cursor) */
#define DBI_SUPPORT_FETCH_RANDOM 161  /* does DBMS support "fetch random"? */
									  /* (cursor) */
#define DBI_SUPPORT_FETCH_RELATIVE 162  /* does DBMS support "fetch relative"? */
									  /* (cursor) */
#define DBI_SUPPORT_FETCH_LAST   163  /* does DBMS support "fetch last"? */
									  /* (cursor) */
#define DBI_FETCH_FIRST          164  /* fetch first (cursor) */
#define DBI_FETCH_PREV           165  /* fetch prior  (cursor) */
#define DBI_FETCH_RANDOM         166  /* fetch random (cursor) */
#define DBI_FETCH_RELATIVE       167  /* fetch relative (cursor) */
#define DBI_FETCH_LAST           168  /* fetch last (cursor) */
#define DBI_MAX_STRING_LENGTH    169  /* return max possible length of the string */
#define DBI_NEW_DBPARM           170  /* notification of the change of dbparm */
#define DBI_ADJUST_CONNECT       171  /* adjust connect parms after */
									  /* successful connect */
#define DBI_DELIMIT_RESERVED_WORD 172 /* return delimited token */
#define DBI_SUPPORT_OUTERJOIN    173  /* does DBMS support outer join? */
#define DBI_SUPPORT_UPDATE_FOR   174  /* does DBMS support "update for"? (cursor) */
#define DBI_DESCRIBE_BEFORE_EXEC 175  /* should we do describe before exec? */
#define DBI_CAN_DESCRIBE_INPUT   176  /* can DBMS describe input parms? */
									  /* (dynamic SQL) */
#define DBI_CAN_DESCRIBE_OUTPUT  177  /* can DBMS describe output parms? */
									  /* (dynamic SQL) */
#define DBI_DESCRIBE_INPUT       178  /* descrine input parms (dynamic SQL) */
#define DBI_DESCRIBE_OUTPUT      179  /* describe output parms (dynamic SQL) */
#define DBI_NEXT_PARAM           180  /* format next host variable parm */
									  /*  (dynamic SQL) */
#define DBI_CANNOT_ADD_COLUMN    181  /* Cannot DBMS add column? */
#define DBI_UNIQUEKEY_CONSTRAINT 182  /* does a given table have unique/primary */
									  /* constraint? */
#define DBI_ANSI_OUTER           183  /* Does DBMS support ANSI outer join syntax? */

#define DBI_GET_FROM_TERMINATOR  184  /* Get table of terminators for FROM clause */
#define DBI_GET_FROM_AFTER       185  /* Get table of terms that can come after */
									  /* tbl name in FROM clause */
#define DBI_GET_FROM_BEFORE      186  /* Get table of terms that can come before */
									  /* tbl name in FROM clause */
#define DBI_DISPLAY_SERVER       187  /* Cannot change a server but stll */
									  /* want to display it */
#define DBI_STOP_WORDS           188  /* Get table of words that STOP parsing */
#define DBI_PARSE_FROMLIST       189  /* Parse FROM clause of select */
#define DBI_PARSE_COLLIST        190  /* Parse column list of select */
#define DBI_GET_FROM_STOP        191  /* Get table of terms that stop parsing */
#define DBI_TEXT_IN_COLLIST      192  /* Can we include text column in a column list? */
#define DBI_BLOB_IN_COLLIST      193  /* Can we include blobs in column list? */
#define DBI_DATETIME_INVALID_IN_SEARCH 194  /* Can we put datetime value in a WHERE clause? */
#define DBI_SUPPORT_PRIMARYKEY_CREATE  195  /* Can we Create Primary key for a database table? */
#define DBI_SUPPORT_FOREIGNKEY_CREATE  196  /* Can we Create Foreign key for a database table? */
#define DBI_SUPPORT_PRIMARYKEY_ALTER   197  /* Can we Create Primary key for a database table? */
#define DBI_SUPPORT_FOREIGNKEY_ALTER   198  /* Can we Create Foreign key for a database table? */
#define DBI_PRIMARYKEY_RETRIEVE        199  /* retrieve Primary key for a database table. */
#define DBI_FOREIGNKEY_RETRIEVE        200  /* retrieve Foreign key for a database table. */
#define DBI_GETFOREIGNKYOPTIONS        201  /* retrieve Foreign key options. */

#define DBI_SUPPORT_DWCURSOR     203            /* Can DW's use cursor like support */
												  /* to fetch row as needed */
#define DBI_SUPPORT_DWDYNAMICCURSOR 204     /* Can DW use scrollable cursors */
#define DBI_PRIMARYKEY_CREATETABLE_SYNTAX 205 /* append a primary key definition to existing Create table statement. */
#define DBI_PRIMARYKEY_ALTERTABLE_SYNTAX  206 /* Generate alter primary key definition. */
#define DBI_ANSI_OUTER_JOIN               207 /* ANSI outer join support */
#define DBI_FOREIGNKEY_CREATETABLE_SYNTAX 208 /* append a foreign key(s) definition to existing Create table statement. */
#define DBI_FOREIGNKEY_ALTERTABLE_SYNTAX  209 /* Generate alter foreign key(s) definition. */
#define DBI_PRIMARYKEY_REFERENCES         210 /* return a list of tables that reference the */
											  /* specified primary key. */
#define DBI_PK_FK_MAXNAMELENGTH           211 /* return the max length that a */
											  /* primary/foreign key may be. */
#define DBI_PK_NAMEABLE                   212 /* can the user specify the primary key name? */
#define DBI_NOTSUPPORT_PRIMARYKEY_DROP    213 /* returns true if dbms can't drop... */
#define DBI_NOTSUPPORT_FOREIGNKEY_DROP    214 /* returns true if dbms can't drop... */
#define DBI_EDITSTYLE_HASH                215 /* build edit style hash list */
#define DBI_COL_EDIT_INFO                 216 /* return edit info for column */
#define DBI_EDIT_UPDATE                   217 /* update the pbcatedt info */
#define DBI_EDIT_DELETE                   218 /* delete the pbcatedt entry */
#define DBI_SHUTDOWN_INTERFACE            219 /* the database interface library is about to be removed from memory.   */
#define DBI_SYNONYM_SOURCE                220 /* obtains a textual description of a table synonym (pbstg_alloc'd memory). */
#define DBI_SPECIAL_DECIMAL               221 /* if TRUE - needs special money string format */
#define DBI_DECIMAL_STRING                222 /* build decimal string */
#define DBI_SUPPORT_INPUT_PARM_BIND       223 /* does the DBMS support input param data */
#define DBI_PREPARE_WITHPARM              224 /* prepare SQL statement with input param data */
#define DBI_MONEY_SCALE                   225 /* decimals for a MONEY data type */
#define DBI_DBHANDLE                      226 /* call to retrieve DBHANDLE return value into lParam, */
											  /* DBI fully supports setting this value, but the */
											  /* database interfaces may set a different value if desired. */
											  /* if you are setting a value, you need to be aware of the flag in */
											  /* wParam : */
											  /*      0 - normal request for dbhandle */
											  /*      1 - request for address of database control block (undocumented DBHANDLE feature) */
											  /* you should set lParam to the value that you */
											  /* want DBHANDLE to return (It's already preset to the lTransactionID value). */
#define DBI_DISPLAY_DSN                   227 /* display a list of ODBC DSNs */
#define DBI_LIST_DSN                      228 /* return a list of ODBC DSNs */
#define DBI_START_TEMPORARY_CONNECT       229 /* start a temporary connect (for ODBC export)                                               */
#define DBI_END_TEMPORARY_CONNECT         230 /* end a temporary connect (for ODBC export)                                              */
#define DBI_REVERSE_ANSI_OUTER            231 /* parse ansi outr join and put back in outerjoin block  */
#define DBI_TIME_INVALID_IN_SEARCH        232  /* Can we put time value in a WHERE clause? */
#define DBI_GET_INSTALLED_DRIVERS         233 /* ODBC SQLGetInstalledDrivers call */
#define DBI_LIST_DATA_SOURCES             234 /* ODBC SQLDataSources loop  */
#define DBI_CONFIG_DATA_SOURCE            235 /* Call SQLConfigDataSource */
#define DBI_DEFAULT_TYPE                  236 /* Get default internal data type */
#define DBI_CHECK_DLL                     237 /* Check if DBMS dll is valid */
#define DBI_PARSE_WHERELIST               238 /* return WHERE clause info */
#define DBI_QUALIFIERS                    239 /* return 0 - standard qualifier rules */
											  /* return 1 - qualify 1 level only */
											  /* return 2 - at most 2 levels  */
#define DBI_SUPPORT_PB_AUTOCOMMIT         240 /* returns TRUE if database supports */
											  /* Powerbuilders autocommit setting */
#define DBI_DEBUG_MESSAGE                 241 /* debug message, used to have the Database Trace  */
											  /* show a message in the output trace file */
											  /* lParam points to the trace message string (LPSTR) */

#define DBI_SUPPORT_REUSABLE_INPUT_PARM_BIND 242
											  /* does the DBMS support input param data and */
											  /* can it reuse the statement, ie; parse the */
											  /* the sql statement with parameter markers for the */
											  /* input parameters and accept the input param data */
											  /* bindings and then execute the statement and be */
											  /* able to do further input param data bindings and */
											  /* execute again (over and over again). */
											  /* Providing this support results in */
											  /* the following benefits: */
											  /* */
											  /*      compile only once for multi insert. */
											  /* */
											  /*      character size limitations are less severe, */
											  /*      ie. some dbms are limited to 255 characters */
											  /*      max in a quoted value. */
											  /* */
											  /*      SQL statement length is reduced. */

#define DBI_PREPARE_FOR_INPUT_PARMS       243
											  /* prepare SQL statement for input param variables, */
											  /* lpszCommandBuffer = sql statement (contains parameter markers) */
											  /* this should only be used if */
											  /* DBI_SUPPORT_REUSABLE_INPUT_PARM_BIND */
											  /* returns non-zero */

#define DBI_BIND_FOR_INPUT_PARMS          244
											  /* used after DBI_PREPARE_FOR_INPUT_PARMS, */
											  /* this guy specifies the list of */
											  /* input bind variables */
											  /* (PDBI_INPUTBIND). */
											  /* This call can come in to rebind */
											  /* a particular statement that has been */
											  /* already prepared and executed. */
											  /* Note that the caller is responsible */
											  /* for releasing the (PDBI_INPUTBIND) */
											  /* storage after calling DBI_DONE_FOR_INPUT_PARMS. */

#define DBI_EXEC_FOR_INPUT_PARMS          245 /* execute the statement that */
											  /* has already been */
											  /* DBI_PREPARE_FOR_INPUT_PARMSd */
											  /* and  */
											  /* DBI_BIND_FOR_INPUT_PARMSd */

#define DBI_DONE_FOR_INPUT_PARMS          246 /* we are done with the */
											  /* statement that was prepared */
											  /* with DBI_PREPARE_FOR_INPUT_PARMS */

#define DBI_SQLCACHE_COMMANDCONTROL       247 /* The DBI Cache support routine */
											  /* use's this command to send */
											  /* requests down to the database */
											  /* interface, wParam will contain */
											  /* operation.  The following */
											  /* is a description of the  */
											  /* various choices: */
											  /* */
											  /* WParam = DBI_SQLCACHE_RELEASESTATEMENT */
											  /* lParam = pCacheEntry which contains */
											  /*          the lpCursor storage that */
											  /*          the database interface should */
											  /*          release (also call database */
											  /*          to release the parsed statement) */

#define DBI_SQLCACHE_RELEASESTATEMENT 0       /* see description for DBI_SQLCACHE_COMMANDCONTROL */

#define DBI_RPC_EXECUTE                   248 /* executes the indicated stored procedure */
#define DBI_SUPPORT_RPC                   249 /* If stored procedures are supported */
											  /* returns true and fills out */
											  /* the 'PDBI_RPC_OPTIONS' (lParam) */
											  /* with the supported options. */
#define DBI_SPECIAL_DOUBLE                250 /* if TRUE - needs special double string format */
#define DBI_FORMAT_NUMERIC DBI_SPECIAL_DOUBLE
#define DBI_DOUBLE_STRING                 251 /* build double string */
#define DBI_SQL_TYPE                      252 /* return datatype list DBI_DATATYPES */

#define DBI_SUPPORT_REUSABLE_DB_PARM_BIND 253
											  /* does the DBMS support input param data and */
											  /* can it reuse the statement, ie; parse the */
											  /* the sql statement with parameter markers for the */
											  /* input parameters and accept the input param data */
											  /* bindings and then execute the statement and be */
											  /* able to do further input param data bindings and */
											  /* execute again (over and over again) if the DB  */
											  /* data type the param maps to is known - Only ODBC */
											  /* returns true in some cases */
											  /* Providing this support results in */
											  /* the following benefits: */
											  /* */
											  /*      compile only once for multi insert. */
											  /* */
											  /*      character size limitations are less severe, */
											  /*      ie. some dbms are limited to 255 characters */
											  /*      max in a quoted value. */
											  /* */
											  /*      SQL statement length is reduced. */
#define DBI_NOLOGPKEY_CREATETABLE_SYNTAX 254  /* append a primary key definition to existing Create table */
											  /* statement with no log. */
#define DBI_NOLOG_CREATETBL_SYNTAX        255 /* return syntax for  */
											  /*"create table" with no log */
#define DBI_NOLOG_CREATEIDX_SYNTAX        266 /* return syntax for  */
											  /* "create index" with nolog*/

#define DBI_NOT_SUPPORT_OWNER_NAME        267 /* owner qualification not supported*/
#define DBI_GETUSERNAME                   268 /* Used by the data pipeline (data migration tool). */
											  /* will fill in lpszUserName field in the */
											  /* DBI_COMMAND block with the database userid */
											  /* this is only done if the userid is not already there. */
#define DBI_PRIMARYKEY_REQUIRES_INDEX_CREATE  269 /* primary key requires unique index */
												  /* for integrity constaints */
#define DBI_GETPUBLICOWNERIDSTRING        270 /* For backend databases that */
											  /* have a particular owner id that can't */
											  /* be placed in front of a table name */
											  /* but indicates that the current user owns a table. */
											  /* This is targeted at Oracle 7 and the way they have */
											  /* 'PUBLIC' as the owner of public synoyms but they */
											  /* don't allow you to select from 'public.syn_name' */
											  /* Oracle will return 'public' for this call so that */
											  /* the sql painter can treat 'public' tables as if they */
											  /* were the users own tables. */
#define DBI_ADJ_LOCAL_DB                  271 /* adjust new local db */
#define DBI_ADDOUTERKEYWORDBEFORETABLENAME 272 /* query if we need to add OUTER keyword */
											  /* before table name for outer join (informix) */
#define DBI_IS_SQL_SELECT_CONVERTABLE     273 /* can the specified SQL Select */
											  /* statement be converted into a PBSELECT? */
#define DBI_SPECIAL_KEY_CREATE  274           /* Used by pipeline to override Primary key create */
											  /* support if it returns TRUE */
#define DBI_SUPPORT_STATIC_BIND 275           /* if db supports binding from PB column */
											  /* info rather than DESCRIBE info return TRUE */
#define DBI_GET_IDENTITY 276                  /* get identity value */
#define DBI_REQUIRE_READBLOB_CONNECT     277  /* database uses second connect to read blob*/
#define DBI_REQUIRE_WRITEBLOB_CONNECT    278  /* database uses second connect to write blob*/
#define DBI_SUPPORT_CLUSTERED_PRIMKEY    279  /* primary key can be clustered or non-clustered */
#define DBI_SUPPORT_DEFAULT_CREATE       280  /* can DB support create table default clause  */
#define DBI_SUPPORT_DEFAULT_ALTER        281  /* can DB support alter table default clause   */
#define DBI_SUPPORT_DEFAULT_EXPRESSION   282  /* can the user supply an expression for default clause */
#define DBI_LIST_DEFAULT_KEYWORDS        283  /* give back PSHLIST of default keywords for combobox   */

//ASH QTS 157050 and 157755 STOP using BULK inserts
//#define DBI_SUPPORT_BULK_INSERT_BIND     284  /* can DB support binding arrays for bulk insert */
//#define DBI_DETERMINE_BULK_INSERT_FACTOR 285  /* determine array size for bulk insert */
//#define DBI_BIND_FOR_BULK_INPUT_PARMS    286  /* bind the input array parms */
//#define DBI_EXEC_FOR_BULK_INPUT_PARMS    287  /* execute for array input parms */
//#define DBI_SET_BUFFER_FOR_BULK_INPUT_PARMS 288 /* set the array buffers for bulk insert */
//End ASH QTS 157050 and 157755 STOP using BULK inserts

#define DBI_QUOTE_TIMESTAMP_VALUE        289  /* quote the SQLSrvr like timestamp value */
#define DBI_DELIMIT_TIMESTAMP_NAME       290  /* delimit the timestamp column name */
#define DBI_NUMERIC_STRING               291  /* format numeric string for SQL syntax */
#define DBI_NEED_TO_BIND_FLOATS_AS_STRING 292 /* do we need to bind floats as string */
#define DBI_NOT_SUPPORT_RPC_ALIAS            293  /* support alias for rpc call */
#define DBI_CHECK_NONFATAL_ERROR          294 /*  rc=0 - FATAL;  rc=1 - NonFatal Error */
#define DBI_FORMAT_ARGS_AS_EXP			  295 /* Ptrack 348185:should we format retrieval args with scientific notation? */
#define DBI_SUPPORT_TXN_SERVER			  296 // ASH - TXNSRVR Jaguar CTS and MTS support
#define DBI_SUPPORT_PROC_PARM_BIND        297	// SM - Indicates if a db allows us to bind input/output
												// and return values instead of explicitly including the
												// the values in the statement
#define DBI_GET_OBJECT_EDITOR			298		// SM - Get object editor interface for a given driver
												// specific object (ie. users, groups)
												// lParam represents the object type,
												// lExtraParm1 represents the window handle
#define DBI_SUPPORT_USERS				299		// Does the driver support returning a list of users
#define DBI_GET_USERS					300		// Returns a list of users using the DBI_OBJECTINFO, lParam may be dbname
#define DBI_DELETE_USER					301		// Deletes a user based on the passed name in the lParam
#define DBI_FREE_USERS					302		// Frees the list of DBI_OBJECTINFO passed in the lParam
#define DBI_SUPPORT_GROUPS				303		// Does the driver support returning a list of groups
#define DBI_GET_GROUPS					304		// Returns a list of groups using the DBI_OBJECTINFO, lParam may be dbname
#define DBI_DELETE_GROUPS				305		// Deletes a group based on the passed name in the lParam
#define DBI_FREE_GROUPS					306		// Frees the list of DBI_OBJECTINFO passed in the lParam
#define DBI_SUPPORT_LOGINS				307		// Does the driver support returning a list of logins
#define DBI_GET_LOGINS					308		// Returns a list of logins using the DBI_OBJECTINFO
#define DBI_DELETE_LOGINS				309		// Deletes a login based on the passed name in the lParam
#define DBI_FREE_LOGINS					310		// Frees the list of DBI_OBJECTINFO passed in the lParam
#define DBI_SUPPORT_TABLE_SECURITY      311		// Support for table security
#define DBI_SUPPORT_COLUMN_SECURITY     312		// Support for column security
#define DBI_SUPPORT_COMMANDS_SECURITY   313		// Support for commands security
#define DBI_TABLE_SECURITY				314		// Display table security dialog (this should be removed
												// when all drivers support a table security object
												// editor).
												// lParam - hParentWnd
#define DBI_COMMANDS_SECURITY			315		// Display commands security dialog (this should be removed
												// when all drivers support a security object
												// editor).
												// lParam - hParentWnd
#define DBI_SUPPORT_SYNONYM				316		// Support synonyms

// DRIVERS MUST SUPPORT ALL THESE DIRECT DDL METHODS IF THEY ANSWER TRUE TO ANY OF THE
// SUPPORT QUESTIONS BELOW.
#define DBI_SUPPORT_DRIVER_CREATETABLE	317		// Driver supports creating any necessary syntax and creates the table
#define DBI_SUPPORT_DRIVER_DROPTABLE	318		// Driver supports creating any necessary syntax and drops the table
#define DBI_SUPPORT_DRIVER_ADDCOLUMNS	319		// Driver supports creating any necessary syntax and add the column to the table
#define DBI_SUPPORT_DRIVER_DROPCOLUMNS	320		// Driver supports creating any necessary syntax and drops the column from the table
#define DBI_SUPPORT_DRIVER_RENAMECOLUMNS	321		// Driver supports creating any necessary syntax and renames the column from the table
#define DBI_SUPPORT_DRIVER_MODIFYCOLUMNS	322		// Driver supports creating any necessary syntax and modifies the column from the table
#define DBI_DRIVER_CREATETABLE			323		// Driver creates any necessary syntax and creates the table
#define DBI_DRIVER_DROPTABLE			324		// Driver creates any necessary syntax and drops the table
#define DBI_DRIVER_ADDCOLUMNS			325		// Driver creates any necessary syntax and add the column to the table
#define DBI_DRIVER_DROPCOLUMNS			326		// Driver creates any necessary syntax and drops the column from the table
#define DBI_DRIVER_RENAMECOLUMNS		327		// Driver creates any necessary syntax and renames the column from the table
#define DBI_DRIVER_MODIFYCOLUMNS		328		// Driver creates any necessary syntax and modifies the column from the table
#define DBI_DRIVER_CREATEINDEX			329		// Driver creates any necessary syntax and creates the index for the table
#define DBI_SUPPORT_DRIVER_CREATEINDEX	330		// Driver supports creating any necessary syntax and creates the index for the table
#define DBI_DRIVER_DROPINDEX			331		// Driver creates any necessary syntax and drops the index for the table
#define DBI_SUPPORT_DRIVER_DROPINDEX	332		// Driver supports creating any necessary syntax and drops the index for the table

#define DBI_CANNOT_IDENTIFY_SYSTEMPROCS	333		// Indicates if a driver can identify what stored procedures are system and
												// which procs are user defined.
#define DBI_CANNOT_CREATEVIEWS			334		// Can the DBMS create views using DDL?
#define DBI_SUPPORT_CHANGE_PASSWORD		335		// Support for changing the password
#define DBI_CHANGE_PASSWORD				336		// Changes password for logged on session
#define DBI_CANNOT_INCLUDEDDLINDMLTRANS	337		// Indicates if DDL statements are allowed within a transaction containing DML
#define DBI_SUPPORT_DRIVER_DROPVIEW		338		// Driver supports creating any necessary syntax and drops the view
#define	DBI_SUPPORT_DRIVER_CREATEVIEW	339		// Driver supports creating any necessary syntax and creates the view
#define	DBI_DRIVER_CREATEVIEW			340		// Driver creates any necessary syntax and creates the view
#define	DBI_DRIVER_DROPVIEW				341		// Driver creates any necessary syntax and drops the view

#define DBI_ACTIVATE_POOLED_CONNECTION   342	// cr204404-threads must explicitly activate transpooled Informix connection */
#define DBI_DEACTIVATE_POOLED_CONNECTION 343	// cr204404-threads must explicitly relinquish transpooled Informix connection */
#define DBI_CAN_IDENTIFY_SYSTEMPROCS	 344		// CR266576

#define DBI_SET_DWNET_TRANSACTION		 345	//set .net transaction object
#define DBI_PARSE_DWNET_PARMS			 346	//parse .net parameters
#define DBI_REMOVE_PK_FROM_IDX			 347	//if remove primarykey from index list

#define DBI_WS_SUPPORT					 348	//if support web services
#define DBI_PROXY_TABLE_INFO			 349	//retrieve proxy table list
#define DBI_WEBSERVICES_INFO			 350	//retrieve web services list
#define DBI_DROP_PROC_SYNTAX			 351	//generate drop proc syntax
#define DBI_DROP_EVENT_SYNTAX			 352	//generate drop event syntax
#define DBI_DROP_TRIGGER_SYNTAX			 353	//generate drop trigger syntax
#define DBI_SUPPORT_TRIGGER_READ		 354    // Driver can obtain a list of triggers
#define DBI_TRIGGER_INFO                 355    // Return trigger list for a specific table
#define DBI_TRIGGER_TEXT                 356    // Return trigger text
#define DBI_SUPPORT_TRIGGER_DELETE		 357	// Driver supports deleting triggers
#define DBI_SUPPORT_PROC_DELETE          358	// Driver supports deleting procedures and functions
#define DBI_SUPPORT_EVENT_READ           359    // Driver can obtain a list of system events
#define DBI_EVENT_INFO                   360	// Return a list of system events
#define DBI_EVENT_TEXT                   361    // Return system event text
#define DBI_SUPPORT_EVENT_DELETE         362    // Driver supports deleting system events
#define DBI_GET_SPID					 363	//Get ASE or ASA @@spid used by Suade
#define DBI_GET_SYSOWNER				 364	//Get database system owners used by suade
#define DBI_GET_CONNECTION_NAME			 365	//Get ASA connection name for suade
#define DBI_GET_SERVER_TIME              366    // CR371583
#define DBI_GET_SELECT_XML_EDITOR		 367	//Get editor interface supporting "select for xml" options
#define DBI_EVENT_ID                     368    // Get Event ID for new event.
#define DBI_PROXYTABLE_CREATE_SYNTAX	 369	// generate create proxytable syntax
#define DBI_PROXYTABLE_DROP_SYNTAX		 370	// generate drop proxytable syntax
#define DBI_TRIGGER_ID                   371    // Get Trigger ID for new event.
#define DBI_GET_SELECT_XML               372
#define DBI_GET_SINGLE_DATA				 373    //get single data from a result set
#define DBI_GET_SELECT_XML_RESULT		 374    //get xml result of a "select for xml" stmt
#define DBI_GET_SELECT_XML_SCHEMA        375    //get xml  schema for "select for xml" stmt using forxmlschemaj function of ASE(only)
#define DBI_IS_DATETIME_EDITABLE		 376    //if dbi_typedatetime is editable(oracle timestamp's precision is editable)
#define DBI_GET_WS_URL					 377    // get hostname/http(s)port/dbname using select property of ASA
#define DBI_SUPPORT_BINARYHEX_UPDATE     378    // DB driver supports dw update of binary/varbinary hex string data
#define DBI_BINARY_HEXSTRING             379    // Format binary hex data for a DML statement
#define DBI_GET_CATALOG					 380	//get current database name
#define DBI_KEEP_VIEW_TEXT				 381	//needn't modify view text from database
#define DBI_NOT_SUPPORT_TSEQUAL			 382	//ms oledb doesn't support function tsequal()
#define DBI_SUPPORT_BATCH				 383	//support batch command or not
#define DBI_SUPPORT_UPDATE_FIRST         384    // Update FIRST allowed in SQL update and delete statement
#define DBI_SUPPORT_UPDATE_TOPN          385    // Update TOP n allowed in SQL update and delete statement
#define DBI_SET_OBJID					 386    // informix pipeline need the function to set source table id
#define DBI_SUPPORT_TEMP_TABLE			 387	// Support Temporary tables
#define DBI_GET_PBCATALOG_OWNER			 388    // Used in Eclipse Workspace plugins to determine the PBCatalog Owner
#define DBI_RENAMEIDX_SYNTAX			 389	// Support informix rename index command
#define DBI_SUPPORT_NLITERAL			 390	// if support N' literal for nchar/nvarchar type
#define DBI_SUPPORT_EMPTYBLOB			 391    //to check whether DBDriver supports empty blob update (default NO)
#define DBI_NOT_SUPPORT_FUNCBIND		 392	// special for CR491994 
#define DBI_SUPPORT_NO_CHECK_NULL_BIND	 393    // special for CR611614
#define DBI_SQL_PRESERVE_SPACE			 394	// CR#629728

#define DBI_GETADOCONNECTION             395
#define DBI_SETADOCONNECTION             396

#define DBI_JAG_DB_RELEASED				 -3		// cr273170
// UPDATE THIS WHEN YOU ADD NEW COMMANDS
#define PB_DBI_COMMANDMAX	394	// This VALUE must be the last value in the commandtype list

/***************************************************************************/
//                            Typedefs
/***************************************************************************/

/*Typedef for database function routine */
		typedef struct  DBI_Command FAR* PDBI_COMMAND;
		typedef PBCALLBACK(PVOID, *DBI_FUNC)  (PDBI_COMMAND);

		// Forward declarations.
		class CPB_DBI_Connection;
		class CPB_DBI_TableSchema;

		/**************************************************************************** */
		/*  Object manager / parm block structures */
		/**************************************************************************** */

		typedef enum
		{
			DBI_3WAY_UNSET = -1,
			DBI_3WAY_FALSE = 0,
			DBI_3WAY_TRUE = 1
		}DBI_3WAY_BOOL;

		struct  DBI_Table;
		struct  DBI_Command;

		/* Primary key structure definition */
		typedef struct DBI_PrimKy
		{
			TCHAR    cName[DBI_MAXNAME];         /* primary key name        */
			INT     iNumberOfColumns;           /* Number of columns in primary key */
			INT     iColumns[MAXCONCAT];        /* array of cols #         */
			struct DBI_Table FAR* lpParentTable;/* Pointer to parent table */
			TCHAR    szCreator[DBI_MAXNAME];     /* Creator of the key      */
			BYTE    bClustered;           	/* Clustered primary key   */
			TCHAR    filler[31];                 /* filler */
		} DBI_PRIMARY_KEY,
			FAR* PDBI_PRIMARY_KEY;

		/* Foreign key structure definition */
		typedef struct DBI_ForeignKy
		{
			TCHAR    cName[DBI_MAXNAME];         /* foreign key name */
			INT     iNumberOfColumns;           /* Number of columns in foreign key */
			INT     iColumns[MAXCONCAT];        /* array of cols # */
			struct DBI_Table FAR* lpParentTable;/* Pointer to parent table */
			TCHAR    szCreator[DBI_MAXNAME];     /* Creator of the key */
			TCHAR    cRefTableName[DBI_MAXNAME]; /* Refers to this Table Name */
			TCHAR    szRefCreator[DBI_MAXNAME];  /* Creator of the reference table */
			BYTE    bDBOption1,             /* Powerbuilder Database DLL interface defined flag 1 */
				bDBOption2,             /* Powerbuilder Database DLL interface defined flag 2 */
				bDBOption3,             /* Powerbuilder Database DLL interface defined flag 3 */
				bDBOption4,             /* Powerbuilder Database DLL interface defined flag 4 */
				bModified,              /* TRUE if the definition of this key has */
				bNotNull,               /* Not Null Foreign key */
				bCheckCommit,           /* CHECK ON COMMIT */
				bFiller1;               /* Unused */

			void FAR* lpLink;                   /* work pointer for the database interface */
												/* DLL's to use. */
			LPTSTR   pOrigFKName;                /* copy of original cName */
			TCHAR    cStatus;                    /* '\0', 'D', 'U', 'A'    */
			short   iUniqueID;                  /* to match up entries from 2 different PSHLISTS */
			LPTSTR   pRefKeyColList;            /* names of the columns in the referenced primary key */
			TCHAR    filler[20];                 /* filler */
		} DBI_FOREIGN_KEY,
			FAR* PDBI_FOREIGN_KEY;

		/* Foreign key option Flags description */
		typedef struct DBI_ForeignKyOptions
		{
			WORD     wOptionCount;               /* how many options does the database interface support? */
			LPTSTR    lpTitle;                    /* title used to describe the options. */
			LPTSTR    lpOptions;                  /* the actual options, each option is  */
												 /* layed out here as a null terminated  */
												 /* string.  The last option string is */
												 /* doubly null terminated (ie; */
												 /* "OPTION1 STRING\0OPTION2 STRING\0" */
												 /* note that the above string is doubly */
												 /* null terminated). */
			WORD     DefOptionNumber;            /* of the above options, which is the default?                                            */
		}  DBI_FOREIGNKYOPTIONS,
			FAR* PDBI_FOREIGNKYOPTIONS;

		typedef struct /* contains the real table name that an Alias */
		{           /* represents */
			TCHAR        cTableName[DBI_MAXNAME];    /* the real Table name */
			TCHAR        cOwner[1];                  /* variable storage for owner name */
		}
		ALIAS_DEF, FAR* pALIAS_DEF;

		/* Table structure */
		typedef struct  DBI_Table
		{
			TCHAR				cTableName[DBI_MAXNAME];      /* Table Name */
			LONG				ObjId;                        /* Table's object id */
			LPTSTR				lpszOwner;                   /* Owner's name */
			INT					iOwnerId;                     /* Owner's id */
			LPTSTR				lpszComments;                /* Ptr to comments */
			INT					iNumberOfColumns;             /* Number of columns */
			INT					iNumberOfKeys;               /* Number of keys */
			LOGFONT				fTableFont[3];				/* logical fonts for */
															/* cols, hdrs, labels */
			PSHLIST				pTableColumnList;			/* Column list */
			PSHLIST				pTableIndexList;			/* Index list */
			LPTSTR				lpszOldTableName;			/* for syntax purposes */
			PVOID				pTableInfo;					/* DB specific info */
			PDBI_PRIMARY_KEY	pPrimaryKy;
			PSHLIST				pForeignKyList;				/* list of Foreign Keys, */
															/* each entry is a 'DBI_FOREIGN_KEY' */
			TCHAR				filler2[130];               /* storage that used to be taken by 'ALIAS_DEF pAliasDef' */
			BOOL				bView;                    	/* if TRUE - this is a view */
			BOOL				bSystem;                  	/* System table switch */
			BOOL				bUniqueKeyConstraint;     	/* Presence of unique key constraint */
			BOOL				bHaveDict;                	/* TRUE - have dict info */
															/* FALSE - don't have it */
			BOOL				bAlias;                   	/* true if this is an alias for a table */
			BOOL				bTempTable;                 /* true if this is an temporary table */
			BOOL				bProxy;						// if it's a proxy table
			BOOL				bCISProxy;					//if it's CIS proxy table
			PVOID				lpUserData1;                /* user data value that can be used by */
															/* whoever requested the Table.*/
			LPTSTR				lpszQualifier;              /* table qualifier, meaning dependent */
			LPTSTR				lpszWebMethod;				//proxy table's web method
			LPTSTR				lpszBaseObject;				// alias based object
			LONG				lTimeout;					//maximum interval that web service must respond
															/* on database */
			PSHLIST  			pTriggerList;       		/*  PSHLIST of DBI_PROCPTRs */
			TCHAR				filler[32];                 /* filler */
		}  DBI_TABLE, FAR* DBI_TBLPTR;

		typedef struct      /* this represents the disk image of table list entry (DBI_TABLE) */
		{               /* Please keep the bitflags in sync */
						/* There is code in pbdbi1.c that use's this structure */

		/* fixed length data */
			ULONG       lRecordLength;                  /* memory size of this table list entry */
			LONG        ObjId;                          /* Table's object id */
			INT         iOwnerId;                       /* Owner's id */
			INT         iNumberOfColumns;               /* Number of columns */
			INT         iNumberOfKeys;                 /* Number of keys */
			BOOL        bView,                      /* if TRUE - this is a view */
				bSystem,                    /* System table flag */
				bUniqueKeyConstraint,       /* Presence of unique key constraint */
				bHaveDict,                  /* TRUE - have dict info */
											/* FALSE - don't have it */
				bAlias,                     /* TRUE if this is an alias for a table */
				bProxy;						/* TRUE if it's a proxy table */
			ULONG       lOwnerNameLength;               /* Owner's name field length (including null terminator) */
			ULONG       lQualifierNameLength;           /* qualifier name field length (including null terminator) */
			ULONG       lTableNameLength;               /* TAble name field length (including the null terminator) */
			/* variable length data */
			TCHAR        cVariableData[1];               /* The Owner name followed by qualifier name */
		} DBI_DISKTABLE, FAR* DBI_DISKTBLPTR;

		/* Column structure */

		typedef struct DBI_Column
		{
			LPTSTR       lpszColumnName;              /* Column name */
			INT         ObjId;                        /* Column's object id */
			LPTSTR       lpszComments;                /* Ptr to column's comments */
			LPTSTR       lpszColumnType;               /* Ptr to data source dependent */
													  /* type name for ODBC    */
			LONG        lColumnLength;                /* Column length */
			UINT        iColumnType;                  /* Data type of column (DB) */
			UINT        iColumnPBType;                /* Data type of column (PB) */
			UINT        iColumnDSType;                 /* accurate dbi type for DataSource */
			UINT        iColumnCType;                 /* Bind type for ODBC types */
			INT         iColumnDec;                   /* # of decimal places */

			INT         iNumberOfColumn;              /* this column # */
			UINT        iNull;                        /* Null indicator */
			LPTSTR       lpszLabel;                    /* Label */
			UINT        iLabPosition;                 /* Label position */
			LPTSTR       lpszHeading;                  /* Heading */
			UINT        iHeadPosition;               /* Heading position */
			UINT        iJustify;                     /* Justify */
			LPTSTR       lpszMask;                     /* Format Mask */
			UINT        iCase;                        /* Case */
			int         iHeight;                     /* Column height */
			int         iWidth;                      /* Column width */
			LPTSTR       lpszPattern;                  /* Validation Pattern */
			LPTSTR       lpszInit;                     /* Initial value */
			BOOL        bComputed;                   /* Computed column flag */
			BOOL			bUpdatable;					/* Updatable Column Flag */
			BOOL        bUseLength;                  /* Length is meaningful */
			BOOL        bBitmap;                     /* if TRUE - this is a bitmap */
			BOOL        bUseScale;                  /* TRUE if type has scale */
			struct DBI_Table  FAR* lpParentTable;    /* Pointer to parent table */
			VOID FAR* pBindLocation;                /* Column bind location */
			VOID FAR* pIndicatorLocation;           /* Indicator bind location */
			INT         iIndicatorLength;             /* Indicator length */
			UINT        iIndicatorType;               /* Indicator type */
			TCHAR        cValueLength;                 /* Runtime value length */
			TCHAR        cStatusCode;                  /* Runtime status code */
			INT         iColumnPrecision;             /* Precision */
			TCHAR        cTableName[DBI_MAXNAME];      /* Parent table name */
			TCHAR        cAliasName[DBI_MAXNAME];    /* Alias name Added by reed.cao*/
			BOOL        bSystemColumn;                /* this is a system column */
			LPTSTR       lpszOldColumnName;            /* for syntax purposes */
			PVOID       pColumnInfo;                  /* DB specific info */
			UINT        iOldNull;                     /* Null indicator before modify */
			LPTSTR       lpszEditStyleName;            /* Edit style name */
			LPTSTR       lpszPatternName;              /* Validation Rule Name */
			LPTSTR       lpszMaskName;                 /* Format name              */
			BOOL        bSelected,                /* User flag, True if this column is selected, */
													  /* this is intended to be used by whoever */
													  /* wants to use it as a flag that indicates */
													  /* that a column has been selected (ie; in a listbox) */
				bUniqueIdxCol,            /* User flag, True if this column */
											  /* is part of an unique index */
				bStoredProc_OutputParameter,
				/* when the DBI_COLUMN is used to */
				/* Describe a stored procedure, this field */
				/* will indicated that the parameter */
				/* is an output parameter (or input and output) */
				bIdentity;                   /* column is an identity type */
											  /* value needs to be updated after insert */
			LONG        lUserData1;                   /* user data value that can be used by */
													  /* whoever requested the column list .*/
			LPTSTR       lpszDefault;                  /* create/alter table default clause syntax */
			LONG			lCharlen;					  /* this is the length by charecter not by byte */
			BOOL			bArray;						/* if it's an array column */

			TCHAR        filler[50];                   /* filler */

		}   DBI_COLUMN, FAR* DBI_COLPTR;

		/* Index structure */

		typedef struct  DBI_Index
		{
			TCHAR        cIndexName[DBI_MAXNAME];      /* Index Name */
			int         iNumberOfColumns;             /* Number of columns */
			INT         iColumns[MAXCONCAT];          /* array of cols # */
			LPTSTR		lpColumnNames[MAXCONCAT];     /* array of cols name # */
			BOOL        bAscend;                     /* TRUE - ascending */
													  /* FALSE - descending */
			BOOL        bUnique;                     /* TRUE -  unique */
													  /* FALSE - duplicate */
			BOOL        bClustered;                   /* TRUE - clustered */
													  /* FALSE - not clustered */
			struct DBI_Table  FAR* lpParentTable;     /* Pointer to parent table */
			PVOID       pIndexInfo;                   /* DB specific info */
			TCHAR        szIndexCreator[DBI_MAXNAME];  /* Creator of the Index */
			TCHAR        cPrimKeyEntry;                /* Y=Yes, N=No,x00=Don't know*/
			LPTSTR       pOrigIdxName;                 /* copy of original cIndexName */
			TCHAR        cStatus;                      /* '\0', 'D', 'U', 'A'    */
			short       iUniqueID;                    /* to match entries from 2 PSHLISTS */
			BYTE        bUnEditable;             /* can't drop because it's a PKey or UC */
			BOOL		bRename;				/* support rename index name */
			TCHAR        filler[54];                   /* filler */

		}  DBI_INDEX, FAR* DBI_IDXPTR;




		typedef struct  Col_Extract
		{
			TCHAR         szColumnName[DBI_MAXNAME];
			TCHAR         szTableName[DBI_MAXNAME];    /* Table name */
			TCHAR         szOwnerName[DBI_MAXNAME];    /* Owner's name */
			DBI_COLPTR   lpColPtr;                    /* Ptr to col block */
			TCHAR         filler[63];                  /* filler */
		}  COL_EXTRACT, FAR* PCOL_EXTRACT;

		typedef struct  Col_ExtractSeq
		{
			LPTSTR        lpszColumnName;
			TCHAR         szTableName[DBI_MAXNAME];    /* Table name */
			TCHAR         szOwnerName[DBI_MAXNAME];    /* Owner's name */
			BOOL         bAsc;                        /* TRUE if sort in asc seq */
			TCHAR         szAliasName[DBI_MAXNAME];    /* Alias name */
			BOOL         bComputed;                   /* TRUE if computed */
			TCHAR         szDBName[DBI_MAXNAME];      /* DB name */
			TCHAR         filler[31];                  /* filler */
		}  COL_EXTRACT_SEQ, FAR* PCOL_EXTRACT_SEQ;

		typedef struct  DBI_Ident
		{
			TCHAR         szColumnName[DBI_MAXNAME];   /* Column name */
			TCHAR         szTableName[DBI_MAXNAME];    /* Table name */
			TCHAR         szOwnerName[DBI_MAXNAME];    /* Owner's name */
			LPTSTR        lpIdentPtr;                  /* Pointer to idenifier's string */
			BOOL         bTable;                      /* TRUE if ident is a table */
			BOOL         bCompute;                    /* set to TRUE if column is computed */
			TCHAR         szDBName[DBI_MAXNAME];      /* Database name */
		}  DBI_IDENT, FAR* PDBI_IDENT;

		typedef struct  DBI_Expr
		{
			LPTSTR		pSyntax;					/* Input syntax */
			LPTSTR		pAllocExpr;					/* Allocated storage for expression */
			LONG			lExprLen;					/* Length of expression */
		}  DBI_EXPR, FAR* PDBI_EXPR;

		/* Proc structure */

		typedef struct  DBI_Proc
		{
			TCHAR       cProcName[DBI_MAXPROCNAME];       /* Proc Name */
			LONG        ObjId;                        /* Proc object id */
			LPTSTR      lpszOwner;                   /* Owner's name */
			INT         iOwnerId;                     /* Owner's id */
			INT         iNumber;                      /* Sub-procedure number */
			BOOL        bSystem;                      /* TRUE if system proc */
			UINT        iReturnValuePBType;           /* if bHasReturnValue is set then */
													  /* will indicate the type of the return value */
			BOOL        bHasReturnValue;              /* TRUE if this procedure returns a value */
			LPTSTR      lpszalias;	                 /* alias name - if NULL pointer use cProcName */
			INT         iDbId;                        /* for pbsyc.  Identifies database  */

			BOOL        bTrigger;                     /* TRUE if Trigger */
			struct DBI_Table  FAR* lpParentTable;     /* Pointer to parent table of trigger */
			LPTSTR      pText;                        /* Trigger definition */
			BOOL		   bArray;						/* if return value is an array */

			TCHAR       filler[36];                   /* filler */

		}  DBI_PROC, FAR* DBI_PROCPTR;

		typedef struct  DBI_Event
		{
			TCHAR       cEventName[DBI_MAXPROCNAME];  /* Event Name */
			LONG        ObjId;                        /* Event object id */
			LPTSTR      lpszOwner;                    /* Owner's name */
			TCHAR       cEnabled;                     /* Enabled / Disabled */
			TCHAR       cLocation;                    /* A-All; C-Consolidated; R-Remote */
			TCHAR       cEventType[30];               /* Event type */
			LPTSTR      pAction;                      /* Action */
			LPTSTR      pExtAction;                   /* External Action */
			LPTSTR      pCondition;                   /* Condition */
			LPTSTR      pRemarks;                     /* Comments */
			LPTSTR      pGenSyntax;                   /* Generated Syntax */
			PSHLIST     pScheduleList;                /* Event schedules */
			TCHAR       filler[8];                    /* filler */
		}  DBI_EVENT, FAR* DBI_EVENTPTR;

		typedef struct DBI_Sched
		{
			SHORT		iRecur;
			SHORT		iDaysOfWeek;
			ULONG		ulDaysOfMonth;
			LONG		lIntervalAmt;
			SH_TIME	StartTime;
			SH_TIME	StopTime;
			SH_TIME	StartDate;
			TCHAR		cScheduleName[DBI_MAXNAME];
			TCHAR		cIntervalUnits[11];
		}  DBI_EVENT_SCHED, FAR* PDBI_EVENT_SCHED;

		//webservices type
		typedef enum
		{
			DBI_WSTYPE_UNKNOWN = 0,
			DBI_WSTYPE_DISH = 1,
			DBI_WSTYPE_SOAP = 2,
			DBI_WSTYPE_XML = 3,
			DBI_WSTYPE_HTML = 4,
			DBI_WSTYPE_RAW = 5
		}DBI_WSTYPE;

		//webservice structure
		typedef struct DBI_WebService
		{
			TCHAR		cServiceName[DBI_MAXNAME];/* WebService Name */
			DBI_WSTYPE	type;	/*WebService Type */
			ULONG		ulServiceId;              /* service's id */
			BOOL		bAuth;			/* if need a valid user */
			BOOL		bSecure;		/* if secure connection is needed*/
			BOOL		bURL; 			/* if URI is accepted*/
			BOOL             bRunAsUser;           /* if web service need to run as a specified user */
			LPTSTR          lpszStoredProc;         /*associated stored procedure */
			LPTSTR		lpszUser;              	/* user has the permission to use the service*/
			LPTSTR		lpszParameter;          /* prefix in a DISH service*/
			LPTSTR		lpszSyntax;		/* executed sql statement*/
			LPTSTR		lpszComment;		/* remark */

		}DBI_WEBSERVICE, FAR* DBI_WEBSERVICEPTR;

		/* Outer join structure for building outer join syntax */

		typedef struct  DBI_Outer
		{
			LPTSTR   lpFirstJoin;                      /* First join name */
			LPTSTR   lpSecondJoin;                     /* Second join name */
			LPTSTR   lpOperator;                       /* Operator */
			LPTSTR   lpOuterJoin;                      /* Outer join name */
			LPTSTR   lpBuffer;                         /* Buffer for syntax */
			LONG     lBufferSize;
			LPTSTR   lpFirstTable;                     /* First table name (only for outer ANSI join) */
			LPTSTR   lpSecondTable;                    /* Second table name (only for outer ANSI join) */
			LPTSTR   lpFirstAlias;                     /* First table alias name (only for outer ANSI join) */
			LPTSTR   lpSecondAlias;                    /* Second table alias name (only for outer ANSI join)    */
			int     iVersionNumber;                   /* PB version with 2 implied decimal places */
													  /* 0 indicates prior to version 4 */
													  /* 400 is version 4.0 */
			TCHAR        filler[54];                   /* filler */
		}  DBI_OUTER, FAR* PDBI_OUTER;

		/* Validate / Format structure */

		typedef struct  DBI_Edit
		{
			LPTSTR   lpName;                           /* Edit name */
			LPTSTR   lpValue;                          /* Edit value */
			INT     iType;                            /* Edit type */
			LONG    lCounter;                         /* Countr value */
			LONG    lStyle;                           /* Edit style      */
			SHORT   sSeqn;                            /* Sequence number */
			LPTSTR   lpExtraValue;                     /* Extra value for edit style                    */
			TCHAR    filler[32];                       /* filler */
		}  DBI_EDIT, FAR* PDBI_EDIT;

		/* Syntax entry structure */

		typedef struct DBI_DSyntax
		{
			LPTSTR   lpSyntaxPtr;                    /* Ptr to syntax string */
			TCHAR    filler[32];                     /* filler */
		}  DBI_DSYNTAX, FAR* PDBI_DSYNTAX;


		/* */
		/* Dialog box invocation structure */
		/* */
		typedef struct DBI_Dialog
		{

			HWND        hParentWnd;                   /* Handle to parent window */
			INT         iDialogID;                    /* Dialog ID */
			TCHAR        filler[8];                    /* filler */

		} DBI_DIALOG, FAR* PDBI_DIALOG;

		/* */
		/* SQL runtime bind structure (for output parameters) */
		/* */
		typedef struct DBI_Bind
		{
			PVOID       pDataLocation;                /* Data location */
			PVOID       pIndicatorLocation;           /* Indicator location */
			LONG        lDataLength;                  /* Data length */
			UINT        iDataType;                    /* PB data type of data reference */
			UINT        iDBDataType;                  /* Database data type */
			UINT        iCDataType;                   /* C data type to bind to for ODBC   */
			UINT        iDecPlaces;                   /* # of decimal places */
			UINT        iLastDataTypeBound;           /* Last data type bound */
			LONG        lValueLength;                 /* Value length */
#ifdef DW_OCX
			LPTSTR       pColumnName;                  /* column name */
			PVOID       pGuestLocation;               /* DBX Data location */
			PLONG       pGuestLength;                 /* DBX return length/indicator */
			ULONG       ulPrecision;
			USHORT      iNull;                    	  /* column is nullable  */
			SHORT       iGuestCDataType;              /* DBX C data type */
			TCHAR        filler[12];                   /* filler */
#else
			TCHAR        filler[32];                   /* filler */
#endif //DW_OCX
		} DBI_BIND, FAR* PDBI_BIND;

		/* database Remote Procedure Call Options */
		typedef struct
		{
			WORD        bSupportArrays,    				/* Supports arrays? */
				bSupportIndicatorArray,    		/* for arrays, are indicator */
												/* variable arrays supported? */
												/* if so then 'wBytesPerIndicator' */
												/* should be set to indicator variable */
												/* array element size. */
				bSupportLengthArray,  			/* for arrays, arrays of length's */
												/* supported? */
												/* if so then wBytesPerLength should */
												/* be set to element size. */
				bSupportOutputArgs,			    /* Support output parameters? */
				bSupportBlobArgs,			    /* Support blob parameters? */
				bCheckBlobLength,			    /* true if blob lengths should be validated against wMaxBytesPerArg */
				bCheckArrayLength,			    /* true if total array length should be validated against wMaxBytesPerArray */
				bUnused;					    /* filler */
			WORD        wMaxBytesPerArg;                /* max size of non array parameter? */
			WORD        wMaxBytesPerArray;              /* max size of an array. */
			WORD        wBytesPerIndicator;             /* if 'bSupportIndicatorArray' */
														/* then this indicates bytes */
														/* in an indicator variable  */
														/* (sizeof( pArrayIndicatorVar[0])). */
			WORD        wBytesPerLength;                /* if 'bSupportLengthArray' */
														/* then this indicates bytes */
														/* in a length variable */
														/* (sizeof(pArrayLengths[0])). */
			TCHAR        filler[12];                     /* filler                                                 */
		} DBI_RPC_OPTIONS, FAR* PDBI_RPC_OPTIONS;

		/* database Remote Procedure Call argument definition */
		typedef struct
		{
			PVOID       pDataLocation;                /* Data location */
			union
			{
				LONG        lIndicatorValue;           /* -1 for null, or equal to iDataLength */
				INT         iInternalIndicatorValue;   /* for DBMS interface only */
				SHORT       iInternalSmallIndicatorValue;   /* for DBMS interface only */
			} uIndic;
			union
			{
				LONG        lDataLength;               /* length of data (must be less then UINT_MAX) */
				INT         iInternalDataLength;       /* for DBMS interface only */
				SHORT       iInternalSmallDataLength;  /* for DBMS interface only */
			} uLen;
			UINT        iDecPlaces;                   /* # of decimal places */
			UINT        iDataType;                    /* PB data type of data reference */
			UINT        iDBDataType;                  /* Database data type */
			UINT        iCDataType;                   /* Database data type */
			ULONG       ulPrecision;                  /* precision */
			INT         iScale;                       /* scale */
			LONG        lLocationSize;                /* allocated buffer size */
			WORD        bRPCbyReference,          	/* True if this bind value buffer */
													/* is being passed by reference (input/output), */
													/* else its passed by value (input only). */
				bArrayOf,                 	/* True if pDataLocation points */
											 /* to an array of iDataType. */
				bDataIsExternal,          	/* pDataLocation points to data */
											 /* that is owned by someone else */
											 /* and should not be released */
											 /* with this input bind storage. */
				bHostVariableIsDEC;        	/* TRUE if the host variable */
											 /* is really a powerbuilder  */
											 /* DECIMAL data type, but has been */
											 /* passed as char. */
			PVOID       pRPCBackPatchInfo;            /* Reserved for the Runtime engine */
													  /* component to keep track of  */
													  /* actual argument addresses for */
													  /* backpatching values after the */
													  /* rpc call is made. */
			LONG        lArrayElements;               /* if bArrayOf is set then this */
													  /* indicates the number of elements */
													  /* in the array (this many variables  */
													  /* of type iDataType). */
			LONG        lArrayElementsWritten;        /* For arrays that are output */
													  /* variables (to be written to */
													  /* by the stored procedure) */
													  /* this is the number of entries */
													  /* written to the array (less then */
													  /* or equal to lArrayElements). */
			PVOID       pArrayIndicatorVar;           /* if argument is an array */
													  /* and indicator variable  */
													  /* arrays are supported then */
													  /* will point to the indicator */
													  /* variable storage. */
			PVOID       pArrayLengths;                /* if argument is an array */
													  /* and array of Lengths are supported, */
													  /* then this points to length array storage. */
			ULONG	   ulOrdinal;					 /* parm's ordinal */
			LPTSTR	   lpstrArgName;				 /* parm name */

			PVOID       pConversionBuffer;            /* reserved for db interface datatype conversions */
		}
		DBI_RPC_ARG, FAR* PDBI_RPC_ARG;

		typedef enum
		{
			DBI_PARAM_TYPE_UNKNOWN = 0,
			DBI_PARAM_INPUT = 1,
			DBI_PARAM_INPUT_OUTPUT = 2,
			DBI_PARAM_OUTPUT = 3
		} DBI_PARMTYPE;

		/* SQL runtime bind structure (for input parameters) */
		typedef struct
		{
			PVOID		pDataLocation;					/* Data location */
			union
			{
				LONG		lIndicatorValue;				/* -1 for null, or equal to iDataLength */
				INT			iInternalIndicatorValue;		/* for DBMS interface only */
				SHORT		iInternalSmallIndicatorValue;	/* for DBMS interface only */
			} uIndic;
			union
			{
				LONG		lDataLength;					/* length of data (must be less then UINT_MAX) */
				INT			iInternalDataLength;			/* for DBMS interface only */
				SHORT		iInternalSmallDataLength;		/* for DBMS interface only */
			} uLen;
			UINT			iDecPlaces;						/* # of decimal places */
			UINT			iDataType;						/* PB data type of data reference */
			UINT			iDBDataType;					/* Database data type */
			UINT			iDSDataType;					/* accurate DBI data type for DataSource*/
														 /* This must be 0 if PB doesn't */
														 /* know what the DB type.  Otherwise ODBC */
														 /* will use it to set the bind param */
			TCHAR		cParamId[DBI_MAXNAME];	/* input param identifier (including the COLON) */
			UINT			iCDataType;						/* Database data type */
			ULONG		ulPrecision;					/* precision */
			INT			iScale;							/* scale */
			LONG			lLocationSize;					/* allocated buffer size */
			ULONG		ulMaxDataLength;				/* maximum data length expected for this bind value */
														 /* This value may be zero if not known */
			PLONG		pMaxDataLength;					/* array of parameter value lengths*/
			LONG			lEntryLength;					/* length of 1 entry in the input array */
			DBI_PARMTYPE	pBindType;						// Indicates if the parameter is input, input/output or output

			//if string data need binded as ansi(utf8), use the location in case pDataLocation is not long enough.
			PVOID		pCVTDataLocation;				/* Converted data location */
		}
		DBI_INPUTBIND, FAR* PDBI_INPUTBIND;

		typedef enum                               /* value returned by the */
		{                                      /* DBI_SUPPORT_INPUT_PARM_BIND */
			DBI_PARMSTYLE_NOTSUPPORTED = 0,          /* call. */
			DBI_PARMSTYLE_COLON = 1,
			DBI_PARMSTYLE_QUESTIONMARK = 2,
			DBI_PARMSTYLE_NAMED = 3
		} DBI_PARMSTYLE;

		/* Data Structures for SQL Cache implementation */
		typedef struct
		{
			LPTSTR   lpszSqlStatement;   /* The Sql Statement, cache owns this storage. */
			PSHLIST pDescribeList;      /* List of Column Descriptions, the DBI cache  */
										/* support routines owns this storage  */
										/* (list of pCacheColDescribe). */
			PSHLIST pInputBindList;     /* List of input value bind buffers, this */
										/* storage is owned by the database interface */
										/* at hand and should be released by the */
										/* database interface on the DBI_SQLCACHE_RELEASESTATEMENT */
										/* (list of PDBI_INPUTBIND). */
										/* It's also up to the db interface to fill this */
										/* field in. */
			LPVOID  lpCursor;           /* This is storage that belongs to  */
										/* the database interface that */
										/* actually prepared the SQL statement (cache doesn't own this storage). */
			ULONG   cHits;              /* How many times did we use this sql entry. */
			ULONG   lParam1;            /* The database interface at hand can do  */
										/* whatever it pleases with this member. */
			WPARAM  wParam1;            /* The database interface at hand can do  */
										/* whatever it pleases with this member. */
			TCHAR    filler[2];
		} CacheEntry, FAR* pCacheEntry;

		typedef struct
		{
			PSHLIST pEntries;           /* List of cached SQL Statements (pCacheEntry). */
			ULONG   cEntryLimit;        /* Max number of statements that can be  */
										/* cached (zero if cache is disabled). */
			ULONG   cHits;              /* How many times did we find a SQL statement in */
										/* the cache. */
			ULONG   cMisses;            /* How many times did we not find a SQL  */
										/* statement in the cache.                                 */
			TCHAR    filler[4];
		} CacheList, FAR* pCacheList;

		typedef struct
		{
			LPTSTR       lpszColumnName;              /* Column name */
			LPTSTR       lpszColumnType;               /* Ptr to data source dependent */
													  /* type name for ODBC */
			LONG        lColumnLength;                /* Column length */
			UINT        iColumnType;                  /* Data type of column (DB) */
			UINT        iColumnPBType;                /* Data type of column (PB) */
			UINT        iColumnCType;                 /* Bind type for ODBC types */
			INT         iColumnDec;                   /* # of decimal places */
			INT         iNumberOfColumn;              /* this column # */
			UINT        iNull;                        /* Null indicator */
			BOOL        bComputed,                /* Computed column flag */
				bUseLength;                /* Length is meaningful */
			INT         iIndicatorLength;             /* Indicator length */
			UINT        iIndicatorType;               /* Indicator type */
			INT         iColumnPrecision;             /* Precision */
			TCHAR        filler[8];                    /* filler */
		} CacheColDescribe, FAR* pCacheColDescribe;

		/* DBI datatype list - used for the pipeline */

		typedef struct
		{
			TCHAR        szColumnType[DBI_MAXNAME];    /* Ptr to data source dependent */
			UINT        iColumnType;                  /* Internal Data type of  */
													  /* column (DB) */
			UINT        iColumnPBType;                /* Data type of column (PB) */
			BOOL        bUseLength;                   /* Length is meaningful */
			BOOL        bUseScale;                    /* Scale is meaningful */
			UINT        iDefaultLength;               /* Used by Table Painter */
			LONG        lMaxLength;                   /* Used by Table Painter */
			UINT        iMaxScale;                    /* Used by Table Painter */
#ifdef DW_OCX
			INT         iSQLCtype;                    /* SQL C TYPE used for Optima */
													  /* native driver support      */
			INT         iSQLtype;                     /* SQL DB TYPE used for Optima */
													  /* native driver support      */
#endif //DW_OCX
		} DBI_DATATYPES, FAR* PDBI_DATATYPES;



		/* */
		/* Definitions for DBI callback to PowerScript
		/* */
		typedef struct DBI_DBNotifyData
		{
			LONG lCode;
			LPCTSTR command;
			LPCTSTR message;
		}DBI_DBNOTIFYDATA, FAR* PDBI_DBNOTIFYDATA;

		typedef struct DBI_DBErrorData
		{
			LONG lCode;
			LPTSTR lpSQLErrorText;
			LPTSTR lpSQLSyntax;
		}DBI_DBERRORDATA, FAR* PDBI_DBERRORDATA;

		typedef struct DBI_SQLPreviewData
		{
			LONG function;
			LPTSTR lpSQLSyntax;
		}DBI_SQLPREVIEWDATA, FAR* PDBI_SQLPREVIEWDATA;

		typedef enum
		{
			DBI_TRANSEVT_DBNOTIF = 0,
			DBI_TRANSEVT_DBERROR = 1,
			DBI_TRANSEVT_SQLPREV = 2
		}DBI_TRANSEVTTYPE;

		struct  DBI_Command;
		typedef   PBCALLBACK(LONG, *DBIPSCallback) (DBI_Command*, PVOID, DBI_TRANSEVTTYPE);

		/* */
		/* SQL command execution structure */
		/* */
		typedef struct  DBI_Command
		{
			TCHAR			szReturnText[DBI_MAXBERRBUFFER];            /* Return text */
			INT				iCommandType;                 /* Command type */
			LONG			lReturnCode;                  /* Return code */
			LONG			lTransactionID;               /* Transaction ID */
			LONG			lReturnValue;                /* Anything that DB returns */
			DBI_FUNC		lpfnRouteProc;               /* Proc of DLL */
			HANDLE			hLibrary;                    /* Handle to the DLL library */
			TCHAR			szDbms[DBI_MAXNAME - 1];     /* DBMS name */
			LPTSTR			lpszLogId;                    /* Login ID */
			LPTSTR			lpszServerName;              /* Server name */
			LPTSTR			lpszLogPassWord;              /* Login password */
			LPTSTR			lpszCommandBuffer;            /* Command buffer */
			LPTSTR			lpszDatabaseName;             /* Database name */
			LPTSTR			lpszPassWord;                 /* Password for database */
			LPTSTR			lpszUserName;                 /* User name (signed on) */
			LPTSTR			lpszLock;                     /* Lock option */
			LPTSTR			lpszDbParm;                   /* Database specific parameter */
			WPARAM			wParam;                      /* Word parameter to pass along (changed from WORD to WPARAM for NT PORT) */
			LONG			lParam;                      /* Long parameter to pass along */
			LPTSTR			lpExtraParm1;                 /* additional string parm */
			LPTSTR			lpExtraParm2;                 /* additional string parm */
			LONG			lExtraParm1;                  /* additional long parm */
			LONG			lExtraParm2;                  /* additional long parm */
			pbstg_subpool	subpoolParm;				 /* subpool parameter */
			PSHLIST			pDescribeColList;             /* Col descriptor list */
			INT				iNumberOfVariables;          /* Number of variables */
			PDBI_BIND		pBindBuffer;                 /* Pointer to bind buffer */
			LPTSTR			lpszCursorName;               /* Cursor name */
			LPTSTR			lpszTblOwner;                 /* Table owner for syntax use */
					   /*  also used for stored procs */
			PSHHASH			pFormatHash;                  /* Ptr to format hash table */
			PSHHASH			pValidHash;                   /* Ptr to validation hash table */
			PSHHASH			pEditStyleHash;               /* Ptr to edit style hash table                                              */
			LONG			lRuntimeCode;                 /* Runtime code */
			ppbstg_anchor	stgThis;                      /* storage manager THIS ptr */
			PVOID			pExtBlock;                    /* Database dependent ext block */
			PSHLIST			pSyntaxList;                  /* List of syntax strings */
			PSHLIST			pErrorList;                   /* Error list    */
			INT				iOperationMode;               /* Mode of operation (awaiting data etc) */
			BOOL			bAsync;                       /* TRUE if async execution requested */
			BOOL			bExportSameDB;                /* TRUE if we export within the same DBMS */

			BYTE			bNoDescribeDW,			/* If TRUE, then DataWindows  */
													/* shouldn't do a describe of the */
													/* SQL statement to get column  */
													/* information 'pDescribeColList', */
													/* as 'pDescribeColList' will already be  */
													/* pointing at the column list. */
				bMoreErrorMsgs,			/* If true more errors are in */
										/* the list pointed to by pErrorList. */
				bPromptForAll,			/* If true prompt for all info to connect. */
				bNoDelimitReserveWord,	/* If true don't call database dll to delimit */
				bChildConnect,			/* True if this DBI_COMMAND block was obtained */
				bGuestConnect,			/* True if Connect was made by Optima, VB, etc. */
				bNeedBLOBNRows;			/* True if  We need to get NRows in DBI_WriteBlob */
							 /*  */

			BYTE			bReadOnly,				/* database is read only */
				bNoPBCatalog;			/* no catalog available */

			BOOL			filler2;

			LPTSTR			lpszWorkData;			/* DBMS specific value, pointer to character  */
													/* string whose memory should be allocated/released */
													/* by the DBMS interface (release on database logoff). */
			LPTSTR			lpszDataSource;			/* ODBC data source pointer  */

			DWORD			dwFlags;				/* PowerBuilder flags                       */
			pbstg_subpool	subpool;				/* subpool to allocate from */
			pCacheList		pSelectCache;			/* cache of Select Statement's */
			struct DBI_Command FAR*
				pParentDB;				/* if bChildConnect is set */
										/* then this points to the  */
										/* real Command block that  */
										/* we are a copy of. */
			PSHLIST			pDatatypeList;			/* dataype list  */
													/* via the DBI_DummyConnect(). */
			BYTE			bDescribeSpecial,		/* True if extra DB API call is needed to */
													/* determine data type, used only by ODBC */
													/* interface for pipeline processing */
													/* Also set for DBI_PROC_INFO call */
													/* to request that information on */
													/* Output/return values be returned */
				bUseQualifier,			/* true if table qualifier needed */
				bNoSyntaxLog,			/* No syntax log used */
				bTableListCacheHasNonSystem,	/* table list cache contains nonsystem table list entries */
				bTableListCacheHasSystem,		/* table list cache contains system table list entries */
				bCommitOnDisconnect;	/* johnf: Commit changes on Disconnect? */

			TCHAR			cQuote;					/* quote character */
			ULONG			lTableListAge;			/* used to determine if we will */
													/* cache the table list. */
													/* 0 = no cache */
													/* > 0 = number of seconds to cache */
													/* the table list for. */
			ULONG			lTableListLastRefresh;	/* indicates when the last table list was obtained */
			LPTSTR			lpszTableListFileName;	/* name of the temporary file containing the table list */
			PVOID			obThis;					/* Ptr to object mgr this */
			struct DBI_Command FAR*
				pPipeDB;				/* if pipeline db requires */
										/* a 2nd connection to read or */
										/* write blobs it is opened  */
										/* by the pipe. */
			PSHLIST			pDefaultList;			/* list of default keywords supported by db */
													/* added to replace globals used in database */
													/* drivers across creat syntax calls   */
			HWND			hWinSyntax;				/* window handle for syntax generation */
			SHORT			nLogWidth;				/* database syntax log                 */
			TCHAR			cDecimalSeparator;		/* DBMS decimal separator              */
			LPTSTR			lpszTempStrBuffer;		/* used by 'DBI_DoubleTheQuotes()' */
													/* temporary storage buffer released by disconnect */
			BYTE            bGenEqualsNull;		    /* Mikec CR 236038  */

			BOOL			bDontCommitAbort;		// ASH - TXNSRVR Jaguar CTS support
			BOOL			bUseContextObject;		// ASH - TXNSRVR Jaguar CTS support PB7.0 uses Conext object
													// instead of 6.0 semantics which use COMMIT to call SetComplete()
													// ABORT to call SetAbort()
			BOOL			bSupportStoredProc;		/* Whether to support stored procedures */
			PVOID			pTrace;					// SM - Tracing class added if we need to trace DBI
			//TCHAR			morefiller[8];			/* filler */
			INT				iJagDBConnection;		// To keep the info DB connection with Jaguar(Connect/Disconnect) CR#273170
			LONG			lProvList;				// for ADO.Net Provider retrive from OLEDB
			BOOL			bDoubleQuoted;			// CR#309174
			BOOL			bInRuntime;
			INT				iType;					//current cursor command type
			BOOL			bDSI;					//it's a DSI block
			LONG			lWarningCode;			//DSI warning code
			LPTSTR			lpWarningMsg;			//DSI warning message

			CPB_DBI_Connection* pDBIConnect;		// CPB_DBI_Connection class instance associated with this DB connection

			DBIPSCallback  fnPS_Callback;			// The function pointer to notify the PowerScript Transaction object
		} DBI_COMMAND;

		typedef struct  DBI_Error
		{
			LONG        lRow;                         /* row the error occurred in */
			LONG        lReturnCode;                  /* database return code */
			TCHAR        szReturnText[DBI_MAXBERRBUFFER];            /* error text */
		} DBI_ERROR, FAR* PDBI_ERROR;

		typedef struct  DBI_PrepBlk
		{

			TCHAR        szTableName[DBI_MAXNAME];        /* Table name */
			TCHAR        szAliasName[DBI_MAXNAME];       /* Alias name */
			TCHAR        szOwnerName[DBI_MAXNAME];        /* Owner's name */
			DBI_TBLPTR  pTableBlock;                    /* Ptr to tbl block */
			BOOL        bHoldLock;                       /* Lock on this table */
			PVOID       pWork;                           /* Wrk field */
			TCHAR        filler[27];                      /* filler */
			TCHAR        szDBName[DBI_MAXNAME];          /* Database name */

		} DBI_PREPBLK, FAR* PDBI_PREPBLK;


		typedef struct DBI_WhereBlk                   /* Where criteria information */
		{

			LPTSTR      lpszExpression1;               /* Pointer to expression 1 string */
			LPTSTR      lpszExpression2;               /* Pointer to expression 2 string */
			LPTSTR      lpszLogical;                   /* Pointer to logical operator string */
			LPTSTR      lpszOperator;                  /* Pointer to operator string */
			short      nOuter;                        /* 0 if not outer join, */
													  /* 1 if left outer join */
													  /* 2 if right outer join    */
		} DBI_WHEREBLK, FAR* PDBI_WHEREBLK;


		typedef struct  DBI_ParmBlk
		{
			LPTSTR      lpKey;
			LPTSTR      lpValue;
			LONG       lValue;
			TCHAR       filler[32];                 /* filler */
		} DBI_PARMBLK, FAR* PDBI_PARMBLK;

		/* */
		/* Connect structure */
		/* */

		typedef struct DBI_Signon
		{
			PDBI_COMMAND  pOldCommandBlk;            /* Ptr to old command blk */
									 /* (if previously signed on) */
			LPTSTR lpszDbms;                          /* Ptr to DBMS */
			LPTSTR lpszServerName;                    /* Ptr to server name */
			LPTSTR lpszLogId;                         /* Ptr to log id */
			LPTSTR lpszLogPassword;                   /* Ptr to log password */
			LPTSTR lpszDatabaseName;                  /* Ptr to database name */
			LPTSTR lpszUserId;                        /* Ptr to user id */
			LPTSTR lpszUserPassword;                  /* Ptr to user password */
			LPTSTR lpszAppName;                       /* Ptr to app painter name */
			short nConnectStep;                      /* Where to start */
			HWND  hParentWnd;                        /* Parent window */
			LPTSTR lpszLock;                          /* Lock option */
			LPTSTR lpszDbParm;                        /* Database parameter */
			ppbstg_anchor stgThis;                           /* Storage manager THIS ptr */
			BYTE  bReadOnly,                     /* database is read only */
				bNoPBCatalog;                  /* no catalog available           */
			TCHAR  filler[63];                        /* filler */
		} DBI_SIGNON, FAR* PDBI_SIGNON;

		/* */
		/* Syntax structure */
		/* */

		typedef struct DBI_Syntax
		{
			LPTSTR   lpszTableName;
			LPTSTR   lpszOldTableName;
			LPTSTR   lpszColumnName;
			LPTSTR   lpszOldColumnName;
			TCHAR    filler[64];                 /* filler */
		} DBI_SYNTAX, FAR* PDBI_SYNTAX;

		typedef struct DBI_Config_Parms
		{
			HWND    hWnd;
			UINT    fRequest;
			LPCTSTR  lpszDriver;
			LPCTSTR  lpszAttributes;
		}  DBI_CONFIG_PARMS, FAR* PDBI_CONFIG_PARMS;

		typedef struct DBI_ObjectInfo
		{
			INT 	iObjectType;
			LPTSTR	lpszLabel;
			PVOID	pData;
		} DBI_OBJECTINFO, FAR* PDBI_OBJECTINFO;

		typedef struct DBI_DBSpecificInfo
		{
			LPTSTR	lpszDbName;
			PVOID	pData;
		} DBI_DBSPECIFICINFO, FAR* PDBI_DBSPECIFICINFO;

		typedef struct DBI_User
		{
			TCHAR cUserName[DBI_MAXNAME];
			TCHAR cUserGroup[DBI_MAXNAME];
			TCHAR cUserLogId[DBI_MAXNAME];
			TCHAR cDBName[DBI_MAXNAME];
		} DBI_USER, FAR* PDBI_USER;

		typedef struct DBI_Group
		{
			TCHAR cGroupName[DBI_MAXNAME];
			TCHAR cDBName[DBI_MAXNAME];
		} DBI_GROUP, FAR* PDBI_GROUP;

		typedef PBCALLBACK(BOOL, *DBI_DLGPROC)(HWND, UINT, WPARAM, LPARAM);

		/*******************************************************************/
		/*    Name    :  Syntax Generation Subroutines                     */
		/*    Synopsis:  Each database interface had its own external      */
		/*               variables and subroutines to handle syntax gen.   */
		/*               This eliminates the global variables and central- */
		/*               izes the process so that the interface dlls are   */
		/*               more thread-safe.                                 */
		/*******************************************************************/
		typedef struct DBI_Syntaxgen
		{
			LPTSTR lpBufAddr;
			LPTSTR lpBufPtr;
			LPTSTR lpBufEnd;
			LPTSTR lpLineEnd;
			LPTSTR lpLineStart;
			SIZE  dwExtent;
			HDC   hDC;
			SHORT nSemWidth;
			SHORT nLogWidth;
			SHORT nLogLength;
			HWND  hWrkSpace;
		} DBI_SYNTAXGEN, FAR* PDBI_SYNTAXGEN;

		typedef struct pdp_command
		{
			PDBI_COMMAND	pCommand;
			LPTSTR			lpszCommand;
		} PDP_COMMAND, FAR* PPDP_COMMAND;

		typedef enum                           /* Optional filters for */
		{                                      /* DBI_ProcInfo() call. */
			DBI_PROCINFO_ALL = 0,                /* Not all drivers can support, */
			DBI_PROCINFO_RESULTSET = 1,          /* default to all. */
			DBI_PROCINFO_NO_RESULTSET = 2
		} DBI_PROCFILTER;

		enum DBI_CaseSensitivity
		{
			DBI_DBCASEUNKNOWN = -1,
			DBI_DBCASEINSENSITIVE,
			DBI_DBCASELOWERCASE,
			DBI_DBCASEUPCASE,
			DBI_DBCASEMIXED,
			DBI_DBCASESENSITIVE
		};

		typedef enum
		{
			PB,
			ANSI,
			ANSI_Escape
		} enumOJSyntax;

		typedef struct DBI_ANSI_OJBlk
		{
			//  This block exists in order to avoid making reference to the
			//  DB driver-specific control block.  The goal is to make
			//  DBI_OuterJoinSyntax_ANSI() a generic function that can be called
			//  from lots of DB drivers.
			//
			enumOJSyntax  eOJSyntax;
			DBI_CaseSensitivity eCase;

		} DBI_ANSI_OJBLK, FAR* PDBI_ANSI_OJBLK;

		typedef PBCALLBACK(VOID, *EXPLODESTAR_FUNC) (PDBI_COMMAND, PCOL_EXTRACT_SEQ, PSHLIST, PSHLIST);

		/***************************************************************************/
		//                            Function Prototypes
		/***************************************************************************/
		PBWINAPI(DBI_FUNC, PBGetDBIProc) (LPTSTR, HINSTANCE);
		PBWINAPI(HRESULT, DBI_DatabaseLoad) (PDBI_COMMAND, PSHLIST FAR*);
		PBWINAPI(HRESULT, DBI_TableLoad) (PDBI_COMMAND, LPTSTR, PSHLIST FAR*);
		PBWINAPI(HRESULT, DBI_TableExplode) (PDBI_COMMAND, DBI_TBLPTR, BOOL);
		PBWINAPI(HRESULT, DBI_DeleteDir) (ppbstg_anchor, PSHLIST);
		PBWINAPI(HRESULT, DBI_DeleteTable) (ppbstg_anchor, DBI_TBLPTR);
		PBWINAPI(VOID, DBI_ComboList) (int, HWND);
		PBCALLBACK(PSHLIST, DBI_BuildComboList)(ppbstg_anchor stgThis, int iResId);
		PBCALLBACK(HRESULT, DBI_DataTypeListString)(int iResId, LPTSTR* lpszProperty);
		PBWINAPI(HRESULT, DBI_FindComboString) (int, int, HWND);
		PBCALLBACK(HRESULT, DBI_FindComboListString)(INT iResId, INT iValue, LPTSTR* lpszSetValue);
		PBWINAPI(HRESULT, DBI_MatchCombo) (int, HWND, int FAR*);
		PBWINAPI(HRESULT, DBI_MatchString) (int, LPTSTR lpszValue, int FAR*);
		PBWINAPI(VOID, DBI_AttrInfo) (PDBI_COMMAND);
		PBWINAPI(HRESULT, DBI_Command_Tran) (PDBI_COMMAND, LPTSTR);
		PBWINAPI(HRESULT, DBI_Step) (PDBI_COMMAND, LPTSTR);
		PBWINAPI(HRESULT, DBI_Commit) (PDBI_COMMAND);
		PBWINAPI(HRESULT, DBI_Connect) (PDBI_COMMAND, LPTSTR, LPTSTR, LPTSTR, LPTSTR);
		PBWINAPI(HRESULT, DBI_DummyConnect)   (ppbstg_anchor, DWORD, LPTSTR, LPTSTR, PDBI_COMMAND FAR*);
		PBWINAPI(HRESULT, DBI_DialogConnect)  (PDBI_SIGNON, DWORD, PDBI_COMMAND FAR*);
		PBWINAPI(HRESULT, DBI_LogIn) (ppbstg_anchor, LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPTSTR, DWORD, PDBI_COMMAND FAR*);
		PBWINAPI(HRESULT, DBI_SetLogIn) (ppbstg_anchor, LPTSTR, LPTSTR, LONG, LONG, PDBI_COMMAND FAR*);
		PBWINAPI(HRESULT, DBI_LogInAdoConnection) (ppbstg_anchor, LPTSTR, LPTSTR, LONG, DWORD, PDBI_COMMAND FAR*);
		PBWINAPI(HRESULT, DBI_SetConnect) (PDBI_COMMAND, LPTSTR, LPTSTR, LPTSTR, LPTSTR);
		PBWINAPI(VOID, DBI_DatabaseInfo)   (PDBI_COMMAND);
		PBCALLBACK(HRESULT, DBI_SystemDatabaseLoad)(PDBI_COMMAND, PSHLIST, PSHLIST FAR*);
		PBWINAPI(HRESULT, DBI_Describe)      (PDBI_COMMAND, INT, PSHLIST FAR*);
		PBWINAPI(HRESULT, DBI_Disconnect) (PDBI_COMMAND);
		PBWINAPI(BOOL, DBI_ErrorSQL) (PDBI_COMMAND);
		PBWINAPI(HRESULT, DBI_Execute) (PDBI_COMMAND, BOOL, LPTSTR);
		PBWINAPI(HRESULT, DBI_FetchNext) (PDBI_COMMAND, PSHLIST FAR*);
		PBWINAPI(HRESULT, DBI_Prepare) (PDBI_COMMAND, LPTSTR, INT);
		PBWINAPI(HRESULT, DBI_PrepareWithParms) (PDBI_COMMAND, LPTSTR, PSHLIST, LPTSTR);
		PBWINAPI(HRESULT, DBI_RollBack) (PDBI_COMMAND);
		PBWINAPI(HRESULT, DBI_TerminateSQL)   (PDBI_COMMAND);
		PBWINAPI(HRESULT, DBI_Rows) (PDBI_COMMAND, LONG FAR*);
		PBWINAPI(VOID, DBI_GetPBTypeString) (PDBI_COMMAND);
		PBWINAPI(HRESULT, DBI_DescribeExtra)  (PDBI_COMMAND, LPTSTR, PSHLIST FAR*);
		PBWINAPI(HRESULT, DBI_DateString)      (PDBI_COMMAND, LPTSTR, LPTSTR FAR*);
		PBWINAPI(HRESULT, DBI_DecimalString)   (PDBI_COMMAND, LPTSTR);
		PBWINAPI(HRESULT, DBI_DoubleString)   (PDBI_COMMAND, LPTSTR);
		PBWINAPI(HRESULT, DBI_Numeri_tstring)   (PDBI_COMMAND, LPTSTR, SHORT, TCHAR, BOOL, BOOL);
		PBWINAPI(HRESULT, DBI_CursorConnect)  (PDBI_COMMAND, PDBI_COMMAND FAR*);
		PBWINAPI(HRESULT, DBI_GetSelectItems) (PDBI_COMMAND, INT FAR*);
		PBWINAPI(HRESULT, DBI_GetSelectInfo)  (PDBI_COMMAND, PDBI_BIND, INT);
		PBWINAPI(HRESULT, DBI_BindSelectBuffer) (PDBI_COMMAND, PDBI_BIND, INT);
		PBWINAPI(HRESULT, DBI_RuntimeFetchNext) (PDBI_COMMAND);
		PBWINAPI(HRESULT, DBI_MPowerFetchNext) (PDBI_COMMAND);
		PBWINAPI(HRESULT, DBI_StartTran)(PDBI_COMMAND);
		PBWINAPI(HRESULT, DBI_UniqueKey)(PDBI_COMMAND, LPTSTR, LPTSTR, LPTSTR FAR*);
		PBWINAPI(HRESULT, DBI_ParseFrom)      (PDBI_COMMAND, LPTSTR, PSHLIST FAR*, BOOL FAR*);
		PBWINAPI(HRESULT, DBI_ParseColList) (PDBI_COMMAND, LPTSTR, PSHLIST, BOOL, PSHLIST FAR*, EXPLODESTAR_FUNC pExplodeStarFunc = NULL, BOOL* bColAlias = FALSE);
		PBWINAPI(HRESULT, DBI_DoubleTheQuotes) (PDBI_COMMAND, LPTSTR, LPTSTR FAR*);
		PBWINAPI(HRESULT, DBI_FreeMem) (PDBI_COMMAND, PVOID);
		PBWINAPI(HRESULT, DBI_FreePrepList) (PDBI_COMMAND, PSHLIST);
		PBWINAPI(HRESULT, DBI_FreeColBlkList) (PDBI_COMMAND, PSHLIST);
		PBWINAPI(HRESULT, DBI_DialogBoxCenter) (HWND);
		PBWINAPI(HRESULT, DBI_CleanUpColumnList) (PDBI_COMMAND);
		PBWINAPI(HRESULT, DBI_Cancel) (PDBI_COMMAND);
		PBWINAPI(HRESULT, DBI_ProcInfo) (PDBI_COMMAND, PSHLIST FAR*, DBI_PROCFILTER);
		PBWINAPI(HRESULT, DBI_ProcText) (PDBI_COMMAND, DBI_PROCPTR, LPTSTR FAR*);
		PBWINAPI(HRESULT, DBI_EventText) (PDBI_COMMAND, DBI_EVENTPTR);
		PBWINAPI(HRESULT, DBI_ProcDescribe) (PDBI_COMMAND, DBI_PROCPTR, PSHLIST FAR*);
		PBWINAPI(HRESULT, DBI_DeleteProcDir)   (ppbstg_anchor, PSHLIST);
		PBWINAPI(HRESULT, DBI_ProcPrepare)     (PDBI_COMMAND, LPTSTR, INT);
		PBWINAPI(HRESULT, DBI_Parse)       (PDBI_COMMAND, LPTSTR);
		PBWINAPI(HRESULT, DBI_OuterJoinSyntax) (PDBI_COMMAND, PDBI_OUTER, LPTSTR FAR*);
		PBWINAPI(HRESULT, DBI_RuntimeExecute) (PDBI_COMMAND, LPTSTR, LONG, LPTSTR);
		PBWINAPI(HRESULT, DBI_FormatHash) (PDBI_COMMAND);
		PBWINAPI(HRESULT, DBI_ValidHash) (PDBI_COMMAND);
		PBWINAPI(HRESULT, DBI_FreeValidHash) (PDBI_COMMAND, PSHHASH FAR*);
		PBWINAPI(HRESULT, DBI_EditStyleHash) (PDBI_COMMAND);
		PBWINAPI(HRESULT, DBI_EditUpdate) (PDBI_COMMAND, PSHLIST, HWND);
		PBWINAPI(HRESULT, DBI_EditStyleInfo) (PDBI_COMMAND, PPDWXEDT, LPTSTR);
		PBWINAPI(LPTSTR, DBI_LoadString)       (INT);
		PBWINAPI(HRESULT, DBI_DynamicBind) (PDBI_COMMAND);
		PBWINAPI(HRESULT, DBI_GetNextResultSet) (PDBI_COMMAND);
		PBWINAPI(HRESULT, DBI_ViewText) (PDBI_COMMAND, LPTSTR, LPTSTR, LPTSTR FAR*);
		PBWINAPI(HRESULT, DBI_ExecPlan) (PDBI_COMMAND, LPTSTR, LPTSTR FAR*);
		PBWINAPI(HRESULT, DBI_GetTimestamp) (PDBI_COMMAND, LPTSTR FAR*);
		PBWINAPI(BOOL, DBI_DoCompare)      (LPTSTR, LPTSTR);
		PBWINAPI(BOOL, DBI_DoCompareFirst)  (LPTSTR, LPTSTR);
		PBWINAPI(BOOL, DBI_DoCompareFirstWithSkip)  (LPTSTR, LPTSTR);
		PBWINAPI(HRESULT, DBI_ReadBlob) (PDBI_COMMAND, ppbstg_anchor, pbstg_subpool, LPTSTR, LPTSTR, LPTSTR, PVOID FAR*);
		PBWINAPI(HRESULT, DBI_WriteBlob) (PDBI_COMMAND, ppbstg_anchor, pbstg_subpool, LPTSTR, LPTSTR, LPTSTR, PVOID);
		PBWINAPI(HRESULT, DBI_FillBlanks) (LPTSTR, int);
		PBWINAPI(HRESULT, DBI_DeleteSyntaxList) (PDBI_COMMAND);
		PBWINAPI(HRESULT, DBI_ParseParms) (PDBI_COMMAND, PSHLIST FAR*);
		PBWINAPI(HRESULT, DBI_ParseKeyWords) (PDBI_COMMAND, LPTSTR, BOOL FAR*);
		PBWINAPI(HRESULT, DBI_FreeParmList) (PDBI_COMMAND, PSHLIST FAR*);
		PBWINAPI(HRESULT, DBI_GetParm) (PDBI_COMMAND, PSHLIST, LPTSTR, PDBI_PARMBLK FAR*);
		PBWINAPI(HRESULT, DBI_FetchFirst)       (PDBI_COMMAND);
		PBWINAPI(HRESULT, DBI_FetchPrev)       (PDBI_COMMAND);
		PBWINAPI(HRESULT, DBI_FetchRandom)     (PDBI_COMMAND);
		PBWINAPI(HRESULT, DBI_FetchRelative)   (PDBI_COMMAND);
		PBWINAPI(HRESULT, DBI_FetchLast)       (PDBI_COMMAND);
		PBWINAPI(HRESULT, DBI_NewDBParm) (PDBI_COMMAND, LPTSTR);
		PBWINAPI(HRESULT, DBI_ReplaceDbParm)   (PDBI_COMMAND, LPTSTR, LPTSTR);
		PBWINAPI(HRESULT, DBI_DelimitReservedWord) (PDBI_COMMAND, LPTSTR, LPTSTR, LONG);
		PBWINAPI(HRESULT, DBI_DescribeInput) (PDBI_COMMAND, LPTSTR);
		PBWINAPI(HRESULT, DBI_DescribeOutput)  (PDBI_COMMAND, LPTSTR);
		PBWINAPI(HRESULT, DBI_DWCursorConnect)  (PDBI_COMMAND, PDBI_COMMAND FAR*);
		PBWINAPI(HRESULT, DBI_ParseColSubset) (PDBI_COMMAND, LPTSTR, PSHLIST, LONG, BOOL, PSHLIST FAR*);
		PBWINAPI(HRESULT, DBI_ParseBasicSelect) (PDBI_COMMAND, LPTSTR, LPTSTR FAR*);
		PBWINAPI(HRESULT, DBI_CreatePrimaryKeySyntax) (PDBI_COMMAND, PDBI_PRIMARY_KEY, HWND, LONG FAR*);
		PBWINAPI(HRESULT, DBI_CreateNoLogPKeySyntax) (PDBI_COMMAND, PDBI_PRIMARY_KEY, LPTSTR, HWND, LONG);
		PBWINAPI(HRESULT, DBI_AlterPrimaryKeySyntax)  (PDBI_COMMAND, PDBI_PRIMARY_KEY, PDBI_PRIMARY_KEY, HWND, LONG FAR*);
		PBWINAPI(HRESULT, DBI_CreateForeignKeySyntax) (PDBI_COMMAND, PSHLIST, LONG FAR*);
		PBWINAPI(HRESULT, DBI_AlterForeignKeySyntax)  (PDBI_COMMAND, PSHLIST, PSHLIST, HWND, LONG FAR*);
		PBWINAPI(HRESULT, DBI_GetForeignKYOptions)   (PDBI_COMMAND, PDBI_FOREIGNKYOPTIONS);
		PBWINAPI(HRESULT, DBI_LibraryName) (ppbstg_anchor, DWORD, LPTSTR, LPTSTR, LPTSTR);
		PBWINAPI(HRESULT, DBI_LookForKeyWord) (PDBI_COMMAND, LPTSTR, LPTSTR, BOOL FAR*, LONG FAR*, LONG FAR*);
		PBWINAPI(HRESULT, DBI_ParseIdentifier) (PDBI_COMMAND, PDBI_IDENT, LPTSTR FAR*, PSHLIST pPrepareTblList = NULL);
		PBWINAPI(HRESULT, DBI_GetColumnExpression) (PDBI_COMMAND, LPTSTR, SHORT, LPTSTR FAR*);
		PBWINAPI(HRESULT, DBI_ParseWhere) (PDBI_COMMAND, LPTSTR, LONG, PSHLIST FAR*, LONG FAR*, INT FAR*);
		PBWINAPI(HRESULT, DBI_FreeWhereList) (PDBI_COMMAND, PSHLIST);
		PBWINAPI(HRESULT, DBI_PrimaryKeyReferences) (PDBI_COMMAND, LPTSTR, LPTSTR, LPTSTR, PSHLIST FAR*);
		PBWINAPI(HRESULT, DBI_PBToSQL) (LPTSTR, ppbstg_anchor, pbstg_subpool, PDBI_COMMAND, LPTSTR FAR*);
		PBWINAPI(HRESULT, DBI_PBToArgs) (LPTSTR, ppbstg_anchor, pbstg_subpool, PDWBTBLARG FAR*);
		PBWINAPI(HRESULT, DBI_ReleaseInputParms) (PDBI_COMMAND, PSHLIST FAR*);
		PBWINAPI(VOID, DBI_SynText) (PDBI_COMMAND);
		VOID Check_DBMS_DLL(PDBI_COMMAND);
		PBWINAPI(HRESULT, DBI_PBC_DialogBox) (HINSTANCE, INT, HWND, DBI_DLGPROC, INT FAR*);
		PBWINAPI(HRESULT, DBI_PBC_DialogBoxParam) (HINSTANCE, INT, HWND, DBI_DLGPROC, LPARAM, INT FAR*);
		PBWINAPI(HRESULT, DBI_PBC_ShowWindow)(HWND, INT);
		PBWINAPI(HRESULT, DBI_DBHandle) (PDBI_COMMAND, WORD, LONG FAR*);
		PBWINAPI(HRESULT, DBI_GetAdoConnection) (PDBI_COMMAND, LONG FAR*);
		PBWINAPI(HRESULT, DBI_SearchReplace) (PDBI_COMMAND, LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPTSTR FAR*);
		PBWINAPI(HRESULT, DBI_CtrlChars2Text) (PDBI_COMMAND, LPTSTR, LPTSTR FAR*);
		PBWINAPI(HRESULT, DBI_Text2CtrlChars) (PDBI_COMMAND, LPTSTR, LPTSTR FAR*);
		PBWINAPI(HRESULT, DBI_SQLCacheBegin) (PDBI_COMMAND, UINT, pCacheList FAR*);
		PBWINAPI(HRESULT, DBI_SQLCacheEnd) (PDBI_COMMAND, pCacheList);
		PBWINAPI(HRESULT, DBI_SQLCacheFlushEntries) (PDBI_COMMAND, pCacheList);
		PBWINAPI(HRESULT, DBI_SQLCacheRegisterSQLStatement) (PDBI_COMMAND, LPTSTR, PVOID, pCacheEntry FAR*);
		PBWINAPI(HRESULT, DBI_SQLCacheRegisterDescribe) (PDBI_COMMAND, pCacheEntry, PSHLIST);
		PBWINAPI(HRESULT, DBI_SQLCacheRequestSqlStatement)(PDBI_COMMAND, pCacheList, LPTSTR, pCacheEntry FAR*);
		PBWINAPI(PSHLIST, DBI_SQLCacheRequestDescribe) (PDBI_COMMAND, pCacheEntry);
		PBWINAPI(HRESULT, DBI_SQLCacheMakeSQLStatementAvailable) (PDBI_COMMAND, pCacheEntry, pCacheList);
		PBWINAPI(HRESULT, DBI_SQLCacheSetCacheSize) (PDBI_COMMAND, pCacheList, LPTSTR);
		PBWINAPI(HRESULT, DBI_SQLCacheDiscardEntry) (PDBI_COMMAND, pCacheEntry, BOOL);
		PBWINAPI(HRESULT, DBI_SQLCacheConnectSetup) (PDBI_COMMAND pDB);
		PBWINAPI(HRESULT, DBI_SQLCacheConnectDrop) (PDBI_COMMAND pDB);
		PBWINAPI(HRESULT, DBI_SQLCacheSetSelectCacheSize) (PDBI_COMMAND pDB);
		PBCALLBACK(INT, DBI_RPC_DoCall)(PDBI_COMMAND, LPTSTR, PSHLIST, UINT, PVOID&, LONG);
		PBWINAPI(LPTSTR, DBI_SQLCacheStatistics) (PDBI_COMMAND, BOOL);
		PBWINAPI(HRESULT, DBI_GetIdentityValue)    (PDBI_COMMAND, PVOID, LONG, LONG, LPTSTR, LPTSTR, SHORT, BOOL FAR*);
		PBWINAPI(LPTSTR, DBI_FormatWindowsEOL)  (ppbstg_anchor, LPTSTR);
		PBCALLBACK(HRESULT, DBI_SquishSyntax) (ppbstg_anchor, pbstg_subpool, LPTSTR, LPTSTR FAR*);
		PBCALLBACK(HRESULT, DBI_BuildRPCAlias)(PDBI_COMMAND, LPTSTR, LPTSTR, LPTSTR FAR*);
		PBCALLBACK(BOOL, DBI_YesTrue1) (PDBI_PARMBLK);
		PBCALLBACK(HRESULT, DBI_StartSyntax) (PDBI_COMMAND, SHORT, HWND, short, PDBI_SYNTAXGEN FAR*);
		PBCALLBACK(HRESULT, DBI_EndSyntax) (PDBI_COMMAND, PDBI_SYNTAXGEN);
		PBCALLBACK(HRESULT, DBI_FinishLine) (PDBI_COMMAND, BOOL, PDBI_SYNTAXGEN);
		PBCALLBACK(HRESULT, DBI_AddSyntaxLine) (PDBI_COMMAND, PDBI_SYNTAXGEN);
		PBCALLBACK(HRESULT, DBI_GetBlobConnect) (PDBI_COMMAND, PDBI_COMMAND FAR*);
		PBCALLBACK(HRESULT, DBI_CanIdentifySystemProcs)(PDBI_COMMAND, BOOL*);
		PBWINAPI(HRESULT, DBI_RegisterVendor)(LPTSTR, LPTSTR);
		PBWINAPI(HRESULT, DBI_UnRegisterVendor)(LPTSTR);
		PBCALLBACK(HRESULT, DBI_ThreadSafeEnabled)(BOOL*);
		PBCALLBACK(HRESULT, DBI_OuterJoinSyntax_ANSI) (PDBI_COMMAND, PDBI_ANSI_OJBLK);
#if !defined(DW_OCX) && !defined(NISQL)
		PBCALLBACK(HINSTANCE, DBI_LoadDBInterface)(LPTSTR, DWORD*);
#endif
		PBCALLBACK(HRESULT, DBI_FreeDBInterface)(HINSTANCE, DWORD);
		PBWINAPI(BOOL, DBI_IsCache)      (PDBI_COMMAND);
		PBWINAPI(BOOL, DBI_IsConnInServerTrans) (PDBI_COMMAND);
		PBWINAPI(BOOL, DBI_IsConnFromServer) (PDBI_COMMAND);
		PBCALLBACK(HRESULT, DBI_FindForXML) (PDBI_COMMAND, LPTSTR, LPTSTR*);
		PBWINAPI(HRESULT, DBI_ConvertHexStringToBlob) (LPTSTR, LPBYTE, LONG*);

		// DBI implementation of generic datasource interface
		PBWINAPI(CPB_DBI_Connection*, CreateDBIConnect) (PDBI_COMMAND);
		PBWINAPI(CPB_DBI_TableSchema*, CreateDBITableSchema) (PDBI_COMMAND, DBI_TBLPTR);

		/***************************************************************************/
		//                            Macros
		/***************************************************************************/
		/* macro for DBI Trace  */
#define DBI_TraceMessage(pDB, lpszStr) \
{ LONG lParamSave = pDB->lParam; \
INT iCommandTypeSave = pDB->iCommandType;\
LONG lRCSave=pDB->lReturnCode,lRVSave=pDB->lReturnValue;\
pDB->iCommandType = DBI_DEBUG_MESSAGE; \
pDB->lParam = (LONG)(LPTSTR)lpszStr; \
DBI_AttrInfo(pDB); \
pDB->lParam = lParamSave; \
pDB->iCommandType = iCommandTypeSave;\
pDB->lReturnCode = lRCSave;pDB->lReturnValue = lRVSave;\
}

#ifdef NDEBUG
#define DBI_Assert(pDB,exp) ((void)0)
#else
#define DBI_Assert(pDB,exp) \
    { if(!exp) \
      { LPTSTR v = PBTEXT("assertion failed! ") PBTEXT(#exp) PBTEXT(__FILE__) ; \
        DBI_TraceMessage(pDB,v) }}
#endif

  /* prototype for the DBI_PrepareForReusableParms macro */
  /* PBWINAPI( VOID, DBI_PrepareForReusableParms ) ( */
  /* PDBI_COMMAND   pCommandBlock,              // Pointer to DBI_COMMAND */
  /* LPSTR          lpszCommandBuffer)          // Pointer to buffer */
#define DBI_PrepareForReusableParms(db,sqlstr) { \
   ((PDBI_COMMAND)db)->iCommandType = DBI_PREPARE_FOR_INPUT_PARMS;\
   ((PDBI_COMMAND)db)->lpszCommandBuffer = sqlstr;\
   (* ((PDBI_COMMAND)db)->lpfnRouteProc) (db);  }

  /* prototype for the DBI_BindForReusableParms macro */
  /* PBWINAPI( VOID, DBI_BindForReusableParms ) ( */
  /* PDBI_COMMAND   pCommandBlock,              // Pointer to DBI_COMMAND */
  /* PSHLIST        pDBIInputBind)              // list of DBI_INPUTBIND parm defs */
#define DBI_BindForReusableParms(db,plist) { \
   ((PDBI_COMMAND)db)->iCommandType = DBI_BIND_FOR_INPUT_PARMS;\
   ((PDBI_COMMAND)db)->lParam = (LPARAM)plist;\
   (* ((PDBI_COMMAND)db)->lpfnRouteProc) (db);  }

  /* prototype for the DBI_ExecForReusableParms macro */
  /* PBWINAPI( VOID, DBI_ExecForReusableParms ) ( */
  /* PDBI_COMMAND   pCommandBlock)              // Pointer to DBI_COMMAND */
#define DBI_ExecForReusableParms(db) { \
   ((PDBI_COMMAND)db)->iCommandType = DBI_EXEC_FOR_INPUT_PARMS;\
   (* ((PDBI_COMMAND)db)->lpfnRouteProc) (db);  }

  /* prototype for the DBI_DoneForReusableParms macro */
  /* PBWINAPI( VOID, DBI_DoneForReusableParms ) ( */
  /* PDBI_COMMAND   pCommandBlock)              // Pointer to DBI_COMMAND */
#define DBI_DoneForReusableParms(db) { \
   ((PDBI_COMMAND)db)->iCommandType = DBI_DONE_FOR_INPUT_PARMS;\
   (* ((PDBI_COMMAND)db)->lpfnRouteProc) (db);  }

//ASH QTS 157050 and 157755 STOP using BULK inserts
#if 0
  /* prototype for the DBI_BulkBindForReusableParms macro */
  /* PBWINAPI( VOID, DBI_BindForReusableParms ) ( */
  /* PDBI_COMMAND   pCommandBlock,              // Pointer to DBI_COMMAND */
  /* PSHLIST        pDBIInputBind)              // list of DBI_INPUTBIND parm defs */
#define DBI_BindBulkForReusableParms(db,plist,bindlist,rowsize) { \
   ((PDBI_COMMAND)db)->iCommandType = DBI_BIND_FOR_BULK_INPUT_PARMS;\
   ((PDBI_COMMAND)db)->lParam = (LPARAM)plist;\
   ((PDBI_COMMAND)db)->lpExtraParm1 = (LPTSTR) bindlist;\
   ((PDBI_COMMAND)db)->lExtraParm1	= rowsize;\
   (* ((PDBI_COMMAND)db)->lpfnRouteProc) (db);  }

  /* prototype for the DBI_BulkSetBufferForReusableParms macro */
  /* PBWINAPI( VOID, BulkSetBufferForReusableParms ) ( */
  /* PDBI_COMMAND   pCommandBlock,              // Pointer to DBI_COMMAND */
  /* PSHLIST        pDBIInputBind)              // list of DBI_INPUTBIND parm defs */
#define DBI_BindSetBufferForReusableParms(db,plist,arraylist,row) { \
   ((PDBI_COMMAND)db)->iCommandType = DBI_SET_BUFFER_FOR_BULK_INPUT_PARMS;\
   ((PDBI_COMMAND)db)->lParam = (LPARAM)plist;\
   ((PDBI_COMMAND)db)->lExtraParm1	= (LONG) arraylist;\
   ((PDBI_COMMAND)db)->lExtraParm2	= row;\
   (* ((PDBI_COMMAND)db)->lpfnRouteProc) (db);  }

  /* prototype for the DBI_ExecForReusableParms macro */
  /* PBWINAPI( VOID, DBI_ExecForReusableParms ) ( */
  /* PDBI_COMMAND   pCommandBlock)              // Pointer to DBI_COMMAND */
#define DBI_ExecBulkForReusableParms(db,arraylist,rowsize) { \
   ((PDBI_COMMAND)db)->iCommandType = DBI_EXEC_FOR_BULK_INPUT_PARMS;\
   ((PDBI_COMMAND)db)->lParam = (LPARAM)arraylist;\
   ((PDBI_COMMAND)db)->lExtraParm1	= rowsize;\
   (* ((PDBI_COMMAND)db)->lpfnRouteProc) (db);  }
#endif //0
//ASH QTS 157050 and 157755 STOP using BULK inserts

  /* prototype for the DBI_SupportRPC macro */
  /* PBWINAPI( VOID, DBI_SupportRPC ) ( */
  /* PDBI_COMMAND       db,              // Pointer to DBI_COMMAND */
  /* PDBI_RPC_OPTIONS   pRPCOptions);    // options to be set by database interface */
#define DBI_SupportRPC(db, pRPCOptions) {\
   ((PDBI_COMMAND)db)->iCommandType = DBI_SUPPORT_RPC;\
   ((PDBI_COMMAND)db)->lParam = (LPARAM)pRPCOptions;\
   (* ((PDBI_COMMAND)db)->lpfnRouteProc) (db);  }

  // PBWINAPI( VOID, DBI_SupportRPCAlias ) (
  // PDBI_COMMAND       db,              // Pointer to DBI_COMMAND
  // BOOL   bResult);    // TRUE if alias is supported
#define DBI_SupportRPCAlias(db,bResult) {\
   ((PDBI_COMMAND)db)->iCommandType = DBI_NOT_SUPPORT_RPC_ALIAS;\
   (* ((PDBI_COMMAND)db)->lpfnRouteProc) (db);  \
   bResult = !((PDBI_COMMAND)db)->lReturnValue;}

	// DBI_CheckNonFatalError(db,bResult)
	// bResult is set to TRUE if the error code in lReturnCode is set to a nonfatal error.
	// For example, if lReturnCode is set to something like: sybase 3902 "commit ignored, no open transaction"
	// then bResult would be set to TRUE.
	// On the other hand, if lReturnCode is set to something like: sybase 10025 "dbprocess is dead or the connection is gone"
	// then bResult would be set to FALSE.
#define DBI_CheckNonFatalError(db,bResult) {\
   ((PDBI_COMMAND)db)->lExtraParm1 = db->lReturnCode;\
   ((PDBI_COMMAND)db)->iCommandType = DBI_CHECK_NONFATAL_ERROR;\
   (* ((PDBI_COMMAND)db)->lpfnRouteProc) (db);  \
   bResult = (BOOL)((PDBI_COMMAND)db)->lReturnValue;  \
   ((PDBI_COMMAND)db)->lExtraParm1 = 0;}

	//   DBI_setbuffer( buff, c, len)
	//   Use this macro to set a string buffer to some non-null character (like spaces)
	//   CR 200187  Use local variables other than i and p because these could be passed as input arguments to the macro.
#ifdef PS_UNICODE
#define    DBI_setbuffer( buff, c, len)   {INT iSetBuffIdx; LPTSTR pSetBuffPtr; \
	 for (iSetBuffIdx = 0, pSetBuffPtr = buff;  iSetBuffIdx < len; iSetBuffIdx++, pSetBuffPtr++) *pSetBuffPtr = c;  }
#else
#define    DBI_setbuffer( buff, c, len)  pbstg_memset( buff, c, len)
#endif

/*  Conversion macros for converting unicode to ANSI for non-unicode databases */
#if defined(PS_UNICODE)
#define DBI_W2A(w, a, cb)     WideCharToMultiByte(                          \
                                               CP_ACP,                      \
                                               0,                           \
                                               w,                           \
                                               -1,                          \
                                               a,                           \
                                               cb,                          \
                                               NULL,                        \
                                               NULL)

#define DBI_A2W(a, w, cb)     MultiByteToWideChar(                          \
                                               CP_ACP,                      \
                                               0,                           \
                                               a,                           \
                                               -1,                          \
                                               w,                           \
                                               cb)
#endif

//
// Obsolete macro used with DBI_FIND_COMBO, DBI_MATCH_COMBO, and DBI_COMBO_LIST
//
/* set the resource id in database dll for the table dialog data type drop down */
#define DBI_DataTypeiResId(db, iResId) {\
   iResId = (INT) ((PDBI_COMMAND)db)->lExtraParm1;  }
/* set the dialog handle in the database dll for the table dialog data */
/* type ddlb */
#define DBI_DataTypehDlg(db, hDlg) {\
   hDlg = (HWND) ((PDBI_COMMAND)db)->lParam;  }

  /* prototype for the DBI_GetPublicOwnerIDString macro */
  /* PBWINAPI( VOID, DBI_GetThePublicOwnerIDString ) ( */
  /* PDBI_COMMAND       db,              Pointer to DBI_COMMAND */
  /* LPSTR              lpszPublicID);   public userid or null */
#define DBI_GetThePublicOwnerIDString(db, lpszPublicID) {\
   ((PDBI_COMMAND)db)->iCommandType = DBI_GETPUBLICOWNERIDSTRING;\
   (* ((PDBI_COMMAND)db)->lpfnRouteProc) (db);\
   lpszPublicID = (LPTSTR)((PDBI_COMMAND)db)->lReturnValue;}

/* clear the table list cache for the specified DBI_Command block */
#define DBI_TableListCacheRelease(pCmdBlock) \
    {pCmdBlock->bTableListCacheHasNonSystem = 0;\
     pCmdBlock->bTableListCacheHasSystem = 0;}

/* determines if there is anything in lpszSqlSelect statement that */
/* prevent it from being converted from a 'SELECT' statement to */
/* a 'PBSELECT' without losing anything (like outer joins in informix). */
/* db is the dbi command ptr. */
/* lpszSelect is the sql statement to check. */
/* lpszMsg will be set to point at what you should assume is static */
/* storage that will be affected on the next database interface call.*/
/* bFlag is set to TRUE if there was a problem in which case */
/* lpszMsg should be examined. */
#define DBI_IsSQLSelectConvertable(db,lpszSqlSelect,lpszMsg,bFlag) {\
   ((PDBI_COMMAND)db)->iCommandType = DBI_IS_SQL_SELECT_CONVERTABLE;\
   ((PDBI_COMMAND)db)->lParam = (LPARAM)(LPTSTR)(lpszSqlSelect);\
   (* ((PDBI_COMMAND)db)->lpfnRouteProc) (db);\
   lpszMsg = (LPTSTR)((PDBI_COMMAND)db)->lReturnValue;\
   bFlag = (BOOL)((PDBI_COMMAND)db)->lReturnCode;}

  /* prototype for the DBI_ActivatePooledConnection macro */
  /* PBWINAPI( VOID, DBI_ActivatePooledConnection ) ( */
  /* PDBI_COMMAND   pCommandBlock)              // Pointer to DBI_COMMAND */
#define DBI_ActivatePooledConnection(db) { \
   ((PDBI_COMMAND)db)->iCommandType = DBI_ACTIVATE_POOLED_CONNECTION;\
   (* ((PDBI_COMMAND)db)->lpfnRouteProc) (db);  }
  /* prototype for the DBI_DeactivatePooledConnection macro */
  /* PBWINAPI( VOID, DBI_DeactivatePooledConnection ) ( */
  /* PDBI_COMMAND   pCommandBlock)              // Pointer to DBI_COMMAND */
#define DBI_DeactivatePooledConnection(db) { \
   ((PDBI_COMMAND)db)->iCommandType = DBI_DEACTIVATE_POOLED_CONNECTION;\
   (* ((PDBI_COMMAND)db)->lpfnRouteProc) (db);  }

// MikeCobb  Avoid ambiguity with ESCAPE_CHAR defined in pbetc.h ('~')
#define DBI_ESCAPE_CHAR     PBTEXTC('{')
#define DBI_END_ESCAPE_CHAR PBTEXTC('}')

#ifdef __cplusplus
	} // extern "C"
#endif
#endif

// DOINC popped back into header 'pbdsi.h'
#endif

#ifndef IPB_DSI_INCL
#define IPB_DSI_INCL

#define DSI_NOT_SET		-1

#ifdef GENERATED_CODE_BUILD
//#define S_FALSE		((HRESULT)0x00000001L)

#ifdef __cplusplus
#define EXTERN_C    extern "C"
#else
#define EXTERN_C    extern
#endif

#ifndef GUID_DEFINED
#define GUID_DEFINED
	typedef struct  _GUID
	{
		DWORD Data1;
		WORD Data2;
		WORD Data3;
		BYTE Data4[8];
	}	GUID;

	typedef GUID IID;
#endif // !GUID_DEFINED

#endif

	// Forward declarations
	class DSI_TableSchema_Iface;
	class DSI_Connection_Iface;


	class DSI_RowSchema_Iface
	{
	public:
		// Gets the number of columns in the table.
		virtual HRESULT	STDMETHODCALLTYPE	GetColumnCount(
			/* OUT */			INT* pColCount
		) = 0;
		// Gets the DB datatype of a column given its 1-based idx.
		virtual HRESULT	STDMETHODCALLTYPE GetColumnType(
			/* IN  */		const INT	idx,
			/* OUT */		LONG* pColType
		) = 0;
		// Gets the PB type of a column given its 1-based idx.
		virtual HRESULT	STDMETHODCALLTYPE GetColumnPBType(
			/* IN  */			const INT	idx,
			/* OUT */			LONG* pColPBType
		) = 0;
		// Gets the length of the column.
		virtual HRESULT	STDMETHODCALLTYPE GetColumnLength(
			/* IN  */		const INT	idx,
			/* OUT */		LONG* pColLen
		) = 0;
		// Gets the precision of a numeric column.
		virtual HRESULT	STDMETHODCALLTYPE GetColumnPrecision(
			/* IN  */		const INT 	idx,
			/* OUT */		LONG* pPrec
		) = 0;
		// Gets the scale of a numeric column.
		virtual HRESULT	STDMETHODCALLTYPE GetColumnScale(
			/* IN  */		const INT	idx,
			/* OUT */		LONG* pScale
		) = 0;
		// Get the column ID (actually the 1-based column number)
		virtual HRESULT	STDMETHODCALLTYPE GetColumnID(
			/* IN  */	LPTSTR	pColName,
			/* OUT */	INT* pID
		) = 0;
		// If DBMS vendor supports column object ID, get it.
		virtual	HRESULT	STDMETHODCALLTYPE	GetColumnObjectId(
			/* IN  */		const INT 	idx,
			/* OUT */		LONG* pObjectId
		) {
			*pObjectId = 0; return S_FALSE;
		}
		//  Gets the name of a column given its 1-based idx.
		virtual	HRESULT	STDMETHODCALLTYPE	GetColumnName(
			/* IN  */	const INT	idx,
			/* OUT */	LPTSTR* ppColName
		) = 0;
		//  Can this column be null?
		virtual	HRESULT	STDMETHODCALLTYPE	IsColumnNullable(
			/* IN  */			const INT  	idx,
			/* OUT */			BOOL* pbNullable
		) = 0;
		//  Is this column identity
		virtual	HRESULT	STDMETHODCALLTYPE	IsColumnIdentity(
			/* IN  */			const INT  	idx,
			/* OUT */			BOOL* pbIdentity
		) = 0;
	};

	EXTERN_C const IID IID_DSI_IndexSchema_Iface;
	//  e22f584d-4fcd-4f22-8a9f-5b6d404b1243

	class DSI_IndexSchema_Iface : public IUnknown
	{
	public:

		//  Gets the name of the index.
		virtual	HRESULT	STDMETHODCALLTYPE	GetIndexName(
			/* OUT */	LPTSTR* ppIdxName
		) = 0;
		//  Gets the name of the index.
		virtual	HRESULT	STDMETHODCALLTYPE	GetIndexOwner(
			/* OUT */	LPTSTR* ppOwner
		) = 0;
		// Gets the name of the table containing the index
		virtual	HRESULT	STDMETHODCALLTYPE	GetTableName(
			/* OUT */	LPTSTR* ppTableName
		) = 0;
		// Gets the number of columns participating in the index
		virtual  HRESULT STDMETHODCALLTYPE	GetColumnCount(
			/* OUT */		INT* pKeyCount
		) = 0;

		// Gets the name of the column given the 1-based position of the column in the index.
		virtual HRESULT STDMETHODCALLTYPE	GetColumnName(
			/* IN  */		const INT  	idx,
			/* OUT */		LPTSTR* ppKeyColName
		) = 0;

		// Gets the column number in the table of the index column in the idx position in the index.
		virtual HRESULT STDMETHODCALLTYPE	GetColumnNumber(
			/* IN  */		const INT  	idx,
			/* OUT */		INT* pKeyColNum
		) = 0;

		virtual HRESULT	STDMETHODCALLTYPE	IsColumnDescending(
			/* IN  */			const INT  	idx,
			/* OUT */			BOOL* pbDescending
		) = 0;

		virtual HRESULT	STDMETHODCALLTYPE	IsUniqueIndex(
			/* OUT */		BOOL* pbUnique
		) = 0;
		virtual HRESULT	STDMETHODCALLTYPE	IsClusteredIndex(
			/* OUT */			BOOL* pbClustered
		) = 0;
		// Returns true if the index is the primary key.
		// hr = S_FALSE if you don't know for sure
		virtual HRESULT	STDMETHODCALLTYPE	IsPrimaryKey(
			/* OUT */	BOOL* pbPK
		) = 0;
		virtual HRESULT	STDMETHODCALLTYPE	IsForeignKey(
			/* OUT */	BOOL* pbFK
		) = 0;
		//  Is this index uneditable?
		virtual	HRESULT	STDMETHODCALLTYPE	IsUneditable(
			/* IN  */				const INT 	idx,
			/* OUT */				BOOL* pbUneditable
		) = 0;
		//  Caller must issue *ppTable->Release() when finished
		virtual HRESULT	STDMETHODCALLTYPE	GetParentTableSchema(
			/* OUT */		DSI_TableSchema_Iface** ppTable
		) = 0;
		//  Caller must issue *ppConnect->Release() when finished
		virtual HRESULT	STDMETHODCALLTYPE	GetConnection(
			/* OUT */		DSI_Connection_Iface** ppConnect
		) = 0;
		//  For foreign keys only.  Return S_FALSE if not a  foreign key.
		virtual HRESULT	STDMETHODCALLTYPE	GetReferencedTableName(
			/* OUT */		LPTSTR* ppRefTableName
		) = 0;
		//  For foreign keys only.  Return S_FALSE if not a  foreign key.															) = 0;
		virtual HRESULT	STDMETHODCALLTYPE	GetReferencedTableOwner(
			/* OUT */		LPTSTR* ppRefTableOwner
		) = 0;
		//  For foreign keys only.  Return S_FALSE if not a  foreign key.
		//  Connection has foreign key options like ON DELETE RESTRICT, ON DELETE SET NULL, etc.
		//  See if the option applies to this FK, using the 1-based index of FK options.
		virtual	HRESULT	STDMETHODCALLTYPE	GetFKOption(
			/*  IN   */		const INT	idx,
			/*  OUT  */		BOOL* pbFKOption
		) = 0;
	};

	EXTERN_C const IID IID_DSI_TableSchema_Iface;
	//0f178645-a8db-4331-a219-76d1814e94a3


	class DSI_TableSchema_Iface : public IUnknown,
		public DSI_RowSchema_Iface
	{
	public:
		virtual				~DSI_TableSchema_Iface() {};

		virtual  	HRESULT	STDMETHODCALLTYPE	GetTableName(
			/* OUT  */	LPTSTR* ppTableName
		) = 0;
		virtual 	HRESULT	STDMETHODCALLTYPE	GetTableComments(
			/* OUT */ 		LPTSTR* ppComments
		) = 0;
		virtual		HRESULT	STDMETHODCALLTYPE	GetObjectId(
			/* OUT  */	LONG* pObjectId
		) {
			*pObjectId = 0; return S_FALSE;
		}

		virtual  	HRESULT	STDMETHODCALLTYPE	GetOwnerName(
			/* OUT  */	LPTSTR* ppOwnerName
		) = 0;

		virtual		HRESULT	STDMETHODCALLTYPE	GetOwnerId(
			/* OUT  */	LONG* pOwnerId
		) {
			*pOwnerId = 0; return S_FALSE;
		}

		virtual		HRESULT	STDMETHODCALLTYPE	GetColumnDefault(
			/* IN  */	const INT	idx,
			/* OUT */	LPTSTR* ppColDefault
		) {
			*ppColDefault = NULL; return S_FALSE;
		}
		virtual		HRESULT	STDMETHODCALLTYPE	GetColumnComments(
			/* IN  */	const INT	idx,
			/* OUT */	LPTSTR* ppColComments
		) {
			*ppColComments = NULL; return S_FALSE;
		}
		virtual		HRESULT	STDMETHODCALLTYPE	GetColumnLabel(
			/* IN  */	const INT	idx,
			/* OUT */	LPTSTR* ppColLabel
		) {
			*ppColLabel = NULL; return S_FALSE;
		}
		virtual		HRESULT	STDMETHODCALLTYPE	IsComputedColumn(
			/* IN  */	const INT	idx,
			/* OUT */	BOOL* pbComputed
		) {
			*pbComputed = FALSE; return S_FALSE;
		}
		virtual		HRESULT	STDMETHODCALLTYPE	GetIndexCount(
			/* OUT  */	LONG* pIndexCount
		) = 0;

		//  Caller must issue *ppIndexSchema->Release() when finished
		virtual 	HRESULT	STDMETHODCALLTYPE	GetIndexSchema(
			/* IN  */		const INT 					idx,
			/* OUT */		DSI_IndexSchema_Iface** ppIdxSchema
		) = 0;
		//  Caller must issue *ppPKSchema->Release() when finished
		virtual 	HRESULT	STDMETHODCALLTYPE	GetPrimaryKey(
			/* OUT */		DSI_IndexSchema_Iface** ppPKSchema
		) = 0;
		virtual		HRESULT	STDMETHODCALLTYPE	GetForeignKeyCount(
			/* OUT  */	LONG* pFKCount
		) = 0;
		//  Caller must issue *ppIndexSchema->Release() when finished
		virtual 	HRESULT	STDMETHODCALLTYPE	GetForeignKeySchema(
			/* IN  */			const INT 					idx,
			/* OUT */			DSI_IndexSchema_Iface** ppIdxSchema
		) = 0;
		virtual 	HRESULT	STDMETHODCALLTYPE	IsSystemObject(
			/* OUT */   	 	BOOL* pbSystem
		) {
			*pbSystem = FALSE; return S_FALSE;
		}
		virtual 	HRESULT	STDMETHODCALLTYPE	IsView(
			/* OUT */   		BOOL* pbView
		) {
			*pbView = FALSE; return S_FALSE;
		}
		virtual 	HRESULT	STDMETHODCALLTYPE	IsAlias(
			/* OUT */   	BOOL* pbAlias
		) {
			*pbAlias = FALSE; return S_FALSE;
		}
		virtual 	HRESULT	STDMETHODCALLTYPE	IsProxy(
			/* OUT */   	BOOL* pbProxy
		) {
			*pbProxy = FALSE; return S_FALSE;
		}
		virtual 	HRESULT	STDMETHODCALLTYPE	HaveDict(
			/* OUT */   		BOOL* pbDict
		) {
			*pbDict = FALSE; return S_FALSE;
		}
		virtual 	HRESULT	STDMETHODCALLTYPE	Refresh() = 0;

		//  Creates a new DBI_TABLE structure containing all the TableSchema information.
		//  User is responsible for
		virtual		HRESULT	STDMETHODCALLTYPE	CreateDBI_TABLE(
			/* OUT */		DBI_TBLPTR*
		) = 0;

		//  Caller must issue *ppConnect->Release() when finished
		virtual		HRESULT	STDMETHODCALLTYPE	GetConnection(
			/* OUT */			DSI_Connection_Iface** ppConnect
		) = 0;


#if 0

		virtual  	HRESULT	STDMETHODCALLTYPE	SetTableName(
			/* IN  */	LPTSTR	pTableName
		) = 0;

		virtual  	HRESULT	STDMETHODCALLTYPE	SetObjectId(
			/* IN  */	LONG	ObjectId
		) = 0;

		virtual  	HRESULT	STDMETHODCALLTYPE	SetOwnerName(
			/* IN  */	LPTSTR   pOwnerName
		) = 0;
		virtual  	HRESULT	STDMETHODCALLTYPE	SetOwnerId(
			/* IN  */	LONG	OwnerId
		) = 0;

		virtual  	HRESULT	STDMETHODCALLTYPE	SetComments(
			/* IN  */	LPTSTR   pComments
		) = 0;

		virtual		HRESULT	STDMETHODCALLTYPE	SetNumberOfColumns(
			/* IN  */	LONG    ColumnCount
		) = 0;

		virtual		HRESULT	STDMETHODCALLTYPE	SetNumberOfIndexes(
			/* IN  */	LONG  	  IndexCount
		) = 0;

		virtual		HRESULT	STDMETHODCALLTYPE	SetDetailFont(
			/* IN  */	LOGFONT  	  DetailFont
		) = 0;

		virtual		HRESULT	STDMETHODCALLTYPE	SetHeadingFont(
			/* IN  */	LOGFONT  	  HeadingFont
		) = 0;

		virtual		HRESULT	STDMETHODCALLTYPE	SetLabelFont(
			/* IN   */	LOGFONT  	  LabelFont
		) = 0;

		virtual  	HRESULT	STDMETHODCALLTYPE	SetOldTableName(
			/* IN  */	LPTSTR	pOldTableName
		) = 0;
#endif

	};


	EXTERN_C const IID IID_DSI_DatasourceSchema_Iface;
	//f10a8fea-5c32-4e67-b230-f3f55edb6b1a
	//----------------------------------------------------------------------------------------
	//	Name: 		DSI_DatasourceSchema_Iface
	//	Synopsis:	This interface acts like a fixed array of basic table information.
	//				Name, object id, object type, etc.  Object instance is created by
	// 				pDSI_Connection->GetSchema() and Release must be called when client is
	//				through with the list.
	//----------------------------------------------------------------------------------------
	class DSI_DatasourceSchema_Iface : public IUnknown
	{
	public:

		virtual				~DSI_DatasourceSchema_Iface() {};

		virtual HRESULT		STDMETHODCALLTYPE	GetTableCount(
			/* OUT */		INT* piCount
		) = 0;

		virtual HRESULT		STDMETHODCALLTYPE	AppendSystemTables(
			/* OUT */		  INT* piCount
		) = 0;
		//  Create TableSchema object for table represented by 1-based index.
		virtual HRESULT		STDMETHODCALLTYPE	GetTableSchema(
			/* IN  */			const BOOL					bRefresh,
			/* IN  */		 	const INT					idx,
			/* OUT */   	 	DSI_TableSchema_Iface** ppTabSchema
		) = 0;
		//  Escape hatch to get the DBI_TBLPTR from the DBI implementation
		virtual HRESULT		STDMETHODCALLTYPE	EntryToTBLPTR(
			/* IN  */		 	const INT	idx,
			/* OUT */   	 	VOID** ppTblPtr
		) {
			*ppTblPtr = NULL;  return S_FALSE;
		}
		virtual HRESULT		STDMETHODCALLTYPE	GetTableOwner(
			/* IN  */		 	const INT	idx,
			/* OUT */   	 	LPTSTR* ppOwner
		) = 0;
		virtual HRESULT		STDMETHODCALLTYPE	GetTableName(
			/* IN  */		 	const INT	idx,
			/* OUT */   	 	LPTSTR* ppName
		) = 0;
		virtual HRESULT		STDMETHODCALLTYPE	GetTableQualifier(
			/* IN  */		 	const INT	idx,
			/* OUT */   	 	LPTSTR* ppQualifier
		) {
			*ppQualifier = NULL; return S_FALSE;
		}
		virtual HRESULT		STDMETHODCALLTYPE	GetObjId(
			/* IN  */		 	const INT	idx,
			/* OUT */   	 	LONG* piObjId
		) {
			*piObjId = 0; return S_FALSE;
		}
		virtual HRESULT		STDMETHODCALLTYPE	IsSystemObject(
			/* IN  */		 		const INT	idx,
			/* OUT */   	 		BOOL* pbSystem
		) {
			*pbSystem = FALSE; return S_FALSE;
		}
		virtual HRESULT		STDMETHODCALLTYPE	IsView(
			/* IN  */		const INT	 idx,
			/* OUT */		BOOL* pbView
		) {
			*pbView = FALSE; return S_FALSE;
		}
		virtual HRESULT		STDMETHODCALLTYPE	IsAlias(
			/* IN  */		const INT	idx,
			/* OUT */		BOOL* pbAlias
		) {
			*pbAlias = FALSE; return S_FALSE;
		}
		virtual HRESULT		STDMETHODCALLTYPE	IsProxy(
			/* IN  */		const INT	idx,
			/* OUT */   	BOOL* pbProxy
		) {
			*pbProxy = FALSE; return S_FALSE;
		}
		//  Caller must issue *ppConnect->Release() when finished
		virtual	HRESULT	   	STDMETHODCALLTYPE	GetConnection(
			/* OUT */			DSI_Connection_Iface** ppConnect
		) = 0;
	};

	//a1d933db-bf49-43da-b1cc-0accb15dfa57
	EXTERN_C const IID IID_DSI_Connection_Iface;

	class DSI_Connection_Iface : public  IUnknown
	{

	public:
		virtual 			~DSI_Connection_Iface() {};
		virtual	HRESULT		STDMETHODCALLTYPE	GetUserName(
			/* OUT */	LPTSTR* ppUserName
		) = 0;
		virtual	HRESULT		STDMETHODCALLTYPE	GetPassword(
			/* OUT */	LPTSTR* ppPassword
		) = 0;

		virtual	HRESULT		STDMETHODCALLTYPE	GetServerName(
			/* OUT */	LPTSTR* ppServer
		) = 0;
		virtual	HRESULT		STDMETHODCALLTYPE	GetDBMS(
			/* OUT */	LPTSTR* ppDBMS
		) = 0;
		virtual	HRESULT		STDMETHODCALLTYPE	GetDatabaseName(
			/* OUT */	LPTSTR* ppPassword
		) = 0;
		// pOutBuffer is a buffer that is pre-allocated by the caller
		virtual	HRESULT		STDMETHODCALLTYPE	DelimitReservedWord(
			/* IN  */	const LPTSTR	pInWord,
			/* OUT */	LPTSTR 			pOutBuffer,
			/* IN  */   LONG            lOutBufferSize
		) = 0;
		//  *pbValid = TRUE  means success.  *pbValid = FALSE means failure.
		virtual	HRESULT		STDMETHODCALLTYPE	ValidateIdentifier(
			/* IN  */	const LPTSTR	pIdent,
			/* OUT */   BOOL* pbValid
		) = 0;
		virtual HRESULT		STDMETHODCALLTYPE	GetNumberOfAggregateFunctions(
			/* OUT */				INT* piCount
		) = 0;

		virtual HRESULT		STDMETHODCALLTYPE	GetAggregateFunctionName(
			/* IN  */		const INT 	idx,
			/* OUT */		LPTSTR* pFunctName
		) = 0;
		virtual HRESULT		STDMETHODCALLTYPE	GetNumberOfFunctions(
			/* OUT */	 INT* piCount
		) = 0;

		virtual HRESULT		STDMETHODCALLTYPE	GetFunctionName(
			/* IN  */		const INT 	idx,
			/* OUT */	 	LPTSTR* ppFunctName
		) = 0;

		virtual	HRESULT		STDMETHODCALLTYPE	GetSchema(
			/*  OUT */		DSI_DatasourceSchema_Iface**
		) = 0;
		//  Create TableSchema object for table if bRefresh==TRUE. Otherwise get TableSchema from cache.
		virtual HRESULT		STDMETHODCALLTYPE	GetTableSchema(
			/* IN  */			const BOOL					bRefresh,
			/* IN  */		 	const LPTSTR				pTableOwner,
			/* IN  */		 	const LPTSTR				pTableName,
			/* OUT */   	 	DSI_TableSchema_Iface** ppTabSchema
		) = 0;
		virtual HRESULT		STDMETHODCALLTYPE	GetSupportPBCatalog(
			/* OUT */			BOOL* pbPBCat
		) {
			*pbPBCat = FALSE; return S_FALSE;
		}
		virtual HRESULT		STDMETHODCALLTYPE	GetLastErrorCode(
			/* OUT */		LONG* pErrCode
		) = 0;
		virtual HRESULT		STDMETHODCALLTYPE	GetLastErrorText(
			/* OUT */		LPTSTR* ppErrText
		) = 0;
		virtual HRESULT		STDMETHODCALLTYPE	GetStgThis(
			/* OUT */	ppbstg_anchor* pstgThis
		) = 0;
		virtual HRESULT		STDMETHODCALLTYPE	SetStgThis(
			/* IN  */	ppbstg_anchor	stgThis
		) = 0;
		virtual HRESULT		STDMETHODCALLTYPE	DeleteDBI_TABLE(
			/* IN  */		DBI_TBLPTR	pTable
		) = 0;
		virtual	HRESULT		STDMETHODCALLTYPE	Commit() { return SUCCESS; }

		virtual	HRESULT		STDMETHODCALLTYPE	Rollback() { return SUCCESS; }

		virtual HRESULT		STDMETHODCALLTYPE	GetProperty(
			/* IN  */		BOOL	bRefresh,
			/* IN  */		LONG	lProperty,
			/* OUT */		LONG* lPropertyValue
		) = 0;

		// Caller must pre-allocate the pDateString buffer 
		virtual HRESULT		STDMETHODCALLTYPE	FormatDateString(
			/* IN  */	PVOID	pDT,
			/* OUT */   LPTSTR  pDateString,
			/* IN  */   LONG    lDateStringSz
		) = 0;



	};

#endif
	// DOINC popped back into header 'rtdbpub.h'
#endif

#ifdef GENERATED_CODE_BUILD
	typedef struct _RTDB_TRANSACTION {} RTDB_TRANSACTION, FAR* PRTDB_TRANSACTION;
#else

//***************************************************************************
// DB runtime anchor block
//***************************************************************************
	typedef struct rtdb_transaction
	{

		BOOL           bAutoCommit;                // Auto commit flag
		BOOL           bCurrentOfCursorWorks;      // Current of cursor flag
		BOOL           bParseOnly;                 // Parse only flag
		BOOL           bSpecialCurrentOfCursor;    // Special current of cursor flag
		TCHAR           cNullStringDefault[2];      // Null string default
		OB_INST_ID     obInstID;                   // Object instance ID
		PDBI_COMMAND   pCommandBlock;              // Current command block
		PSHLIST        pStatementList;             // Statement list
		BOOL           bSkipSelectCountVerify;     // Skip select count verify
		BOOL           bDescribeBeforeExecute;     // Describe before execute
		BOOL           bPassedTransaction;         // Transaction got passed to us
		DBI_PARMSTYLE  UseBindVariables;           // should we use input bind variables
		PSHLIST        pDBIInputBind;              // input parameter bind list, this is
												   // storage allocated by rtdb
												   // using the database connection command
												   // block's storage anchor.  It is to be
												   // released by the actual database interface
												   // at hand.  Its life span should only
												   // be for the Prepare/Execute of a
												   // SQL statement.
		BOOL			bDB2DoubleQuote;			 // CR#309174 - to support DB2 double quote
		DSI_Connection_Iface* pDSI;               // Data source Connection interface
	} RTDB_TRANSACTION, FAR* PRTDB_TRANSACTION;

	typedef struct rtdb_transaction_pool
	{
		INT            iMaxConnections;
		INT            iMinConnections;
		INT            iTimeout;
		INT            iWaitFail;
		HANDLE         hPoolSemaphore;
		PSHLIST        pshlTransactions;
	} RTDB_TRANSACTION_POOL, FAR* PRTDB_TRANSACTION_POOL;

	typedef struct rtdb_trans_pool_list
	{
		PDBI_COMMAND   pCommandBlock;
		ppbstg_anchor  stgthis;				        // Storage anchor for DB command block
		LONG           LastConnectTimeTicker;
		BOOL           bTransInUse;                 // DB command block is in use
		LPTSTR		 origUserID;
	} RTDB_TRANS_POOL_LIST, FAR* PRTDB_TRANS_POOL_LIST;

	//***************************************************************************
	//  Function prototypes
	//***************************************************************************

#ifdef    __cplusplus
	extern "C" {
#endif    /* __cplusplus */

		PBWINAPI(VOID, rtdb_reset_autocommit)
			(PRT_THIS,
				PRTDB_TRANSACTION,
				BOOL);

		PBWINAPI(VOID, rtdb_set_transaction)
			(PRT_THIS     pThis,
				OB_INST_ID   obTransactionID,
				PDBI_COMMAND pCommandBlock,
				BOOL         bAutoCommit);

		PBWINAPI(PRTDB_TRANSACTION, rtdb_transaction_resolve)
			(PRT_THIS,
				OB_INST_ID,
				BOOL);

		PBWINAPI(PRTDB_TRANSACTION, rtdb_transaction_resolve2)
			(PRT_THIS,
				OB_INST_ID,
				BOOL);

		PBWINAPI(OB_INST_ID, rtdb_transaction_reverse_resolve)
			(PRT_THIS,
				PDBI_COMMAND);

#ifdef    __cplusplus
	}	// extern "C" {
#endif    /* __cplusplus */

#endif // GENERATED_CODE_BUILD

#endif    // RTDB_DEF_PUB_H


// DOINC popped back into header 'rtdbsem.h'
#endif

//***************************************************************************
// #defines for rtdb_cursor_proc_resolve
//***************************************************************************
#define RTDB_CURSOR         1                // Cursor
#define RTDB_EITHER         2                // Cursor or procedure
#define RTDB_PROCEDURE      3                // Procedure

//***************************************************************************
// #defines for Fetch direction
//***************************************************************************
#define RTDB_FETCH_NEXT     1                // Fetch next
#define RTDB_FETCH_FIRST    2                // Fetch first
#define RTDB_FETCH_PRIOR    3                // Fetch prior
#define RTDB_FETCH_LAST     4                // Fetch last

//***************************************************************************
// Default numeric/data buffer size
//***************************************************************************
#define RTDB_BUFFER_SIZE    40L              // Maximum buffer size

//***************************************************************************
// DB output variable information block (stored in conpool)
//***************************************************************************

	typedef struct rtdb_output_varinfo
	{
		USHORT			flags;					 // Contains:
	//	BOOL						has_indvar     	: 1; TRUE if has indicator var
	//	BOOL						free_refpak    	: 2; TRUE if refpak is freed

	} RTDB_OUTPUT_VARINFO, FAR* PRTDB_OUTPUT_VARINFO;

	// flags field masks and shifts
#define RTDB_OUTVAR_INDVAR_MASK		0x0001				// 1 bit
#define RTDB_OUTVAR_FREEPAK_MASK   	0x0002				// 1 bit

#define RTDB_OUTVAR_INDVAR_SHIFT   	0
#define RTDB_OUTVAR_FREEPAK_SHIFT  	1

// flags access methods
#define rtdb_does_outvar_have_indvar(obthis,outvar_entry)  		 			\
	ob_get_bitfield ((outvar_entry)->flags, BOOL,							\
		RTDB_OUTVAR_INDVAR_SHIFT, RTDB_OUTVAR_INDVAR_MASK)

#define rtdb_set_outvar_has_indvar(obthis,outvar,ivar)				   		\
	ob_set_bitfield ((outvar)->flags, USHORT, ivar,							\
		RTDB_OUTVAR_INDVAR_SHIFT, RTDB_OUTVAR_INDVAR_MASK)

#define rtdb_does_outvar_free_refpak(obthis,outvar_entry)  		 			\
	ob_get_bitfield ((outvar_entry)->flags, BOOL,							\
		RTDB_OUTVAR_FREEPAK_SHIFT, RTDB_OUTVAR_FREEPAK_MASK)

#define rtdb_set_outvar_free_refpak(obthis,outvar,free)				   		\
	ob_set_bitfield ((outvar)->flags, USHORT, free,							\
		RTDB_OUTVAR_FREEPAK_SHIFT, RTDB_OUTVAR_FREEPAK_MASK)

//***************************************************************************
// DB runtime cursor/procedure block
//***************************************************************************

	typedef struct rtdb_cursor_proc
	{

		PDBI_BIND      pDBBindBuffer;              // Pointer to DB bind buffer
		PDBI_COMMAND   pCommandBlock;              // Current command block
		UINT           iNumberOfSelectItems;       // Number of select items
		UINT           iType;                      // Type of block
		LPTSTR			 pName;						 // Name of Proc/Cursor
		TIME_T		 timeStamp;					 // Provides with pName a unique id

	} RTDB_CURSOR_PROC, FAR* PRTDB_CURSOR_PROC;

	//***************************************************************************
	// DB runtime statement block
	//***************************************************************************

	typedef struct rtdb_statement
	{

		SHORT          bBindSelectBuffer;          // Bind select buffer flag
		SHORT			 risc_padding;
		OB_CONST_REF   obcrOutputInfoBuffer;       // Bind output information buffer
		OB_CONST_REF   obcrDeclaration;            // Declaration handle
		OB_CONST_REF   obcrName;                   // Name
		OB_CONST_REF   obcrOffsetArray;            // Array of offsets for substitution
		OB_CONST_REF   obcrStagingArea;            // Staging area handle
		OB_CONST_REF   obcrSyntax;                 // Command syntax
		OB_CONST_REF   obcrTransaction;            // Transaction handle
		OB_CONST_REF	 obcrCursprocVarPcode;		 // Pcode list for cursor/proc variables
		USHORT         iFetchDirection;            // Fetch direction
		SHORT			 risc_padding2;
		USHORT         iNumberOfInputItems;        // Number of input items
		SHORT			 risc_padding3;
		USHORT         iNumberOfOutputItems;       // Number of output items
		SHORT			 risc_padding4;
		TIME_T		 timeStamp;					 // Provides with crName a unique id
		POB_GROUP		 pGroup;					 // Group where statement block lives
												   // (runtime only)

	} RTDB_STATEMENT, FAR* PRTDB_STATEMENT;

	typedef struct rtdb_statement_indirect
	{
		OB_SYM_ID      idSourceGroup;              // globsym reference to source group
		SHORT			 padding;
		OB_CONST_REF   obcrStatement;       		// Statement in source group

	} RTDB_STATEMENT_INDIRECT, FAR* PRTDB_STATEMENT_INDIRECT;

	//***************************************************************************
	// DB runtime syntax block
	//***************************************************************************

	typedef struct rtdb_syntax
	{

		LPTSTR          lpszCurrentSyntax;          // Pointer to current syntax
		UINT           iCurrentSyntaxLength;       // Current syntax length
		UINT           iTotalSyntaxLength;         // Current total length

	} RTDB_SYNTAX, FAR* PRTDB_SYNTAX;


	//***************************************************************************
	// Cursor/procedure variable info block
	// NOTE:
	//		This isn't really used by the runtime system, but it is part of the
	//		conpool structure which is read by runtime. Therefore I put the
	//		structure definition on the runtime side of things. JJK.
	//***************************************************************************

	typedef struct rtdb_cursproc_varinfo
	{

		OB_CONST_REF	 var_pcode;			 // Pcode snippet for cursor/proc variable


	} RTDB_CURSPROC_VARINFO, FAR* PRTDB_CURSPROC_VARINFO;


	//****************************************************************************
	// Work function prototypes
	//****************************************************************************

#ifdef    __cplusplus
	extern "C" {
#endif    /* __cplusplus */

		PBWINAPI(INT, rtdb_close)
			(
				POB_THIS			obthis,
				POB_RUNTIME_INST	target_object,
				PRTDB_STATEMENT		cursor_statement_block
				);

		PBWINAPI(INT, rtdb_commit)
			(
				POB_THIS			obthis,
				POB_RUNTIME_INST	transaction_object
				);

		PBWINAPI(INT, rtdb_delete)
			(
				POB_THIS			obthis,
				OB_CONST_REF		statement_offset,
				UINT				no_inputs,
				POB_DATA 			input_expr_array,
				POB_RUNTIME_INST	transaction_object
				);


		PBWINAPI(INT, rtdb_deletewithcurs)
			(
				POB_THIS			obthis,
				OB_CONST_REF		statement_offset,
				UINT				no_inputs,
				POB_DATA 			input_expr_array,
				POB_RUNTIME_INST	target_object,
				PRTDB_STATEMENT		cursor_statement_block
				);

		PBWINAPI(INT, rtdb_describe)
			(
				POB_THIS			obthis,
				POB_RUNTIME_INST	sqlsa_object,
				POB_RUNTIME_INST	sqlda_object
				);

		PBWINAPI(INT, rtdb_execute)
			(
				POB_THIS			obthis,
				UINT				no_inputs,
				POB_DATA 			input_expr_array,
				POB_RUNTIME_INST	transaction_object,
				PRTDB_STATEMENT		procedure_statement_block
				);

		PBWINAPI(INT, rtdb_executedyn)
			(
				POB_THIS			obthis,
				OB_CONST_REF		statement_offset,
				UINT				no_inputs,
				POB_DATA 			input_expr_array,
				POB_RUNTIME_INST	sqlsa_object
				);

		PBWINAPI(INT, rtdb_executeimmed)
			(
				POB_THIS			obthis,
				LPTSTR				syntax_string,
				POB_RUNTIME_INST	transaction_object
				);

		PBWINAPI(INT, rtdb_execdynproc)
			(
				POB_THIS			obthis,
				OB_CONST_REF		statement_offset,
				UINT				no_inputs,
				POB_DATA 			input_expr_array,
				POB_RUNTIME_INST	sqlsa_object,
				PRTDB_STATEMENT		procedure_statement_block
				);

		PBWINAPI(INT, rtdb_execdynwithdesc)
			(
				POB_THIS			obthis,
				OB_CONST_REF		statement_offset,
				POB_RUNTIME_INST	sqlsa_object,
				POB_RUNTIME_INST	sqlda_object,
				PRTDB_STATEMENT		procedure_statement_block
				);

		PBWINAPI(INT, rtdb_fetch)
			(
				POB_THIS			obthis,
				OB_CONST_REF		statement_offset,
				UINT				no_outputs,
				POB_DATA 			output_expr_array,
				POB_RUNTIME_INST	target_object,
				PRTDB_STATEMENT	   	cursor_statement_block
				);

		PBWINAPI(INT, rtdb_fetchwithdesc)
			(
				POB_THIS			obthis,
				OB_CONST_REF		statement_offset,
				POB_RUNTIME_INST	sqlsa_object,
				POB_RUNTIME_INST	sqlda_object,
				PRTDB_STATEMENT	  	cursor_statement_block
				);

		PBWINAPI(INT, rtdb_insert)
			(
				POB_THIS			obthis,
				OB_CONST_REF		statement_offset,
				UINT				no_inputs,
				POB_DATA 			input_expr_array,
				POB_RUNTIME_INST	transaction_object
				);

		PBWINAPI(INT, rtdb_open)
			(
				POB_THIS			obthis,
				UINT				no_inputs,
				POB_DATA 			input_expr_array,
				POB_RUNTIME_INST	transaction_object,
				PRTDB_STATEMENT	   	cursor_statement_block
				);

		PBWINAPI(INT, rtdb_opendyn)
			(
				POB_THIS			obthis,
				OB_CONST_REF		statement_offset,
				UINT				no_inputs,
				POB_DATA 			input_expr_array,
				POB_RUNTIME_INST	sqlsa_object,
				PRTDB_STATEMENT	   	cursor_statement_block
				);

		PBWINAPI(INT, rtdb_opendynwithdesc)
			(
				POB_THIS			obthis,
				OB_CONST_REF		statement_offset,
				POB_RUNTIME_INST	sqlsa_object,
				POB_RUNTIME_INST	sqlda_object,
				PRTDB_STATEMENT		cursor_statement_block
				);

		PBWINAPI(INT, rtdb_prepare)
			(
				POB_THIS			obthis,
				POB_RUNTIME_INST	sqlsa_object,
				LPTSTR				syntax_string,
				POB_RUNTIME_INST	transaction_object
				);

		PBWINAPI(INT, rtdb_rollback)
			(
				POB_THIS			obthis,
				POB_RUNTIME_INST	transaction_object
				);

		PBWINAPI(INT, rtdb_select)
			(
				POB_THIS			obthis,
				OB_CONST_REF		statement_offset,
				UINT				no_inputs,
				UINT				no_outputs,
				POB_DATA 			input_expr_array,
				POB_DATA 			output_expr_array,
				POB_RUNTIME_INST	transaction_object
				);

		PBWINAPI(INT, rtdb_selectblob)
			(
				POB_THIS			obthis,
				OB_CONST_REF		statement_offset,
				UINT				no_inputs,
				UINT				no_outputs,
				POB_DATA 			input_expr_array,
				POB_DATA 			output_expr_array,
				POB_RUNTIME_INST	transaction_object
				);

		PBWINAPI(INT, rtdb_start)
			(
				POB_THIS			obthis,
				POB_RUNTIME_INST	transaction_object
				);

		PBWINAPI(INT, rtdb_stop)
			(
				POB_THIS			obthis,
				POB_RUNTIME_INST	transaction_object
				);

		PBWINAPI(INT, rtdb_update)
			(
				POB_THIS			obthis,
				OB_CONST_REF		statement_offset,
				UINT				no_inputs,
				POB_DATA 			input_expr_array,
				POB_RUNTIME_INST	transaction_object
				);

		PBWINAPI(INT, rtdb_updatewithcurs)
			(
				POB_THIS			obthis,
				OB_CONST_REF		statement_offset,
				UINT				no_inputs,
				POB_DATA 			input_expr_array,
				POB_RUNTIME_INST	target_object,
				PRTDB_STATEMENT	   	cursor_statement_block
				);

		PBWINAPI(INT, rtdb_updateblob)
			(
				POB_THIS			obthis,
				OB_CONST_REF		statement_offset,
				UINT				no_inputs,
				POB_DATA 			input_expr_array,
				POB_RUNTIME_INST	transaction_object,
				POB_DATA			blob_var
				);


		//****************************************************************************
		//	Macros
		//****************************************************************************

#define rtdb_pop_statement(obthis)									\
	((PRTDB_STATEMENT) ob_get_data_ptr (ot_pop_rvalue (obthis)))

#define rtdb_pop_object(obthis)										\
	((POB_RUNTIME_INST) ob_get_data_ptr (ot_pop_rvalue (obthis)))

#define rtdb_get_const(obthis,group,offset)							\
	ob_get_const_data (obthis, 										\
					   ob_get_group_conpool (obthis, group), 		\
					   offset)

//***************************************************************************
//  Tool Function prototypes
//***************************************************************************

		VOID 				rtdb_cursproc_static_add
		(
			POB_THIS          	pThis,
			PRTDB_TRANSACTION 	pTransactionBlock,
			PRTDB_STATEMENT   	pStatementBlock,
			POB_RUNTIME_INST  	obTransactionInstID,
			INT               	iType,
			UINT			  	no_inputs,
			POB_DATA 	    	input_expr_array
		);

		VOID 				rtdb_cursproc_dynamic_add
		(
			POB_THIS          	pThis,
			PRTDB_TRANSACTION 	pTransactionBlock,
			PRTDB_STATEMENT   	pStatementBlock,
			POB_RUNTIME_INST  	obTransactionInstID,
			POB_RUNTIME_INST   	obStagingAreaInstID,
			POB_RUNTIME_INST  	obDescriptorInstID,
			INT               	iType,
			UINT			  	no_inputs,
			POB_DATA 	    	input_expr_array
		);

		VOID               rtdb_cursor_proc_buffer_free(POB_THIS, PDBI_BIND, INT);

		VOID               rtdb_cursor_proc_remove(POB_THIS, PRTDB_TRANSACTION,
			PRTDB_CURSOR_PROC);

		VOID               rtdb_cursor_proc_remove_all(POB_THIS, PRTDB_TRANSACTION);

		PRTDB_CURSOR_PROC  rtdb_cursor_proc_resolve(POB_THIS, PRTDB_TRANSACTION,
			PRTDB_STATEMENT,
			BOOL, POB_RUNTIME_INST, INT);

		INT                rtdb_cursor_proc_terminate(POB_THIS, OB_SYM_ID, UINT, INT);

		INT                rtdb_database_error(POB_THIS, PDBI_COMMAND,
			POB_RUNTIME_INST, BOOL);

		VOID               rtdb_describe_output(POB_THIS, UINT,
			POB_RUNTIME_INST, PDBI_COMMAND);

		INT 				rtdb_fetch_run
		(
			POB_THIS          	pThis,
			PRTDB_STATEMENT   	pRetrieveStatementBlock,
			PRTDB_STATEMENT   	pFetchStatementBlock,
			PDBI_COMMAND      	pCommandBlock,
			PDBI_BIND         	pDBBindBuffer,
			POB_RUNTIME_INST  	rtInstID,
			UINT              	iNumberOfOutputItems,
			UINT			  	iNumberOfActualItems,
			POB_DATA 	 	  	output_expr_array,
			PRTDB_OUTPUT_VARINFO pRTOutvarInfo,
			UINT			  	iType,
			PRTDB_CURSOR_PROC 	pBlock,
			PRTDB_TRANSACTION 	pTransactionBlock,
			POB_RUNTIME_INST  	obDescriptorInstID
		);

		VOID 				rtdb_free_output_refpaks
		(
			POB_THIS        	pThis,
			UINT            	iNumberOfOutputItems,
			POB_DATA 	    	pOutputExprArray,
			PRTDB_OUTPUT_VARINFO pRTOutvarInfo
		);

		POB_DATA	      	rtdb_get_descriptor_input(POB_THIS, POB_RUNTIME_INST,
			UINT);

		INT 				rtdb_non_select_command
		(
			POB_THIS       		pThis,
			OB_CONST_REF		const_ref,
			UINT				no_inputs,
			POB_DATA 			input_expr_array,
			POB_RUNTIME_INST	obTransactionInstID
		);


		INT 				rtdb_non_select_with_cursor
		(
			POB_THIS			pThis,
			OB_CONST_REF		statement_offset,
			UINT				no_inputs,
			POB_DATA 			input_expr_array,
			POB_RUNTIME_INST	target_object,
			PRTDB_STATEMENT   	pCursorStatementBlock
		);

		INT                rtdb_parameter_count(LPTSTR, PUSHORT, BOOL);

		POB_DATA 		   rtdb_pop_array
		(
			POB_THIS          	pThis,
			UINT				iNumItems
		);

		LPTSTR 			   rtdb_pop_string
		(
			POB_THIS          	pThis
		);

		PDBI_BIND          rtdb_retrieval_build(POB_THIS, PDBI_COMMAND,
			PRTDB_STATEMENT);

		PDBI_BIND          rtdb_retrieval_resolve(POB_THIS, PRTDB_STATEMENT,
			PDBI_COMMAND, LPTSTR,
			PRTDB_TRANSACTION, INT);

		INT 			   	rtdb_retrieval_run
		(
			POB_THIS          	pThis,
			PRTDB_STATEMENT   	pRetrieveStatementBlock,
			PRTDB_TRANSACTION 	pTransactionBlock,
			PDBI_COMMAND      	pCommandBlock,
			POB_RUNTIME_INST  	rtInstID,
			LPTSTR             	lpszCursorName,
			POB_GROUP         	pobRetrieveGroup,
			BOOL              	bIsaStoredProcedure,
			UINT			  	no_inputs,
			POB_DATA 	    	input_expr_array
		);

		INT 			   rtdb_select_run
		(
			POB_THIS          	pThis,
			PRTDB_STATEMENT   	pCursorStatementBlock,
			PRTDB_STATEMENT   	pFetchStatementBlock,
			PDBI_COMMAND      	pCommandBlock,
			PDBI_BIND         	pDBBindBuffer,
			POB_RUNTIME_INST  	rtInstID,
			UINT              	iNumberOfOutputItems,
			UINT			  	iNumberOfActualItems,
			POB_DATA	 	  	output_expr_array,
			PRTDB_OUTPUT_VARINFO pRTOutvarInfo
		);

		VOID               rtdb_set_error_fields(POB_THIS, POB_RUNTIME_INST,
			LONG, LONG, LONG, UINT, LPTSTR);
		VOID               rtdb_set_error_fields2(POB_THIS, POB_RUNTIME_INST,
			LONG, LONG, LONG, UINT, LPTSTR);

		INT 			   rtdb_sql_execute
		(
			POB_THIS          	pThis,
			PDBI_COMMAND      	pCommandBlock,
			LPTSTR             	lpszCursorName,
			POB_RUNTIME_INST  	pTransactionObject,
			LPTSTR             	lpszCurrentSyntax,
			BOOL              	bExecuteImmediately,
			PRTDB_TRANSACTION 	pTransactionBlock
		);

		VOID               rtdb_stop_all(POB_THIS);

		LPTSTR rtdb_subs_values
		(
			POB_THIS            pThis,
			PDBI_COMMAND        pCommandBlock,
			PRTDB_STATEMENT     pStatementBlock,
			LPTSTR               lpszCurrentSyntax,
			PUSHORT             pPassedVariableOffset,
			POB_DATA 			pInputExprArray,
			INT                 iNumberOfInputItems,
			BOOL                bSkipFirstInput,
			DBI_PARMSTYLE       UseRealDBBindVariable,
			PRTDB_TRANSACTION   pTransactionBlock
		);

		VOID               rtdb_transaction_add(POB_THIS, PDBI_COMMAND,
			POB_RUNTIME_INST, BOOL, BOOL);

		VOID               rtdb_transaction_remove(POB_THIS, PRTDB_TRANSACTION);

		LONG               rtdb_event_notifier
		(
			POB_THIS            obThis,
			OB_INST_ID			obTransactionID,
			PVOID				pData,
			DBI_TRANSEVTTYPE	event_type
		);

		PBWINAPI(PDBI_COMMAND, rtdb_trans_pool_login)
			(
				POB_THIS         pThis,
				LPTSTR            lpszDBMS,
				LPTSTR            lpszServerName,
				LPTSTR            lpszLogId,
				LPTSTR            lpszLogPassWord,
				LPTSTR            lpszDbParm,
				LPTSTR            lpszDatabase,
				LPTSTR            lpszUserID,                 /* database user id */
				LPTSTR            lpszDBPass,                 /* database password */
				LPTSTR			   lpszLock,                   /* isolation level */
				POB_RUNTIME_INST pTransactionObject,
				PBOOL				pbCalledLogIn			// did we do a LogIn() ?
				);

		PBWINAPI(VOID, rtdb_trans_pool_disconnect)
			(
				POB_THIS         pThis,
				PDBI_COMMAND     pCommandBlock
				);

#ifdef    __cplusplus
	}	// extern "C" {
#endif    /* __cplusplus */


#endif    // RTDB_DEF_H
// DOINC popped back into header 'rtccode.h'
// ***** DOINC including obobjstk.h *****
// $RCSfile: obobjstk.h $;$Revision: 4.10 $
//**************************************************************************
//
//                            Copyright 1989 
//                        Computer Solutions Inc.
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
//    INCORPORATED.
//
// ------------------------------------------------------------------------
//
//    Filename :	obobjstk.h	
//
//    Author   :	Jim Kosko
//
//    Purpose  : 	Definitions for PB object manager currency routines.
//
//****************************************************************************

#ifndef OBOBJSTK_H
#define OBOBJSTK_H

//****************************************************************************
// Includes
//****************************************************************************

#ifndef OBTYPDEF_H
// ***** DOINC including obtypdef.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBOBJECT_H
// ***** DOINC including obobject.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OBTHIS_H
// ***** DOINC including obthis.h *****
	// DOINC skipping duplicate include
#endif
#ifndef OTEXPR_H
// ***** DOINC including otexpr.h *****
	// DOINC skipping duplicate include
#endif

	typedef struct ob_objstk_node
	{
		POB_RUNTIME_INST		rtinst;
		OT_EVAL_NODE			return_value;

		// deal with local variables for machine code executables
		POB_DATA				local_vars;
		ULONG					num_vars;
	} OB_OBJSTK_NODE, FAR* POB_OBJSTK_NODE;


	//****************************************************************************
	// Function prototypes.
	//****************************************************************************


#ifdef    __cplusplus
	extern "C" {
#endif    /* __cplusplus */

#define ob_get_curr_rtinst(obthis)			\
	((POB_RUNTIME_INST)(obthis)->curr_obinst)

		PBWINAPI(VOID, ob_set_curr_rtinst_and_return)
			(
				POB_THIS 			obthis,
				POB_RUNTIME_INST	new_rtinst
				);

		PBWINAPI(VOID, ob_unset_curr_rtinst_and_return)
			(
				POB_THIS 			obthis
				);

		VOID
			create_rtinst_stack
			(
				POB_THIS 				 	obthis
			);

		VOID 		ob_remove_rtinst_stack_references
		(
			POB_THIS 				 	obthis,
			POB_RUNTIME_INST		 	rtinst_to_remove
		);

		BOOL 		ob_rtinst_in_rtinst_stack
		(
			POB_THIS 				 	obthis,
			POB_RUNTIME_INST		 	rtinst_to_find
		);

		VOID 		ob_mark_references_in_rtinst_stack
		(
			POB_THIS 				 	obthis
		);

		BOOL object_reference_in_stack
		(
			POB_THIS			obthis,
			POB_RUNTIME_INST	rtinst
		);

#ifdef    __cplusplus
	}	// extern "C" {
#endif    /* __cplusplus */


#endif // OBOBJSTK_H
// DOINC popped back into header 'rtccode.h'
// ***** DOINC including obtrace.h *****
//**************************************************************************
//
//                            Copyright 1996
//                        Powersoft Corporation
//
//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM POWERSOFT CORPORATION.
//
// ------------------------------------------------------------------------
//
//    Filename :	obtrace.h
//
//    Author   :	Boleslaw Ciesielski
//
//    Purpose  : 	Public interface to runtime trace facility.
//
//****************************************************************************

#ifndef OBTRACE_H
#define OBTRACE_H

/*

Trace feature is the basis for profiling. During runtime it produces a
trace file (an event log really) which contains an record for each
runtime event (event here is used in general sense, not a Powerscript
event). There is a predefined set of events in the form of a TRACEID
type (enum). There are three kinds of log records: entry, exit and
atomic. Some events can last for some time and therefore other events
may happen in the meantime. In such cases the beginning and start of
such an event needs to be bracketed by entry and exit records.
Other events are considered atomic and are logged using the atomic log
record.

Event tracing can be enabled/disabled globally (ob_begin_trace, ob_end_trace)
or per event kind (ob_enable_event_trace).

ob_begin_trace should probably log an implicit event entry for the current
routine, so the subsequent line or pcode tracing records make sense (not
implemented yet).

Each log record has a time stamp. User can choose between measuring
wall clock time, process time or thread time. Generally wall clock time
measurement has the highest resolution and has the least overhead but
is skewed by the activities in the rest of the system. Some platforms
may not support all kinds of time measurement and may even ignore the
setting.

We may decide that for performance reasons line and pcode trace
records do not have timestamps at all (currently they do).

The trace file starts with the header and ends with the group table which
contains group ids, modification times and group names for all the groups.
There is an offset to the group table in the header.

*/

//****************************************************************************
// Assume C declarations for C++
//****************************************************************************
#ifdef __cplusplus
	extern "C" {
#endif	/* __cplusplus */

		// ***** DOINC including obthis.h *****
			// DOINC skipping duplicate include

		// if you change the numbers or add one, change typdef.scr: type TimerValueKind
		typedef enum ob_timer_kind
		{
			OB_TIMER_NONE = 1,			// do not log timer values
			OB_TIMER_CLOCK = 2,			// use the wall clock
			OB_TIMER_PROCESS = 3,		// use the process time (kernel + user)
			OB_TIMER_THREAD = 4			// use the thread time (kernel + user)
		} OB_TIMERKIND;


		// if you change the numbers or add one, change typdef.scr: type TraceActivity
		// you also need to change the static num_args and eventstr arrays in obtrace.cpp
		typedef enum ob_trace_id
		{
			OB_TRACEID_ROUTINE = 1,
			OB_TRACEID_LINE = 2,
			OB_TRACEID_PCODE = 3,
			OB_TRACEID_ESQL = 4,
			OB_TRACEID_OBJECT_CREATE = 5,
			OB_TRACEID_OBJECT_DESTROY = 6,
			OB_TRACEID_USER = 7,
			OB_TRACEID_ERROR = 8,
			OB_TRACEID_BEGIN = 9,
			OB_TRACEID_GC = 10,
			// Insert here
			OB_TRACEID_LAST = 11			// must be last, not actually used
		} OB_TRACEID, * POB_TRACEID;


		// if you change the numbers or add one, change typdef.scr: type TraceCategory
		typedef enum ob_trace_record_type
		{
			OB_TRACE_ENTRY = 1,
			OB_TRACE_EXIT = 2,
			OB_TRACE_ATOMIC = 3
		} OB_TRACERECORDTYPE;

		// if you change the numbers or add one, change typdef.scr: type ErrorReturn
		typedef enum ob_error_return
		{
			ERR_RET_Success = 1,
			ERR_RET_TraceStartedError = 2,
			ERR_RET_TraceNotStartedError = 3,
			ERR_RET_FileCloseError = 4,
			ERR_RET_FileOpenError = 5,
			ERR_RET_FileReadError = 6,
			ERR_RET_FileWriteError = 7,
			ERR_RET_FileNotOpenError = 8,
			ERR_RET_FileAlreadyOpenError = 9,
			ERR_RET_NoMoreNodes = 10,
			ERR_RET_FileInvalidFormatError = 11,
			ERR_RET_ModelNotExistsError = 12,
			ERR_RET_ModelExistsError = 13,
			ERR_RET_GeneralError = 14,
			ERR_RET_FileNotSetError = 15,
			ERR_RET_EventNotExistError = 16,
			ERR_RET_EventWrongPrototypeError = 17,
			ERR_RET_FeatureNotSupportedError = 18,
			ERR_RET_SharedObjectNotExistsError = 19,
			ERR_RET_SharedObjectExistsError = 20,
			ERR_RET_MutexCreateError = 21,
			ERR_RET_SharedObjectCreateInstanceError = 22,
			ERR_RET_SharedObjectCreatePBSessionError = 23,
			ERR_RET_EnterpriseOnlyFeature = 24,
			ERR_RET_SourcePBLNotFound = 25

		} OB_ERROR_RETURN, * POB_ERROR_RETURN;


#define MAXSTRING	32

#if defined(_MSC_VER)  &&  (_MSC_VER >= 900)
		typedef	__int64		OB_TRACETIME, * POB_TRACETIME;
#define OB_TRACETIME_MAX 9223372036854775807
#elif defined(__sun)
		typedef	longlong_t	OB_TRACETIME, * POB_TRACETIME;
#define OB_TRACETIME_MAX ULONG_MAX
#elif defined(PBOS_UNIX)
		typedef	long long	OB_TRACETIME, * POB_TRACETIME;
#define OB_TRACETIME_MAX ULONG_MAX
#elif defined(PBOS_MAC)
		typedef	ULONG	OB_TRACETIME, * POB_TRACETIME;
#define OB_TRACETIME_MAX ULONG_MAX
#elif defined(PBOS_LINUX)
		typedef	__int64		OB_TRACETIME, * POB_TRACETIME;
#define OB_TRACETIME_MAX ULONG_MAX
#elif ! defined(PBWIN32)
		typedef	ULONG	OB_TRACETIME, * POB_TRACETIME;
#define OB_TRACETIME_MAX ULONG_MAX
#else
		typedef struct ob_tracetime
		{
			ULONG	loword, hiword;
		} OB_TRACETIME, * POB_TRACETIME;
#endif

		typedef struct ob_trace_runtime
		{
			LPVOID				tracefile;				// output trace file handle
			DWORD				dwTraceEnable;			// per event trace enable mask
			UINT				tskind;					// time stamp kind
			LONG				numActivities;			// the number of activities written to the file
			HANDLE				hProcess;				// current process handle
			HANDLE				hThread;				// current thread handle
			OB_TRACETIME		tTotalSkew;				// time skew because of tracing facility
			OB_TRACETIME		tGetTimeCost;			// cost to get and calculate the time
		} OB_TRACE_RUNTIME, FAR* POB_TRACE_RUNTIME;

		// TJC TODO - deal with platform!
#ifdef PBOS_MAC
#define TRACE_PLATFORM PBTEXT("MAC")
#else 
#if defined(PBOS_UNIX)
#define TRACE_PLATFORM PBTEXT("UNIX")
#else
#define TRACE_PLATFORM PBTEXT("INTEL")
#endif
#endif

#define TRACEFILE_VER PBTEXT("01") 
#define EXPAND_OBVER(obver) PBTEXT(#obver)

// this is a combination of Platform, the tracefile version and the object manager version
#define TRACE_VER_STRING(obver) TRACE_PLATFORM PBTEXT(" ") TRACEFILE_VER PBTEXT(" ") EXPAND_OBVER(obver) 

#define MAXNAMESIZE		64		// this needs to be bigger than 42 and aligned nicely
		typedef struct ob_trace_header
		{
			TCHAR 				magic[MAXSTRING];
			TCHAR 				version[MAXSTRING];
			TCHAR 				applicationName[MAXNAMESIZE]; // max name size for pb names
			ULONG				platform;
			LONG				group_table_offset;
			LONG				library_list_offset;
			ULONG				library_count;
			ULONG				group_count;
			ULONG				group_max;
			OB_TRACETIME		ticks_per_sec;
			OB_TRACETIME		total_skew;
			OB_TIMERKIND		tskind;
			LONG				numActivities;
			ULONG				unused1;
			ULONG				unused2;
			ULONG				unused3;
			ULONG				unused4;
			ULONG				unused5;
			ULONG				unused6;
		} OB_TRACEHEADER, * POB_TRACEHEADER;

		// these tags are used to write the group table
#define TRACE_GROUP_TAG			0x01
#define TRACE_CLASS_TAG			0x02
#define TRACE_LAST_CLASS_TAG	0x03
#define TRACE_ROUTINE_TAG		0x04
#define TRACE_LAST_ROUTINE_TAG	0x05

#define POB_TRACE_STRUCT(obthis)			((POB_TRACE_RUNTIME)((obthis)->traceStruct))
#define OB_TRACE_ENABLED(obthis, traceid)	(POB_TRACE_STRUCT(obthis)->dwTraceEnable & (1 << (traceid)))
#define OB_TRACEFILE(obthis)				((POB_TRACE_STRUCT (obthis) != NULL) ? (FILE *) POB_TRACE_STRUCT(obthis)->tracefile : NULL)
#define OB_INCR_NUM_TRACE_NODES(obthis)		(POB_TRACE_STRUCT (obthis)->numActivities++)

// Initialize the trace module. Return success or failure.
		PBWINAPI(OB_ERROR_RETURN, ob_open_trace)
			(
				POB_THIS obthis,
				LPTSTR filename,
				OB_TIMERKIND kind
				);

		// Close the trace file and cleanup
		PBWINAPI(OB_ERROR_RETURN, ob_close_trace) (POB_THIS obthis);

		// start and stop all tracing (logged into the trace file)
		PBWINAPI(OB_ERROR_RETURN, ob_begin_trace) (POB_THIS obthis, LPTSTR message);
		PBWINAPI(OB_ERROR_RETURN, ob_end_trace) (POB_THIS obthis);

		// Enable/disable tracing of a particular event kind.
		// Can only be called when not currently tracing. Returns success.
		PBWINAPI(OB_ERROR_RETURN, ob_enable_event_trace)  (POB_THIS obthis, OB_TRACEID event);
		PBWINAPI(OB_ERROR_RETURN, ob_disable_event_trace) (POB_THIS obthis, OB_TRACEID event);


		// The following are actual trace routines, called when things happen:

#if (defined(PBOS_NT) || defined(PBOS_WIN40) || defined(PBOS_MAC))
#define ob_trace_event		_ob_trace_event
#endif

		PBCDECLAPI_(OB_ERROR_RETURN) ob_trace_event
		(
			POB_THIS obthis,
			OB_TRACEID event,
			OB_TRACERECORDTYPE rectype,
			...
		);


#define ob_trace_routine_entry(obthis, groupid, classid, vtabid, rtinst)	\
	if (obthis->bTracing  &&  OB_TRACE_ENABLED (obthis, OB_TRACEID_ROUTINE))\
		ob_trace_event (obthis, OB_TRACEID_ROUTINE, OB_TRACE_ENTRY,			\
						MAKELONG (groupid, classid), vtabid, rtinst);		\
	else ;

#define ob_trace_routine_exit(obthis, groupid, classid, vtabid, rtinst)	\
	if (obthis->bTracing  &&  OB_TRACE_ENABLED (obthis, OB_TRACEID_ROUTINE))\
		ob_trace_event (obthis, OB_TRACEID_ROUTINE, OB_TRACE_EXIT,			\
						MAKELONG (groupid, classid), vtabid, rtinst);		\
	else ;

#define ob_trace_gc_entry(obthis)	\
	if (obthis->bTracing  &&  OB_TRACE_ENABLED (obthis, OB_TRACEID_GC))\
		ob_trace_event (obthis, OB_TRACEID_GC, OB_TRACE_ENTRY);		\
	else ;

#define ob_trace_gc_exit(obthis)	\
	if (obthis->bTracing  &&  OB_TRACE_ENABLED (obthis, OB_TRACEID_GC))\
		ob_trace_event (obthis, OB_TRACEID_GC, OB_TRACE_EXIT);		\
	else ;

#define ob_trace_line(obthis, line)											\
	if (obthis->bTracing  &&  OB_TRACE_ENABLED (obthis, OB_TRACEID_LINE))	\
		ob_trace_event (obthis, OB_TRACEID_LINE, OB_TRACE_ATOMIC, line);	\
	else ;

#define ob_trace_pcode(obthis, pcode, opcode)								\
	if (obthis->bTracing  &&  OB_TRACE_ENABLED (obthis, OB_TRACEID_PCODE))	\
		ob_trace_event (obthis, OB_TRACEID_PCODE, OB_TRACE_ATOMIC, pcode, opcode); \
	else ;

#define ob_trace_object_create_entry(obthis, groupid, classid, rtinst)				\
	if (obthis->bTracing  &&  OB_TRACE_ENABLED (obthis, OB_TRACEID_OBJECT_CREATE))	\
		ob_trace_event (obthis, OB_TRACEID_OBJECT_CREATE, OB_TRACE_ENTRY,			\
						MAKELONG (groupid, classid), rtinst);				\
	else ;

#define ob_trace_object_create_exit(obthis, groupid, classid, rtinst)				\
	if (obthis->bTracing  &&  OB_TRACE_ENABLED (obthis, OB_TRACEID_OBJECT_CREATE))	\
		ob_trace_event (obthis, OB_TRACEID_OBJECT_CREATE, OB_TRACE_EXIT,			\
						MAKELONG (groupid, classid), rtinst);				\
	else ;

#define ob_trace_object_destroy_entry(obthis, groupid, classid, rtinst)				\
	if (obthis->bTracing  &&  OB_TRACE_ENABLED (obthis, OB_TRACEID_OBJECT_DESTROY))	\
		ob_trace_event (obthis, OB_TRACEID_OBJECT_DESTROY, OB_TRACE_ENTRY,			\
						MAKELONG (groupid, classid), rtinst);				\
	else ;

#define ob_trace_object_destroy_exit(obthis, groupid, classid, rtinst)				\
	if (obthis->bTracing  &&  OB_TRACE_ENABLED (obthis, OB_TRACEID_OBJECT_DESTROY))	\
		ob_trace_event (obthis, OB_TRACEID_OBJECT_DESTROY, OB_TRACE_EXIT,			\
						MAKELONG (groupid, classid), rtinst);				\
	else ;
#define ob_trace_esql_entry(obthis, command)							\
	if (obthis->bTracing  &&  OB_TRACE_ENABLED (obthis, OB_TRACEID_ESQL))  \
		ob_trace_event (obthis, OB_TRACEID_ESQL, OB_TRACE_ENTRY, command); \
	else ;

#define ob_trace_esql_exit(obthis, command)								\
	if (obthis->bTracing  &&  OB_TRACE_ENABLED (obthis, OB_TRACEID_ESQL))  \
		ob_trace_event (obthis, OB_TRACEID_ESQL, OB_TRACE_EXIT,	command);  \
	else ;

#define ob_trace_user(obthis, arg, msg, result)										\
	if (obthis->bTracing  &&  OB_TRACE_ENABLED (obthis, OB_TRACEID_USER))	\
		result = ob_trace_event (obthis, OB_TRACEID_USER, OB_TRACE_ATOMIC, arg, msg);\
	else ;

#define ob_trace_error(obthis, arg, msg, result)									\
	if (obthis->bTracing  &&  OB_TRACE_ENABLED (obthis, OB_TRACEID_ERROR))	\
		result = ob_trace_event (obthis, OB_TRACEID_ERROR, OB_TRACE_ATOMIC, arg, msg);\
	else ;

#define ob_trace_trace_begin(obthis, msg)	\
	ob_trace_event (obthis, OB_TRACEID_BEGIN, OB_TRACE_ENTRY, msg)

#define ob_trace_trace_end(obthis)	\
	ob_trace_event (obthis, OB_TRACEID_BEGIN, OB_TRACE_EXIT, NULL)

#ifdef __cplusplus
	}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif // OBTRACE_H
// DOINC popped back into header 'rtccode.h'

// #include "pbmain.h"
/* #include "fnpublic.h" removed, we only needed FN_RunExecutable */
	PBWINAPI_(WPARAM)
		FN_RunExecutable
		(
			HINSTANCE      hInstCurr,          // Handle to curr EXE instance
			HINSTANCE      hInstPrev,          // Handle to prev EXE instance
			LPTSTR          lpCmdLine,          // Ptr to command line
			INT            nCmdShow,           // How to show the 1st window
			LPTSTR          lpAppIcon,          // Ptr to app icon name
			BOOL		   bRunningCExe   	   // are we running a generated C EXE
		);

	// ***** DOINC including otcgen.h *****
	//**************************************************************************
	//
	//                            Copyright 1989 
	//                        Computer Solutions Inc.
	//
	//    ALL RIGHTS RESERVED.  NO PORTION OF THIS MATERIAL MAY BE COPIED
	//    IN ANY WAY WITHOUT PRIOR WRITTEN CONSENT FROM COMPUTER SOLUTIONS
	//    INCORPORATED.
	//
	// ------------------------------------------------------------------------
	//
	//    Filename :	otcgen.h
	//
	//    Author   :	Jeff Calow
	//
	//    Purpose  : 	Routines supporting codegen executables.
	//
	//****************************************************************************

	//****************************************************************************
	// Assume C declarations for C++
	//****************************************************************************

#ifdef __cplusplus
	extern "C" {
#endif	/* __cplusplus */


		PBWINAPI(INT, otcg_string_cat)
			(
				POB_THIS		obthis,
				LPTSTR			string1,
				BOOL			string1_null,
				LPTSTR			string2,
				BOOL			string2_null
				);

		PBWINAPI(INT, otcg_binary_cat)
			(
				POB_THIS		obthis,
				PSH_BINARY		binary1,
				BOOL			binary1_null,
				PSH_BINARY		binary2,
				BOOL			binary2_null
				);

		PBWINAPI(VOID, otcg_add_object_argument_reference)
			(
				POB_THIS		obthis,
				POB_DATA		data_node
				);

		PBWINAPI(POB_GROUP, otcg_embedded_group)
			(
				POB_THIS		obthis,
				POB_GROUP		curr_group,
				OB_CLASS_ID		class_id
				);

		//****************************************************************************
		// End of extern "C" block
		//****************************************************************************

#ifdef __cplusplus
	}                       /* End of extern "C" { */
#endif	/* __cplusplus */
// DOINC popped back into header 'rtccode.h'

#ifdef __cplusplus
	}
#endif  /* __cplusplus */

// this is pulled in from pbstub.h in libman
/* *********************************************************************** */
/*  Stub icon ID                                                           */
/* *********************************************************************** */
#define IDI_STUB_ICON         1000


// we want to use our own versions of these
#undef WINAPI
#undef PBWINAPI
#undef FAR
#undef PASCAL

#ifdef PBWIN32
#define FAR
#define PASCAL
#else
#define FAR 		_far
#define PASCAL      _pascal
#endif


#ifdef PBOS_NT
#define WINAPI              __stdcall
#else
#define WINAPI              FAR PASCAL
#endif

#ifdef  PBOS_MAC
#define PBWINAPI(r,n)   PASCAL r (n)
#elif   defined(PBOS_OS2)
#define PBWINAPI(r,n)   FAR PASCAL __loadds r n
#elif defined(__WATCOMC__) && defined(__cplusplus)
#define PBWINAPI(r,n)   __declspec(dllexport) r ( WINAPI      n )
#elif defined(PBOS_UNIX)
// gmoison CODEGEN
#define PBWINAPI(r,n)   r ( WINAPI     n )
#elif defined(PBOS_WIN)
#define PBWINAPI(r,n)   r  WINAPI      n
#else
#define PBWINAPI(r,n)   __declspec(dllexport) r ( WINAPI      n )
#endif

#define PBHIWORD(l)  ((USHORT)((((ULONG)(l)) >> 16) & 0xFFFF))
#define PBLOWORD(l)  ((USHORT)(((ULONG)(l)) & 0xFFFF))

#ifndef MAKELONG
#define MAKELONG(low, high)     \
				((LONG)(((WORD)(low)) | (((DWORD)((WORD)(high))) << 16)))
#endif

#pragma pack(pop)

#endif /* _RTCCODE_H_ */

